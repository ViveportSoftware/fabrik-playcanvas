const ya = class {
  static randomNextFloat() {
    return Math.random();
  }
  static randomNextInt(r) {
    return Math.floor(Math.random() * r);
  }
  static randRangeFloat(r, e) {
    return ya.randomNextFloat() * (e - r) + r;
  }
  static randRangeInt(r, e) {
    return ya.randomNextInt(e - r) + r;
  }
  static approximatelyEquals(r, e, t) {
    return Math.abs(r - e) <= t;
  }
  /**
   * Determine the sign of a float value.
   *
   * @param	value	The value to return the sign of.
   * @return			1.0f if the provided float value is positive, -1.0f otherwise.
   */
  static sign(r) {
    return r >= 0 ? 1 : -1;
  }
  /**
   * Return the given name capped at 100 characters, if necessary.
   *
   * @param	name	The name to validate.
   * @return			The given name capped at 100 characters, if necessary.
   */
  static getValidatedName(r) {
    return r.length >= ya.MAX_NAME_LENGTH ? r.substring(0, ya.MAX_NAME_LENGTH) : r;
  }
  /**
   * Validate a direction unit vector (Vec3f) to ensure that it does not have a magnitude of zero.
   * <p>
   * If the direction unit vector has a magnitude of zero then an IllegalArgumentException is thrown.
   * @param	directionUV	The direction unit vector to validate
   */
  static validateDirectionUV(r) {
    if (r.length() <= 0)
      throw new Error("Vec3f direction unit vector cannot be zero.");
  }
  /**
   * Validate the length of a bone to ensure that it's a positive value.
   * <p>
   * If the provided bone length is not greater than zero then an IllegalArgumentException is thrown.
   * @param	length	The length value to validate.
   */
  static validateLength(r) {
    if (r < 0)
      throw new Error("Length must be a greater than or equal to zero.");
  }
  /** Ensure we have a legal line width with which to draw.
   * <p>
   * Valid line widths are between 1.0f and 32.0f pixels inclusive.
   * <p>
   * Line widths outside this range will cause an IllegalArgumentException to be thrown.
   *
   * @param	lineWidth	The width of the line we are validating.
   */
  static validateLineWidth(r) {
    if (r < 1 || r > 32)
      throw new Error(
        "Line widths must be within the range 1.0f to 32.0f - but only 1.0f is guaranteed to be supported."
      );
  }
};
let be = ya;
be.DEGS_TO_RADS = Math.PI / 180;
be.RADS_TO_DEGS = 180 / Math.PI;
be.MAX_NAME_LENGTH = 100;
const mn = class {
  constructor(r = 0, e = 0, t = 0, s = 0, i = 0, n = 0, a = 0, o = 0, h = 0) {
    this.m00 = r, this.m01 = e, this.m02 = t, this.m10 = s, this.m11 = i, this.m12 = n, this.m20 = a, this.m21 = o, this.m22 = h;
  }
  /** Zero all elements of this matrix. */
  zero() {
    this.m00 = this.m01 = this.m02 = this.m10 = this.m11 = this.m12 = this.m20 = this.m21 = this.m22 = 0;
  }
  /** Reset this matrix to identity. */
  setIdentity() {
    this.m00 = this.m11 = this.m22 = 1, this.m01 = this.m02 = this.m10 = this.m12 = this.m20 = this.m21 = 0;
  }
  /**
   * Return a new matrix which is the transposed version of the provided matrix.
   *
   * @param	m	The matrix which we will transpose (this matrix is not modified)
   * @return		A transposed version of the provided matrix.
   */
  static transpose(r) {
    return new mn(
      r.m00,
      r.m10,
      r.m20,
      r.m01,
      r.m11,
      r.m21,
      r.m02,
      r.m12,
      r.m22
    );
  }
  /**
   * Create a rotation matrix from a given direction.
   * <p>
   * The reference direction is aligned to the Z-Axis. Note: The singularity is on the positive Y-Axis.
   * <p>
   * This method uses the <a href="https://gist.github.com/roxlu/3082114">Frisvad technique</a> for generating perpendicular axes.
   *
   * @param	referenceDirection	The vector to use as the Z-Axis
   * @return	The created rotation matrix.
   *
   * @see Vec3f#genPerpendicularVectorQuick(Vec3f)
   */
  static createRotationMatrix(r) {
    const e = new mn();
    return Math.abs(r.y) > 0.9999 ? (e.setZBasis(r), e.setXBasis(new R(1, 0, 0)), e.setYBasis(
      R.crossProduct(e.getXBasis(), e.getZBasis()).normalised()
    )) : (e.setZBasis(r), e.setXBasis(
      R.crossProduct(
        r,
        new R(0, 1, 0)
      ).normalised()
    ), e.setYBasis(
      R.crossProduct(e.getXBasis(), e.getZBasis()).normalised()
    )), e;
  }
  /**
   * Return whether this matrix consists of three orthogonal axes or not to within a cross-product of 0.01f.
   *
   * @return	Whether or not this matrix is orthogonal.
   */
  isOrthogonal() {
    const r = R.dotProduct(this.getXBasis(), this.getYBasis()), e = R.dotProduct(this.getXBasis(), this.getZBasis()), t = R.dotProduct(this.getYBasis(), this.getZBasis());
    return !!(be.approximatelyEquals(r, 0, 0.01) && be.approximatelyEquals(e, 0, 0.01) && be.approximatelyEquals(t, 0, 0.01));
  }
  /**
   * Multiply this matrix by another matrix (in effect, combining them) and return the result as a new Mat3f.
   * <p>
   * Neither this matrix or the provided matrix argument are modified by this process - you must assign the result to your desired
   * combined matrix.
   * <p>
   * To create a ModelView matrix using this method you would use viewMatrix.times(modelMatrix).
   * To create a ModelViewProjection matrix using this method you would use projectionMatrix.times(viewMatrix).times(modelMatrix).
   *
   * @param	m	The matrix to multiply this matrix by.
   * @return		The resulting combined matrix.
   */
  times(r) {
    const e = new mn();
    return e.m00 = this.m00 * r.m00 + this.m10 * r.m01 + this.m20 * r.m02, e.m01 = this.m01 * r.m00 + this.m11 * r.m01 + this.m21 * r.m02, e.m02 = this.m02 * r.m00 + this.m12 * r.m01 + this.m22 * r.m02, e.m10 = this.m00 * r.m10 + this.m10 * r.m11 + this.m20 * r.m12, e.m11 = this.m01 * r.m10 + this.m11 * r.m11 + this.m21 * r.m12, e.m12 = this.m02 * r.m10 + this.m12 * r.m11 + this.m22 * r.m12, e.m20 = this.m00 * r.m20 + this.m10 * r.m21 + this.m20 * r.m22, e.m21 = this.m01 * r.m20 + this.m11 * r.m21 + this.m21 * r.m22, e.m22 = this.m02 * r.m20 + this.m12 * r.m21 + this.m22 * r.m22, e;
  }
  /**
   * Multiply a vector by this matrix and return the result as a new Vec3f.
   *
   * @param	source	The source vector to transform.
   * @return		The provided source vector transformed by this matrix.
   */
  timesByVec3(r) {
    return new R(
      this.m00 * r.x + this.m10 * r.y + this.m20 * r.z,
      this.m01 * r.x + this.m11 * r.y + this.m21 * r.z,
      this.m02 * r.x + this.m12 * r.y + this.m22 * r.z
    );
  }
  /**
   * Calculate and return the determinant of this matrix.
   *
   * @return	The determinant of this matrix.
   */
  determinant() {
    return this.m20 * this.m01 * this.m12 - this.m20 * this.m02 * this.m11 - this.m10 * this.m01 * this.m22 + this.m10 * this.m02 * this.m21 + this.m00 * this.m11 * this.m22 - this.m00 * this.m12 * this.m21;
  }
  /**
   * Return a matrix which is the inverse of the provided matrix.
   *
   * @param	m	The matrix to invert.
   * @return		The inverse matrix of of the provided matrix argument.
   */
  static inverse(r) {
    const e = r.determinant(), t = new mn();
    return t.m00 = (r.m11 * r.m22 - r.m12 * r.m21) / e, t.m01 = -(r.m01 * r.m22 - r.m02 * r.m21) / e, t.m02 = (r.m01 * r.m12 - r.m02 * r.m11) / e, t.m10 = -(-r.m20 * r.m12 + r.m10 * r.m22) / e, t.m11 = (-r.m20 * r.m02 + r.m00 * r.m22) / e, t.m12 = -(-r.m10 * r.m02 + r.m00 * r.m12) / e, t.m20 = (-r.m20 * r.m11 + r.m10 * r.m21) / e, t.m21 = -(-r.m20 * r.m01 + r.m00 * r.m21) / e, t.m22 = (-r.m10 * r.m02 + r.m00 * r.m11) / e, t;
  }
  /**
   *  Rotate this matrix by the provided angle about the specified axis.
   *
   *  @param	angleRads		The angle to rotate the matrix, specified in radians.
   *  @param	rotationAxis	The axis to rotate this matrix about, relative to the current configuration of this matrix.
   *  @return					The rotated version of this matrix.
   */
  rotateRads(r, e) {
    const t = new mn(), s = Math.sin(e), i = Math.cos(e), n = 1 - i, a = r.x * r.y, o = r.y * r.z, h = r.x * r.z, l = r.x * s, c = r.y * s, d = r.z * s, u = r.x * r.x * n + i, f = a * n + d, m = h * n - c, _ = a * n - d, p = r.y * r.y * n + i, g = o * n + l, b = h * n + c, x = o * n - l, y = r.z * r.z * n + i, S = this.m00 * u + this.m10 * f + this.m20 * m, C = this.m01 * u + this.m11 * f + this.m21 * m, w = this.m02 * u + this.m12 * f + this.m22 * m, M = this.m00 * _ + this.m10 * p + this.m20 * g, T = this.m01 * _ + this.m11 * p + this.m21 * g, A = this.m02 * _ + this.m12 * p + this.m22 * g;
    return t.m20 = this.m00 * b + this.m10 * x + this.m20 * y, t.m21 = this.m01 * b + this.m11 * x + this.m21 * y, t.m22 = this.m02 * b + this.m12 * x + this.m22 * y, t.m00 = S, t.m01 = C, t.m02 = w, t.m10 = M, t.m11 = T, t.m12 = A, t;
  }
  /**
   *  Rotate this matrix by the provided angle about the specified axis.
   *
   *  @param	angleDegs	The angle to rotate the matrix, specified in degrees.
   *  @param	localAxis	The axis to rotate this matrix about, relative to the current configuration of this matrix.
   *  @return			The rotated version of this matrix.
   *  */
  rotateDegs(r, e) {
    return this.rotateRads(e, r * mn.DEGS_TO_RADS);
  }
  /**
   * Set the X basis of this matrix.
   *
   * @param	v	The vector to use as the X-basis of this matrix.
   */
  setXBasis(r) {
    this.m00 = r.x, this.m01 = r.y, this.m02 = r.z;
  }
  /**
   * Get the X basis of this matrix.
   *
   * @return The X basis of this matrix as a Vec3f
   **/
  getXBasis() {
    return new R(this.m00, this.m01, this.m02);
  }
  /**
   * Set the Y basis of this matrix.
   *
   * @param	v	The vector to use as the Y-basis of this matrix.
   */
  setYBasis(r) {
    this.m10 = r.x, this.m11 = r.y, this.m12 = r.z;
  }
  /**
   * Get the Y basis of this matrix.
   *
   * @return The Y basis of this matrix as a Vec3f
   **/
  getYBasis() {
    return new R(this.m10, this.m11, this.m12);
  }
  /**
   * Set the Z basis of this matrix.
   *
   * @param	v	The vector to use as the Z-basis of this matrix.
   */
  setZBasis(r) {
    this.m20 = r.x, this.m21 = r.y, this.m22 = r.z;
  }
  /**
   * Get the Z basis of this matrix.
   *
   * @return The Z basis of this matrix as a Vec3f
   **/
  getZBasis() {
    return new R(this.m20, this.m21, this.m22);
  }
  /**
   * Return this Mat3f as an array of 9 floats.
   *
   * @return	This Mat3f as an array of 9 floats.
   */
  toArray() {
    return [
      this.m00,
      this.m01,
      this.m02,
      this.m10,
      this.m11,
      this.m12,
      this.m20,
      this.m21,
      this.m22
    ];
  }
  toString() {
    return `X Axis: ${this.m00},	 ${this.m01},	 ${this.m02}\r
Y Axis: ${this.m10},	 ${this.m11},	 ${this.m12}\r
Z Axis: ${this.m20},	 ${this.m21},	 ${this.m22}`;
  }
};
let Ns = mn;
Ns.DEGS_TO_RADS = Math.PI / 180;
Ns.RADS_TO_DEGS = 180 / Math.PI;
const ae = class {
  constructor(r = 0, e = 0, t = 0) {
    this.x = r, this.y = e, this.z = t;
  }
  static clone(r) {
    return new ae(r.x, r.y, r.z);
  }
  set(r) {
    this.x = r.x, this.y = r.y, this.z = r.z;
  }
  approximatelyEquals(r, e) {
    if (e < 0)
      throw new Error(
        "Equality threshold must be greater than or equal to 0.0f"
      );
    const t = Math.abs(this.x - r.x), s = Math.abs(this.y - r.y), i = Math.abs(this.z - r.z);
    return t < e && s < e && i < e;
  }
  /**
   * Return whether the two provided vectors are perpendicular (to a dot-product tolerance of 0.01f).
   *
   * @param	a	The first vector.
   * @param	b	The second vector.
   * @return		Whether the two provided vectors are perpendicular (true) or not (false).
   */
  static perpendicular(r, e) {
    return !!be.approximatelyEquals(ae.dotProduct(r, e), 0, 0.01);
  }
  /**
   * Return whether the length of this Vec3f is approximately equal to a given value to within a given tolerance.
   *
   * @param	value		The value to compare the length of this vector to.
   * @param	tolerance	The tolerance within which the values must be to return true.
   * @return				A boolean indicating whether the length of this vector is approximately the same as that of the provided value.
   */
  lengthIsApproximately(r, e) {
    if (e < 0)
      throw new Error("Comparison tolerance cannot be less than zero.");
    return Math.abs(this.length() - r) < e;
  }
  zero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Negate and return this vector.
   * <p>
   * Note: It is actually <em>this</em> vector which is negated and returned, not a copy / clone.
   *
   * @return	This vector negated.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  negated() {
    return new ae(-this.x, -this.y, -this.z);
  }
  /**
   * Return whether two vectors are approximately equal to within a given tolerance.
   *
   * @param	a		The first vector.
   * @param	b		The second vector.
   * @param	tolerance	The value which each component of each vector must be within to be considered approximately equal.
   * @return			Whether the two provided vector arguments are approximately equal (true) or not (false).
   */
  static approximatelyEqual(r, e, t) {
    return Math.abs(r.x - e.x) < t && Math.abs(r.y - e.y) < t && Math.abs(r.z - e.z) < t;
  }
  normalise() {
    const r = Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z
    );
    return r > 0 && (this.x /= r, this.y /= r, this.z /= r), this;
  }
  /**
   * Return a normalised version of this vector without modifying 'this' vector.
   *
   * @return	A normalised version of this vector.
   */
  normalised() {
    return new ae(this.x, this.y, this.z).normalise();
  }
  /**
   * Return the scalar product of two vectors.
   * <p>
   * If the provided vectors are normalised then this will be the same as the dot product.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The scalar product of the two vectors.
   */
  static scalarProduct(r, e) {
    return r.x * e.x + r.y * e.y + r.z * e.z;
  }
  /**
   * Return the scalar product of two vectors.
   * <p>
   * Normalised versions of the provided vectors are used in the dot product operation.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The dot product of the two vectors.
   */
  static dotProduct(r, e) {
    const t = r.normalised(), s = e.normalised();
    return t.x * s.x + t.y * s.y + t.z * s.z;
  }
  /**
   * Calculate and return a vector which is the cross product of the two provided vectors.
   * <p>
   * The returned vector is not normalised.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The non-normalised cross-product of the two vectors v1-cross-v2.
   */
  static crossProduct(r, e) {
    return new ae(
      r.y * e.z - r.z * e.y,
      r.z * e.x - r.x * e.z,
      r.x * e.y - r.y * e.x
    );
  }
  /**
   * Calculate and return a vector which is the cross product of this vector and another vector.
   * <p>
   * The returned vector is not normalised.
   *
   * @param	v	The Vec3f with which we will cross product this Vec3f.
   * @return		The non-normalised cross product if the two vectors this-cross-v.
   */
  cross(r) {
    return new ae(
      this.y * r.z - this.z * r.y,
      this.z * r.x - this.x * r.z,
      this.x * r.y - this.y * r.x
    );
  }
  /**
   * Calculate and return the distance between two points in 3D space.
   *
   * @param	v1	The first point.
   * @param	v2	The second point.
   * @return		The distance between the two points.
   */
  static distanceBetween(r, e) {
    const t = e.x - r.x, s = e.y - r.y, i = e.z - r.z;
    return Math.sqrt(t * t + s * s + i * i);
  }
  /**
   * Calculate and return the Manhattan distance between two Vec3f objects.
   * <p>
   * The Manhattan distance is an approximate distance between two points, but
   * can be calculated faster than the exact distance.
   * <p>
   * Further reading:
   *     http://en.wikipedia.org/wiki/floataxicab_geometry
   *     http://stackoverflow.com/questions/3693514/very-fast-3d-distance-check
   *
   * @param	v1	The first point.
   * @param	v2	The second point.
   * @return		The Manhattan distance between the two points.
   */
  static manhattanDistanceBetween(r, e) {
    return Math.abs(e.x - r.x) + Math.abs(e.y - r.y) + Math.abs(e.z - r.z);
  }
  /**
   * Return whether two locations are within a given manhattan distance of each other.
   * <p>
   * The manhattan distance is an approximate distance between two points, but
   * can be calculated faster than the exact distance.
   * <p>
   * Further reading:
   *     http://en.wikipedia.org/wiki/floataxicab_geometry
   *     http://stackoverflow.com/questions/3693514/very-fast-3d-distance-check
   *
   * @param	v1	The first location vector
   * @param	v2	The second location vector
   * @return	boolean
   */
  static withinManhattanDistance(r, e, t) {
    return !(Math.abs(e.x - r.x) > t || Math.abs(e.y - r.y) > t || Math.abs(e.z - r.z) > t);
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Return a component-wise absolute version (i.e. all components are positive) of this vector.
   * <p>
   * Note: This vector itself is not modified - a new vector is created, each component is made positive, and the new vector is returned.
   *
   * @param	source	The vector to make absolute.
   * @return		A component-wise absolute version of this vector.
   */
  static abs(r) {
    const e = new ae();
    return r.x < 0 ? e.x = -r.x : e.x = r.x, r.y < 0 ? e.y = -r.y : e.y = r.y, r.z < 0 ? e.z = -r.z : e.z = r.z, e;
  }
  /**
   * Return a normalised Vec3f which is perpendicular to the vector provided.
   * <p>
   * This is a very fast method of generating a perpendicular vector that works for any vector
   * which is 5 degrees or more from vertical 'up'.
   * <p>
   * The code in this method is adapted from: http://blog.selfshadow.com/2011/10/17/perp-vectors/
   *
   * @param	u	The vector to use as the basis for generating the perpendicular vector.
   * @return		A normalised vector which is perpendicular to the provided vector argument.
   */
  static genPerpendicularVectorQuick(r) {
    let e;
    return Math.abs(r.y) < 0.99 ? e = new ae(-r.z, 0, r.x) : e = new ae(0, r.z, -r.y), e.normalise();
  }
  /**
   * Method to generate a vector perpendicular to another one using the Hughes-Muller method.
   * <p>
   * The returned vector is normalised.
   * <p>
   * The code in this method is adapted from: http://blog.selfshadow.com/2011/10/17/perp-vectors/
   * <p>
   * Further reading: Hughes, J. F., Muller, T., "Building an Orthonormal Basis from a Unit Vector", Journal of Graphics Tools 4:4 (1999), 33-35.
   *
   * @param	u	The vector with regard to which we will generate a perpendicular unit vector.
   * @return		A normalised vector which is perpendicular to the provided vector argument.
   */
  static genPerpendicularVectorHM(r) {
    const e = ae.abs(r);
    return e.x <= e.y && e.x <= e.z ? new ae(0, -r.z, r.y).normalise() : e.y <= e.x && e.y <= e.z ? new ae(-r.z, 0, r.x).normalise() : new ae(-r.y, r.x, 0).normalise();
  }
  //TODO: Test if better than Quick version and document.
  /**
   * Method to generate a vector perpendicular to another one using the Frisvad method.
   * <p>
   * The returned vector is normalised.
   *
   * @param	u	The vector with regard to which we will generate a perpendicular unit vector.
   * @return		A normalised vector which is perpendicular to the provided vector argument.
   */
  static genPerpendicularVectorFrisvad(r) {
    if (r.z < -0.9999999)
      return new ae(0, -1, 0);
    const e = 1 / (1 + r.z);
    return new ae(1 - r.x * r.x * e, -r.x * r.y * e, -r.x).normalised();
  }
  /**
   * Return the unit vector between two provided vectors.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The unit vector between the two provided vector arguments.
   */
  static getUvBetween(r, e) {
    return new ae(e.minus(r).x, e.minus(r).y, e.minus(r).z).normalise();
  }
  /**
   * Calculate and return the angle between two vectors in radians.
   * <p>
   * The result will always be a positive value between zero and pi (3.14159f) radians.
   * <p>
   * This method does not modify the provided vectors, but does use normalised versions of them in the calculations.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The angle between the vector in radians.
   */
  static getAngleBetweenRads(r, e) {
    return Math.acos(ae.dotProduct(r, e));
  }
  /**
   * Calculate and return the angle between two vectors in degrees.
   * <p>
   * The result will always be a positive value between [0..180) degrees.
   * <p>
   * This method does not modify the provided vectors, but does use normalised versions of them in the calculations.
   *
   * @param	v1	The first vector.
   * @param	v2	The second vector.
   * @return		The angle between the vector in degrees.
   */
  static getAngleBetweenDegs(r, e) {
    return ae.getAngleBetweenRads(r, e) * ae.RADS_TO_DEGS;
  }
  /**
   * Return a signed angle between two vectors within the range -179.9f..180.0f degrees.
   *
   * @param	referenceVector	The baseline vector which we consider to be at zero degrees.
   * @param	otherVector		The vector we will use to calculate the signed angle with respect to the reference vector.
   * @param	normalVector	The normal vector (i.e. vector perpendicular to) both the reference and 'other' vectors.
   * @return					The signed angle from the reference vector to the other vector in degrees.
   **/
  static getSignedAngleBetweenDegs(r, e, t) {
    const s = ae.getAngleBetweenDegs(
      r,
      e
    ), i = be.sign(
      ae.dotProduct(
        ae.crossProduct(r, e),
        t
      )
    );
    return s * i;
  }
  /**
   * Return an angle limited vector with regard to another vector.
   * <p>
   * @param	vecToLimit		The vector which we will limit to a given angle with regard to the the baseline vector.
   * @param	vecBaseline		The vector which will be used as the baseline / frame-of-reference when rotating the vecToLimit.
   * @param	angleLimitDegs	The maximum angle which the vecToLimit may be rotated away from the vecBaseline, in degrees.
   * @return					The rotated vecToLimit, which is constraint to a maximum of the angleLimitDegs argument.
   */
  static getAngleLimitedUnitVectorDegs(r, e, t) {
    if (ae.getAngleBetweenDegs(
      e,
      r
    ) > t) {
      const i = ae.crossProduct(
        e.normalised(),
        r.normalised()
      ).normalise();
      return ae.rotateAboutAxisDegs(
        e,
        t,
        i
      ).normalised();
    } else
      return r.normalised();
  }
  /**
  	 * Return the global pitch of this vector about the global X-Axis. The returned value is within the range -179.9f..180.0f 
  degrees.
  	 *
  	 * @return	The pitch of the vector in degrees.
  	 **/
  getGlobalPitchDegs() {
    const r = this.projectOntoPlane(ae.X_AXIS), e = ae.getAngleBetweenDegs(ae.Z_AXIS.negated(), r);
    return r.y < 0 ? -e : e;
  }
  /**
  	 * Return the global yaw of this vector about the global Y-Axis. The returned value is within the range -179.9f..180.0f 
  degrees.
  	 *
  	 * @return	The yaw of the vector in degrees.
  	 **/
  getGlobalYawDegs() {
    const r = this.projectOntoPlane(ae.Y_AXIS), e = ae.getAngleBetweenDegs(ae.Z_AXIS.negated(), r);
    return r.x < 0 ? -e : e;
  }
  /**
   * Rotate a Vec3f about the world-space X-axis by a given angle specified in radians.
   *
   * @param	source		The vector to rotate.
   * @param	angleRads	The angle to rotate the vector in radians.
   * @return				A rotated version of the vector.
   */
  static rotateXRads(r, e) {
    const t = Math.cos(e), s = Math.sin(e);
    return new ae(
      r.x,
      r.y * t - r.z * s,
      r.y * s + r.z * t
    );
  }
  /**
   * Rotate a Vec3f about the world-space X-axis by a given angle specified in degrees.
   *
   * @param	source		The vector to rotate.
   * @param	angleDegs	The angle to rotate the vector in degrees.
   * @return				A rotated version of the vector.
   */
  static rotateXDegs(r, e) {
    return ae.rotateXRads(r, e * ae.DEGS_TO_RADS);
  }
  /**
   * Rotate a Vec3f about the world-space Y-axis by a given angle specified in radians.
   *
   * @param	source		The vector to rotate.
   * @param	angleRads	The angle to rotate the vector in radians.
   * @return				A rotated version of the vector.
   */
  static rotateYRads(r, e) {
    const t = Math.cos(e), s = Math.sin(e);
    return new ae(
      r.z * s + r.x * t,
      r.y,
      r.z * t - r.x * s
    );
  }
  /**
   * Rotate a Vec3f about the world-space Y-axis by a given angle specified in degrees.
   *
   * @param	source		The vector to rotate.
   * @param	angleDegs	The angle to rotate the vector in degrees.
   * @return				A rotated version of the vector.
   */
  static rotateYDegs(r, e) {
    return ae.rotateYRads(r, e * ae.DEGS_TO_RADS);
  }
  /**
   * Rotate a Vec3f about the world-space Z-axis by a given angle specified in radians.
   *
   * @param	source		The vector to rotate.
   * @param	angleRads	The angle to rotate the vector in radians.
   * @return				A rotated version of the vector.
   */
  static rotateZRads(r, e) {
    const t = Math.cos(e), s = Math.sin(e);
    return new ae(
      r.x * t - r.y * s,
      r.x * s + r.y * t,
      r.z
    );
  }
  /**
   * Rotate a Vec3f about the world-space Z-axis by a given angle specified in degrees.
   *
   * @param	source		The vector to rotate.
   * @param	angleDegs	The angle to rotate the vector in degrees.
   * @return				A rotated version of the vector.
   */
  static rotateZDegs(r, e) {
    return ae.rotateZRads(r, e * ae.DEGS_TO_RADS);
  }
  /**
   * Rotate a source vector an amount in radians about an arbitrary axis.
   *
   * @param source		The vector to rotate.
   * @param angleRads		The amount of rotation to perform in radians.
   * @param rotationAxis	The rotation axis.
   * @return				The source vector rotated about the rotation axis.
   */
  static rotateAboutAxisRads(r, e, t) {
    const s = new Ns(), i = Math.sin(e), n = Math.cos(e), a = 1 - n, o = t.x * t.y * a, h = t.x * t.z * a, l = t.y * t.z * a;
    return s.m00 = t.x * t.x * a + n, s.m01 = o + t.z * i, s.m02 = h - t.y * i, s.m10 = o - t.z * i, s.m11 = t.y * t.y * a + n, s.m12 = l + t.x * i, s.m20 = h + t.y * i, s.m21 = l - t.x * i, s.m22 = t.z * t.z * a + n, s.timesByVec3(r);
  }
  /**
   * Rotate a source vector an amount in degrees about an arbitrary axis.
   *
   * @param source		The vector to rotate.
   * @param angleDegs		The amount of rotation to perform in degrees.
   * @param rotationAxis	The rotation axis.
   * @return				The source vector rotated about the rotation axis.
   */
  static rotateAboutAxisDegs(r, e, t) {
    return ae.rotateAboutAxisRads(
      r,
      e * ae.DEGS_TO_RADS,
      t
    );
  }
  toString() {
    return `x: ${this.x}, y: ${this.y}, z: ${this.z}`;
  }
  plus(r) {
    return new ae(this.x + r.x, this.y + r.y, this.z + r.z);
  }
  minus(r) {
    return new ae(this.x - r.x, this.y - r.y, this.z - r.z);
  }
  times(r) {
    return new ae(this.x * r, this.y * r, this.z * r);
  }
  /**
   * Add a vector to a source vector - the source vector is modified.
   * <p>
   * This method does not perform any memory allocations - it merely adds 'other' to 'source'.
   *
   *  @param	source	The vector to which we will add a vector.
   *  @param	other	The vector we will add to the 'source' vector.
   */
  static add(r, e) {
    r.x += e.x, r.y += e.y, r.z += e.z;
  }
  /**
   * Subtract a vector from a source vector - the source vector is modified.
   * <p>
   * This method does not perform any memory allocations - it merely subtracts 'other' from 'source'.
   *
   *  @param	source	The vector to which we will subtract a vector.
   *  @param	other	The vector we will suctract from the 'source' vector.
   */
  static subtract(r, e) {
    r.x -= e.x, r.y -= e.y, r.z -= e.z;
  }
  dividedBy(r) {
    return new ae(this.x / r, this.y / r, this.z / r);
  }
  /**
   * Return a vector which is the result of projecting this vector onto a plane described by the provided surface normal.
   * <p>
   * Neither the vector on which this method is called or the provided plane normal vector are modified.
   * <p>
   * If the plane surface normal has a magnitude of zero then an IllegalArgumentException is thrown.
   *
   * @param	planeNormal	The normal that describes the plane onto which we will project this vector.
   * @return				A projected version of this vector.
   */
  projectOntoPlane(r) {
    if (!(r.length() > 0))
      throw new Error("Plane normal cannot be a zero vector.");
    const e = this.normalised(), t = r.normalised();
    return e.minus(t.times(ae.dotProduct(e, r))).normalise();
  }
  /**
   * Calculate and return the direction unit vector from point a to point b.
   * <p>
   * If the opposite direction is required then the argument order can be swapped or the the result can simply be negated.
   *
   * @param	v1	The first location.
   * @param	v2	The second location.
   * @return		The normalised direction unit vector between point v1 and point v2.
   */
  static getDirectionUV(r, e) {
    return e.minus(r).normalise();
  }
  /**
   * Randomise the components of this vector to be random values between the provided half-open range as described by the minimum and maximum value arguments.
   *
   * @param	min	The minimum value for any given component (inclusive).
   * @param	max	The maximum value for any given component (exclusive, i.e. a max of 5.0f will be assigned values up to 4.9999f or such).
   **/
  randomise(r, e) {
    this.x = be.randRangeFloat(r, e), this.y = be.randRangeFloat(r, e), this.z = be.randRangeFloat(r, e);
  }
  equals(r) {
    if (this == r)
      return !0;
    if (r == null)
      return !1;
    const e = r;
    return !(this.x != e.x || this.y != e.y || this.z != e.z);
  }
  static centerPoint(r, e) {
    return new ae((r.x + e.x) / 2, (r.y + e.y) / 2, (r.z + e.z) / 2);
  }
};
let R = ae;
R.DEGS_TO_RADS = Math.PI / 180;
R.RADS_TO_DEGS = 180 / Math.PI;
R.X_AXIS = new ae(1, 0, 0);
R.Y_AXIS = new ae(0, 1, 0);
R.Z_AXIS = new ae(0, 0, 1);
const hI = new R(0, 0, 0), Ae = new R(1, 0, 0), re = new R(0, 1, 0), es = new R(0, 0, 1), pn = new R(-1, 0, 0), ri = new R(0, -1, 0), Th = new R(0, 0, -1);
var _t = /* @__PURE__ */ ((r) => (r[r.START = 0] = "START", r[r.END = 1] = "END", r))(_t || {});
const At = class {
  constructor(r = 0, e = 0, t = 0, s = 0) {
    this.r = r, this.g = e, this.b = t, this.a = s;
  }
  static clamp(r) {
    return r > At.MAX_COMPONENT_VALUE ? At.MAX_COMPONENT_VALUE : r < At.MIN_COMPONENT_VALUE ? At.MIN_COMPONENT_VALUE : r;
  }
  set(r) {
    this.r = At.clamp(r.r), this.g = At.clamp(r.g), this.b = At.clamp(r.b), this.a = At.clamp(r.a);
  }
  addRGB(r, e, t) {
    return this.r = At.clamp(this.r + r), this.g = At.clamp(this.g + e), this.b = At.clamp(this.b + t), this;
  }
  subtractRGB(r, e, t) {
    return this.r = At.clamp(this.r - r), this.g = At.clamp(this.g - e), this.b = At.clamp(this.b - t), this;
  }
  lighten(r) {
    return this.addRGB(r, r, r);
  }
  darken(r) {
    return this.subtractRGB(r, r, r);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return `Red: ${this.r}, Green: ${this.g}, Blue: ${this.b}, Alpha: ${this.a}`;
  }
  static randomOpaqueColour() {
    return new At(
      be.randomNextFloat(),
      be.randomNextFloat(),
      be.randomNextFloat(),
      1
    );
  }
  equals(r) {
    if (this == r)
      return !0;
    if (r == null)
      return !1;
    const e = r;
    return !(this.r !== e.r || this.g !== e.g || this.b !== e.b || this.a !== e.a);
  }
};
let Xe = At;
Xe.MIN_COMPONENT_VALUE = 0;
Xe.MAX_COMPONENT_VALUE = 1;
var Ce = /* @__PURE__ */ ((r) => (r[r.BALL = 0] = "BALL", r[r.GLOBAL_HINGE = 1] = "GLOBAL_HINGE", r[r.LOCAL_HINGE = 2] = "LOCAL_HINGE", r))(Ce || {});
const dt = class {
  // ---------- Constructors ----------
  /**
   * Default constructor.
   * <p>
   * By default, a FabrikJoint3D cannot be used until the type of joint that it represents has
   * been specified. This may be done via the {@link #setAsBallJoint(float)},
   * {@link #setAsGlobalHinge(au.edu.federation.utils.Vec3f, float, float, Vec3f)} or
   * {@link #setAsLocalHinge(au.edu.federation.utils.Vec3f, float, float, Vec3f)} methods.
   */
  // constructor() { }
  /**
   * Copy constructor.
   * <p>
   * Performs a deep copy / clone of the source object so that there are no shared references
   * between the objects after the new object has been constructed.
   *
   * @param	source	The FabrikJoint3D object to copy.
   */
  constructor(r = void 0) {
    this.mRotorConstraintDegs = dt.MAX_CONSTRAINT_ANGLE_DEGS, this.mHingeClockwiseConstraintDegs = dt.MAX_CONSTRAINT_ANGLE_DEGS, this.mHingeAnticlockwiseConstraintDegs = dt.MAX_CONSTRAINT_ANGLE_DEGS, this.mRotationAxisUV = new R(), this.mReferenceAxisUV = new R(), this.mJointType = 0, r && this.set(r);
  }
  /**
   * Method to clone a FabrikJoint3D.
   * <p>
   * Internally, this uses the copy constructor {@link #FabrikJoint3D(FabrikJoint3D)} to
   * perform the clone.
   *
   * @param	source	The FabrikJoint3D to clone.
   * @return			The cloned FabrikJoint3D.
   */
  clone(r) {
    return new dt(r);
  }
  /**
   * Set this joint to have the same properties as the proided 'source' joint.
   *
   * @param	source	The joint from which to duplicate all properties on this joint.
   */
  // @Override
  set(r) {
    r && (this.mJointType = r.mJointType, this.mRotorConstraintDegs = r.mRotorConstraintDegs, this.mHingeClockwiseConstraintDegs = r.mHingeClockwiseConstraintDegs, this.mHingeAnticlockwiseConstraintDegs = r.mHingeAnticlockwiseConstraintDegs, this.mRotationAxisUV.set(r.mRotationAxisUV), this.mReferenceAxisUV.set(r.mReferenceAxisUV));
  }
  /**
   * Set this joint to be a ball joint.
   *
   * @param	constraintAngleDegs	The maximum allowable angle in degrees between this bone and the previous bone in the chain.
   */
  setAsBallJoint(r) {
    dt.validateConstraintAngleDegs(r), this.mRotorConstraintDegs = r, this.mJointType = 0;
  }
  /**
   * Specify this joint to be a hinge with the provided settings.
   *
   * @param jointType						The type of joint, this may be either BALL, GLOBAL_HINGE or LOCAL_HINGE.
   * @param rotationAxis					The rotation axis of the hinge.
   * @param clockwiseConstraintDegs		The clockwise constraint angle about the reference axis.
   * @param anticlockwiseConstraintDegs	The anticlockwise constraint angle about the reference axis.
   * @param referenceAxis					The reference axis itself, which must fall within the plane of the hinge rotation axis.
   */
  setHinge(r, e, t, s, i) {
    if (!be.approximatelyEquals(
      R.dotProduct(e, i),
      0,
      0.01
    )) {
      const n = R.getAngleBetweenDegs(e, i);
      throw new Error(
        "The reference axis must be in the plane of the hinge rotation axis - angle between them is currently: " + n
      );
    }
    dt.validateConstraintAngleDegs(t), dt.validateConstraintAngleDegs(s), dt.validateAxis(e), dt.validateAxis(i), this.mHingeClockwiseConstraintDegs = t, this.mHingeAnticlockwiseConstraintDegs = s, this.mJointType = r, this.mRotationAxisUV.set(e.normalised()), this.mReferenceAxisUV.set(i.normalised());
  }
  /**
   * Make this FabrikJoint3D a global hinge joint - that is, a hinge which rotates around a global / world-space axis.
   * <p>
   * Once performed, the hinge is considered initialised and ready for use.
   * <p>
   * Providing a zero vec3f for any axis, or constraint angles outside the range 0..180 degrees results in an IllegalArgumentException.
   *
   * @param globalRotationAxis	The global / world-space axis about which the hinge allows rotation.
   * @param cwConstraintDegs		The clockwise constraint angle in degrees.
   * @param acwConstraintDegs		The anti-clockwise constraint angle in degrees.
   * @param globalReferenceAxis	The initial axis around the globalHingeRotationAxis which we will enforce rotational constraints.
   */
  setAsGlobalHinge(r, e, t, s) {
    this.setHinge(
      1,
      r,
      e,
      t,
      s
    );
  }
  /**
   * Make this FabrikJoint3D a local hinge joint - that is, a hinge which rotates around an axis relative to the bone to which it is attached.
   * <p>
   * Once performed, the hinge is considered initialised and ready for use.
   * <p>
   * Providing a zero vec3f for any axis, or constraint angles outside the range 0..180 degrees results in an IllegalArgumentException.
   *
   * @param localRotationAxis		The local (i.e. previous bone direction relative) axis about which the hinge allows rotation.
   * @param cwConstraintDegs		The clockwise constraint angle in degrees.
   * @param acwConstraintDegs		The anti-clockwise constraint angle in degrees.
   * @param localReferenceAxis	The initial axis around the localRotationAxis which we will enforce rotational constraints.
   */
  setAsLocalHinge(r, e, t, s) {
    this.setHinge(
      2,
      r,
      e,
      t,
      s
    );
  }
  /**
   * Get the clockwise constraint angle of a local or global hinge joint.
   * <p>
   * If the joint is of type JointType.BALL then a RuntimeException is thrown.
   *
   * @return	The clockwise constraint angle in degrees.
   */
  getHingeClockwiseConstraintDegs() {
    if (this.mJointType != 0)
      return this.mHingeClockwiseConstraintDegs;
    throw new Error(
      "Joint type is JointType.BALL - it does not have hinge constraint angles."
    );
  }
  /**
   * Get the anti-clockwise constraint angle of a local or global hinge joint.
   * <p>
   * If the joint is of type JointType.BALL then a RuntimeException is thrown.
   *
   * @return	The anti-clockwise constraint angle in degrees.
   */
  getHingeAnticlockwiseConstraintDegs() {
    if (this.mJointType != 0)
      return this.mHingeAnticlockwiseConstraintDegs;
    throw new Error(
      "Joint type is JointType.BALL - it does not have hinge constraint angles."
    );
  }
  /**
   * Set the rotor constraint angle of a ball joint.
   * <p>
   * If the angle is outside of the range 0.0f..180.0f then an IllegalArgumentException is thrown.
   * If the joint is not of type JointType.BALL then a RuntimeException is thrown.
   *
   * @param	angleDegs	The rotor constraint angle in degrees.
   */
  setBallJointConstraintDegs(r) {
    if (dt.validateConstraintAngleDegs(r), this.mJointType == 0)
      this.mRotorConstraintDegs = r;
    else
      throw new Error(
        "This joint is of type: " + this.mJointType + " - only joints of type JointType.BALL have a ball joint constraint angle."
      );
  }
  /**
   * Get the rotor constraint angle of a ball joint.
   * <p>
   * If the joint is not of type JointType.BALL then a RuntimeException is thrown.
   *
   * @return	The rotor constraint angle in degrees.
   */
  getBallJointConstraintDegs() {
    if (this.mJointType == 0)
      return this.mRotorConstraintDegs;
    throw new Error(
      "This joint is not of type JointType.BALL - it does not have a ball joint constraint angle."
    );
  }
  /**
   * Set the clockwise constraint angle of a hinge joint.
   * <p>
   * If the angle is outside of the range 0.0f..180.0f then an IllegalArgumentException is thrown.
   * If the joint is of type JointType.BALL then a RuntimeException is thrown.
   *
   * @param	angleDegs	The clockwise hinge constraint angle in degrees.
   */
  setHingeJointClockwiseConstraintDegs(r) {
    if (dt.validateConstraintAngleDegs(r), this.mJointType != 0)
      this.mHingeClockwiseConstraintDegs = r;
    else
      throw new Error(
        "Joint type is JointType.BALL - it does not have hinge constraint angles."
      );
  }
  /**
   * Set the anit-clockwise constraint angle of a hinge joint.
   * <p>
   * If the angle is outside of the range 0.0f..180.0f then an IllegalArgumentException is thrown.
   * If the joint is of type JointType.BALL then a RuntimeException is thrown.
   *
   * @param	angleDegs	The anti-clockwise hinge constraint angle in degrees.
   */
  setHingeJointAnticlockwiseConstraintDegs(r) {
    if (dt.validateConstraintAngleDegs(r), this.mJointType != 0)
      this.mHingeAnticlockwiseConstraintDegs = r;
    else
      throw new Error(
        "Joint type is JointType.BALL - it does not have hinge constraint angles."
      );
  }
  /**
   * Set the hinge rotation axis as a normalised version of the provided axis.
   * <p>
   * If a zero axis is specifed then an InvalidArgument exception is thrown.
   * If the joint type is JointType.BALL then a RuntimeException is thrown.
   *
   * @param axis	The axis which the hinge rotates about.
   */
  setHingeRotationAxis(r) {
    if (dt.validateAxis(r), this.mJointType != 0)
      this.mRotationAxisUV.set(r.normalised());
    else
      throw new Error(
        "Joint type is JointType.BALL - it does not have a hinge rotation axis."
      );
  }
  /**
   * Return the hinge reference axis, which is the direction about which hinge rotation is measured.
   * <p>
   * If the joint type is BALL (i.e. not a hinge) then a RuntimeException is thrown.
   *
   * @return	The hinge reference axis vector.
   */
  getHingeReferenceAxis() {
    if (this.mJointType != 0)
      return this.mReferenceAxisUV;
    throw new Error(
      "Joint type is JointType.BALL - it does not have a hinge reference axis."
    );
  }
  /**
   * Set the hinge reference axis, which is the direction about which the hinge rotation is measured.
   * <p>
   * If a zero axis is specifed then an InvalidArgument exception is thrown.
   * If the joint type is JointType.BALL then a RuntimeException is thrown.
   *
   * @param referenceAxis	The reference axis about which hinge rotation is measured.
   */
  setHingeReferenceAxis(r) {
    if (dt.validateAxis(r), this.mJointType != 0)
      this.mReferenceAxisUV.set(r.normalised());
    else
      throw new Error(
        "Joint type is JointType.BALL - it does not have a hinge reference axis."
      );
  }
  /**
   * Return the hinge rotation axis.
   * <p>
   * If the joint type is JointType.BALL (i.e. not a hinge) then a RuntimeException is thrown.
   *
   * @return	The hinge rotation axis vector.
   */
  getHingeRotationAxis() {
    if (this.mJointType != 0)
      return this.mRotationAxisUV;
    throw new Error(
      "Joint type is JointType.BALL - it does not have a hinge rotation axis."
    );
  }
  /**
   * Return the type of this joint.
   * <p>
   * This may be JointType.BALL, JointType.GLOBAL_HINGE or JointType.LOCAL_HINGE.
   *
   * @return	The type of this joint.
   */
  getJointType() {
    return this.mJointType;
  }
  /** Return a concise, human-readable description of this FebrikJoint3D object. */
  // @Override
  toString() {
    let r = "";
    switch (this.mJointType) {
      case 0:
        r += `Joint type: Ball\r
`, r += `Constraint angle: ${this.mRotorConstraintDegs}`;
        break;
      case 1:
      case 2:
        this.mJointType == 1 ? r += `Joint type                    : Global hinge\r
` : r += `Joint type                    : Local hinge\r
`, r += `Rotation axis                 : ${this.mRotationAxisUV}\r
`, r += `Reference axis                : ${this.mReferenceAxisUV}\r
`, r += `Anticlockwise constraint angle: ${this.mHingeClockwiseConstraintDegs}\r
`, r += `Clockwise constraint angle    : ${this.mHingeClockwiseConstraintDegs}\r
`;
        break;
    }
    return r;
  }
  // ---------- Private Methods ----------
  static validateConstraintAngleDegs(r) {
    if (r < dt.MIN_CONSTRAINT_ANGLE_DEGS || r > dt.MAX_CONSTRAINT_ANGLE_DEGS)
      throw new Error(
        "Constraint angles must be within the range " + dt.MIN_CONSTRAINT_ANGLE_DEGS + " to " + dt.MAX_CONSTRAINT_ANGLE_DEGS + " inclusive."
      );
  }
  static validateAxis(r) {
    if (r.length() <= 0)
      throw new Error("Provided axis is illegal - it has a magnitude of zero.");
  }
  //   @Override
  //   public int hashCode() {
  //     final int prime = 31;
  //     int result = 1;
  //     result = prime * result + Float.floatToIntBits(mHingeAnticlockwiseConstraintDegs);
  //     result = prime * result + Float.floatToIntBits(mHingeClockwiseConstraintDegs);
  //     result = prime * result + ((mJointType == null) ? 0 : mJointType.hashCode());
  //     result = prime * result + ((mReferenceAxisUV == null) ? 0 : mReferenceAxisUV.hashCode());
  //     result = prime * result + ((mRotationAxisUV == null) ? 0 : mRotationAxisUV.hashCode());
  //     result = prime * result + Float.floatToIntBits(mRotorConstraintDegs);
  //     return result;
  //   }
  //   @Override
  equals(r) {
    if (this == r)
      return !0;
    if (r == null)
      return !1;
    const e = r;
    if (this.mHingeAnticlockwiseConstraintDegs != e.mHingeAnticlockwiseConstraintDegs || this.mHingeClockwiseConstraintDegs != e.mHingeClockwiseConstraintDegs || this.mJointType != e.mJointType)
      return !1;
    if (this.mReferenceAxisUV == null) {
      if (e.mReferenceAxisUV != null)
        return !1;
    } else if (!this.mReferenceAxisUV.equals(e.mReferenceAxisUV))
      return !1;
    if (this.mRotationAxisUV == null) {
      if (e.mRotationAxisUV != null)
        return !1;
    } else if (!this.mRotationAxisUV.equals(e.mRotationAxisUV))
      return !1;
    return this.mRotorConstraintDegs == e.mRotorConstraintDegs;
  }
};
let Zt = dt;
Zt.MIN_CONSTRAINT_ANGLE_DEGS = 0;
Zt.MAX_CONSTRAINT_ANGLE_DEGS = 180;
const Is = class {
  // ---------- Constructors ----------
  /**
   * Default constructor */
  // FabrikBone3D() { }
  /**
   * Create a new FabrikBone3D from a start and end location as provided by a pair of Vec3fs.
   * <p>
   * The {@link #mLength} property is calculated and set from the provided locations. All other properties
   * are set to their default values.
   * <p>
   * Instantiating a FabrikBone3D with the exact same start and end location, and hence a length of zero,
   * will result in an IllegalArgumentException being thrown.
   *
   * @param	startLocation	The start location of this bone.
   * @param	endLocation		The end location of this bone.
   */
  constructor(r = void 0, e = void 0, t = void 0) {
    this.mBoneConnectionPoint = _t.END, this.mJoint = new Zt(), this.mStartLocation = new R(), this.mEndLocation = new R(), this.mName = "", this.mLength = 0, this.mColor = new Xe(), this.mLineWidth = 1, r && e && (this.mStartLocation.set(r), this.mEndLocation.set(e), this.setLength(R.distanceBetween(r, e)), t || (t = new Xe(0.5, 0.5, 0.5)), this.setColor(t));
  }
  /**
   * Create a new FabrikBone3D from a start and end location and a String.
   * <p>
   * This constructor is merely for convenience if you intend on working with named bones, and internally
   * calls the {@link #FabrikBone3D(Vec3f, Vec3f)} constructor.
   *
   * @param	startLocation	The start location of this bone.
   * @param	endLocation		The end location of this bone.
   * @param	name			The name of this bone.
   */
  // public FabrikBone3D(Vec3f startLocation, Vec3f endLocation, String name)
  // {
  // 	// Call the start/end location constructor - which also sets the length of the bone
  // 	this(startLocation, endLocation);
  // 	setName(name);
  // }
  static NewByStartEndName(r, e, t) {
    const s = new Is(r, e);
    return s.setName(t), s;
  }
  /**
   * Create a new FabrikBone3D from a start location, a direction unit vector and a length.
   * <p>
   * The end location of the bone is calculated as the start location plus the direction unit
   * vector multiplied by the length (which must be a positive value). All other properties
   * are set to their default values.	 *
   * <p>
   * If this constructor is provided with a direction unit vector of magnitude zero, or with a
   * length less than or equal to zero then an {@link IllegalArgumentException} is thrown.
   *
   * @param	startLocation	The start location of this bone.
   * @param	directionUV		The direction unit vector of this bone.
   * @param	length			The length of this bone.
   */
  // public FabrikBone3D(Vec3f startLocation, Vec3f directionUV, float length)
  // {
  // 	// Sanity checking
  // 	setLength(length); // Throws IAE if < zero
  // 	if ( directionUV.length() <= 0.0f ) {
  // 	  throw new IllegalArgumentException("Direction cannot be a zero vector");
  // 	}
  // 	// Set the length, start and end locations
  // 	setLength(length);
  // 	mStartLocation.set(startLocation);
  // 	mEndLocation.set( mStartLocation.plus( directionUV.normalised().times(length) ) );
  // }
  static NewByStartDirectionLength(r, e, t) {
    if (e.length() <= 0)
      throw new Error("Direction cannot be a zero vector");
    const s = new Is();
    return s.setLength(t), s.setStartLocation(r), s.setEndLocation(
      r.plus(e.normalised().times(t))
    ), s;
  }
  /**
   * Create a named FabrikBone3D from a start location, a direction unit vector, a bone length and a name.
   * <p>
   * This constructor is merely for convenience if you intend on working with named bones, and internally
   * calls the {@link #FabrikBone3D(Vec3f, Vec3f, float)} constructor.
   * <p>
   * If the provided length argument is zero or if the direction is a zero vector then an IllegalArgumentException is thrown.
   *
   * @param	startLocation	The start location of this bone.
   * @param	directionUV		The direction unit vector of this bone.
   * @param	length			The length of this bone.
   * @param	name			The name of this bone.
   */
  // public FabrikBone3D(Vec3f startLocation, Vec3f directionUV, float length, String name)
  // {
  // 	this(startLocation, directionUV, length);
  // 	setName(name);
  // }
  static NewByStartDirectionLengthName(r, e, t, s) {
    const i = Is.NewByStartDirectionLength(
      r,
      e,
      t
    );
    return i.setName(s), i;
  }
  /**
   * Create a new FabrikBone3D from a start location, a direction unit vector, a bone length and a color.
   * <p>
   * This constructor is merely for convenience if you intend on working with named bones, and internally
   * calls the {@link #FabrikBone3D(Vec3f, Vec3f, float)} constructor.
   *
   * @param	startLocation	The start location of this bone.
   * @param	directionUV		The direction unit vector of this bone.
   * @param	length			The length of this bone.
   * @param	color			The color to draw this bone.
   */
  // public FabrikBone3D(Vec3f startLocation, Vec3f directionUV, float length, Color4f color)
  // {
  // 	this(startLocation, directionUV, length);
  // 	setColor(color);
  // }
  static NewByStartDirectionLengthColor(r, e, t, s) {
    const i = Is.NewByStartDirectionLength(
      r,
      e,
      t
    );
    return i.setColor(s), i;
  }
  /**
   * Copy constructor.
   * <p>
   * Takes a source FabrikBone3D object and copies all properties into the new FabrikBone3D by value.
   * Once this is done, there are no shared references between the source and the new object, and they are
   * exact copies of each other.
   *
   * @param	source	The bone to use as the basis for this new bone.
   */
  // public FabrikBone3D(FabrikBone3D source)
  // {
  // 	// Set all Vec3f properties by value via their set method
  // 	mStartLocation.set(source.mStartLocation);
  // 	mEndLocation.set(source.mEndLocation);
  // 	mJoint.set(source.mJoint);
  // 	mColor.set(source.mColor);
  // 	// Set the remaining properties by value via simple assignment
  // 	mName                = source.mName;
  // 	mLength              = source.mLength;
  // 	mLineWidth           = source.mLineWidth;
  // 	mBoneConnectionPoint = source.mBoneConnectionPoint;
  // }
  static NewByFabrikBone3D(r) {
    const e = new Is();
    return e.mStartLocation.set(r.mStartLocation), e.mEndLocation.set(r.mEndLocation), e.mJoint.set(r.mJoint), e.mColor.set(r.mColor), e.mName = r.mName, e.mLength = r.mLength, e.mLineWidth = r.mLineWidth, e.mBoneConnectionPoint = r.mBoneConnectionPoint, e;
  }
  // ---------- Methods ----------
  /**
   * {@inheritDoc}
   */
  // @Override
  length() {
    return this.mLength;
  }
  /**
   * Return the live (i.e. live calculated) length of this bone from its current start and end locations.
   *
   * @return	The 'live' calculated distance between the start and end locations of this bone.
   */
  liveLength() {
    return R.distanceBetween(this.mStartLocation, this.mEndLocation);
  }
  /**
   * Specify the bone connection point of this bone.
   * <p>
   * This connection point property controls whether, when THIS bone connects to another bone in another chain, it does so at
   * the start or the end of the bone we connect to.
   * <p>
   * The default is BoneConnectionPoint3D.END.
   *
   * @param	bcp	The bone connection point to use (BoneConnectionPoint3.START or BoneConnectionPoint.END).
   *
   */
  setBoneConnectionPoint(r) {
    this.mBoneConnectionPoint = r;
  }
  /**
   * Return the bone connection point for THIS bone, which will be either BoneConnectionPoint.START or BoneConnectionPoint.END.
   * <p>
   * This connection point property controls whether, when THIS bone connects to another bone in another chain, it does so at
   * the start or the end of the bone we connect to.
   *
   * @return	The bone connection point for this bone.
   */
  getBoneConnectionPoint() {
    return this.mBoneConnectionPoint;
  }
  /**
   * Return the color of this bone.
   *
   * @return	The color to draw this bone, as stored in the mColor property.
   */
  getColor() {
    return this.mColor;
  }
  /**
   * Set the color used to draw this bone.
   *
   * @param	color	The color (used to draw this bone) to set on the mColor property.
   */
  setColor(r) {
    this.mColor.set(r);
  }
  /**
   * Return the line width in pixels used to draw this bone.
   *
   * @return	The line width in pixels used to draw this bone.
   */
  getLineWidth() {
    return this.mLineWidth;
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getStartLocation() {
    return this.mStartLocation;
  }
  /**
   * Return the start location of this bone as an array of three floats.
   *
   * @return	The start location of this bone as an array of three floats.
   */
  getStartLocationAsArray() {
    return [
      this.mStartLocation.x,
      this.mStartLocation.y,
      this.mStartLocation.z
    ];
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getEndLocation() {
    return this.mEndLocation;
  }
  /**
   * Return the end location of this bone as an array of three floats.
   *
   * @return	The end location of this bone as an array of three floats.
   */
  getEndLocationAsArray() {
    return [this.mEndLocation.x, this.mEndLocation.y, this.mEndLocation.z];
  }
  /**
   * Set the FabrikJoint3D of this bone to match the properties of the provided FabrikJoint3D argument.
   *
   * @param	joint	The joint to use as the source for all joint properties on this bone.
   */
  setJoint(r) {
    this.mJoint.set(r);
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getJoint() {
    return this.mJoint;
  }
  /**
   * Return the type of FabrikJoint3D.JointType associated with this bone.
   *
   * @return	The type of FabrikJoint3D.JointType associated with this bone.
   */
  getJointType() {
    return this.mJoint.getJointType();
  }
  /**
   * Set the clockwise constraint angle of this bone's joint in degrees (0.0f to 180.0f inclusive).
   * <p>
   * If a constraint angle outside of this range is provided, then an IllegalArgumentException is
   * thrown.
   *
   * @param  angleDegs  The relative clockwise constraint angle specified in degrees.
   */
  setHingeJointClockwiseConstraintDegs(r) {
    this.mJoint.setHingeJointClockwiseConstraintDegs(r);
  }
  /**
   * Return the clockwise constraint angle of this bone's hinge joint in degrees.
   *
   * @return	 The clockwise constraint angle of this bone's hinge joint in degrees.
   */
  getHingeJointClockwiseConstraintDegs() {
    return this.mJoint.getHingeClockwiseConstraintDegs();
  }
  /**
   * Set the anticlockwise constraint angle of this bone's joint in degrees (0.0f to 180.0f inclusive).
   * <p>
   * If a constraint angle outside of this range is provided, then an {@link IllegalArgumentException}
   * is thrown.
   *
   * @param  angleDegs  The relative anticlockwise constraint angle specified in degrees.
   */
  setHingeJointAnticlockwiseConstraintDegs(r) {
    this.mJoint.setHingeJointAnticlockwiseConstraintDegs(r);
  }
  /**
   * Return the anticlockwise constraint angle of this bone's hinge joint in degrees.
   *
   * @return	 The anticlockwise constraint angle of this bone's hinge joint in degrees.
   */
  getHingeJointAnticlockwiseConstraintDegs() {
    return this.mJoint.getHingeAnticlockwiseConstraintDegs();
  }
  /**
   * Set the rotor constraint angle of this bone's joint in degrees (0.0f to 180.0f inclusive).
   * <p>
   * If a constraint angle outside of this range is provided, then an {@link IllegalArgumentException}
   * is thrown.
   *
   * @param  angleDegs  The angle in degrees relative to the previous bone which this bone is constrained to.
   */
  setBallJointConstraintDegs(r) {
    if (r < 0 || r > 180)
      throw new Error(
        "Rotor constraints for ball joints must be in the range 0.0f to 180.0f degrees inclusive."
      );
    this.mJoint.setBallJointConstraintDegs(r);
  }
  /**
   * Return the anticlockwise constraint angle of this bone's joint in degrees.
   *
   * @return	The anticlockwise constraint angle of this bone's joint in degrees.
   */
  getBallJointConstraintDegs() {
    return this.mJoint.getBallJointConstraintDegs();
  }
  /**
   * Get the direction unit vector between the start location and end location of this bone.
   * <p>
   * If the opposite (i.e. end to start) location is required then you can simply negate the provided direction.
   *
   * @return  The direction unit vector of this bone.
   * @see		Vec3f#negate()
   * @see		Vec3f#negated()
   */
  getDirectionUV() {
    return R.getDirectionUV(this.mStartLocation, this.mEndLocation);
  }
  /**
   * Get the global pitch of this bone with regard to the X-Axis. Pitch returned is in the range -179.9f to 180.0f.
   *
   * @return  The global pitch of this bone in degrees.
   */
  getGlobalPitchDegs() {
    return R.getDirectionUV(
      this.mStartLocation,
      this.mEndLocation
    ).getGlobalPitchDegs();
  }
  /**
   * Get the global yaw of this bone with regard to the Y-Axis. Yaw returned is in the range -179.9f to 180.0f.
   *
   * @return  The global yaw of this bone in degrees.
   */
  getGlobalYawDegs() {
    return R.getDirectionUV(
      this.mStartLocation,
      this.mEndLocation
    ).getGlobalYawDegs();
  }
  /**
   * Set the line width with which to draw this bone.
   * <p>
   * If the provided parameter is outside the valid range of 1.0f to 64.0f inclusive then an
   * IllegalArgumentException is thrown.
   *
   * @param	lineWidth	The value to set on the mLineWidth property.
   */
  setLineWidth(r) {
    if (r >= Is.MIN_LINE_WIDTH && r <= Is.MAX_LINE_WIDTH)
      this.mLineWidth = r;
    else
      throw new Error(
        "Line width must be between " + Is.MIN_LINE_WIDTH + " and " + Is.MAX_LINE_WIDTH + " inclusive."
      );
  }
  /**
   * Set the name of this bone, capped to 100 characters if required.
   *
   * @param	name	The name to set.
   */
  setName(r) {
    this.mName = be.getValidatedName(r);
  }
  /**
   * Get the name of this bone.
   * <p>
   * If the bone has not been specifically named through a constructor or by using the {@link #setName(String)} method,
   * then the name will be the default of "UnnamedFabrikBone3D".
   * @return String
   */
  getName() {
    return this.mName;
  }
  /**
   * Return a concise, human readable description of this FabrikBone3D as a String.
   */
  // @Override
  toString() {
    return `Start joint location : ${this.mStartLocation}\r
End   joint location : ${this.mEndLocation}\r
Bone length          : ${this.mLength}\r
Color                : ${this.mColor}\r
`;
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  setStartLocation(r) {
    this.mStartLocation.set(r);
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  setEndLocation(r) {
    this.mEndLocation.set(r);
  }
  /**
   * Set the length of the bone.
   * <p>
   * This method validates the length argument to ensure that it is greater than zero.
   * <p>
   * If the length argument is not a positive value then an {@link IllegalArgumentException} is thrown.
   *
   * @param	length	The value to set on the {@link #mLength} property.
   */
  setLength(r) {
    if (r > 0)
      this.mLength = r;
    else
      throw new Error("Bone length must be a positive value.");
  }
  //   @Override
  //   public int hashCode() {
  //     final int prime = 31;
  //     int result = 1;
  //     result = prime * result + ((mBoneConnectionPoint == null) ? 0 : mBoneConnectionPoint.hashCode());
  //     result = prime * result + ((mColor == null) ? 0 : mColor.hashCode());
  //     result = prime * result + ((mEndLocation == null) ? 0 : mEndLocation.hashCode());
  //     result = prime * result + ((mJoint == null) ? 0 : mJoint.hashCode());
  //     result = prime * result + Float.floatToIntBits(mLength);
  //     result = prime * result + Float.floatToIntBits(mLineWidth);
  //     result = prime * result + ((mName == null) ? 0 : mName.hashCode());
  //     result = prime * result + ((mStartLocation == null) ? 0 : mStartLocation.hashCode());
  //     return result;
  //   }
  //   @Override
  equals(r) {
    if (this == r)
      return !0;
    if (r == null)
      return !1;
    const e = r;
    if (this.mBoneConnectionPoint != e.mBoneConnectionPoint)
      return !1;
    if (this.mColor == null) {
      if (e.mColor != null)
        return !1;
    } else if (!this.mColor.equals(e.mColor))
      return !1;
    if (this.mEndLocation == null) {
      if (e.mEndLocation != null)
        return !1;
    } else if (!this.mEndLocation.equals(e.mEndLocation))
      return !1;
    if (this.mJoint == null) {
      if (e.mJoint != null)
        return !1;
    } else if (!this.mJoint.equals(e.mJoint))
      return !1;
    if (this.mLength != e.mLength || this.mLineWidth != e.mLineWidth)
      return !1;
    if (this.mName == null) {
      if (e.mName != null)
        return !1;
    } else if (this.mName != e.mName)
      return !1;
    if (this.mStartLocation == null) {
      if (e.mStartLocation != null)
        return !1;
    } else if (!this.mStartLocation.equals(e.mStartLocation))
      return !1;
    return !0;
  }
};
let Cr = Is;
Cr.MIN_LINE_WIDTH = 1;
Cr.MAX_LINE_WIDTH = 64;
var pe = /* @__PURE__ */ ((r) => (r[r.NONE = 0] = "NONE", r[r.GLOBAL_ROTOR = 1] = "GLOBAL_ROTOR", r[r.LOCAL_ROTOR = 2] = "LOCAL_ROTOR", r[r.GLOBAL_HINGE = 3] = "GLOBAL_HINGE", r[r.LOCAL_HINGE = 4] = "LOCAL_HINGE", r))(pe || {});
const Fi = class {
  /**
   * Naming constructor.
   *
   * @param	name	The name to set for this chain.
   */
  constructor(r) {
    this.mChain = new Array(), this.mName = "", this.mSolveDistanceThreshold = 1, this.mMaxIterationAttempts = 20, this.mMinIterationChange = 0.01, this.mChainLength = 0, this.mFixedBaseLocation = new R(), this.mFixedBaseMode = !0, this.mBaseboneConstraintType = 0, this.mBaseboneConstraintUV = new R(), this.mBaseboneRelativeConstraintUV = new R(), this.mBaseboneRelativeReferenceConstraintUV = new R(), this.mLastTargetLocation = new R(
      Number.MAX_VALUE,
      Number.MAX_VALUE,
      Number.MAX_VALUE
    ), this.mConstraintLineWidth = 2, this.mLastBaseLocation = new R(
      Number.MAX_VALUE,
      Number.MAX_VALUE,
      Number.MAX_VALUE
    ), this.mCurrentSolveDistance = Number.MAX_VALUE, this.mConnectedChainNumber = -1, this.mConnectedBoneNumber = -1, this.mEmbeddedTarget = new R(), this.mUseEmbeddedTarget = !1, this.mName = r;
  }
  // ---------- Constructors ----------
  /** Default constructor */
  // constructor() {}
  /**
   * Copy constructor.
   *
   * @param	source	The chain to duplicate.
   */
  // public FabrikChain3D(FabrikChain3D source)
  // {
  // 	// Force copy by value
  // 	mChain = source.cloneIkChain();
  // 	mFixedBaseLocation.set( source.getBaseLocation() );
  // 	mLastTargetLocation.set(source.mLastTargetLocation);
  // 	mLastBaseLocation.set(source.mLastBaseLocation);
  // 	mEmbeddedTarget.set(source.mEmbeddedTarget);
  // 	// Copy the basebone constraint UV if there is one to copy
  // 	if (source.mBaseboneConstraintType != BaseboneConstraintType3D.NONE)
  // 	{
  // 		mBaseboneConstraintUV.set(source.mBaseboneConstraintUV);
  // 		mBaseboneRelativeConstraintUV.set(source.mBaseboneRelativeConstraintUV);
  // 	}
  // 	// Native copy by value for primitive members
  // 	mChainLength            = source.mChainLength;
  // 	mCurrentSolveDistance   = source.mCurrentSolveDistance;
  // 	mConnectedChainNumber   = source.mConnectedChainNumber;
  // 	mConnectedBoneNumber    = source.mConnectedBoneNumber;
  // 	mBaseboneConstraintType = source.mBaseboneConstraintType;
  // 	mName                   = source.mName;
  // 	mConstraintLineWidth    = source.mConstraintLineWidth;
  // 	mUseEmbeddedTarget      = source.mUseEmbeddedTarget;
  // }
  static NewByFabrikChain3D(r) {
    const e = new Fi(r.getName());
    return e.mChain = r.cloneIkChain(), e.mFixedBaseLocation.set(r.getBaseLocation()), e.mLastTargetLocation.set(r.mLastTargetLocation), e.mLastBaseLocation.set(r.mLastBaseLocation), e.mEmbeddedTarget.set(r.mEmbeddedTarget), r.mBaseboneConstraintType != 0 && (e.mBaseboneConstraintUV.set(r.mBaseboneConstraintUV), e.mBaseboneRelativeConstraintUV.set(r.mBaseboneRelativeConstraintUV)), e.mChainLength = r.mChainLength, e.mCurrentSolveDistance = r.mCurrentSolveDistance, e.mConnectedChainNumber = r.mConnectedChainNumber, e.mConnectedBoneNumber = r.mConnectedBoneNumber, e.mBaseboneConstraintType = r.mBaseboneConstraintType, e.mName = r.mName, e.mConstraintLineWidth = r.mConstraintLineWidth, e.mUseEmbeddedTarget = r.mUseEmbeddedTarget, e;
  }
  // ---------- Public Methods ------------
  isEmpty() {
    return this.mChain.length == 0;
  }
  firstBone() {
    if (this.isEmpty())
      throw new Error("chain is empty");
    return this.mChain[0];
  }
  lastBone() {
    if (this.isEmpty())
      throw new Error("chain is empty");
    return this.mChain[this.mChain.length - 1];
  }
  firstBoneEndLocation() {
    if (this.isEmpty())
      throw new Error("chain is empty");
    return this.firstBone().getEndLocation();
  }
  lastBoneEndLocation() {
    if (this.isEmpty())
      throw new Error("chain is empty");
    return this.lastBone().getEndLocation();
  }
  /**
   * Add a bone to the end of this IK chain of this FabrikChain3D object.
   * <p>
   * This chain's {@link mChainLength} property is updated to take into account the length of the
   * new bone added to the chain.
   * <p>
   * In addition, if the bone being added is the very first bone, then this chain's
   * {@link mFixedBaseLocation} property is set from the start joint location of the bone.
   *
   * @param	bone	The FabrikBone3D object to add to this FabrikChain3D.
   * @see		#mChainLength
   * @see		#mFixedBaseLocation
   */
  // @Override
  addBone(r) {
    this.mChain.push(r), this.mChain.length == 1 && (this.mFixedBaseLocation.set(r.getStartLocation()), this.mBaseboneConstraintUV = r.getDirectionUV()), this.updateChainLength();
  }
  /**
   * Add a bone to the end of this IK chain given the direction unit vector and length of the new bone to add.
   * <p>
   * The bone added does not have any rotational constraints enforced, and will be drawn with a default color
   * of white at full opacity.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
   * is thrown.
   * <p>
   * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
   * {@link IllegalArgumentException} is thrown.
   *
   * @param	directionUV The initial direction of the new bone
   * @param	length		The length of the new bone
   */
  // @Override
  // public  addConsecutiveBone( directionUV:Vec3,  length:number):void { this.addConsecutiveBone(directionUV, length, new Color() ); }
  /**
   * Add a consecutive bone to the end of this IK chain given the direction unit vector and length of the new bone to add.
   * <p>
   * The bone added does not have any rotational constraints enforced, and will be drawn with a default color
   * of white at full opacity.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
   * is thrown.
   * <p>
   * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
   * {@link IllegalArgumentException} is thrown.
   *
   * @param	directionUV The initial direction of the new bone
   * @param	length		The length of the new bone
   * @param	color		The color with which to draw the bone
   */
  // public  addConsecutiveBone( directionUV:Vec3,  length:number,  color:Color = new Color()):void
  // {
  // 	// Validate the direction unit vector - throws an IllegalArgumentException if it has a magnitude of zero
  // 	Utils.validateDirectionUV(directionUV);
  // 	// Validate the length of the bone - throws an IllegalArgumentException if it is not a positive value
  // 	Utils.validateLength(length);
  // 	// If we have at least one bone already in the chain...
  // 	if (!mChain.isEmpty())
  // 	{
  // 		// Get the end location of the last bone, which will be used as the start location of the new bone
  // 		Vec3f prevBoneEnd = mChain.get(mChain.size()-1).getEndLocation();
  // 		// Add a bone to the end of this IK chain
  // 		// Note: We use a normalised version of the bone direction
  // 		addBone( new FabrikBone3D(prevBoneEnd, directionUV.normalised(), length, color) );
  // 	}
  // 	else // Attempting to add a relative bone when there is no basebone for it to be relative to?
  // 	{
  // 		throw new RuntimeException("You cannot add the basebone as a consecutive bone as it does not provide a start location. Use the addBone() method instead.");
  // 	}
  // }
  /**
   * Add a pre-created consecutive bone to the end of this IK chain.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a {@link RuntimeException}
   * is thrown.
   * <p>
   * If this method is provided with a direction unit vector of zero, or a bone length of zero then then an
   * {@link IllegalArgumentException} is thrown.
   *
   * @param	bone		The bone to add to the end of the chain.
   */
  addConsecutiveBone(r) {
    const e = r.getDirectionUV();
    be.validateDirectionUV(e);
    const t = r.liveLength();
    if (be.validateLength(t), this.mChain.length != 0) {
      const s = this.lastBoneEndLocation();
      r.setStartLocation(s), r.setEndLocation(s.plus(e.times(t))), this.addBone(r);
    } else
      throw new Error(
        "You cannot add the base bone to a chain using this method as it does not provide a start location."
      );
  }
  /**
   * Add a consecutive hinge constrained bone to the end of this chain. The bone may rotate freely about the hinge axis.
   * <p>
   * The bone will be drawn with a default color of white.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with a direction unit vector of zero, then an IllegalArgumentException is thrown.
   * If the joint type requested is not JointType.LOCAL_HINGE or JointType.GLOBAL_HINGE then an IllegalArgumentException is thrown.
   * If this method is provided with a hinge rotation axis unit vector of zero, then an IllegalArgumentException is thrown.
   *
   * @param	directionUV			The initial direction of the new bone.
   * @param	length				The length of the new bone.
   * @param	jointType			The type of hinge joint to be used - either JointType.LOCAL or JointType.GLOBAL.
   * @param	hingeRotationAxis	The axis about which the hinge joint freely rotates.
   */
  // public  addConsecutiveFreelyRotatingHingedBone( directionUV:Vec3,  length:number,  jointType:JointType,  hingeRotationAxis:Vec3):void
  // {
  // 	// Because we aren't constraining this bone to a reference axis within the hinge rotation axis we don't care about the hinge constraint
  // 	// reference axis (7th param) so we'll just generate an axis perpendicular to the hinge rotation axis and use that.
  // 	this.addConsecutiveHingedBone( directionUV, length, jointType, hingeRotationAxis, 180.0, 180.0, Vec3.genPerpendicularVectorQuick(hingeRotationAxis), new Color() );
  // }
  /**
   * Add a consecutive hinge constrained bone to the end of this chain. The bone may rotate freely about the hinge axis.
   * <p>
   * The bone will be drawn with a default color of white.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with a direction unit vector of zero, then an IllegalArgumentException is thrown.
   * If the joint type requested is not JointType.LOCAL_HINGE or JointType.GLOBAL_HINGE then an IllegalArgumentException is thrown.
   * If this method is provided with a hinge rotation axis unit vector of zero, then an IllegalArgumentException is thrown.
   *
   * @param	directionUV			The initial direction of the new bone.
   * @param	length				The length of the new bone.
   * @param	jointType			The type of hinge joint to be used - either JointType.LOCAL or JointType.GLOBAL.
   * @param	hingeRotationAxis	The axis about which the hinge joint freely rotates.
   * @param	color				The color to draw the bone.
   */
  addConsecutiveFreelyRotatingHingedBone(r, e, t, s, i = new Xe()) {
    this.addConsecutiveHingedBone(
      r,
      e,
      t,
      s,
      180,
      180,
      R.genPerpendicularVectorQuick(s),
      i
    );
  }
  /**
   * Add a consecutive hinge constrained bone to the end of this IK chain.
   * <p>
   * The hinge type may be a global hinge where the rotation axis is specified in world-space, or
   * a local hinge, where the rotation axis is relative to the previous bone in the chain.
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
   * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
   *
   * @param	directionUV			The initial direction of the new bone.
   * @param	length				The length of the new bone.
   * @param	jointType			The joint type of the new bone.
   * @param	hingeRotationAxis	The axis about which the hinge rotates.
   * @param	clockwiseDegs		The clockwise constraint angle in degrees.
   * @param	anticlockwiseDegs	The anticlockwise constraint angle in degrees.
   * @param	hingeReferenceAxis	The axis about which any clockwise/anticlockwise rotation constraints are enforced.
   * @param	color				The color to draw the bone.
   */
  addConsecutiveHingedBone(r, e, t, s, i, n, a, o = new Xe(0.5, 0.5, 0.5)) {
    if (be.validateDirectionUV(r), be.validateDirectionUV(s), be.validateLength(e), this.isEmpty())
      throw new Error(
        "You must add a basebone before adding a consectutive bone."
      );
    r.normalise(), s.normalise();
    const h = this.lastBoneEndLocation(), l = Cr.NewByStartDirectionLength(
      h,
      r,
      e
    );
    l.setColor(o);
    const c = new Zt();
    switch (t) {
      case Ce.GLOBAL_HINGE:
        c.setAsGlobalHinge(
          s,
          i,
          n,
          a
        );
        break;
      case Ce.LOCAL_HINGE:
        c.setAsLocalHinge(
          s,
          i,
          n,
          a
        );
        break;
      default:
        throw new Error(
          "Hinge joint types may be only JointType.GLOBAL_HINGE or JointType.LOCAL_HINGE."
        );
    }
    l.setJoint(c), this.addBone(l);
  }
  /**
   * Add a consecutive hinge constrained bone to the end of this IK chain.
   * <p>
   * The hinge type may be a global hinge where the rotation axis is specified in world-space, or
   * a local hinge, where the rotation axis is relative to the previous bone in the chain.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
   * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
   *
   * @param	directionUV						The initial direction of the new bone.
   * @param	length							The length of the new bone.
   * @param	jointType						The joint type of the new bone.
   * @param	hingeRotationAxis				The axis about which the hinge rotates.
   * @param	clockwiseDegs					The clockwise constraint angle in degrees.
   * @param	anticlockwiseDegs				The anticlockwise constraint angle in degrees.
   * @param	hingeConstraintReferenceAxis	The reference axis about which any clockwise/anticlockwise rotation constraints are enforced.
   */
  // public void addConsecutiveHingedBone(Vec3f directionUV,
  // 		                                       float length,
  // 		                                       JointType jointType,
  // 		                                       Vec3f hingeRotationAxis,
  // 		                                       float clockwiseDegs,
  // 		                                       float anticlockwiseDegs,
  // 		                                       Vec3f hingeConstraintReferenceAxis)
  // {
  // 	addConsecutiveHingedBone(directionUV, length, jointType, hingeRotationAxis, clockwiseDegs, anticlockwiseDegs, hingeConstraintReferenceAxis, new Color4f() );
  // }
  /**
   * Add a consecutive rotor (i.e. ball joint) constrained bone to the end of this IK chain.
   * <p>
   * This method can only be used when the IK chain contains a basebone, as without it we do not
   * have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
   *
   * @param	boneDirectionUV					The initial direction unit vector of the new bone.
   * @param	boneLength						The length of the new bone.
   * @param	constraintAngleDegs				The rotor constraint angle of the new bone.
   * @param	color							The color to draw the bone.
   */
  addConsecutiveRotorConstrainedBone(r, e, t, s = new Xe(0.5, 0.5, 0.5)) {
    if (be.validateDirectionUV(r), be.validateLength(e), this.isEmpty())
      throw new Error(
        "Add a basebone before attempting to add consectuive bones."
      );
    const i = Cr.NewByStartDirectionLengthColor(
      this.lastBoneEndLocation(),
      r.normalise(),
      e,
      s
    );
    i.setBallJointConstraintDegs(t), this.addBone(i);
  }
  /**
   * Add a consecutive rotor (i.e. ball joint) constrained bone to the end of this IK chain.
   * <p>
   * The bone will be drawn in white at full opacity by default. This method can only be used when the IK chain contains
   * a basebone, as without it we do not have a start location for this bone (i.e. the end location of the previous bone).
   * <p>
   * If this method is executed on a chain which does not contain a basebone then a RuntimeException is thrown.
   * If this method is provided with bone direction or hinge constraint axis of zero then an IllegalArgumentException is thrown.
   * If the joint type requested is not LOCAL_HINGE or GLOBAL_HINGE then an IllegalArgumentException is thrown.
   *
   * @param	boneDirectionUV		The initial direction unit vector of the new bone.
   * @param	boneLength			The length of the new bone.
   * @param	constraintAngleDegs	The rotor constraint angle for of the new bone.
   */
  // public void addConsecutiveRotorConstrainedBone(Vec3f boneDirectionUV, float boneLength, float constraintAngleDegs)
  // {
  // 	addConsecutiveRotorConstrainedBone( boneDirectionUV, boneLength, constraintAngleDegs, new Color4f() );
  // }
  /**
   * Return the basebone relative unit vector of this chain.
   *
   * This direction is updated by the FabrikStructure3D when this chain is connected to another chain. There is
   * no other possible way of doing it as we have no knowledge of other chains, but the structure does, allowing
   * us to calculate this relative constraint UV.
   *
   * @return The basebone relative constraint UV as updated (on solve) by the structure containing this chain.
   */
  // @Override
  getBaseboneRelativeConstraintUV() {
    return this.mBaseboneRelativeConstraintUV;
  }
  /**
   * Return the basebone constraint type of this chain.
   *
   * @return	The basebone constraint type of this chain.
   */
  // @Override
  getBaseboneConstraintType() {
    return this.mBaseboneConstraintType;
  }
  /**
   * Method to set the line width (in pixels) with which to draw any constraint lines.
   * <p>
   * Valid values are 1.0f to 32.0f inclusive, although the OpenGL standard specifies that only line widths of 1.0f are guaranteed to work.
   * Values outside of this range will result in an IllegalArgumentException being thrown.
   *
   * @param	lineWidth	The width of the line used to draw constraint lines.
   */
  setConstraintLineWidth(r) {
    be.validateLineWidth(r), this.mConstraintLineWidth = r;
  }
  /**
   * Get the directional constraint of the basebone.
   * <p>
   * If the basebone is not constrained then a RuntimeException is thrown. If you wish to check whether the
   * basebone of this IK chain is constrained you may use the {@link #getBaseboneConstraintType()} method.
   *
   * @return  The global directional constraint unit vector of the basebone of this IK chain.
   */
  // @Override
  getBaseboneConstraintUV() {
    if (this.mBaseboneConstraintType != 0)
      return this.mBaseboneConstraintUV;
    throw new Error(
      "Cannot return the basebone constraint when the basebone constraint type is NONE."
    );
  }
  /**
   * Return the base location of the IK chain.
   * <p>
   * Regardless of how many bones are contained in the chain, the base location is always the start location of the
   * first bone in the chain.
   * <p>
   * This method does not return the mBaseLocation property of this chain because the start location of the basebone
   * may be more up-to-date due to a moving 'fixed' location.
   *
   * @return	The location of the start joint of the first bone in this chain.
   */
  // @Override
  getBaseLocation() {
    return this.firstBone().getStartLocation();
  }
  /**
   * Return a bone by its zero-indexed location in the IK chain.
   *
   * @param	boneNumber	The number of the bone to return from the Vector of FabrikBone3D objects.
   * @return				The specified bone.
   */
  // @Override
  getBone(r) {
    if (this.isEmpty())
      throw new Error("chain is empty");
    if (r < 0 && r >= this.mChain.length)
      throw new Error("out of range");
    return this.mChain[r];
  }
  /**
   * Return the List%lt;FabrikBone3D%gt; which comprises the actual IK chain of this FabrikChain3D object.
   *
   * @return	The List%lt;FabrikBone3D%gt; which comprises the actual IK chain of this FabrikChain3D object.
   */
  // @Override
  getChain() {
    return this.mChain;
  }
  /**
   * Return the current length of the IK chain.
   * <p>
   * This method does not dynamically re-calculate the length of the chain - it merely returns the previously
   * calculated chain length, which gets updated each time a bone is added or removed from the chain. However,
   * as the chain length is updated whenever necessary this should be fine.
   * <p>
   * If you need a calculated-on-the-fly value for the chain length, then use the getLiveChainLength() method.
   *
   * @return	The pre-calculated length of the IK chain as stored in the mChainLength property.
   */
  // @Override
  getChainLength() {
    return this.mChainLength;
  }
  /**
   * Return the index of the bone in another chain that this this chain is connected to.
   * <p>
   * Returns -1 (default) if this chain is not connected to another chain.
   *
   * @return	The zero-indexed number of the bone we are connected to in the chain we are connected to.
   */
  // @Override
  getConnectedBoneNumber() {
    return this.mConnectedBoneNumber;
  }
  /**
   * Return the index of the chain in a FabrikStructure3D that this this chain is connected to.
   * <p>
   * Returns -1 (default) if this chain is not connected to another chain.
   *
   * @return	The zero-index number of the chain we are connected to.
   */
  // @Override
  getConnectedChainNumber() {
    return this.mConnectedChainNumber;
  }
  /**
   * Return the location of the end effector in the IK chain.
   * <p>
   * Regardless of how many bones are contained in the chain, the end effector is always the end location
   * of the final bone in the chain.
   *
   * @return	The location of this chain's end effector.
   */
  // @Override
  getEffectorLocation() {
    return this.lastBoneEndLocation();
  }
  /**
   * Return whether or not this chain uses an embedded target.
   *
   * Embedded target mode may be enabled or disabled using setEmbeddededTargetMode(boolean).
   *
   * @return whether or not this chain uses an embedded target.
   */
  // @Override
  getEmbeddedTargetMode() {
    return this.mUseEmbeddedTarget;
  }
  /**
   * Return the embedded target location.
   *
   * @return the embedded target location.
   */
  // @Override
  getEmbeddedTarget() {
    return this.mEmbeddedTarget;
  }
  /**
   * Return the target of the last solve attempt.
   * <p>
   * The target location and the effector location are not necessarily at the same location unless the chain has been solved
   * for distance, and even then they are still likely to be <i>similar</i> rather than <b>identical</b> values.
   *
   * @return	The target location of the last solve attempt.
   */
  // @Override
  getLastTargetLocation() {
    return this.mLastTargetLocation;
  }
  /**
   * Return the live calculated length of the chain.
   *
   * Typically, the getChainLength() can be called which returns the length of the chain as updated /
   * recalculated when a bone is added or removed from the chain (which is significantly faster as it
   * doesn't require recalculation), but sometimes it may be useful to get the definitive most
   * up-to-date chain length so you can check if operations being performed have altered the chain
   * length - hence this method.
   *
   * @return	The 'live' (i.e. calculated from scratch) length of the chain.
   */
  getLiveChainLength() {
    let r = 0;
    return this.mChain.forEach((e) => {
      r += e.liveLength();
    }), r;
  }
  /**
   * Return the name of this IK chain.
   *
   * @return	The name of this IK chain.
   */
  // @Override
  getName() {
    return this.mName;
  }
  /**
   * Return the number of bones in this IK chain.
   *
   * @return	The number of bones in this IK chain.
   */
  // @Override
  getNumBones() {
    return this.mChain.length;
  }
  /**
   * Remove a bone from this IK chain by its zero-indexed location in the chain.
   * <p>
   * This chain's {@link mChainLength} property is updated to take into account the new chain length.
   * <p>
   * If the bone number to be removed does not exist in the chain then an IllegalArgumentException is thrown.
   *
   * @param	boneNumber	The zero-indexed bone to remove from this IK chain.
   */
  // @Override
  removeBone(r) {
    if (r < this.mChain.length)
      this.mChain.splice(r, 1), this.updateChainLength();
    else
      throw new Error(
        "Bone " + r + " does not exist to be removed from the chain. Bones are zero indexed."
      );
  }
  /**
   * Set the relative basebone constraint UV - this direction should be relative to the coordinate space of the basebone.
   *
   * This function is deliberately made package-private as it should not be used by the end user - instead, the
   * FabrikStructure3D.solveForTarget() method will update this mBaseboneRelativeConstraintUV property FOR USE BY this
   * chain as required.
   *
   * The reason for this is that this chain on its own cannot calculate the relative constraint
   * direction, because it relies on direction of the connected / 'host' bone in the chain that this chain is connected
   * to - only we have no knowledge of that other chain! But, the FabrikStructure3D DOES have knowledge of that other
   * chain, and is hence able to calculate and update this relative basebone constraint direction for us.
   **/
  setBaseboneRelativeConstraintUV(r) {
    this.mBaseboneRelativeConstraintUV = r;
  }
  /**
   * Set the relative basebone reference constraint UV - this direction should be relative to the coordinate space of the basebone.
   *
   * This function is deliberately made package-private as it should not be used by the end user - instead, the
   * FabrikStructure3D.solveForTarget() method will update this mBaseboneRelativeConstraintUV property FOR USE BY this
   * chain as required.
   *
   * This property is required when we have a LOCAL_HINGE basebone constraint with reference axes - we must maintain the
   * hinge's own rotation and reference axes, and then the FabrikStructure3D.solveForTarget() method updates the
   * mBaseboneRelativeConstraintUV and mBaseboneRelativeReferenceConstraintUV as required.
   **/
  setBaseboneRelativeReferenceConstraintUV(r) {
    this.mBaseboneRelativeReferenceConstraintUV = r;
  }
  /**
   * Return the relative basebone reference constraint unit vector.
   *
   * @return	The relative basebone reference constraint unit vector.
   */
  getBaseboneRelativeReferenceConstraintUV() {
    return this.mBaseboneRelativeReferenceConstraintUV;
  }
  /**
   * Specify whether we should use the embedded target location when solving the IK chain.
   *
   * @param	value	Whether we should use the embedded target location when solving the IK chain.
   */
  // @Override
  setEmbeddedTargetMode(r) {
    this.mUseEmbeddedTarget = r;
  }
  /**
   * Set this chain to have a rotor basebone constraint.
   * <p>
   * Depending on whether the constraint type is GLOBAL_ROTOR or LOCAL_ROTOR the constraint will be applied
   * about global space or about the local coordinate system of a bone in another chain that this chain is
   * attached to.
   * <p>
   * The angle provided should be between the range of 0.0f (completely constrained) to 180.0f (completely free to
   * rotate). Values outside of this range will be clamped to the relevant minimum or maximum.
   * <p>
   * If this chain does not contain a basebone then a RuntimeException is thrown.
   * If the constraint axis is a zero vector or the rotor type is not GLOBAL_ROTOR or LOCAL_ROTOR then then an
   * IllegalArgumentException is thrown.
   *
   * @param	rotorType		The type of constraint to apply, this may be GLOBAL_ROTOR or LOCAL_ROTOR.
   * @param	constraintAxis	The axis about which the rotor applies.
   * @param	angleDegs		The angle about the constraint axis to limit movement in degrees.
   */
  setRotorBaseboneConstraint(r, e, t) {
    if (this.isEmpty())
      throw new Error(
        "Chain must contain a basebone before we can specify the basebone constraint type."
      );
    if (e.length() <= 0)
      throw new Error("Constraint axis cannot be zero.");
    if (t < 0 && (t = 0), t > 180 && (t = 180), !(r == 1 || r == 2))
      throw new Error(
        "The only valid rotor types for this method are GLOBAL_ROTOR and LOCAL_ROTOR."
      );
    this.mBaseboneConstraintType = r, this.mBaseboneConstraintUV = e.normalised(), this.mBaseboneRelativeConstraintUV.set(this.mBaseboneConstraintUV), this.getBone(0).getJoint().setAsBallJoint(t);
  }
  /**
   * Set this chain to have a hinged basebone constraint.
   * <p>
   * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
   * If the hinge rotation or reference axes are zero vectors then an IllegalArgumentException is thrown.
   * If the hinge reference axis does not lie in the plane of the hinge rotation axis (that is, they are not perpendicular)
   * then an IllegalArgumentException is thrown.
   *
   * @param hingeType				The type of constraint to apply, this may be GLOBAL_HINGE or LOCAL_HINGE.
   * @param hingeRotationAxis		The axis about which the global hinge rotates.
   * @param cwConstraintDegs		The clockwise constraint angle about the hinge reference axis in degrees.
   * @param acwConstraintDegs		The clockwise constraint angle about the hinge reference axis in degrees.
   * @param hingeReferenceAxis	The axis (perpendicular to the hinge rotation axis) about which the constraint angles apply.
   */
  setHingeBaseboneConstraint(r, e, t, s, i) {
    if (this.isEmpty())
      throw new Error(
        "Chain must contain a basebone before we can specify the basebone constraint type."
      );
    if (e.length() <= 0)
      throw new Error("Hinge rotation axis cannot be zero.");
    if (i.length() <= 0)
      throw new Error("Hinge reference axis cannot be zero.");
    if (!R.perpendicular(e, i))
      throw new Error(
        "The hinge reference axis must be in the plane of the hinge rotation axis, that is, they must be perpendicular."
      );
    if (!(r == 3 || r == 4))
      throw new Error(
        "The only valid hinge types for this method are GLOBAL_HINGE and LOCAL_HINGE."
      );
    this.mBaseboneConstraintType = r, this.mBaseboneConstraintUV.set(e.normalised());
    const n = new Zt();
    r == 3 ? n.setHinge(
      Ce.GLOBAL_HINGE,
      e,
      t,
      s,
      i
    ) : n.setHinge(
      Ce.LOCAL_HINGE,
      e,
      t,
      s,
      i
    ), this.getBone(0).setJoint(n);
  }
  /**
   * Set this chain to have a freely rotating globally hinged basebone.
   * <p>
   * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
   * is generated to be any vector perpendicular to the hinge rotation axis.
   * <p>
   * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
   * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
   *
   * @param hingeRotationAxis		The world-space axis about which the global hinge rotates.
   */
  setFreelyRotatingGlobalHingedBasebone(r) {
    this.setHingeBaseboneConstraint(
      3,
      r,
      180,
      180,
      R.genPerpendicularVectorQuick(r)
    );
  }
  /**
   * Set this chain to have a freely rotating globally hinged basebone.
   * <p>
   * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
   * is generated to be any vector perpendicular to the hinge rotation axis.
   * <p>
   * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
   * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
   *
   * @param hingeRotationAxis		The world-space axis about which the global hinge rotates.
   */
  setFreelyRotatingLocalHingedBasebone(r) {
    this.setHingeBaseboneConstraint(
      4,
      r,
      180,
      180,
      R.genPerpendicularVectorQuick(r)
    );
  }
  /**
   * Set this chain to have a locally hinged basebone.
   * <p>
   * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
   * is generated to be any vector perpendicular to the hinge rotation axis.
   * <p>
   * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
   * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
   *
   * @param hingeRotationAxis		The local axis about which the hinge rotates.
   * @param cwDegs				The clockwise constraint angle in degrees.
   * @param acwDegs				The anticlockwise constraint angle in degrees.
   * @param hingeReferenceAxis	The local reference axis about which the hinge is constrained.
   * */
  setLocalHingedBasebone(r, e, t, s) {
    this.setHingeBaseboneConstraint(
      4,
      r,
      e,
      t,
      s
    );
  }
  /**
   * Set this chain to have a globally hinged basebone.
   * <p>
   * The clockwise and anticlockwise constraint angles are automatically set to 180 degrees and the hinge reference axis
   * is generated to be any vector perpendicular to the hinge rotation axis.
   * <p>
   * If the number of bones in this chain is zero (i.e. it does not contain a basebone) then a RuntimeException is thrown.
   * If the hinge rotation axis are zero vectors then an IllegalArgumentException is thrown.
   *
   * @param hingeRotationAxis		The global / world-space axis about which the hinge rotates.
   * @param cwDegs				The clockwise constraint angle in degrees.
   * @param acwDegs				The anticlockwise constraint angle in degrees.
   * @param hingeReferenceAxis	The global / world-space reference axis about which the hinge is constrained.
   * */
  setGlobalHingedBasebone(r, e, t, s) {
    this.setHingeBaseboneConstraint(
      3,
      r,
      e,
      t,
      s
    );
  }
  /**
   * Set a directional constraint for the basebone.
   * <p>
   * This method constrains the <strong>basebone</strong> (<em>only</em>) to a global direction unit vector.
   * <p>
   * Attempting to set the basebone constraint when the bone has a basebone constraint type of NONE or providing
   * a constraint vector of zero will result will result in an IllegalArgumentException being thrown.
   *
   * @param	constraintUV	The direction unit vector to constrain the basebone to.
   * @see		au.edu.federation.caliko.FabrikJoint3D#setBallJointConstraintDegs(float angleDegs)
   * @see		au.edu.federation.caliko.FabrikJoint3D#setHingeJointClockwiseConstraintDegs(float)
   * @see		au.edu.federation.caliko.FabrikJoint3D#setHingeJointAnticlockwiseConstraintDegs(float)
   */
  // @Override
  setBaseboneConstraintUV(r) {
    if (this.mBaseboneConstraintType == 0)
      throw new Error(
        "Specify the basebone constraint type with setBaseboneConstraintTypeCannot specify a basebone constraint when the current constraint type is BaseboneConstraint.NONE."
      );
    be.validateDirectionUV(r), r.normalise(), this.mBaseboneConstraintUV.set(r);
  }
  /**
   * Method used to move the base location of a chain relative to its connection point.
   * <p>
   * The assignment is made by reference so that this base location and the location where
   * we attach to the other chain are the same Vec3f object.
   * <p>
   * Note: If this chain is attached to another chain then this 'fixed' base location will be updated
   * as and when the connection point in the chain we are attached to moves.
   *
   * @param	baseLocation	The fixed base location for this chain.
   */
  // @Override
  setBaseLocation(r) {
    this.mFixedBaseLocation = r;
  }
  /**
   * Connect this chain to the specified bone in the specified chain in the provided structure.
   * <p>
   * In order to connect this chain to another chain, both chains must exist within the same structure.
   * <p>
   * If the structure does not contain the specified chain or bone then an IllegalArgumentException is thrown.
   *
   * @param	structure	The structure which contains the chain which contains the bone to connect to.
   * @param	chainNumber	The zero-indexed number of the chain in the structure to connect to.
   * @param	boneNumber	The zero-indexed number of the bone in the chain to connect to.
   */
  connectToStructure(r, e, t) {
    const s = r.getNumChains();
    if (e > s)
      throw new Error(
        "Structure does not contain a chain " + e + " - it has " + s + " chains."
      );
    const i = r.getChain(e).getNumBones();
    if (t > i)
      throw new Error(
        "Chain does not contain a bone " + t + " - it has " + i + " bones."
      );
    this.mConnectedChainNumber = e, this.mConnectedBoneNumber = t;
  }
  /**
   * Set the fixed basebone mode for this chain.
   * <p>
   * If the basebone is 'fixed' in place, then its start location cannot move. The bone is still allowed to
   * rotate, with or without constraints.
   * <p>
   * Specifying a non-fixed base location while this chain is connected to another chain will result in a
   * RuntimeException being thrown.
   * <p>
   * Fixing the basebone's start location in place and constraining to a global absolute direction are
   * mutually exclusive. Disabling fixed base mode while the chain's constraint type is
   * BaseboneConstraintType3D.GLOBAL_ABSOLUTE will result in a RuntimeException being thrown.	 *
   *
   * @param  value  Whether or not to fix the basebone start location in place.
   */
  // @Override
  setFixedBaseMode(r) {
    if (!r && this.mConnectedChainNumber != -1)
      throw new Error(
        "This chain is connected to another chain so must remain in fixed base mode."
      );
    if (this.mBaseboneConstraintType == 1 && !r)
      throw new Error(
        "Cannot set a non-fixed base mode when the chain's constraint type is BaseboneConstraintType3D.GLOBAL_ABSOLUTE_ROTOR."
      );
    this.mFixedBaseMode = r;
  }
  /**
   * Set the maximum number of attempts that will be made to solve this IK chain.
   * <p>
   * The FABRIK algorithm may require more than a single pass in order to solve
   * a given IK chain for an acceptable distance threshold. If we reach this
   * iteration limit then we stop attempting to solve the IK chain. Further details
   * on this topic are provided in the {@link #mMaxIterationAttempts} documentation.
   * <p>
   * If a maxIterations value of less than 1 is provided then an IllegalArgumentException is
   * thrown, as we must make at least a single attempt to solve an IK chain.
   *
   * @param maxIterations  The maximum number of attempts that will be made to solve this IK chain.
   */
  // @Override
  setMaxIterationAttempts(r) {
    if (r < 1)
      throw new Error(
        "The maximum number of attempts to solve this IK chain must be at least 1."
      );
    this.mMaxIterationAttempts = r;
  }
  /**
   * Set the minimum iteration change before we dynamically abort any further attempts to solve this IK chain.
   * <p>
   * If the latest solution found has changed by less than this amount then we consider the progress being made
   * to be not worth the computational effort and dynamically abort any further attempt to solve the chain for
   * the current target to minimise CPU usage.
   * <p>
   * If a minIterationChange value of less than zero is specified then an IllegalArgumentException is
   * thrown.
   *
   * @param	minIterationChange  The minimum change in solve distance from one iteration to the next.
   */
  // @Override
  setMinIterationChange(r) {
    if (r < 0)
      throw new Error(
        "The minimum iteration change value must be more than or equal to zero."
      );
    this.mMinIterationChange = r;
  }
  /**
   * Set the name of this chain, capped to 100 characters if required.
   *
   * @param	name	The name to set.
   */
  // @Override
  setName(r) {
    this.mName = be.getValidatedName(r);
  }
  /**
   * Set the distance threshold within which we consider the IK chain to be successfully solved.
   * <p>
   * If a solve distance value of less than zero is specified then an IllegalArgumentException is thrown.
   *
   * @param  solveDistance  The distance between the end effector of this IK chain and target within which we will accept the solution.
   */
  // @Override
  setSolveDistanceThreshold(r) {
    if (r < 0)
      throw new Error(
        "The solve distance threshold must be greater than or equal to zero."
      );
    this.mSolveDistanceThreshold = r;
  }
  /**
   * Set the color of all bones in this chain to the specified color.
   *
   * @param	color	The color to set all bones in this chain.
   */
  setColor(r) {
    this.mChain.forEach((e) => {
      e.setColor(r);
    });
  }
  /**
   * Solve this IK chain for the current embedded target location.
   *
   * The embedded target location can be updated by calling updateEmbeddedTarget(Vec3f).
   *
   * @return The distance between the end effector and the chain's embedded target location for our best solution.
   */
  // @Override
  solveForEmbeddedTarget() {
    if (this.mUseEmbeddedTarget)
      return this.solveForTarget(this.mEmbeddedTarget);
    throw new Error(
      "This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true)."
    );
  }
  /**
   * Method to solve this IK chain for the given target location.
   * <p>
   * The end result of running this method is that the IK chain configuration is updated.
   * <p>
   * To minimuse CPU usage, this method dynamically aborts if:
   * - The solve distance (i.e. distance between the end effector and the target) is below the {@link mSolveDistanceThreshold},
   * - A solution incrementally improves on the previous solution by less than the {@link mMinIterationChange}, or
   * - The number of attempts to solve the IK chain exceeds the {@link mMaxIterationAttempts}.
   *
   * @param	targetX	The x location of the target
   * @param	targetY	The y location of the target
   * @param	targetZ	The z location of the target
   * @return			The resulting distance between the end effector and the new target location after solving the IK chain.
   */
  // public solveForTarget( targetX:number,  targetY:number,  targetZ:number):number
  // {
  // 	return this.solveForTarget( new Vec3(targetX, targetY, targetZ) );
  // }
  /**
   * Method to solve this IK chain for the given target location.
   * <p>
   * The end result of running this method is that the IK chain configuration is updated.
   * <p>
   * To minimuse CPU usage, this method dynamically aborts if:
   * - The solve distance (i.e. distance between the end effector and the target) is below the {@link mSolveDistanceThreshold},
   * - A solution incrementally improves on the previous solution by less than the {@link mMinIterationChange}, or
   * - The number of attempts to solve the IK chain exceeds the {@link mMaxIterationAttempts}.
   *
   * @param	newTarget	The location of the target for which we will solve this IK chain.
   * @return	float		The resulting distance between the end effector and the new target location after solving the IK chain.
   */
  // @Override
  solveForTarget(r) {
    this.mLastTargetLocation.approximatelyEquals(
      r,
      Fi.DefaultApproximatelyEqualsTolerance
    ) && this.mLastBaseLocation.approximatelyEquals(
      this.getBaseLocation(),
      Fi.DefaultApproximatelyEqualsTolerance
    );
    let e = new Array(), t = Number.MAX_VALUE, s = Number.MAX_VALUE, i;
    for (let n = 0; n < this.mMaxIterationAttempts; ++n) {
      if (i = this.solveIK(r), i < t) {
        if (t = i, e = this.cloneIkChain(), i <= this.mSolveDistanceThreshold)
          break;
      } else if (Math.abs(i - s) < this.mMinIterationChange)
        break;
      s = i;
    }
    return this.mCurrentSolveDistance = t, this.mChain = e, this.mLastBaseLocation.set(this.getBaseLocation()), this.mLastTargetLocation.set(r), this.mCurrentSolveDistance;
  }
  /** Return a concise, human-readable of the IK chain. */
  // @Override
  toString() {
    let r = `--- FabrikChain3D: ${this.mName} ---\r
`;
    return this.isEmpty() ? r += "Chain does not contain any bones" : (r += `Bone count:    : ${this.mChain.length}\r
`, r += `Base location  : ${this.getBaseLocation()}\r
`, r += `Chain length   : ${this.getChainLength()}\r
`, r += `Fixed base mode: ${this.mFixedBaseMode ? "YES" : "NO"}\r
`, this.mChain.forEach((e) => {
      r += `--- Bone: ${e} " ---\r
`, r += e.toString();
    })), r;
  }
  // ---------- Private Methods ----------
  /**
   * Solve the IK chain for the given target using the FABRIK algorithm.
   * <p>
   * If this chain does not contain any bones then a RuntimeException is thrown.
   *
   * @return	The best solve distance found between the end-effector of this chain and the provided target.
   */
  solveIK(r) {
    if (this.isEmpty())
      throw new Error(
        "It makes no sense to solve an IK chain with zero bones."
      );
    for (let e = this.mChain.length - 1; e >= 0; --e) {
      const t = this.getBone(e), s = t.length(), i = t.getJoint(), n = t.getJointType();
      if (e != this.mChain.length - 1) {
        const a = this.getBone(e + 1).getDirectionUV().negated();
        let o = t.getDirectionUV().negated();
        if (n == Ce.BALL) {
          const l = R.getAngleBetweenDegs(
            a,
            o
          ), c = i.getBallJointConstraintDegs();
          l > c && (o = R.getAngleLimitedUnitVectorDegs(
            o,
            a,
            c
          ));
        } else if (n == Ce.GLOBAL_HINGE)
          o = o.projectOntoPlane(
            i.getHingeRotationAxis()
          );
        else if (n == Ce.LOCAL_HINGE) {
          let l = new Ns(), c = new R();
          e > 0 ? (l = Ns.createRotationMatrix(
            this.getBone(e - 1).getDirectionUV()
          ), c = l.timesByVec3(i.getHingeRotationAxis()).normalise()) : c = this.mBaseboneRelativeConstraintUV, o = o.projectOntoPlane(
            c
          );
        }
        const h = t.getEndLocation().plus(o.times(s));
        t.setStartLocation(h), e > 0 && this.getBone(e - 1).setEndLocation(h);
      } else {
        t.setEndLocation(r);
        let a = t.getDirectionUV().negated();
        switch (n) {
          case Ce.BALL:
            break;
          case Ce.GLOBAL_HINGE:
            a = a.projectOntoPlane(
              i.getHingeRotationAxis()
            );
            break;
          case Ce.LOCAL_HINGE:
            const l = Ns.createRotationMatrix(
              this.getBone(e - 1).getDirectionUV()
            ).timesByVec3(i.getHingeRotationAxis()).normalise();
            a = a.projectOntoPlane(
              l
            );
            break;
        }
        const o = r.plus(
          a.times(s)
        );
        t.setStartLocation(o), e > 0 && this.getBone(e - 1).setEndLocation(o);
      }
    }
    for (let e = 0; e < this.mChain.length; ++e) {
      const t = this.getBone(e), s = t.length();
      if (e != 0) {
        let i = t.getDirectionUV(), n = this.getBone(e - 1).getDirectionUV();
        const a = t.getJoint(), o = a.getJointType();
        if (o == Ce.BALL) {
          const l = R.getAngleBetweenDegs(
            n,
            i
          ), c = a.getBallJointConstraintDegs();
          l > c && (i = R.getAngleLimitedUnitVectorDegs(
            i,
            n,
            c
          ));
        } else if (o == Ce.GLOBAL_HINGE) {
          const l = a.getHingeRotationAxis();
          i = i.projectOntoPlane(l);
          const c = -a.getHingeClockwiseConstraintDegs(), d = a.getHingeAnticlockwiseConstraintDegs();
          if (!be.approximatelyEquals(
            c,
            -Zt.MAX_CONSTRAINT_ANGLE_DEGS,
            Fi.DefaultApproximatelyEqualsTolerance
          ) && !be.approximatelyEquals(
            d,
            Zt.MAX_CONSTRAINT_ANGLE_DEGS,
            Fi.DefaultApproximatelyEqualsTolerance
          )) {
            const u = a.getHingeReferenceAxis(), f = R.getSignedAngleBetweenDegs(
              u,
              i,
              l
            );
            f > d ? i = R.rotateAboutAxisDegs(
              u,
              d,
              l
            ).normalised() : f < c && (i = R.rotateAboutAxisDegs(
              u,
              c,
              l
            ).normalised());
          }
        } else if (o == Ce.LOCAL_HINGE) {
          const l = a.getHingeRotationAxis(), c = Ns.createRotationMatrix(n), d = c.timesByVec3(l).normalise();
          i = i.projectOntoPlane(
            d
          );
          const u = -a.getHingeClockwiseConstraintDegs(), f = a.getHingeAnticlockwiseConstraintDegs();
          if (!be.approximatelyEquals(
            u,
            -Zt.MAX_CONSTRAINT_ANGLE_DEGS,
            Fi.DefaultApproximatelyEqualsTolerance
          ) && !be.approximatelyEquals(
            f,
            Zt.MAX_CONSTRAINT_ANGLE_DEGS,
            Fi.DefaultApproximatelyEqualsTolerance
          )) {
            const m = c.timesByVec3(a.getHingeReferenceAxis()).normalise(), _ = R.getSignedAngleBetweenDegs(
              m,
              i,
              d
            );
            _ > f ? i = R.rotateAboutAxisDegs(
              m,
              f,
              d
            ).normalise() : _ < u && (i = R.rotateAboutAxisDegs(
              m,
              u,
              d
            ).normalise());
          }
        }
        const h = t.getStartLocation().plus(i.times(s));
        t.setEndLocation(h), e < this.mChain.length - 1 && this.getBone(e + 1).setStartLocation(h);
      } else if (this.mFixedBaseMode ? t.setStartLocation(this.mFixedBaseLocation) : t.setStartLocation(
        t.getEndLocation().minus(t.getDirectionUV().times(s))
      ), this.mBaseboneConstraintType == 0) {
        const i = t.getStartLocation().plus(t.getDirectionUV().times(s));
        t.setEndLocation(i), this.mChain.length > 1 && this.getBone(1).setStartLocation(i);
      } else if (this.mBaseboneConstraintType == 1) {
        let i = t.getDirectionUV();
        const n = R.getAngleBetweenDegs(
          this.mBaseboneConstraintUV,
          i
        ), a = t.getBallJointConstraintDegs();
        n > a && (i = R.getAngleLimitedUnitVectorDegs(
          i,
          this.mBaseboneConstraintUV,
          a
        ));
        const o = t.getStartLocation().plus(i.times(s));
        t.setEndLocation(o), this.mChain.length > 1 && this.getBone(1).setStartLocation(o);
      } else if (this.mBaseboneConstraintType == 2) {
        let i = t.getDirectionUV();
        const n = R.getAngleBetweenDegs(
          this.mBaseboneRelativeConstraintUV,
          i
        ), a = t.getBallJointConstraintDegs();
        n > a && (i = R.getAngleLimitedUnitVectorDegs(
          i,
          this.mBaseboneRelativeConstraintUV,
          a
        ));
        const o = t.getStartLocation().plus(i.times(s));
        t.setEndLocation(o), this.mChain.length > 1 && this.getBone(1).setStartLocation(o);
      } else if (this.mBaseboneConstraintType == 3) {
        const i = t.getJoint(), n = i.getHingeRotationAxis(), a = -i.getHingeClockwiseConstraintDegs(), o = i.getHingeAnticlockwiseConstraintDegs();
        let h = t.getDirectionUV().projectOntoPlane(n);
        if (!(be.approximatelyEquals(
          a,
          -Zt.MAX_CONSTRAINT_ANGLE_DEGS,
          0.01
        ) && be.approximatelyEquals(
          o,
          Zt.MAX_CONSTRAINT_ANGLE_DEGS,
          0.01
        ))) {
          const c = i.getHingeReferenceAxis(), d = R.getSignedAngleBetweenDegs(
            c,
            h,
            n
          );
          d > o ? h = R.rotateAboutAxisDegs(
            c,
            o,
            n
          ).normalise() : d < a && (h = R.rotateAboutAxisDegs(
            c,
            a,
            n
          ).normalise());
        }
        const l = t.getStartLocation().plus(h.times(s));
        t.setEndLocation(l), this.mChain.length > 1 && this.getBone(1).setStartLocation(l);
      } else if (this.mBaseboneConstraintType == 4) {
        const i = t.getJoint(), n = this.mBaseboneRelativeConstraintUV, a = -i.getHingeClockwiseConstraintDegs(), o = i.getHingeAnticlockwiseConstraintDegs();
        let h = t.getDirectionUV().projectOntoPlane(n);
        if (!(be.approximatelyEquals(
          a,
          -Zt.MAX_CONSTRAINT_ANGLE_DEGS,
          0.01
        ) && be.approximatelyEquals(
          o,
          Zt.MAX_CONSTRAINT_ANGLE_DEGS,
          0.01
        ))) {
          const c = this.mBaseboneRelativeReferenceConstraintUV, d = R.getSignedAngleBetweenDegs(
            c,
            h,
            n
          );
          d > o ? h = R.rotateAboutAxisDegs(
            c,
            o,
            n
          ).normalise() : d < a && (h = R.rotateAboutAxisDegs(
            c,
            a,
            n
          ).normalise());
        }
        const l = t.getStartLocation().plus(h.times(s));
        t.setEndLocation(l), this.mChain.length > 1 && this.getBone(1).setStartLocation(l);
      }
    }
    return this.mLastTargetLocation.set(r), R.distanceBetween(this.lastBoneEndLocation(), r);
  }
  /***
   * Calculate the length of this IK chain by adding up the lengths of each bone.
   * <p>
   * The resulting chain length is stored in the mChainLength property.
   * <p>
   * This method is called each time a bone is added to the chain. In addition, the
   * length of each bone is recalculated during the process to ensure that our chain
   * length is accurate. As the typical usage of a FabrikChain3D is to add a number
   * of bones once (during setup) and then use them, this should not have any
   * performance implication on the typical execution cycle of a FabrikChain3D object,
   * as this method will not be called in any method which executes regularly.
   */
  // @Override
  updateChainLength() {
    this.mChainLength = 0, this.mChain.forEach((r) => {
      this.mChainLength += r.length();
    });
  }
  /**
   * Update the embedded target for this chain.
   *
   * The internal mEmbeddedTarget object is updated with the location of the provided parameter.
   * If the chain is not in useEmbeddedTarget mode then a RuntimeException is thrown.
   * Embedded target mode can be enabled by calling setEmbeddedTargetMode(true) on the chain.
   *
   * @param newEmbeddedTarget	The location of the embedded target.
   */
  // @Override
  updateEmbeddedTarget(r) {
    if (this.mUseEmbeddedTarget)
      this.mEmbeddedTarget.set(r);
    else
      throw new Error(
        "This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true)."
      );
  }
  /**
   * Update the embedded target for this chain.
   *
   * The internal mEmbeddedTarget object is updated with the location of the provided parameter.
   * If the chain is not in useEmbeddedTarget mode then a RuntimeException is thrown.
   * Embedded target mode can be enabled by calling setEmbeddedTargetMode(true) on the chain.
   *
   * @param x	The x location of the embedded target.
   * @param y	The y location of the embedded target.
   * @param z	The z location of the embedded target.
   */
  // public updateEmbeddedTarget( x:number, y:number, z:number):void
  // {
  // 	// Using embedded target mode? Overwrite embedded target with provided location
  // 	if (mUseEmbeddedTarget) {
  // 	  mEmbeddedTarget.set( new Vec3f(x, y, z) );
  // 	}
  // 	else {
  // 	  throw new RuntimeException("This chain does not have embedded targets enabled - enable with setEmbeddedTargetMode(true).");
  // 	}
  // }
  /**
   * Clone and return the IK Chain of this FabrikChain3D, that is, the list of FabrikBone3D objects.
   *
   * @return	A cloned List%lt;FabrikBone3D%gt;
   */
  cloneIkChain() {
    this.mChain.length;
    const r = new Array();
    return this.mChain.forEach((e) => {
      r.push(Cr.NewByFabrikBone3D(e));
    }), r;
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getMaxIterationAttempts() {
    return this.mMaxIterationAttempts;
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getMinIterationChange() {
    return this.mMinIterationChange;
  }
  /**
   * {@inheritDoc}
   */
  // @Override
  getSolveDistanceThreshold() {
    return this.mSolveDistanceThreshold;
  }
  //   @Override
  //   public int hashCode() {
  //     final int prime = 31;
  //     int result = 1;
  //     result = prime * result + ((mBaseboneConstraintType == null) ? 0 : mBaseboneConstraintType.hashCode());
  //     result = prime * result + ((mBaseboneConstraintUV == null) ? 0 : mBaseboneConstraintUV.hashCode());
  //     result = prime * result + ((mBaseboneRelativeConstraintUV == null) ? 0 : mBaseboneRelativeConstraintUV.hashCode());
  //     result = prime * result
  //         + ((mBaseboneRelativeReferenceConstraintUV == null) ? 0 : mBaseboneRelativeReferenceConstraintUV.hashCode());
  //     result = prime * result + ((mChain == null) ? 0 : mChain.hashCode());
  //     result = prime * result + Float.floatToIntBits(mChainLength);
  //     result = prime * result + mConnectedBoneNumber;
  //     result = prime * result + mConnectedChainNumber;
  //     result = prime * result + Float.floatToIntBits(mConstraintLineWidth);
  //     result = prime * result + Float.floatToIntBits(mCurrentSolveDistance);
  //     result = prime * result + ((mEmbeddedTarget == null) ? 0 : mEmbeddedTarget.hashCode());
  //     result = prime * result + ((mFixedBaseLocation == null) ? 0 : mFixedBaseLocation.hashCode());
  //     result = prime * result + (mFixedBaseMode ? 1231 : 1237);
  //     result = prime * result + ((mLastBaseLocation == null) ? 0 : mLastBaseLocation.hashCode());
  //     result = prime * result + ((mLastTargetLocation == null) ? 0 : mLastTargetLocation.hashCode());
  //     result = prime * result + mMaxIterationAttempts;
  //     result = prime * result + Float.floatToIntBits(mMinIterationChange);
  //     result = prime * result + ((mName == null) ? 0 : mName.hashCode());
  //     result = prime * result + Float.floatToIntBits(mSolveDistanceThreshold);
  //     result = prime * result + (mUseEmbeddedTarget ? 1231 : 1237);
  //     return result;
  //   }
  //   @Override
  equals(r) {
    if (this == r)
      return !0;
    if (r == null)
      return !1;
    const e = r;
    if (this.mBaseboneConstraintType != e.mBaseboneConstraintType)
      return !1;
    if (this.mBaseboneConstraintUV == null) {
      if (e.mBaseboneConstraintUV != null)
        return !1;
    } else if (!this.mBaseboneConstraintUV.equals(e.mBaseboneConstraintUV))
      return !1;
    if (this.mBaseboneRelativeConstraintUV == null) {
      if (e.mBaseboneRelativeConstraintUV != null)
        return !1;
    } else if (!this.mBaseboneRelativeConstraintUV.equals(
      e.mBaseboneRelativeConstraintUV
    ))
      return !1;
    if (this.mBaseboneRelativeReferenceConstraintUV == null) {
      if (e.mBaseboneRelativeReferenceConstraintUV != null)
        return !1;
    } else if (!this.mBaseboneRelativeReferenceConstraintUV.equals(
      e.mBaseboneRelativeReferenceConstraintUV
    ))
      return !1;
    if (this.mChain == null) {
      if (e.mChain != null)
        return !1;
    } else if (this.mChain != e.mChain)
      return !1;
    if (this.mChainLength != e.mChainLength || this.mConnectedBoneNumber != e.mConnectedBoneNumber || this.mConnectedChainNumber != e.mConnectedChainNumber || this.mConstraintLineWidth != e.mConstraintLineWidth || this.mCurrentSolveDistance != e.mCurrentSolveDistance)
      return !1;
    if (this.mEmbeddedTarget == null) {
      if (e.mEmbeddedTarget != null)
        return !1;
    } else if (this.mEmbeddedTarget != e.mEmbeddedTarget)
      return !1;
    if (this.mFixedBaseLocation == null) {
      if (e.mFixedBaseLocation != null)
        return !1;
    } else if (this.mFixedBaseLocation != e.mFixedBaseLocation)
      return !1;
    if (this.mFixedBaseMode != e.mFixedBaseMode)
      return !1;
    if (this.mLastBaseLocation == null) {
      if (e.mLastBaseLocation != null)
        return !1;
    } else if (this.mLastBaseLocation != e.mLastBaseLocation)
      return !1;
    if (this.mLastTargetLocation == null) {
      if (e.mLastTargetLocation != null)
        return !1;
    } else if (this.mLastTargetLocation != e.mLastTargetLocation)
      return !1;
    if (this.mMaxIterationAttempts != e.mMaxIterationAttempts || this.mMinIterationChange != e.mMinIterationChange)
      return !1;
    if (this.mName == null) {
      if (e.mName != null)
        return !1;
    } else if (this.mName != e.mName)
      return !1;
    return !(this.mSolveDistanceThreshold != e.mSolveDistanceThreshold || this.mUseEmbeddedTarget != e.mUseEmbeddedTarget);
  }
};
let Le = Fi;
Le.DefaultApproximatelyEqualsTolerance = 1e-3;
class St {
  // --------- Public Methods ----------
  /** Default constructor. */
  constructor() {
    this.mName = "", this.mChains = new Array(), this.mChainsMap = /* @__PURE__ */ new Map();
  }
  /**
   * Naming constructor.
   * <p>
   * Name lengths are truncated to a maximum of 100 characters, if necessary.
   *
   *  @param	name	The name you wish to call the structure.
   */
  static NewByName(e) {
    const t = new St();
    return t.setName(e), t;
  }
  isEmpty() {
    return this.mChains.length == 0;
  }
  /**
   * Solve the structure for the given target location.
   * <p>
   * All chains in this structure are solved for the given target location EXCEPT those which have embedded targets enabled, which are
   * solved for the target location embedded in the chain.
   * <p>
   * After this method has been executed, the configuration of all IK chains attached to this structure will have been updated.
   *
   * @param   newTargetLocation	The location of the target for which we will attempt to solve all chains attached to this structure.
   */
  // @Override
  solveForTarget(e) {
    const t = this.mChains.length;
    let s;
    for (let i = 0; i < t; ++i) {
      const n = this.getChain(i);
      if (s = n.getConnectedChainNumber(), s == -1)
        n.solveForTarget(e);
      else {
        const o = this.getChain(s).getBone(n.getConnectedBoneNumber());
        o.getBoneConnectionPoint() == _t.START ? n.setBaseLocation(o.getStartLocation()) : n.setBaseLocation(o.getEndLocation());
        const h = n.getBaseboneConstraintType();
        switch (h) {
          case pe.NONE:
          case pe.GLOBAL_ROTOR:
          case pe.GLOBAL_HINGE:
            break;
          case pe.LOCAL_ROTOR:
          case pe.LOCAL_HINGE: {
            const l = Ns.createRotationMatrix(
              o.getDirectionUV()
            ), c = l.timesByVec3(n.getBaseboneConstraintUV()).normalised();
            n.setBaseboneRelativeConstraintUV(
              c
            ), h == pe.LOCAL_HINGE && n.setBaseboneRelativeReferenceConstraintUV(
              l.timesByVec3(
                n.getBone(0).getJoint().getHingeReferenceAxis()
              )
            );
            break;
          }
        }
        n.getEmbeddedTargetMode() ? n.solveForEmbeddedTarget() : n.solveForTarget(e);
      }
    }
  }
  // End of updateTarget method
  solveForTargets(e) {
    const t = this.mChains.length;
    let s;
    for (let i = 0; i < t; ++i) {
      const n = this.getChain(i), a = e.get(n.getName());
      if (a) {
        if (s = n.getConnectedChainNumber(), s != -1) {
          const h = this.getChain(s).getBone(n.getConnectedBoneNumber());
          h.getBoneConnectionPoint() == _t.START ? n.setBaseLocation(h.getStartLocation()) : n.setBaseLocation(h.getEndLocation());
          const l = n.getBaseboneConstraintType();
          switch (l) {
            case pe.NONE:
            case pe.GLOBAL_ROTOR:
            case pe.GLOBAL_HINGE:
              break;
            case pe.LOCAL_ROTOR:
            case pe.LOCAL_HINGE: {
              const c = Ns.createRotationMatrix(
                h.getDirectionUV()
              ), d = c.timesByVec3(n.getBaseboneConstraintUV()).normalised();
              n.setBaseboneRelativeConstraintUV(d), l == pe.LOCAL_HINGE && n.setBaseboneRelativeReferenceConstraintUV(
                c.timesByVec3(
                  n.getBone(0).getJoint().getHingeReferenceAxis()
                )
              );
              break;
            }
          }
        }
        n.getEmbeddedTargetMode() ? n.solveForEmbeddedTarget() : n.solveForTarget(a);
      }
    }
  }
  /**
   * Add a FabrikChain3D to this FabrikStructure3D.
   * <p>
   * In effect, the chain is added to the mChains list of FabrikChain3D objects, and the mNumChains property is incremented.
   * <p>
   * Adding a chain using this method adds the chain to the structure, but does not connect it to any existing chain
   * in the structure. If you wish to connect a chain, use one of the connectChain methods instead.
   * <p>
   * All chains in a structure share the same target, and all chains in the structure can be solved for the target location
   * via a single call to updateTarget.
   *
   * @param	chain	(FabrikChain3D)	The FabrikChain3D to add to this structure.
   * @see   #connectChain(FabrikChain3D, int, int)
   * @see		#connectChain(FabrikChain3D, int, int, BoneConnectionPoint)
   **/
  // @Override
  addChain(e) {
    if (this.mChainsMap.get(e.getName()))
      throw new Error(`chain name [${e.getName()}] is existed`);
    this.mChains.push(e), this.mChainsMap.set(e.getName(), e);
  }
  /**
   * Remove a FabrikChain3D from this FabrikStructure3D by its index.
   * <p>
   * In effect, the chain is removed from the mChains list of FabrikChain3D objects, and the mNumChains property is decremented.
   *
   * @param	chainIndex	The index of the chain to remove from the mChains list of FabrikChain3D objects.
   **/
  removeChain(e) {
    if (this.isEmpty())
      throw new Error("mChains is empty");
    if (e < 0 || e >= this.mChains.length)
      throw new Error("out of range");
    this.mChains.splice(e, 1);
  }
  /**
   * Connect a chain to an existing chain in this structure.
   * <p>
   * Both chains and bones are are zero indexed.
   * <p>
   * If the existingChainNumber or existingBoneNumber specified to connect to does not exist in this structure
   * then an IllegalArgumentExeception is thrown.
   *
   * @param	newChain			The chain to connect to this structure
   * @param	existingChainNumber	The index of the chain to connect the new chain to.
   * @param	existingBoneNumber	The index of the bone to connect the new chain to within the existing chain.
   */
  // @Override
  // public  connectChain( newChain:FabrikChain3D,  existingChainNumber:number,  existingBoneNumber:number):void
  // {
  // 	// Does this chain exist? If not throw an IllegalArgumentException
  // 	if (existingChainNumber > this.mChains.size())
  // 	{
  // 		throw new IllegalArgumentException("Cannot connect to chain " + existingChainNumber + " - no such chain (remember that chains are zero indexed).");
  // 	}
  // 	// Do we have this bone in the specified chain? If not throw an IllegalArgumentException
  // 	if (existingBoneNumber > mChains.get(existingChainNumber).getNumBones() )
  // 	{
  // 		throw new IllegalArgumentException("Cannot connect to bone " + existingBoneNumber + " of chain " + existingChainNumber + " - no such bone (remember that bones are zero indexed).");
  // 	}
  // 	// Make a copy of the provided chain so any changes made to the original do not affect this chain
  // 	FabrikChain3D relativeChain = new FabrikChain3D(newChain);
  // 	// Connect the copy of the provided chain to the specified chain and bone in this structure
  // 	relativeChain.connectToStructure(this, existingChainNumber, existingBoneNumber);
  // 	// The chain as we were provided should be centred on the origin, so we must now make it
  // 	// relative to the start location of the given bone in the given chain.
  // 	// Get the connection point so we know to connect at the start or end location of the bone we're connecting to
  // 	BoneConnectionPoint connectionPoint = this.getChain(existingChainNumber).getBone(existingBoneNumber).getBoneConnectionPoint();
  // 	Vec3f connectionLocation;
  // 	if (connectionPoint == BoneConnectionPoint.START)
  // 	{
  // 		connectionLocation = mChains.get(existingChainNumber).getBone(existingBoneNumber).getStartLocation();
  // 	}
  // 	else // If it's BoneConnectionPoint.END then we set the connection point to be the end location of the bone we're connecting to
  // 	{
  // 		connectionLocation = mChains.get(existingChainNumber).getBone(existingBoneNumber).getEndLocation();
  // 	}
  // 	relativeChain.setBaseLocation(connectionLocation);
  // 	// When we have a chain connected to a another 'host' chain, the chain is which is connecting in
  // 	// MUST have a fixed base, even though that means the base location is 'fixed' to the connection
  // 	// point on the host chain, rather than a static location.
  // 	relativeChain.setFixedBaseMode(true);
  // 	// Translate the chain we're connecting to the connection point
  // 	for (int loop = 0; loop < relativeChain.getNumBones(); ++loop)
  // 	{
  // 		Vec3f origStart = relativeChain.getBone(loop).getStartLocation();
  // 		Vec3f origEnd   = relativeChain.getBone(loop).getEndLocation();
  // 		Vec3f translatedStart = origStart.plus(connectionLocation);
  // 		Vec3f translatedEnd   = origEnd.plus(connectionLocation);
  // 		relativeChain.getBone(loop).setStartLocation(translatedStart);
  // 		relativeChain.getBone(loop).setEndLocation(translatedEnd);
  // 	}
  // 	this.addChain(relativeChain);
  // }
  /**
   * Connect a chain to an existing chain in this structure.
   * <p>
   * Both chains and bones are are zero indexed.
   * <p>
   * If the existingChainNumber or existingBoneNumber specified to connect to does not exist in this structure
   * then an IllegalArgumentExeception is thrown.
   *
   * @param	newChain		The chain to connect to this structure
   * @param	existingChainNumber	The index of the chain to connect the new chain to.
   * @param	existingBoneNumber	The index of the bone to connect the new chain to within the existing chain.
   * @param	boneConnectionPoint	Whether the new chain should connect to the START or END of the specified bone in the specified chain.
   */
  // @Override
  connectChain(e, t, s, i) {
    if (t > this.mChains.length)
      throw new Error(
        "Cannot connect to chain " + t + " - no such chain (remember that chains are zero indexed)."
      );
    if (s > this.getChain(t).getNumBones())
      throw new Error(
        "Cannot connect to bone " + s + " of chain " + t + " - no such bone (remember that bones are zero indexed)."
      );
    const n = Le.NewByFabrikChain3D(e);
    n.connectToStructure(
      this,
      t,
      s
    ), this.getChain(t).getBone(s).setBoneConnectionPoint(i);
    let a;
    i == _t.START ? a = this.getChain(t).getBone(s).getStartLocation() : a = this.getChain(t).getBone(s).getEndLocation(), n.setBaseLocation(a), n.setFixedBaseMode(!0);
    for (let o = 0; o < n.getNumBones(); ++o) {
      const h = n.getBone(o).getStartLocation(), l = n.getBone(o).getEndLocation(), c = h.plus(a), d = l.plus(a);
      n.getBone(o).setStartLocation(c), n.getBone(o).setEndLocation(d);
    }
    this.addChain(n);
  }
  connectChainByName(e, t, s, i) {
    const n = this.getChainByName(t);
    if (!n)
      throw new Error(`chain ${t} is not existed`);
    if (this.getChainByName(e.getName()))
      throw new Error(`new chain ${e.getName()} is already existed`);
    const o = this.mChains.indexOf(n);
    this.connectChain(
      e,
      o,
      s,
      i
    );
  }
  /**
   * Return the number of chains in this structure.
   *
   * @return	The number of chains in this structure.
   */
  // @Override
  getNumChains() {
    return this.mChains.length;
  }
  /**
   * Return the specified chain from this structure.
   * <p>
   * Chain numbers are zero indexed. If the specified chain does not exist in this structure
   * then an IllegalArgumentException is thrown.
   *
   * @param	chainNumber	The specified chain from this structure.
   * @return	The specified FabrikChain3D from this chain.
   */
  // @Override
  getChain(e) {
    if (this.isEmpty())
      throw new Error("mChains is empty");
    return this.mChains[e];
  }
  getChainByName(e) {
    if (this.isEmpty())
      throw new Error("mChains is empty");
    return this.mChainsMap.get(e);
  }
  /**
   * Set the fixed base mode on all chains in this structure.
   *
   * @param	fixedBaseMode	Whether all chains should operate in fixed base mode (true) or not (false).
   */
  setFixedBaseMode(e) {
    for (let t = 0; t < this.mChains.length; ++t)
      this.getChain(t).setFixedBaseMode(e);
  }
  /**
   * Set the name of this structure, capped to 100 characters if required.
   *
   * @param	name	The name to set.
   */
  // @Override
  setName(e) {
    this.mName = be.getValidatedName(e);
  }
  // @Override
  getName() {
    return this.mName;
  }
  /**
   * Return a concise, human readable description of this FabrikStructure3D.
   * <p>
   * If further details on a specific chain are required, then you should get and print each chain individually.
   *
   * @return A concise, human readable description of this FabrikStructure3D.
   */
  // @Override
  toString() {
    let e = "";
    e += `"----- FabrikStructure3D: ${this.mName} -----\r
`, e += `Number of chains: ${this.mChains.length}\r
`;
    for (let t = 0; t < this.mChains.length; ++t)
      e += this.getChain(t).toString();
    return e;
  }
  //   @Override
  //   public int hashCode() {
  //     final int prime = 31;
  //     int result = 1;
  //     result = prime * result + ((mChains == null) ? 0 : mChains.hashCode());
  //     result = prime * result + ((mName == null) ? 0 : mName.hashCode());
  //     return result;
  //   }
  //   @Override
  equals(e) {
    if (this == e)
      return !0;
    if (e == null)
      return !1;
    const t = e;
    if (this.mChains == null) {
      if (t.mChains != null)
        return !1;
    } else if (this.mChains != t.mChains)
      return !1;
    if (this.mName == null) {
      if (t.mName != null)
        return !1;
    } else if (this.mName != t.mName)
      return !1;
    return !0;
  }
}
const ft = class {
  constructor() {
    this.m00 = 0, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m10 = 0, this.m11 = 0, this.m12 = 0, this.m13 = 0, this.m20 = 0, this.m21 = 0, this.m22 = 0, this.m23 = 0, this.m30 = 0, this.m31 = 0, this.m32 = 0, this.m33 = 0;
  }
  // ---------- Constructors ----------
  /**
   * Default constructor.
   * <p>
   * All member properties are implicitly set to zero by Java as that is the default value of a float primitive.
   */
  Mat4f() {
  }
  /**
   * Copy constructor.
   * <p>
   * Copies all properties from the source matrix into the newly constructed matrix.
   *
   * @param	source	The matrix to copy the values from.
   */
  // public Mat4f(Mat4f source)
  // {
  // 	m00 = source.m00;
  // 	m01 = source.m01;
  // 	m02 = source.m02;
  // 	m03 = source.m03;
  // 	m10 = source.m10;
  // 	m11 = source.m11;
  // 	m12 = source.m12;
  // 	m13 = source.m13;
  // 	m20 = source.m20;
  // 	m21 = source.m21;
  // 	m22 = source.m22;
  // 	m23 = source.m23;
  // 	m30 = source.m30;
  // 	m31 = source.m31;
  // 	m32 = source.m32;
  // 	m33 = source.m33;
  // }
  /**
   * Constructor to create a Mat4f from a Mat3f and an origin.
   *
   * @param	rotationMatrix	The Mat3f to use for the X/Y/Z axes.
   * @param	origin			The Vec3f to use as the origin.
   */
  // public Mat4f(Mat3f rotationMatrix, Vec3f origin)
  // {
  // 	m00 = rotationMatrix.m00;
  // 	m01 = rotationMatrix.m01;
  // 	m02 = rotationMatrix.m02;
  // 	m03 = 0.0f;
  // 	m10 = rotationMatrix.m10;
  // 	m11 = rotationMatrix.m11;
  // 	m12 = rotationMatrix.m12;
  // 	m13 = 0.0f;
  // 	m20 = rotationMatrix.m20;
  // 	m21 = rotationMatrix.m21;
  // 	m22 = rotationMatrix.m22;
  // 	m23 = 0.0f;
  // 	m30 = origin.x;
  // 	m31 = origin.y;
  // 	m32 = origin.z;
  // 	m33 = 1.0f;
  // }
  /**
   * Float array constructor.
   * <p>
   * The matrix is set a column at a time, so the first four floats from the source array are set on m0
   * to m03, the next four on m10 to m13 and so on.
   * <p>
   * If the source array is not an array of precisely 16 floats then a IllegalArgumentException is thrown.
   *
   * @param	source	The array of 16 floats used as the source values to set on this Mat4f.
   */
  // public Mat4f(float[] source)
  // {
  // 	// If we have an array of precisely 16 floats then proceed with initialisation
  // 	if (source.length == 16)
  // 	{
  // 		// First column (x-axis)
  // 		m00 = source[0 ];
  // 		m01 = source[1 ];
  // 		m02 = source[2 ];
  // 		m03 = source[3 ];
  // 		// Second column (y-axis)
  // 		m10 = source[4 ];
  // 		m11 = source[5 ];
  // 		m12 = source[6 ];
  // 		m13 = source[7 ];
  // 		// Third column (z-axis)
  // 		m20 = source[8 ];
  // 		m21 = source[9 ];
  // 		m22 = source[10];
  // 		m23 = source[11];
  // 		// Fourth column (origin)
  // 		m30 = source[12];
  // 		m31 = source[13];
  // 		m32 = source[14];
  // 		m33 = source[15];
  // 	}
  // 	else // Bad array size? Throw an exception.
  // 	{
  // 		throw new IllegalArgumentException("Source array must contain precisely 16 floats.");
  // 	}
  // }
  /**
   * One parameter constructor.
   * <p>
   * Sets the provided value diagonally across the matrix. For example, to create an identity matrix with
   * 1.0f across the diagonal then you can call:
   * <p>
   * {@code Mat4f m = new Mat4f(1.0f)}
   * <p>
   * Which will result in a matrix with the following properties:
   * <p>
   * 1.0f  0.0f  0.0f  0.0f
   * <p>
   * 0.0f  1.0f  0.0f  0.0f
   * <p>
   * 0.0f  0.0f  1.0f  0.0f
   * <p>
   * 0.0f  0.0f  0.0f  1.0f
   *
   * @param	value	The value to set across the diagonal of the matrix.
   */
  static NewByOneValue(r) {
    const e = new ft();
    return e.m00 = e.m11 = e.m22 = e.m33 = r, e;
  }
  // public Mat4f(float value)
  // {
  // 	// Set diagonal
  // 	m00 = m11 = m22 = m33 = value;
  // 	// All other values are implicitly set to zero by Java as that is the default value of a float primitive.
  // }
  // ---------- Methods ----------
  /**
   * Zero all properties of a matrix.
   */
  zero() {
    this.m00 = this.m01 = this.m02 = this.m03 = this.m10 = this.m11 = this.m12 = this.m13 = this.m20 = this.m21 = this.m22 = this.m23 = this.m30 = this.m31 = this.m32 = this.m33 = 0;
  }
  /**
   * Reset a matrix to the identity matrix.
   * <p>
   * The matrix is set as follows:
   * <p>
   * 1.0f  0.0f  0.0f  0.0f
   * <p>
   * 0.0f  1.0f  0.0f  0.0f
   * <p>
   * 0.0f  0.0f  1.0f  0.0f
   * <p>
   * 0.0f  0.0f  0.0f  1.0f
   */
  setIdentity() {
    this.m00 = this.m11 = this.m22 = this.m33 = 1, this.m01 = this.m02 = this.m03 = this.m10 = this.m12 = this.m13 = this.m20 = this.m21 = this.m23 = this.m30 = this.m31 = this.m32 = 0;
  }
  /**
   * Set the details of this Mat4f from an array of 16 floats.
   * <p>
   * The matrix is set a column at a time, so the first four floats from the source array are set on m0
   * to m03, the next four on m10 to m13 and so on.
   * <p>
   * If the source array is not an array of precisely 16 floats then a IllegalArgumentException is thrown.
   *
   * @param	source	The array of 16 floats used as the source values to set on this Mat4f.
   */
  setFromArray(r) {
    if (r.length == 16)
      this.m00 = r[0], this.m01 = r[1], this.m02 = r[2], this.m03 = r[3], this.m10 = r[4], this.m11 = r[5], this.m12 = r[6], this.m13 = r[7], this.m20 = r[8], this.m21 = r[9], this.m22 = r[10], this.m23 = r[11], this.m30 = r[12], this.m31 = r[13], this.m32 = r[14], this.m33 = r[15];
    else
      throw new Error("Source array must contain precisely 16 floats.");
  }
  /**
   * Return the x-basis of this Mat4f as a Vec3f.
   * <p>
   * The x-basis is the orientation of the x-axis, as held by the m00, m01 and m02 properties.
   *
   * @return		A Vec3f containing the x-basis of this Mat4f.
   */
  getXBasis() {
    return new R(this.m00, this.m01, this.m02);
  }
  /**
   * Return the x-basis of this Mat4f as an array of three floats.
   * <p>
   * The x-basis is the orientation of the x-axis, as held by the m00, m01 and m02 properties.
   * <p>
   * This method is provided to allow for interoperability for users who do not want to use the {@link Vec3f} class.
   *
   * @return		An array of three floats containing the x-basis of this Mat4f.
   */
  getXBasisArray() {
    return [this.m00, this.m01, this.m02];
  }
  /**
   * Set the x-basis of this Mat4f from a provided Vec3f.
   * <p>
   * The x-basis is the orientation of the x-axis, as held by the m00, m01 and m02 properties.
   * <p>
   * To ensure the legality of the x-basis, the provided Vec3f is normalised if required before being set.
   * <p>
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which accept a float array and do not attempt to enforce
   * rotation matrix legality such as {@link #setFromArray(float[])} and {@link #Mat4f(float[])}.
   *
   * @param	v	The Vec3f holding the x-basis to set.
   * @see #setFromArray(float[])
   * @see #Mat4f(float[])
   */
  setXBasis(r) {
    r.lengthIsApproximately(1, ft.FLOAT_EQUALITY_TOLERANCE) || r.normalise(), this.m00 = r.x, this.m01 = r.y, this.m02 = r.z;
  }
  /**
   * Set the x-basis of this Mat4f from a provided array of three floats.
   * <p>
   * The x-basis is the orientation of the x-axis, as held by the m00, m01 and m02 properties.
   * <p>
   * To ensure the legality of the x-basis, the provided array is converted into a Vec3f and
   * normalised (if required) before being set.
   * <p>
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which do not enforce normalisation such as the
   * {@link #setFromArray(float[])} and {@link #Mat4f(float[])} methods.
   *
   * @param	f	The array of three floats to set as the x-basis of this Mat4f.
   * @see		#setFromArray(float[])
   * @see		#Mat4f(float[])
   */
  // public void setXBasis(float[] f)
  // {
  // 	// Array is correct size? If not then return without setting any values
  // 	if (f.length != 3)
  // 	{
  // 		return;
  // 	}
  // 	// Construct a Vec3f from the array and normalise it if required
  // 	Vec3f v = new Vec3f(f[0], f[1], f[2]);
  // 	if ( !v.lengthIsApproximately(1.0f, FLOAT_EQUALITY_TOLERANCE) )
  // 	{
  // 		v.normalise();
  // 	}
  // 	// Set the x-basis
  // 	m00 = v.x;
  // 	m01 = v.y;
  // 	m02 = v.z;
  // }
  /**
   * Return the y-basis of this Mat4f as a Vec3f.
   * <p>
   * The y-basis is the orientation of theyx-axis, as held by the m10, m11 and m12 properties.
   *
   * @return		A Vec3f containing the y-basis of this Mat4f.
   */
  getYBasis() {
    return new R(this.m10, this.m11, this.m12);
  }
  /**
   * Return the y-basis of this Mat4f as an array of three floats.
   * <p>
   * The y-basis is the orientation of the y-axis, as held by the m10, m11 and m12 properties.
   * <p>
   * This method is provided to allow for interoperability for users who do not want to use the {@link Vec3f} class.
   *
   * @return		An array of three floats containing the y-basis of this Mat4f.
   */
  getYBasisArray() {
    return [this.m10, this.m11, this.m12];
  }
  /**
   * Set the y-basis of this Mat4f from a provided Vec3f.
   * <p>
   * The y-basis is the orientation of the y-axis, as held by the m10, m11 and m12 properties.
   * <p>
   * To ensure the legality of the y-basis, the provided Vec3f is normalised if required before being set.
   * <p>
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which do not enforce normalisation such as the
   * {@link #setFromArray(float[])} and {@link #Mat4f(float[])} methods.
   *
   * @param	v	The Vec3f holding the y-basis to set.
   * @see		#setFromArray(float[])
   * @see		#Mat4f(float[])
   */
  setYBasis(r) {
    r.lengthIsApproximately(1, ft.FLOAT_EQUALITY_TOLERANCE) || r.normalise(), this.m10 = r.x, this.m11 = r.y, this.m12 = r.z;
  }
  /**
   * Set the y-basis of this Mat4f from a provided array of three floats.
   * <p>
   * The y-basis is the orientation of the y-axis, as held by the m10, m11 and m12 properties.
   * <p>
   * To ensure the legality of the y-basis, the provided array is converted into a Vec3f and
   * normalised (if required) before being set.
   * <p>
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which do not enforce normalisation such as the
   * {@link #setFromArray(float[])} and {@link #Mat4f(float[])} methods.
   *
   * @param	f	The array of three floats to set as the y-basis of this Mat4f.
   * @see		#setFromArray(float[])
   * @see		#Mat4f(float[])
   */
  // public void setYBasis(float[] f)
  // {
  // 	// Array is correct size? If not then return without setting any values
  // 	if (f.length != 3)
  // 	{
  // 		return;
  // 	}
  // 	// Construct a Vec3f from the array and normalise it if required
  // 	Vec3f v = new Vec3f(f[0], f[1], f[2]);
  // 	if ( !v.lengthIsApproximately(1.0f, FLOAT_EQUALITY_TOLERANCE) )
  // 	{
  // 		v.normalise();
  // 	}
  // 	// Set the y-basis
  // 	m10 = v.x;
  // 	m11 = v.y;
  // 	m12 = v.z;
  // }
  /**
   * Return the z-basis of this Mat4f as a Vec3f.
   * <p>
   * The z-basis is the orientation of the x-axis, as held by the m20, m21 and m22 properties.
   *
   * @return		A Vec3f containing the z-basis of this Mat4f.
   */
  getZBasis() {
    return new R(this.m20, this.m21, this.m22);
  }
  /**
   * Return the z-basis of this Mat4f as an array of three floats.
   * <p>
   * The z-basis is the orientation of the z-axis, as held by the m20, m21 and m22 properties.
   * <p>
   * This method is provided to allow for interoperability for users who do not want to use the {@link Vec3f} class.
   *
   * @return		An array of three floats containing the y-basis of this Mat4f.
   */
  getZBasisArray() {
    return [this.m20, this.m21, this.m22];
  }
  /**
   * Set the z-basis of this Mat4f from a provided Vec3f.
   * <p>
   * The z-basis is the orientation of the z-axis, as held by the m20, m21 and m22 properties.
   * <p>
   * To ensure the legality of the z-basis, the provided Vec3f is normalised if required before being set.
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which do not enforce normalisation such as the
   * {@link #setFromArray(float[])} and {@link #Mat4f(float[])} methods.
   *
   * @param	v	The Vec3f holding the z-basis to set.
   * @see #setFromArray(float[])
   * @see #Mat4f(float[])
   */
  setZBasis(r) {
    r.lengthIsApproximately(1, ft.FLOAT_EQUALITY_TOLERANCE) || r.normalise(), this.m20 = r.x, this.m21 = r.y, this.m22 = r.z;
  }
  /**
   * Set the z-basis of this Mat4f from a provided array of three floats.
   * <p>
   * The z-basis is the orientation of the z-axis, as held by the m20, m21 and m22 properties.
   * <p>
   * To ensure the legality of the z-basis, the provided array is converted into a Vec3f and
   * normalised (if required) before being set.
   * <p>
   * If you wish to use this class for storing matrices which do not represent a rotation matrix
   * then you should avoid the setXBasis/setYBasis/setZBasis methods and instead set the matrix
   * properties via other methods which do not enforce normalisation such as the
   * {@link #setFromArray(float[])} and {@link #Mat4f(float[])} methods.
   *
   * @param	f	The array of three floats to set as the z-basis of this Mat4f.
   * @see 	#setFromArray(float[])
   * @see 	#Mat4f(float[])
   */
  // public void setZBasis(float[] f)
  // {
  // 	// Array is correct size? If not then return without setting any values
  // 	if (f.length != 3)
  // 	{
  // 		return;
  // 	}
  // 	// Construct a Vec3f from the array and normalise it if required
  // 	Vec3f v = new Vec3f(f[0], f[1], f[2]);
  // 	if ( !v.lengthIsApproximately(1.0f, FLOAT_EQUALITY_TOLERANCE) )
  // 	{
  // 		v.normalise();
  // 	}
  // 	// Set the y-basis
  // 	m20 = v.x;
  // 	m21 = v.y;
  // 	m22 = v.z;
  // }
  /**
   * Return the origin of this Mat4f.
   *
   * @return		A Vec3f of the origin location of this Mat4f, as stored in the m30, m31 and m32 properties.
   */
  getOrigin() {
    return new R(this.m30, this.m31, this.m32);
  }
  /**
   * Set the origin of this Mat4f.
   * <p>
   * The origin is stored in the matrix properties m30 (x location), m31 (y location) and m32 (z location).
   * <p>
   * As the origin may be at any location, as such it is <em>not</em> normalised before being set.
   *
   * @param	v	The origin of this Mat4f as a Vec3f.
   */
  setOrigin(r) {
    this.m30 = r.x, this.m31 = r.y, this.m32 = r.z, this.m33 = 1;
  }
  /**
   * Return whether or not all three axes of this Mat4f are orthogonal (i.e. at 90 degrees to each other).
   * <p>
   * Any two axes, such as x/y, x/z or y/z will be orthogonal if their dot product is zero. However, to
   * account for floating point precision errors, this method accepts that two axes are orthogonal if
   * their dot product is less than or equal to 0.01f.
   * <p>
   * If you want to find out if any two specific axes are orthogonal, then you can use code similar to the
   * following:
   * <p>
   * {@code boolean xDotYOrthogonal = Math.abs( xAxis.dot(yAxis) ) <= 0.01f;}
   *
   * @return		A boolean indicating whether this Mat4f is orthogonal or not.
   */
  isOrthogonal() {
    const r = new R(this.m00, this.m01, this.m02), e = new R(this.m10, this.m11, this.m12), t = new R(this.m20, this.m21, this.m22), s = 0.01, i = Math.abs(R.dotProduct(r, e)) <= s, n = Math.abs(R.dotProduct(r, t)) <= s, a = Math.abs(R.dotProduct(e, t)) <= s;
    return i && n && a;
  }
  /**
   * Transpose this Mat4f.
   * <p>
   * <strong>This</strong> Mat4f is transposed, not a copy.
   * <p>
   * If you want to return a transposed version of a Mat4f <em>without modifying</em> the source
   * then use the {@link #transposed()} method instead.
   *
   * @return	Return this Mat4f for chaining.
   * @see		#transposed()
   */
  transpose() {
    const r = this.m01, e = this.m02, t = this.m03, s = this.m10, i = this.m12, n = this.m13, a = this.m20, o = this.m21, h = this.m23, l = this.m30, c = this.m31, d = this.m32;
    return this.m01 = s, this.m02 = a, this.m03 = l, this.m10 = r, this.m12 = o, this.m13 = c, this.m20 = e, this.m21 = i, this.m23 = d, this.m30 = t, this.m31 = n, this.m32 = h, this;
  }
  /**
   * Return a transposed version of this Mat4f.
   * <p>
   * This Mat4f is <strong>not</strong> modified during the transposing process.
   * <p>
   * If you want to transpose 'this' Mat4f rather than return a transposed copy then use the
   * {@link #transpose()} method instead.
   *
   * @return		A transposed version of this Mat4f.
   */
  transposed() {
    const r = new ft();
    return r.m00 = this.m00, r.m01 = this.m10, r.m02 = this.m20, r.m03 = this.m30, r.m10 = this.m01, r.m11 = this.m11, r.m12 = this.m21, r.m13 = this.m31, r.m20 = this.m02, r.m21 = this.m12, r.m22 = this.m22, r.m23 = this.m32, r.m30 = this.m03, r.m31 = this.m13, r.m32 = this.m23, r.m33 = this.m33, r;
  }
  /**
   * Method to multiply this Mat4f by another Mat4f and return the result.
   * <p>
   * Neither this matrix or the provided matrix argument are modified by the multiplication process,
   * instead a new Mat4f containing the resulting matrix is returned.
   * <p>
   * Matrix multiplication is <strong>not commutative</strong> (i.e. {@code AB != BA} - that is, the
   * result of multiplying matrix A by matrix B is <em>not</em> the same as multiplying matrix B by
   * matrix A). As such, to construct a ModelView or ModelViewProjection matrix you must specify them
   * in that precise order <strong>reversed</strong> (because of the order in which the calculations
   * take place), for example:
   * <p>
   * {@code Mat4f modelViewMatrix = viewMatrix.times(modelMatrix); }
   * <p>
   * {@code Mat4f modelViewProjectionMatrix = projectionMatrix.times(viewMatrix).times(modelMatrix); }
   * <p>
   * Although matrix multiplication is <strong>not</strong> commutative, it <strong>is</strong>
   * associative (i.e. {@code A(BC) == (AB)C}), so you can quite happily combine matrices like this:
   * <p>
   * {@code Mat4f modelViewMatrix = viewMatrix.times(modelMatrix); }
   * <p>
   * {@code Mat4f modelViewProjectionMatrix = projectionMatrix.times(modelViewMatrix); }
   *
   * @param	m	The matrix to multiply this matrix by.
   * @return		A Mat4f which is the result of multiplying this matrix by the provided matrix.
   */
  times(r) {
    const e = new ft();
    return e.m00 = this.m00 * r.m00 + this.m10 * r.m01 + this.m20 * r.m02 + this.m30 * r.m03, e.m01 = this.m01 * r.m00 + this.m11 * r.m01 + this.m21 * r.m02 + this.m31 * r.m03, e.m02 = this.m02 * r.m00 + this.m12 * r.m01 + this.m22 * r.m02 + this.m32 * r.m03, e.m03 = this.m03 * r.m00 + this.m13 * r.m01 + this.m23 * r.m02 + this.m33 * r.m03, e.m10 = this.m00 * r.m10 + this.m10 * r.m11 + this.m20 * r.m12 + this.m30 * r.m13, e.m11 = this.m01 * r.m10 + this.m11 * r.m11 + this.m21 * r.m12 + this.m31 * r.m13, e.m12 = this.m02 * r.m10 + this.m12 * r.m11 + this.m22 * r.m12 + this.m32 * r.m13, e.m13 = this.m03 * r.m10 + this.m13 * r.m11 + this.m23 * r.m12 + this.m33 * r.m13, e.m20 = this.m00 * r.m20 + this.m10 * r.m21 + this.m20 * r.m22 + this.m30 * r.m23, e.m21 = this.m01 * r.m20 + this.m11 * r.m21 + this.m21 * r.m22 + this.m31 * r.m23, e.m22 = this.m02 * r.m20 + this.m12 * r.m21 + this.m22 * r.m22 + this.m32 * r.m23, e.m23 = this.m03 * r.m20 + this.m13 * r.m21 + this.m23 * r.m22 + this.m33 * r.m23, e.m30 = this.m00 * r.m30 + this.m10 * r.m31 + this.m20 * r.m32 + this.m30 * r.m33, e.m31 = this.m01 * r.m30 + this.m11 * r.m31 + this.m21 * r.m32 + this.m31 * r.m33, e.m32 = this.m02 * r.m30 + this.m12 * r.m31 + this.m22 * r.m32 + this.m32 * r.m33, e.m33 = this.m03 * r.m30 + this.m13 * r.m31 + this.m23 * r.m32 + this.m33 * r.m33, e;
  }
  /**
   * Transform a point in 3D space.
   * <p>
   * This method multiplies the provided Vec3f by this matrix. This is commonly used to transform vertices
   * between coordinate spaces, for example you might multiply a vertex location by a model matrix to
   * transform the vertex from model space into world space.
   * <p>
   * The difference between this method and the {@link #transformDirection} method is that this method
   * takes the origin of this Mat4f into account when performing the transformation, whilst
   * transformDirection does not.
   *
   * @param	v	The Vec3f location to transform.
   * @return		The transformed Vec3f location.
   */
  transformPoint(r) {
    const e = new R();
    return e.x = this.m00 * r.x + this.m10 * r.y + this.m20 * r.z + this.m30, e.y = this.m01 * r.x + this.m11 * r.y + this.m21 * r.z + this.m31, e.z = this.m02 * r.x + this.m12 * r.y + this.m22 * r.z + this.m32, e;
  }
  /**
   * Transform a direction in 3D space taking into account the orientation of this Mat4fs x/y/z axes.
   * <p>
   * The difference between this method and the {@link #transformPoint} method is that this method
   * does not take the origin of this Mat4f into account when performing the transformation, whilst
   * transformPoint does.
   *
   * @param	v	The Vec3f to transform.
   * @return		The transformed Vec3f.
   */
  transformDirection(r) {
    const e = new R();
    return e.x = this.m00 * r.x + this.m10 * r.y + this.m20 * r.z, e.y = this.m01 * r.x + this.m11 * r.y + this.m21 * r.z, e.z = this.m02 * r.x + this.m12 * r.y + this.m22 * r.z, e;
  }
  /**
   * Calculate and return the inverse of a Mat4f.
   * <p>
   * Only matrices which do not have a {@link #determinant()} of zero can be inverted. If
   * the determinant of the provided matrix is zero then an IllegalArgumentException is thrown.
   *
   * @param	m	The matrix to invert.
   * @return		The inverted matrix.
   */
  static inverse(r) {
    const e = new ft();
    if (e.m00 = r.m12 * r.m23 * r.m31 - r.m13 * r.m22 * r.m31 + r.m13 * r.m21 * r.m32 - r.m11 * r.m23 * r.m32 - r.m12 * r.m21 * r.m33 + r.m11 * r.m22 * r.m33, e.m01 = r.m03 * r.m22 * r.m31 - r.m02 * r.m23 * r.m31 - r.m03 * r.m21 * r.m32 + r.m01 * r.m23 * r.m32 + r.m02 * r.m21 * r.m33 - r.m01 * r.m22 * r.m33, e.m02 = r.m02 * r.m13 * r.m31 - r.m03 * r.m12 * r.m31 + r.m03 * r.m11 * r.m32 - r.m01 * r.m13 * r.m32 - r.m02 * r.m11 * r.m33 + r.m01 * r.m12 * r.m33, e.m03 = r.m03 * r.m12 * r.m21 - r.m02 * r.m13 * r.m21 - r.m03 * r.m11 * r.m22 + r.m01 * r.m13 * r.m22 + r.m02 * r.m11 * r.m23 - r.m01 * r.m12 * r.m23, e.m10 = r.m13 * r.m22 * r.m30 - r.m12 * r.m23 * r.m30 - r.m13 * r.m20 * r.m32 + r.m10 * r.m23 * r.m32 + r.m12 * r.m20 * r.m33 - r.m10 * r.m22 * r.m33, e.m11 = r.m02 * r.m23 * r.m30 - r.m03 * r.m22 * r.m30 + r.m03 * r.m20 * r.m32 - r.m00 * r.m23 * r.m32 - r.m02 * r.m20 * r.m33 + r.m00 * r.m22 * r.m33, e.m12 = r.m03 * r.m12 * r.m30 - r.m02 * r.m13 * r.m30 - r.m03 * r.m10 * r.m32 + r.m00 * r.m13 * r.m32 + r.m02 * r.m10 * r.m33 - r.m00 * r.m12 * r.m33, e.m13 = r.m02 * r.m13 * r.m20 - r.m03 * r.m12 * r.m20 + r.m03 * r.m10 * r.m22 - r.m00 * r.m13 * r.m22 - r.m02 * r.m10 * r.m23 + r.m00 * r.m12 * r.m23, e.m20 = r.m11 * r.m23 * r.m30 - r.m13 * r.m21 * r.m30 + r.m13 * r.m20 * r.m31 - r.m10 * r.m23 * r.m31 - r.m11 * r.m20 * r.m33 + r.m10 * r.m21 * r.m33, e.m21 = r.m03 * r.m21 * r.m30 - r.m01 * r.m23 * r.m30 - r.m03 * r.m20 * r.m31 + r.m00 * r.m23 * r.m31 + r.m01 * r.m20 * r.m33 - r.m00 * r.m21 * r.m33, e.m22 = r.m01 * r.m13 * r.m30 - r.m03 * r.m11 * r.m30 + r.m03 * r.m10 * r.m31 - r.m00 * r.m13 * r.m31 - r.m01 * r.m10 * r.m33 + r.m00 * r.m11 * r.m33, e.m23 = r.m03 * r.m11 * r.m20 - r.m01 * r.m13 * r.m20 - r.m03 * r.m10 * r.m21 + r.m00 * r.m13 * r.m21 + r.m01 * r.m10 * r.m23 - r.m00 * r.m11 * r.m23, e.m30 = r.m12 * r.m21 * r.m30 - r.m11 * r.m22 * r.m30 - r.m12 * r.m20 * r.m31 + r.m10 * r.m22 * r.m31 + r.m11 * r.m20 * r.m32 - r.m10 * r.m21 * r.m32, e.m31 = r.m01 * r.m22 * r.m30 - r.m02 * r.m21 * r.m30 + r.m02 * r.m20 * r.m31 - r.m00 * r.m22 * r.m31 - r.m01 * r.m20 * r.m32 + r.m00 * r.m21 * r.m32, e.m32 = r.m02 * r.m11 * r.m30 - r.m01 * r.m12 * r.m30 - r.m02 * r.m10 * r.m31 + r.m00 * r.m12 * r.m31 + r.m01 * r.m10 * r.m32 - r.m00 * r.m11 * r.m32, e.m33 = r.m01 * r.m12 * r.m20 - r.m02 * r.m11 * r.m20 + r.m02 * r.m10 * r.m21 - r.m00 * r.m12 * r.m21 - r.m01 * r.m10 * r.m22 + r.m00 * r.m11 * r.m22, e.determinant() == 0)
      throw new Error("Cannot invert a matrix with a determinant of zero.");
    const s = 1 / e.determinant();
    return e.m00 *= s, e.m01 *= s, e.m02 *= s, e.m03 *= s, e.m10 *= s, e.m11 *= s, e.m12 *= s, e.m13 *= s, e.m20 *= s, e.m21 *= s, e.m22 *= s, e.m23 *= s, e.m30 *= s, e.m31 *= s, e.m32 *= s, e.m33 *= s, e;
  }
  /**
   * Calculate the determinant of this matrix.
   *
   * @return	The determinant of this matrix.
   */
  determinant() {
    return this.m03 * this.m12 * this.m21 * this.m30 - this.m02 * this.m13 * this.m21 * this.m30 - this.m03 * this.m11 * this.m22 * this.m30 + this.m01 * this.m13 * this.m22 * this.m30 + this.m02 * this.m11 * this.m23 * this.m30 - this.m01 * this.m12 * this.m23 * this.m30 - this.m03 * this.m12 * this.m20 * this.m31 + this.m02 * this.m13 * this.m20 * this.m31 + this.m03 * this.m10 * this.m22 * this.m31 - this.m00 * this.m13 * this.m22 * this.m31 - this.m02 * this.m10 * this.m23 * this.m31 + this.m00 * this.m12 * this.m23 * this.m31 + this.m03 * this.m11 * this.m20 * this.m32 - this.m01 * this.m13 * this.m20 * this.m32 - this.m03 * this.m10 * this.m21 * this.m32 + this.m00 * this.m13 * this.m21 * this.m32 + this.m01 * this.m10 * this.m23 * this.m32 - this.m00 * this.m11 * this.m23 * this.m32 - this.m02 * this.m11 * this.m20 * this.m33 + this.m01 * this.m12 * this.m20 * this.m33 + this.m02 * this.m10 * this.m21 * this.m33 - this.m00 * this.m12 * this.m21 * this.m33 - this.m01 * this.m10 * this.m22 * this.m33 + this.m00 * this.m11 * this.m22 * this.m33;
  }
  /**
   * Translate this matrix by a provided Vec3f.
   * <p>
   * The changes made are to <strong>this</strong> Mat4f, in the coordinate space of this matrix.
   *
   * @param	v	The vector to translate this matrix by.
   * @return		This Mat4f for chaining.
   */
  translate(r) {
    return this.m30 += this.m00 * r.x + this.m10 * r.y + this.m20 * r.z, this.m31 += this.m01 * r.x + this.m11 * r.y + this.m21 * r.z, this.m32 += this.m02 * r.x + this.m12 * r.y + this.m22 * r.z, this.m33 += this.m03 * r.x + this.m13 * r.y + this.m23 * r.z, this;
  }
  /**
   * Translate this matrix by separate x, y and z amounts specified as floats.
   * <p>
   * The changes made are to <strong>this</strong> Mat4f.
   *
   * @param	x	The amount to translate on the X-axis.
   * @param	y	The amount to translate on the Y-axis.
   * @param	z	The amount to translate on the Z-axis.
   * @return		This translated Mat4f for chaining.
   */
  // public Mat4f translate(float x, float y, float z)
  // {
  // 	return this.translate( new Vec3f(x, y, z) );
  // }
  /*public static Mat4f rotateAroundArbitraryAxisRads(float angleRads, Vec3f axis)
  {
  	Mat4f result = new Mat4f();
  	
  	float sinTheta = (float)Math.sin(angleRads);
  	float cosTheta = (float)Math.cos(angleRads);
  	float oneMinusCosTheta = 1.0f - cosTheta;
  	
  	result.m00 = m00 * m00 * oneMinusCosTheta + cosTheta;
  	result.m01 = 
  }*/
  /**
   * Rotate this matrix about a local axis by an angle specified in radians.
   * <p>
   * By a 'local' axis we mean that for example, if you rotated this matrix about the positive
   * X-axis (1,0,0), then rotation would occur around the positive X-axis of
   * <strong>this matrix</strong>, not the <em>global / world-space</em> X-axis.
   *
   * @param	angleRads	The angle to rotate the matrix in radians.
   * @param	localAxis	The local axis around which to rotate the matrix.
   * @return				This rotated matrix
   */
  // Method to rotate a matrix around an arbitrary axis
  rotateAboutLocalAxisRads(r, e) {
    const t = new ft(), s = Math.cos(r), i = Math.sin(r), n = 1 - s, a = e.x * e.y, o = e.y * e.z, h = e.x * e.z, l = e.x * i, c = e.y * i, d = e.z * i, u = e.x * e.x * n + s, f = a * n + d, m = h * n - c, _ = a * n - d, p = e.y * e.y * n + s, g = o * n + l, b = h * n + c, x = o * n - l, y = e.z * e.z * n + s, S = this.m00 * u + this.m10 * f + this.m20 * m, C = this.m01 * u + this.m11 * f + this.m21 * m, w = this.m02 * u + this.m12 * f + this.m22 * m, M = this.m03 * u + this.m13 * f + this.m23 * m, T = this.m00 * _ + this.m10 * p + this.m20 * g, A = this.m01 * _ + this.m11 * p + this.m21 * g, L = this.m02 * _ + this.m12 * p + this.m22 * g, O = this.m03 * _ + this.m13 * p + this.m23 * g;
    return t.m20 = this.m00 * b + this.m10 * x + this.m20 * y, t.m21 = this.m01 * b + this.m11 * x + this.m21 * y, t.m22 = this.m02 * b + this.m12 * x + this.m22 * y, t.m23 = this.m03 * b + this.m13 * x + this.m23 * y, t.m00 = S, t.m01 = C, t.m02 = w, t.m03 = M, t.m10 = T, t.m11 = A, t.m12 = L, t.m13 = O, t.m30 = this.m30, t.m31 = this.m31, t.m32 = this.m32, t.m33 = this.m33, this.m00 = t.m00, this.m01 = t.m01, this.m02 = t.m02, this.m03 = t.m03, this.m10 = t.m10, this.m11 = t.m11, this.m12 = t.m12, this.m13 = t.m13, this.m20 = t.m20, this.m21 = t.m21, this.m22 = t.m22, this.m23 = t.m23, this.m30 = t.m30, this.m31 = t.m31, this.m32 = t.m32, this.m33 = t.m33, this;
  }
  /**
   * Rotate this matrix about a local axis by an angle specified in degrees.
   * <p>
   * By a 'local' axis we mean that for example, if you rotated this matrix about the positive
   * X-axis (1,0,0), then rotation would occur around the positive X-axis of
   * <strong>this matrix</strong>, not the <em>global / world-space</em> X-axis.
   *
   * @param	angleDegs	The angle to rotate the matrix in degrees.
   * @param	localAxis	The local axis around which to rotate the matrix.
   * @return				This rotated matrix
   */
  rotateAboutLocalAxisDegs(r, e) {
    return this.rotateAboutLocalAxisRads(
      r * ft.DEGS_TO_RADS,
      e
    );
  }
  /**
   * Rotate this matrix about a world-space axis by an angle specified in radians.
   * <p>
   * The cardinal 'world-space' axes are defined so that the +X axis runs to the right,
   * the +Y axis runs upwards, and the +Z axis runs directly outwards from the screen.
   *
   * @param	angleRads	The angle to rotate the matrix in radians.
   * @param	worldAxis	The world-space axis around which to rotate the matrix.
   * @return			This rotated matrix.
   */
  // public  rotateAboutWorldAxisRads( angleRads:number,  worldAxis:Vec3):Mat4
  // {
  // 	// Extract the x/y/z axes from this matrix
  // 	const xAxis = new Vec3(this.m00, this.m01, this.m02);
  // 	const yAxis = new Vec3(this.m10, this.m11, this.m12);
  // 	const zAxis = new Vec3(this.m20, this.m21, this.m22);
  // 	// Rotate them around the global axis
  // 	const rotatedXAxis = Vec3.rotateAboutAxisRads(xAxis, angleRads, worldAxis);
  // 	const rotatedYAxis = Vec3.rotateAboutAxisRads(yAxis, angleRads, worldAxis);
  // 	const rotatedZAxis = Vec3.rotateAboutAxisRads(zAxis, angleRads, worldAxis);
  // 	// Assign the rotated axes back to the this matrix
  // 	// Set rotated X-axis
  // 	this.m00 = rotatedXAxis.x;
  // 	this.m01 = rotatedXAxis.y;
  // 	this.m02 = rotatedXAxis.z;
  // 	//this.m03 = this.m03; // No change to w
  // 	// Set rotated Y-axis
  // 	this.m10 = rotatedYAxis.x;
  // 	this.m11 = rotatedYAxis.y;
  // 	this.m12 = rotatedYAxis.z;
  // 	//this.m13 = matrix.m13; // No change to w
  // 	// Set rotated Z-axis
  // 	this.m20 = rotatedZAxis.x;
  // 	this.m21 = rotatedZAxis.y;
  // 	this.m22 = rotatedZAxis.z;
  // 	// this.m23 = matrix.m23; No change to w
  // 	// The origin does not change
  // 	//this.m30 = matrix.m30;
  // 	//this.m31 = matrix.m31;
  // 	//this.m32 = matrix.m32;
  // 	//this.m33 = matrix.m33;
  // 	// Return the rotated matrix
  // 	return this;
  // }
  /**
   * Rotate a matrix about a given global axis by an angle in radians.
   * <p>
   * The matrix provided is NOT modified - a rotated version is returned.
   * <p>
   * The axis specified to rotate the matrix about is <strong>not</strong>
   * specified in the coordinate space of the matrix being rotated - it is
   * specified in global coordinates, such as used in OpenGL world space. In
   * this coordinate system:
   * <ul>
   * <li>The positive X-axis runs to the right (1,0,0),
   * <li>The positive Y-axis runs vertically upwards (0,1,0), and</li>
   * <li>The positive Z-axis runs outwards from the screen (0,0,1).</li>
   * </ul>
   *
   * @param	matrix		The matrix to rotate.
   * @param	angleRads	The angle to rotate the matrix in radians.
   * @param	worldAxis	The world-space axis to rotate around.
   * @return			The rotated matrix.
   */
  static rotateAboutWorldAxisRads(r, e, t) {
    const s = new R(r.m00, r.m01, r.m02), i = new R(r.m10, r.m11, r.m12), n = new R(r.m20, r.m21, r.m22), a = R.rotateAboutAxisRads(s, e, t), o = R.rotateAboutAxisRads(i, e, t), h = R.rotateAboutAxisRads(n, e, t), l = new ft();
    return l.m00 = a.x, l.m01 = a.y, l.m02 = a.z, l.m03 = r.m03, l.m10 = o.x, l.m11 = o.y, l.m12 = o.z, l.m13 = r.m13, l.m20 = h.x, l.m21 = h.y, l.m22 = h.z, l.m23 = r.m23, l.m30 = r.m30, l.m31 = r.m31, l.m32 = r.m32, l.m33 = r.m33, l;
  }
  /**
   * Rotate a matrix about a given global axis by an angle in radians.
   * <p>
   * The matrix provided is NOT modified - a rotated version is returned.
   * <p>
   * The axis specified to rotate the matrix about is <strong>not</strong>
   * specified in the coordinate space of the matrix being rotated - it is
   * specified in global coordinates, such as used in OpenGL world space. In
   * this coordinate system:
   * <ul>
   * <li>The positive X-axis runs to the right (1,0,0),
   * <li>The positive Y-axis runs vertically upwards (0,1,0), and</li>
   * <li>The positive Z-axis runs outwards from the screen (0,0,1).</li>
   * </ul>
   *
   * @param	matrix		The matrix to rotate.
   * @param	angleDegs	The angle to rotate the matrix in degrees.
   * @param	worldAxis	The world-space axis to rotate around.
   * @return			A rotated version of the provided matrix.
   */
  static rotateAboutWorldAxisDegs(r, e, t) {
    return ft.rotateAboutWorldAxisRads(
      r,
      e * ft.DEGS_TO_RADS,
      t
    );
  }
  /**
   * Rotate matrix about a relative axis.
   * <p>
   * The matrix is rotated about the provided axis in the coordinate system of the provided matrix.
   *
   * @param	matrix		The matrix to rotate.
   * @param	angleRads	The angle to rotate the matrix about in radians.
   * @param	localAxis	The relative axis to rotate about.
   * @return			A rotated matrix.
   */
  static rotateMatrixAboutLocalAxisRads(r, e, t) {
    const s = r.transformDirection(t);
    return ft.rotateAboutWorldAxisRads(r, e, s);
  }
  /**
   * Rotate matrix about a relative axis.
   * <p>
   * The matrix is rotated about the provided axis in the coordinate system of the provided matrix.
   *
   * @param	matrix		The matrix to rotate.
   * @param	angleDegs	The angle to rotate the matrix about in degrees.
   * @param	localAxis	The relative axis to rotate about.
   * @return			A rotated matrix.
   */
  static rotateMatrixAboutLocalAxisDegs(r, e, t) {
    return ft.rotateMatrixAboutLocalAxisDegs(
      r,
      e * ft.DEGS_TO_RADS,
      t
    );
  }
  /**
   * Return a Mat3f version of this Mat4f.
   * <p>
   * The x, y and z axes are returned in the Mat3f, while the w component of each axis
   * and the origin plus it's w component are discarded.
   * <p>
   * In effect, we are extracting the orientation of this Mat4f into a Mat3f.
   *
   * @return	A Mat3f version of this Mat4f.
   */
  toMat3f() {
    const r = new Ns();
    return r.m00 = this.m00, r.m01 = this.m01, r.m02 = this.m02, r.m10 = this.m10, r.m11 = this.m11, r.m12 = this.m12, r.m20 = this.m20, r.m21 = this.m21, r.m22 = this.m22, r;
  }
  /**
   * Return this Mat4f as an array of 16 floats.
   *
   * @return	This Mat4f as an array of 16 floats.
   */
  toArray() {
    return [
      this.m00,
      this.m01,
      this.m02,
      this.m03,
      this.m10,
      this.m11,
      this.m12,
      this.m13,
      this.m20,
      this.m21,
      this.m22,
      this.m23,
      this.m30,
      this.m31,
      this.m32,
      this.m33
    ];
  }
  /**
   * Overridden toString method.
   * <p>
   * The matrix values are formatted to three decimal places. If you require the exact unformatted
   * m<em>XY</em> values then they may be accessed directly.
   *
   * @return	A concise, human-readable description of a Mat4f.
   */
  // @Override
  toString() {
    return `X-axis: (${this.m00.toFixed(3)}, ${this.m01.toFixed(
      3
    )}, ${this.m02.toFixed(3)}, ${this.m03.toFixed(3)})\r
Y-axis: (${this.m10.toFixed(3)}, ${this.m11.toFixed(
      3
    )}, ${this.m12.toFixed(3)}, ${this.m13.toFixed(3)}})\r
Z-axis: (${this.m20.toFixed(3)}, ${this.m21.toFixed(
      3
    )}, ${this.m22.toFixed(3)}, ${this.m23.toFixed(3)}})\r
Origin: (${this.m30.toFixed(3)}, ${this.m31.toFixed(
      3
    )}, ${this.m32.toFixed(3)}, ${this.m33.toFixed(3)}})\r
`;
  }
  // ---------- Static methods ----------
  /**
   * Construct an orthographic projection matrix.
   * <p>
   * Orthographic projections are commonly used when working in 2D or CAD scenarios. As orthographic projection
   * does not perform foreshortening on any projected geometry, objects are drawn the same size regardless of
   * their distance from the camera.
   * <p>
   * By specifying the bottom clipping plane to be 0.0f and the top clipping plane to be the height of the window,
   * the origin of the coordinate space is at the bottom-left of the window and the positive y-axis runs upwards.
   * To place the origin at the top left of the window and have the y-axis run downwards, simply swap the top and
   * bottom values.
   * <p>
   * Once you have an orthographic projection matrix, if you are not using any separate Model or View matrices
   * then you may simply use the orthographic matrix as a ModelViewProjection matrix.
   * <p>
   * If values are passed so that (right - left), (top - bottom) or (far - near) are zero then an
   * IllegalArgumentException is thrown.
   *
   * @param	left	The left   clipping plane, typically 0.0f.
   * @param	right	The right  clipping plane, typically the width of the window.
   * @param	top		The top    clipping plane, typically the height of the window.
   * @param	bottom  The bottom clipping plane, typically 0.0f.
   * @param	near	The near   clipping plane, typically -1.0f.
   * @param	far     The far    clipping plane, typically  1.0f.
   * @return			The constructed orthographic matrix
   * @see				<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html#ortho">http://www.songho.ca/opengl/gl_projectionmatrix.html#ortho</a>
   */
  static createOrthographicProjectionMatrix(r, e, t, s, i, n) {
    if (e - r === 0)
      throw new Error("(right - left) cannot be zero.");
    if (t - s === 0)
      throw new Error("(top - bottom) cannot be zero.");
    if (n - i === 0)
      throw new Error("(far - near) cannot be zero.");
    const a = new ft();
    return a.m00 = 2 / (e - r), a.m01 = 0, a.m02 = 0, a.m03 = 0, a.m10 = 0, a.m11 = 2 / (t - s), a.m12 = 0, a.m13 = 0, a.m20 = 0, a.m21 = 0, a.m22 = -2 / (n - i), a.m23 = 0, a.m30 = -(e + r) / (e - r), a.m31 = -(t + s) / (t - s), a.m32 = -(n + i) / (n - i), a.m33 = 1, a;
  }
  /**
   * Construct a perspective projection matrix.
   * <p>
   * The parameters provided are the locations of the left/right/top/bottom/near/far clipping planes.
   * <p>
   * There is rarely any need to specify the bounds of a projection matrix in this manner, and you
   * are likely to be better served by using the
   * {@link #createPerspectiveProjectionMatrix(float, float, float, float)} method instead.
   * <p>
   * Once you have a Projection matrix, then it can be combined with a ModelView or separate Model and
   * View matrices in the following manner (be careful: multiplication order is important) to create a
   * ModelViewProjection matrix:
   * <p>
   * {@code Mat4f mvpMatrix = projectionMatrix.times(modelViewMatrix);}
   * <p>
   * or
   * <p>
   * {@code Mat4f mvpMatrix = projectionMatrix.times(viewMatrix).times(modelMatrix);}
   *
   * @param	left	The left   clipping plane, typically 0.0f.
   * @param	right	The right  clipping plane, typically the width of the window.
   * @param	top		The top    clipping plane, typically the height of the window.
   * @param	bottom  The bottom clipping plane, typically 0.0f.
   * @param	near	The near   clipping plane, typically -1.0f.
   * @param	far     The far    clipping plane, typically  1.0f.
   * @return			The constructed orthographic matrix
   * @see				<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html#ortho">http://www.songho.ca/opengl/gl_projectionmatrix.html#ortho</a>
   */
  static createPerspectiveProjectionMatrix(r, e, t, s, i, n) {
    const a = ft.NewByOneValue(1);
    return a.m00 = 2 * i / (e - r), a.m11 = 2 * i / (t - s), a.m20 = (e + r) / (e - r), a.m21 = (t + s) / (t - s), a.m22 = -(n + i) / (n - i), a.m23 = -1, a.m32 = -2 * n * i / (n - i), a.m33 = 0, a;
  }
  /***
   * Construct a perspective projection matrix.
   * <p>
   * The vertical and horizontal field of view (FoV) values are related in such a way that if you know one
   * then you can calculate the other. This method takes the vertical FoV and allows the horizontal FoV to
   * adapt to it based on the aspect ratio of the screen in a technique called 'Hor+' (horizontal plus) scaling.
   * <p>
   * If required, the horizontal and vertical FoVs can be calculated via the following process (note: all angles
   * are specified in <strong>radians</strong>):
   * <p>
   * {@code float horizFoVRads = 2.0f * (float)Math.atan( Math.tan(vertFoVRads  / 2.0f) * aspectRatio);}
   * <p>
   * {@code float vertFoVRads  = 2.0f * (float)Math.atan( Math.tan(horizFoVRads / 2.0f) * (1.0f / aspectRatio) ); }
   * <p>
   * The aspect ratio can be calculated as: {@code (float)windowWidth / (float)windowHeight} - if the size of the
   * window changes then a new projection matrix should be created with the new aspect ratio of the window.
   * <p>
   * {@code zNear} and {@code zFar} represent the near and far clipping distances outside of which any geometry
   * will be clipped (i.e. not rendered). An acceptable value for zNear is <strong>1.0f</strong> (0.0f should be
   * avoided), however, specifying a zNear value of <strong>2.0f</strong> will essentially double the precision
   * of your depth buffer due to the way in which floating point values distribute bits between the significand
   * (i.e. the value before the decimal point) and the exponent (the value to raise or lower the significand to).
   * Choosing good values for your near and far clipping planes can often eliminate any z-fighting in your scenes.
   * <p>
   * An {@link IllegalArgumentException} is thrown is any of the parameters are specified with illegal values.
   *
   * @param	vertFoVDegs	The vertical Field of View angle - must be a positive value between 1.0f and 179.0f. For good
   * choices, see <a href="http://en.wikipedia.org/wiki/Field_of_view_in_video_games#Choice_of_field_of_view">choice of
   * field of view</a>.
   * @param	aspectRatio	The aspect ratio of the window in which drawing will occur - must be a positive value.
   * @param	zNear		The near clipping distance - must be a positive value which is less than zFar.
   * @param	zFar		The far  clipping distance - must be a positive value which is greater than zNear.
   * @return				A projection matrix as a Mat4f.
   * @see		<a href="http://en.wikipedia.org/wiki/Field_of_view_in_video_games">http://en.wikipedia.org/wiki/Field_of_view_in_video_games</a>
   * @see		<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a>
   * @see		<a href="https://www.opengl.org/archives/resources/faq/technical/depthbuffer.htm">https://www.opengl.org/archives/resources/faq/technical/depthbuffer.htm</a>
   * @see		<a href="http://en.wikipedia.org/wiki/Floating_point">http://en.wikipedia.org/wiki/Floating_point</a>
   * @see		<a href="http://en.wikipedia.org/wiki/Z-fighting">http://en.wikipedia.org/wiki/Z-fighting</a>
   */
  // public static Mat4f createPerspectiveProjectionMatrix(float vertFoVDegs, float aspectRatio, float zNear, float zFar)
  // {
  // 	// Sanity checking
  // 	if (aspectRatio < 0.0f                        ) { throw new IllegalArgumentException("Aspect ratio cannot be negative.");                        }
  // 	if (zNear <= 0.0f || zFar <= 0.0f             ) { throw new IllegalArgumentException("The values of zNear and zFar must be positive.");          }
  // 	if (zNear >= zFar                             ) { throw new IllegalArgumentException("zNear must be less than than zFar.");                      }
  // 	if (vertFoVDegs < 1.0f || vertFoVDegs > 179.0f) {throw new IllegalArgumentException("Vertical FoV must be within 1 and 179 degrees inclusive."); }
  // 	float frustumLength = zFar - zNear;
  // 	// Calculate half the vertical field of view in radians
  // 	float halfVertFoVRads = (vertFoVDegs / 2.0f) * DEGS_TO_RADS;
  // 	// There is no built in Math.cot() in Java, but co-tangent is simply 1 over tangent
  // 	float cotangent = 1.0f / (float)Math.tan(halfVertFoVRads);
  // 	// Instantiate a new matrix, initialised to identity
  // 	Mat4f p = new Mat4f(1.0f);
  // 	// Set matrix values and return the constructed projection matrix
  // 	p.m00 = cotangent / aspectRatio;
  // 	p.m11 = cotangent;
  // 	p.m22 = -(zFar + zNear) / frustumLength;
  // 	p.m23 = -1.0f;
  // 	p.m32 = (-2.0f * zNear * zFar) / frustumLength;
  // 	p.m33 = 0.0f;
  // 	return p;
  // }
};
let i_ = ft;
i_.DEGS_TO_RADS = Math.PI / 180;
i_.FLOAT_EQUALITY_TOLERANCE = 1e-4;
var xa = {};
function Ky(r) {
  window.console && window.console.error && window.console.error(r);
}
function Zy(r) {
  window.console && window.console.log && window.console.log(r);
}
function Jy(r, e) {
  xa[r] = !0, e !== void 0 && Ky(e);
}
function Qy(r) {
  var e = r.getError;
  r.getError = function() {
    var t;
    do
      t = e.apply(r), t != r.NO_ERROR && (xa[t] = !0);
    while (t != r.NO_ERROR);
    for (var t in xa)
      if (xa[t])
        return delete xa[t], parseInt(t);
    return r.NO_ERROR;
  };
}
var eo = function r(e) {
  var t = e.gl;
  this.ext = e, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
  for (var s = 0; s < this.attribs.length; s++) {
    var i = new r.VertexAttrib(t);
    this.attribs[s] = i;
  }
  this.maxAttrib = 0;
};
eo.VertexAttrib = function(e) {
  this.enabled = !1, this.buffer = null, this.size = 4, this.type = e.FLOAT, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache();
};
eo.VertexAttrib.prototype.recache = function() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
var Nn = function(e) {
  var t = this;
  this.gl = e, Qy(e);
  var s = this.original = {
    getParameter: e.getParameter,
    enableVertexAttribArray: e.enableVertexAttribArray,
    disableVertexAttribArray: e.disableVertexAttribArray,
    bindBuffer: e.bindBuffer,
    getVertexAttrib: e.getVertexAttrib,
    vertexAttribPointer: e.vertexAttribPointer
  };
  e.getParameter = function(n) {
    return n == t.VERTEX_ARRAY_BINDING_OES ? t.currentVertexArrayObject == t.defaultVertexArrayObject ? null : t.currentVertexArrayObject : s.getParameter.apply(this, arguments);
  }, e.enableVertexAttribArray = function(n) {
    var a = t.currentVertexArrayObject;
    a.maxAttrib = Math.max(a.maxAttrib, n);
    var o = a.attribs[n];
    return o.enabled = !0, s.enableVertexAttribArray.apply(this, arguments);
  }, e.disableVertexAttribArray = function(n) {
    var a = t.currentVertexArrayObject;
    a.maxAttrib = Math.max(a.maxAttrib, n);
    var o = a.attribs[n];
    return o.enabled = !1, s.disableVertexAttribArray.apply(this, arguments);
  }, e.bindBuffer = function(n, a) {
    switch (n) {
      case e.ARRAY_BUFFER:
        t.currentArrayBuffer = a;
        break;
      case e.ELEMENT_ARRAY_BUFFER:
        t.currentVertexArrayObject.elementArrayBuffer = a;
        break;
    }
    return s.bindBuffer.apply(this, arguments);
  }, e.getVertexAttrib = function(n, a) {
    var o = t.currentVertexArrayObject, h = o.attribs[n];
    switch (a) {
      case e.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
        return h.buffer;
      case e.VERTEX_ATTRIB_ARRAY_ENABLED:
        return h.enabled;
      case e.VERTEX_ATTRIB_ARRAY_SIZE:
        return h.size;
      case e.VERTEX_ATTRIB_ARRAY_STRIDE:
        return h.stride;
      case e.VERTEX_ATTRIB_ARRAY_TYPE:
        return h.type;
      case e.VERTEX_ATTRIB_ARRAY_NORMALIZED:
        return h.normalized;
      default:
        return s.getVertexAttrib.apply(this, arguments);
    }
  }, e.vertexAttribPointer = function(n, a, o, h, l, c) {
    var d = t.currentVertexArrayObject;
    d.maxAttrib = Math.max(d.maxAttrib, n);
    var u = d.attribs[n];
    return u.buffer = t.currentArrayBuffer, u.size = a, u.type = o, u.normalized = h, u.stride = l, u.offset = c, u.recache(), s.vertexAttribPointer.apply(this, arguments);
  }, e.instrumentExtension && e.instrumentExtension(this, "OES_vertex_array_object"), e.canvas.addEventListener("webglcontextrestored", function() {
    Zy("OESVertexArrayObject emulation library context restored"), t.reset_();
  }, !0), this.reset_();
};
Nn.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
Nn.prototype.reset_ = function() {
  var e = this.vertexArrayObjects !== void 0;
  if (e)
    for (var t = 0; t < this.vertexArrayObjects.length; ++t)
      this.vertexArrayObjects.isAlive = !1;
  var s = this.gl;
  this.maxVertexAttribs = s.getParameter(s.MAX_VERTEX_ATTRIBS), this.defaultVertexArrayObject = new eo(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null);
};
Nn.prototype.createVertexArrayOES = function() {
  var e = new eo(this);
  return this.vertexArrayObjects.push(e), e;
};
Nn.prototype.deleteVertexArrayOES = function(e) {
  e.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1), this.currentVertexArrayObject == e && this.bindVertexArrayOES(null);
};
Nn.prototype.isVertexArrayOES = function(e) {
  return !!(e && e instanceof eo && e.hasBeenBound && e.ext == this);
};
Nn.prototype.bindVertexArrayOES = function(e) {
  var t = this.gl;
  if (e && !e.isAlive) {
    Jy(t.INVALID_OPERATION, "bindVertexArrayOES: attempt to bind deleted arrayObject");
    return;
  }
  var s = this.original, i = this.currentVertexArrayObject;
  this.currentVertexArrayObject = e || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
  var n = this.currentVertexArrayObject;
  if (i != n) {
    (!i || n.elementArrayBuffer != i.elementArrayBuffer) && s.bindBuffer.call(t, t.ELEMENT_ARRAY_BUFFER, n.elementArrayBuffer);
    for (var a = this.currentArrayBuffer, o = Math.max(i ? i.maxAttrib : 0, n.maxAttrib), h = 0; h <= o; h++) {
      var l = n.attribs[h], c = i ? i.attribs[h] : null;
      if ((!i || l.enabled != c.enabled) && (l.enabled ? s.enableVertexAttribArray.call(t, h) : s.disableVertexAttribArray.call(t, h)), l.enabled) {
        var d = !1;
        (!i || l.buffer != c.buffer) && (a != l.buffer && (s.bindBuffer.call(t, t.ARRAY_BUFFER, l.buffer), a = l.buffer), d = !0), (d || l.cached != c.cached) && s.vertexAttribPointer.call(t, h, l.size, l.type, l.normalized, l.stride, l.offset);
      }
    }
    this.currentArrayBuffer != a && s.bindBuffer.call(t, t.ARRAY_BUFFER, this.currentArrayBuffer);
  }
};
const e0 = function(e) {
  if (e.getSupportedExtensions) {
    var t = e.getSupportedExtensions();
    if (t.indexOf("OES_vertex_array_object") != -1)
      return;
  } else if (e.getExtension) {
    var s = e.getExtension("OES_vertex_array_object");
    if (s)
      return;
  }
  if (e.getSupportedExtensions) {
    var i = e.getSupportedExtensions;
    e.getSupportedExtensions = function() {
      var o = i.call(this) || [];
      return o.push("OES_vertex_array_object"), o;
    };
  }
  var n = e.getExtension;
  e.getExtension = function(o) {
    return o == "OES_vertex_array_object" ? (e.__OESVertexArrayObject || (e.__OESVertexArrayObject = new Nn(e)), e.__OESVertexArrayObject) : n ? n.call(this, o) : null;
  };
}, t0 = "1.61.0", s0 = "ff5c7f266", i0 = function() {
  const r = {}, e = ["Array", "Object", "Function", "Date", "RegExp", "Float32Array"];
  for (let t = 0; t < e.length; t++)
    r["[object " + e[t] + "]"] = e[t].toLowerCase();
  return r;
}();
function _f(r) {
  if (r === null)
    return "null";
  const e = typeof r;
  return e === "undefined" || e === "number" || e === "string" || e === "boolean" ? e : i0[Object.prototype.toString.call(r)];
}
function Hi(r, e) {
  for (const t in e) {
    const s = e[t];
    _f(s) === "object" ? r[t] = Hi({}, s) : _f(s) === "array" ? r[t] = Hi([], s) : r[t] = s;
  }
  return r;
}
class _e {
  constructor() {
    this._callbacks = {}, this._callbackActive = {};
  }
  initEventHandler() {
    this._callbacks = {}, this._callbackActive = {};
  }
  _addCallback(e, t, s, i = !1) {
    !e || typeof e != "string" || !t || (this._callbacks[e] || (this._callbacks[e] = []), this._callbackActive[e] && this._callbackActive[e] === this._callbacks[e] && (this._callbackActive[e] = this._callbackActive[e].slice()), this._callbacks[e].push({
      callback: t,
      scope: s || this,
      once: i
    }));
  }
  on(e, t, s) {
    return this._addCallback(e, t, s, !1), this;
  }
  off(e, t, s) {
    if (e)
      this._callbackActive[e] && this._callbackActive[e] === this._callbacks[e] && (this._callbackActive[e] = this._callbackActive[e].slice());
    else
      for (const i in this._callbackActive)
        this._callbacks[i] && this._callbacks[i] === this._callbackActive[i] && (this._callbackActive[i] = this._callbackActive[i].slice());
    if (!e)
      this._callbacks = {};
    else if (!t)
      this._callbacks[e] && (this._callbacks[e] = []);
    else {
      const i = this._callbacks[e];
      if (!i)
        return this;
      let n = i.length;
      for (let a = 0; a < n; a++)
        i[a].callback === t && (s && i[a].scope !== s || (i[a--] = i[--n]));
      i.length = n;
    }
    return this;
  }
  fire(e, t, s, i, n, a, o, h, l) {
    if (!e || !this._callbacks[e])
      return this;
    let c;
    this._callbackActive[e] ? (this._callbackActive[e] === this._callbacks[e] && (this._callbackActive[e] = this._callbackActive[e].slice()), c = this._callbacks[e].slice()) : this._callbackActive[e] = this._callbacks[e];
    for (let d = 0; (c || this._callbackActive[e]) && d < (c || this._callbackActive[e]).length; d++) {
      const u = (c || this._callbackActive[e])[d];
      if (u.callback.call(u.scope, t, s, i, n, a, o, h, l), u.once) {
        const f = this._callbacks[e], m = f ? f.indexOf(u) : -1;
        m !== -1 && (this._callbackActive[e] === f && (this._callbackActive[e] = this._callbackActive[e].slice()), this._callbacks[e].splice(m, 1));
      }
    }
    return c || (this._callbackActive[e] = null), this;
  }
  once(e, t, s) {
    return this._addCallback(e, t, s, !0), this;
  }
  hasEvent(e) {
    return this._callbacks[e] && this._callbacks[e].length !== 0 || !1;
  }
}
const mu = {
  attach: function(r) {
    const e = mu;
    return r._addCallback = e._addCallback, r.on = e.on, r.off = e.off, r.fire = e.fire, r.once = e.once, r.hasEvent = e.hasEvent, r._callbacks = {}, r._callbackActive = {}, r;
  },
  _addCallback: _e.prototype._addCallback,
  on: _e.prototype.on,
  off: _e.prototype.off,
  fire: _e.prototype.fire,
  once: _e.prototype.once,
  hasEvent: _e.prototype.hasEvent
}, n0 = {
  create: function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(r) {
      const e = Math.random() * 16 | 0;
      return (r === "x" ? e : e & 3 | 8).toString(16);
    });
  }
}, me = {
  delimiter: "/",
  join: function() {
    const r = arguments.length;
    let e = arguments[0];
    for (let t = 0; t < r - 1; ++t) {
      const s = arguments[t], i = arguments[t + 1];
      if (i[0] === me.delimiter) {
        e = i;
        continue;
      }
      s && i && s[s.length - 1] !== me.delimiter && i[0] !== me.delimiter ? e += me.delimiter + i : e += i;
    }
    return e;
  },
  normalize: function(r) {
    const e = r.startsWith(me.delimiter), t = r.endsWith(me.delimiter), s = r.split("/");
    let i = "", n = [];
    for (let a = 0; a < s.length; a++)
      if (s[a] !== "" && s[a] !== ".") {
        if (s[a] === ".." && n.length > 0) {
          n = n.slice(0, n.length - 2);
          continue;
        }
        a > 0 && n.push(me.delimiter), n.push(s[a]);
      }
    return i = n.join(""), !e && i[0] === me.delimiter && (i = i.slice(1)), t && i[i.length - 1] !== me.delimiter && (i += me.delimiter), i;
  },
  split: function(r) {
    const e = r.lastIndexOf(me.delimiter);
    return e !== -1 ? [r.substring(0, e), r.substring(e + 1)] : ["", r];
  },
  getBasename: function(r) {
    return me.split(r)[1];
  },
  getDirectory: function(r) {
    return me.split(r)[0];
  },
  getExtension: function(r) {
    const e = r.split("?")[0].split(".").pop();
    return e !== r ? "." + e : "";
  },
  isRelativePath: function(r) {
    return r.charAt(0) !== "/" && r.match(/:\/\//) === null;
  },
  extractPath: function(r) {
    let e = "";
    const t = r.split("/");
    let s = 0;
    if (t.length > 1)
      if (me.isRelativePath(r))
        if (t[0] === ".")
          for (s = 0; s < t.length - 1; ++s)
            e += s === 0 ? t[s] : "/" + t[s];
        else if (t[0] === "..")
          for (s = 0; s < t.length - 1; ++s)
            e += s === 0 ? t[s] : "/" + t[s];
        else
          for (e = ".", s = 0; s < t.length - 1; ++s)
            e += "/" + t[s];
      else
        for (s = 0; s < t.length - 1; ++s)
          e += s === 0 ? t[s] : "/" + t[s];
    return e;
  }
};
let va = !1, ch = !1, n_ = !1, r_ = !1, a_ = !1, o_ = !1, h_ = !1, l_ = !1, c_ = !1, d_ = !1;
if (typeof navigator < "u") {
  const r = navigator.userAgent;
  /(windows|mac os|linux|cros)/i.test(r) && (va = !0), /xbox/i.test(r) && (r_ = !0), /(windows phone|iemobile|wpdesktop)/i.test(r) ? (va = !1, ch = !0, n_ = !0) : /android/i.test(r) ? (va = !1, ch = !0, a_ = !0) : /ip([ao]d|hone)/i.test(r) && (va = !1, ch = !0, o_ = !0), typeof window < "u" && (h_ = "ontouchstart" in window || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0), l_ = "getGamepads" in navigator, c_ = typeof Worker < "u";
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        return d_ = !0, !1;
      }
    });
    window.addEventListener("testpassive", null, e), window.removeEventListener("testpassive", null, e);
  } catch {
  }
}
const ic = typeof window < "u" ? "browser" : "node", lt = {
  environment: ic,
  global: ic === "browser" ? window : global,
  browser: ic === "browser",
  desktop: va,
  mobile: ch,
  ios: o_,
  android: a_,
  windows: n_,
  xbox: r_,
  gamepads: l_,
  touch: h_,
  workers: c_,
  passiveEvents: d_
}, u_ = "abcdefghijklmnopqrstuvwxyz", f_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", r0 = u_ + f_, id = 55296, m_ = 56319, gf = 56320, a0 = 57343, o0 = 8205, yf = 127462, xf = 127487, h0 = 127995, l0 = 127999, c0 = 8400, d0 = 8447, nd = 65024, rd = 65039;
function ad(r, e = 0) {
  const t = r.length;
  if (e < 0 || e >= t)
    return null;
  const s = r.charCodeAt(e);
  if (t > 1 && s >= id && s <= m_) {
    const i = r.charCodeAt(e + 1);
    if (i >= gf && i <= a0)
      return {
        code: (s - id) * 1024 + i - gf + 65536,
        long: !0
      };
  }
  return {
    code: s,
    long: !1
  };
}
function Oi(r, e, t) {
  if (!r)
    return !1;
  const s = ad(r);
  if (s) {
    const i = s.code;
    return i >= e && i <= t;
  }
  return !1;
}
function u0(r, e) {
  if (e === r.length - 1)
    return 1;
  if (Oi(r[e], id, m_)) {
    const t = r.substring(e, e + 2), s = r.substring(e + 2, e + 4);
    return Oi(s, h0, l0) || Oi(t, yf, xf) && Oi(s, yf, xf) ? 4 : Oi(s, nd, rd) ? 3 : 2;
  }
  return Oi(r[e + 1], nd, rd) ? 2 : 1;
}
const dh = {
  ASCII_LOWERCASE: u_,
  ASCII_UPPERCASE: f_,
  ASCII_LETTERS: r0,
  format: function(r) {
    for (let e = 1; e < arguments.length; e++)
      r = r.replace("{" + (e - 1) + "}", arguments[e]);
    return r;
  },
  toBool: function(r, e = !1) {
    if (r === "true")
      return !0;
    if (e) {
      if (r === "false")
        return !1;
      throw new TypeError("Not a boolean string");
    }
    return !1;
  },
  getCodePoint: function(r, e) {
    const t = ad(r, e);
    return t && t.code;
  },
  getCodePoints: function(r) {
    if (typeof r != "string")
      throw new TypeError("Not a string");
    let e = 0;
    const t = [];
    let s;
    for (; s = ad(r, e); )
      t.push(s.code), e += s.long ? 2 : 1;
    return t;
  },
  getSymbols: function(r) {
    if (typeof r != "string")
      throw new TypeError("Not a string");
    let e = 0;
    const t = r.length, s = [];
    let i = 0, n;
    for (; e < t; ) {
      if (i += u0(r, e + i), n = r[e + i], Oi(n, c0, d0) && (n = r[e + i++]), Oi(n, nd, rd) && (n = r[e + i++]), n && n.charCodeAt(0) === o0) {
        n = r[e + i++];
        continue;
      }
      const a = r.substring(e, e + i);
      s.push(a), e += i, i = 0;
    }
    return s;
  },
  fromCodePoint: function() {
    const r = [];
    let e, t, s;
    for (let i = 0; i < arguments.length; ++i)
      e = Number(arguments[i]), t = e - 65536, s = e > 65535 ? [(t >> 10) + 55296, t % 1024 + 56320] : [e], r.push(String.fromCharCode.apply(null, s));
    return r.join("");
  }
};
class f0 {
  constructor() {
    this._list = [], this._index = {};
  }
  push(e, t) {
    if (this._index[e])
      throw Error("Key already in index " + e);
    const s = this._list.push(t) - 1;
    this._index[e] = s;
  }
  has(e) {
    return this._index[e] !== void 0;
  }
  get(e) {
    const t = this._index[e];
    return t !== void 0 ? this._list[t] : null;
  }
  remove(e) {
    const t = this._index[e];
    if (t !== void 0) {
      this._list.splice(t, 1), delete this._index[e];
      for (e in this._index) {
        const s = this._index[e];
        s > t && (this._index[e] = s - 1);
      }
      return !0;
    }
    return !1;
  }
  list() {
    return this._list;
  }
  clear() {
    this._list.length = 0;
    for (const e in this._index)
      delete this._index[e];
  }
}
const m0 = (r) => {
  const e = {};
  let t = e;
  return () => (t === e && (t = r()), t);
};
class Qt {
  static loadScript(e, t) {
    const s = document.createElement("script");
    s.setAttribute("src", e), s.onload = () => {
      t(null);
    }, s.onerror = () => {
      t(`Failed to load script='${e}'`);
    }, document.body.appendChild(s);
  }
  static loadWasm(e, t, s) {
    const i = Qt.wasmSupported() && t.glueUrl && t.wasmUrl ? t.glueUrl : t.fallbackUrl;
    i ? Qt.loadScript(i, (n) => {
      if (n)
        s(n, null);
      else {
        const a = window[e];
        window[e] = void 0, a({
          locateFile: () => t.wasmUrl,
          onAbort: () => {
            s("wasm module aborted.");
          }
        }).then((o) => {
          s(null, o);
        });
      }
    }) : s("No supported wasm modules found.", null);
  }
  static getModule(e) {
    return Qt.modules.hasOwnProperty(e) || (Qt.modules[e] = {
      config: null,
      initializing: !1,
      instance: null,
      callbacks: []
    }), Qt.modules[e];
  }
  static initialize(e, t) {
    if (t.initializing)
      return;
    const s = t.config;
    (s.glueUrl || s.wasmUrl || s.fallbackUrl) && (t.initializing = !0, Qt.loadWasm(e, s, (i, n) => {
      i ? s.errorHandler ? s.errorHandler(i) : console.error(`failed to initialize module=${e} error=${i}`) : (t.instance = n, t.callbacks.forEach((a) => {
        a(n);
      }));
    }));
  }
}
Qt.modules = {};
Qt.wasmSupported = m0(() => {
  try {
    if (typeof WebAssembly == "object" && typeof WebAssembly.instantiate == "function") {
      const r = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
      if (r instanceof WebAssembly.Module)
        return new WebAssembly.Instance(r) instanceof WebAssembly.Instance;
    }
  } catch {
  }
  return !1;
});
class p0 {
  static setConfig(e, t) {
    const s = Qt.getModule(e);
    s.config = t, s.callbacks.length > 0 && Qt.initialize(e, s);
  }
  static getInstance(e, t) {
    const s = Qt.getModule(e);
    s.instance ? t(s.instance) : (s.callbacks.push(t), s.config && Qt.initialize(e, s));
  }
}
class p_ {
  constructor(e) {
    this.arraybuffer = e, this.dataView = new DataView(e), this.offset = 0, this.stack = [];
  }
  get remainingBytes() {
    return this.dataView.byteLength - this.offset;
  }
  reset(e = 0) {
    this.offset = e;
  }
  skip(e) {
    this.offset += e;
  }
  align(e) {
    this.offset = this.offset + e - 1 & ~(e - 1);
  }
  _inc(e) {
    return this.offset += e, this.offset - e;
  }
  readChar() {
    return String.fromCharCode(this.dataView.getUint8(this.offset++));
  }
  readChars(e) {
    let t = "";
    for (let s = 0; s < e; ++s)
      t += this.readChar();
    return t;
  }
  readU8() {
    return this.dataView.getUint8(this.offset++);
  }
  readU16() {
    return this.dataView.getUint16(this._inc(2), !0);
  }
  readU32() {
    return this.dataView.getUint32(this._inc(4), !0);
  }
  readU64() {
    return this.readU32() + 2 ** 32 * this.readU32();
  }
  readU32be() {
    return this.dataView.getUint32(this._inc(4), !1);
  }
  readArray(e) {
    for (let t = 0; t < e.length; ++t)
      e[t] = this.readU8();
  }
  readLine() {
    const e = this.dataView;
    let t = "";
    for (; !(this.offset >= e.byteLength); ) {
      const s = String.fromCharCode(this.readU8());
      if (s === `
`)
        break;
      t += s;
    }
    return t;
  }
}
class Ch {
  constructor(e) {
    this.items = [], this.length = 0, this.loopIndex = -1, this._sortBy = void 0, this._sortHandler = void 0, this._sortBy = e.sortBy, this._sortHandler = this._doSort.bind(this);
  }
  _binarySearch(e) {
    let t = 0, s = this.items.length - 1;
    const i = e[this._sortBy];
    let n, a;
    for (; t <= s; )
      n = Math.floor((t + s) / 2), a = this.items[n][this._sortBy], a <= i ? t = n + 1 : a > i && (s = n - 1);
    return t;
  }
  _doSort(e, t) {
    const s = this._sortBy;
    return e[s] - t[s];
  }
  insert(e) {
    const t = this._binarySearch(e);
    this.items.splice(t, 0, e), this.length++, this.loopIndex >= t && this.loopIndex++;
  }
  append(e) {
    this.items.push(e), this.length++;
  }
  remove(e) {
    const t = this.items.indexOf(e);
    t < 0 || (this.items.splice(t, 1), this.length--, this.loopIndex >= t && this.loopIndex--);
  }
  sort() {
    const e = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
    this.items.sort(this._sortHandler), e !== null && (this.loopIndex = this.items.indexOf(e));
  }
}
class __ extends _e {
  constructor(e) {
    super(), this._index = {}, this._list = [], this._parent = e;
  }
  add() {
    let e = !1;
    const t = this._processArguments(arguments, !0);
    if (!t.length)
      return e;
    for (let s = 0; s < t.length; s++)
      this._index[t[s]] || (e = !0, this._index[t[s]] = !0, this._list.push(t[s]), this.fire("add", t[s], this._parent));
    return e && this.fire("change", this._parent), e;
  }
  remove() {
    let e = !1;
    if (!this._list.length)
      return e;
    const t = this._processArguments(arguments, !0);
    if (!t.length)
      return e;
    for (let s = 0; s < t.length; s++)
      this._index[t[s]] && (e = !0, delete this._index[t[s]], this._list.splice(this._list.indexOf(t[s]), 1), this.fire("remove", t[s], this._parent));
    return e && this.fire("change", this._parent), e;
  }
  clear() {
    if (!this._list.length)
      return;
    const e = this._list.slice(0);
    this._list = [], this._index = {};
    for (let t = 0; t < e.length; t++)
      this.fire("remove", e[t], this._parent);
    this.fire("change", this._parent);
  }
  has() {
    return this._list.length ? this._has(this._processArguments(arguments)) : !1;
  }
  _has(e) {
    if (!this._list.length || !e.length)
      return !1;
    for (let t = 0; t < e.length; t++)
      if (e[t].length === 1) {
        if (this._index[e[t][0]])
          return !0;
      } else {
        let s = !0;
        for (let i = 0; i < e[t].length; i++)
          if (!this._index[e[t][i]]) {
            s = !1;
            break;
          }
        if (s)
          return !0;
      }
    return !1;
  }
  list() {
    return this._list.slice(0);
  }
  _processArguments(e, t) {
    const s = [];
    let i = [];
    if (!e || !e.length)
      return s;
    for (let n = 0; n < e.length; n++)
      if (e[n] instanceof Array) {
        t || (i = []);
        for (let a = 0; a < e[n].length; a++)
          typeof e[n][a] == "string" && (t ? s.push(e[n][a]) : i.push(e[n][a]));
        !t && i.length && s.push(i);
      } else
        typeof e[n] == "string" && (t ? s.push(e[n]) : s.push([e[n]]));
    return s;
  }
  get size() {
    return this._list.length;
  }
}
const Xi = typeof window < "u" && window.performance && window.performance.now && window.performance.timing ? performance.now.bind(performance) : Date.now, _0 = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class nc {
  constructor(e) {
    this.scheme = void 0, this.authority = void 0, this.path = void 0, this.query = void 0, this.fragment = void 0;
    const t = e.match(_0);
    this.scheme = t[2], this.authority = t[4], this.path = t[5], this.query = t[7], this.fragment = t[9];
  }
  toString() {
    let e = "";
    return this.scheme && (e += this.scheme + ":"), this.authority && (e += "//" + this.authority), e += this.path, this.query && (e += "?" + this.query), this.fragment && (e += "#" + this.fragment), e;
  }
  getQuery() {
    const e = {};
    if (this.query) {
      const t = decodeURIComponent(this.query).split("&");
      for (const s of t) {
        const i = s.split("=");
        e[i[0]] = i[1];
      }
    }
    return e;
  }
  setQuery(e) {
    let t = "";
    for (const s in e)
      e.hasOwnProperty(s) && (t !== "" && (t += "&"), t += encodeURIComponent(s) + "=" + encodeURIComponent(e[s]));
    this.query = t;
  }
}
const g0 = 0, pu = 1, vf = 2, y0 = 3, Sf = 4, x0 = 5, U = {
  DEG_TO_RAD: Math.PI / 180,
  RAD_TO_DEG: 180 / Math.PI,
  clamp: function(r, e, t) {
    return r >= t ? t : r <= e ? e : r;
  },
  intToBytes24: function(r) {
    const e = r >> 16 & 255, t = r >> 8 & 255, s = r & 255;
    return [e, t, s];
  },
  intToBytes32: function(r) {
    const e = r >> 24 & 255, t = r >> 16 & 255, s = r >> 8 & 255, i = r & 255;
    return [e, t, s, i];
  },
  bytesToInt24: function(r, e, t) {
    return r.length && (t = r[2], e = r[1], r = r[0]), r << 16 | e << 8 | t;
  },
  bytesToInt32: function(r, e, t, s) {
    return r.length && (s = r[3], t = r[2], e = r[1], r = r[0]), (r << 24 | e << 16 | t << 8 | s) >>> 0;
  },
  lerp: function(r, e, t) {
    return r + (e - r) * U.clamp(t, 0, 1);
  },
  lerpAngle: function(r, e, t) {
    return e - r > 180 && (e -= 360), e - r < -180 && (e += 360), U.lerp(r, e, U.clamp(t, 0, 1));
  },
  powerOfTwo: function(r) {
    return r !== 0 && !(r & r - 1);
  },
  nextPowerOfTwo: function(r) {
    return r--, r |= r >> 1, r |= r >> 2, r |= r >> 4, r |= r >> 8, r |= r >> 16, r++, r;
  },
  nearestPowerOfTwo: function(r) {
    return Math.pow(2, Math.round(Math.log(r) / Math.log(2)));
  },
  random: function(r, e) {
    const t = e - r;
    return Math.random() * t + r;
  },
  smoothstep: function(r, e, t) {
    return t <= r ? 0 : t >= e ? 1 : (t = (t - r) / (e - r), t * t * (3 - 2 * t));
  },
  smootherstep: function(r, e, t) {
    return t <= r ? 0 : t >= e ? 1 : (t = (t - r) / (e - r), t * t * t * (t * (t * 6 - 15) + 10));
  },
  roundUp: function(r, e) {
    return e === 0 ? r : Math.ceil(r / e) * e;
  },
  between: function(r, e, t, s) {
    const i = Math.min(e, t), n = Math.max(e, t);
    return s ? r >= i && r <= n : r > i && r < n;
  }
};
class z {
  constructor(e = 0, t = 0, s = 0, i = 1) {
    this.r = void 0, this.g = void 0, this.b = void 0, this.a = void 0;
    const n = e.length;
    n === 3 || n === 4 ? (this.r = e[0], this.g = e[1], this.b = e[2], this.a = e[3] !== void 0 ? e[3] : 1) : (this.r = e, this.g = t, this.b = s, this.a = i);
  }
  clone() {
    const e = this.constructor;
    return new e(this.r, this.g, this.b, this.a);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  set(e, t, s, i = 1) {
    return this.r = e, this.g = t, this.b = s, this.a = i, this;
  }
  lerp(e, t, s) {
    return this.r = e.r + s * (t.r - e.r), this.g = e.g + s * (t.g - e.g), this.b = e.b + s * (t.b - e.b), this.a = e.a + s * (t.a - e.a), this;
  }
  fromString(e) {
    const t = parseInt(e.replace("#", "0x"), 16);
    let s;
    return e.length > 7 ? s = U.intToBytes32(t) : (s = U.intToBytes24(t), s[3] = 255), this.set(s[0] / 255, s[1] / 255, s[2] / 255, s[3] / 255), this;
  }
  toString(e) {
    let t = "#" + (16777216 + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1);
    if (e === !0) {
      const s = Math.round(this.a * 255).toString(16);
      this.a < 16 / 255 ? t += "0" + s : t += s;
    }
    return t;
  }
}
z.BLACK = Object.freeze(new z(0, 0, 0, 1));
z.BLUE = Object.freeze(new z(0, 0, 1, 1));
z.CYAN = Object.freeze(new z(0, 1, 1, 1));
z.GRAY = Object.freeze(new z(0.5, 0.5, 0.5, 1));
z.GREEN = Object.freeze(new z(0, 1, 0, 1));
z.MAGENTA = Object.freeze(new z(1, 0, 1, 1));
z.RED = Object.freeze(new z(1, 0, 0, 1));
z.WHITE = Object.freeze(new z(1, 1, 1, 1));
z.YELLOW = Object.freeze(new z(1, 1, 0, 1));
class g_ {
  constructor(e, t = 0) {
    this._curve = void 0, this._left = -1 / 0, this._right = 1 / 0, this._recip = 0, this._p0 = 0, this._p1 = 0, this._m0 = 0, this._m1 = 0, this._curve = e, this._reset(t);
  }
  evaluate(e, t = !1) {
    (t || e < this._left || e >= this._right) && this._reset(e);
    let s;
    const i = this._curve.type;
    if (i === x0)
      s = this._p0;
    else {
      const n = this._recip === 0 ? 0 : (e - this._left) * this._recip;
      i === g0 ? s = U.lerp(this._p0, this._p1, n) : i === pu ? s = U.lerp(this._p0, this._p1, n * n * (3 - 2 * n)) : s = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, n);
    }
    return s;
  }
  _reset(e) {
    const t = this._curve.keys, s = t.length;
    if (!s)
      this._left = -1 / 0, this._right = 1 / 0, this._recip = 0, this._p0 = this._p1 = this._m0 = this._m1 = 0;
    else if (e < t[0][0])
      this._left = -1 / 0, this._right = t[0][0], this._recip = 0, this._p0 = this._p1 = t[0][1], this._m0 = this._m1 = 0;
    else if (e >= t[s - 1][0])
      this._left = t[s - 1][0], this._right = 1 / 0, this._recip = 0, this._p0 = this._p1 = t[s - 1][1], this._m0 = this._m1 = 0;
    else {
      let i = 0;
      for (; e >= t[i + 1][0]; )
        i++;
      this._left = t[i][0], this._right = t[i + 1][0];
      const n = 1 / (this._right - this._left);
      this._recip = isFinite(n) ? n : 0, this._p0 = t[i][1], this._p1 = t[i + 1][1], this._isHermite() && this._calcTangents(t, i);
    }
  }
  _isHermite() {
    return this._curve.type === vf || this._curve.type === y0 || this._curve.type === Sf;
  }
  _calcTangents(e, t) {
    let s;
    const i = e[t], n = e[t + 1];
    let a;
    if (t === 0 ? s = [e[0][0] + (e[0][0] - e[1][0]), e[0][1] + (e[0][1] - e[1][1])] : s = e[t - 1], t === e.length - 2 ? a = [e[t + 1][0] + (e[t + 1][0] - e[t][0]), e[t + 1][1] + (e[t + 1][1] - e[t][1])] : a = e[t + 2], this._curve.type === Sf) {
      const o = 2 * (n[0] - i[0]) / (n[0] - s[0]), h = 2 * (n[0] - i[0]) / (a[0] - i[0]);
      this._m0 = this._curve.tension * (isFinite(o) ? o : 0) * (n[1] - s[1]), this._m1 = this._curve.tension * (isFinite(h) ? h : 0) * (a[1] - i[1]);
    } else {
      const o = (n[0] - i[0]) / (i[0] - s[0]), h = (n[0] - i[0]) / (a[0] - n[0]), l = i[1] + (s[1] - i[1]) * (isFinite(o) ? o : 0), c = n[1] + (a[1] - n[1]) * (isFinite(h) ? h : 0), d = this._curve.type === vf ? 0.5 : this._curve.tension;
      this._m0 = d * (n[1] - l), this._m1 = d * (c - i[1]);
    }
  }
  _evaluateHermite(e, t, s, i, n) {
    const a = n * n, o = n + n, h = 1 - n, l = h * h;
    return e * ((1 + o) * l) + s * (n * l) + t * (a * (3 - o)) + i * (a * (n - 1));
  }
}
class ms {
  constructor(e) {
    if (this.keys = [], this.type = pu, this.tension = 0.5, this._eval = new g_(this), e)
      for (let t = 0; t < e.length - 1; t += 2)
        this.keys.push([e[t], e[t + 1]]);
    this.sort();
  }
  get length() {
    return this.keys.length;
  }
  add(e, t) {
    const s = this.keys, i = s.length;
    let n = 0;
    for (; n < i && !(s[n][0] > e); n++)
      ;
    const a = [e, t];
    return this.keys.splice(n, 0, a), a;
  }
  get(e) {
    return this.keys[e];
  }
  sort() {
    this.keys.sort(function(e, t) {
      return e[0] - t[0];
    });
  }
  value(e) {
    return this._eval.evaluate(e, !0);
  }
  closest(e) {
    const t = this.keys, s = t.length;
    let i = 2, n = null;
    for (let a = 0; a < s; a++) {
      const o = Math.abs(e - t[a][0]);
      if (i >= o)
        i = o, n = t[a];
      else
        break;
    }
    return n;
  }
  clone() {
    const e = new this.constructor();
    return e.keys = Hi(e.keys, this.keys), e.type = this.type, e.tension = this.tension, e;
  }
  quantize(e) {
    e = Math.max(e, 2);
    const t = new Float32Array(e), s = 1 / (e - 1);
    t[0] = this._eval.evaluate(0, !0);
    for (let i = 1; i < e; i++)
      t[i] = this._eval.evaluate(s * i);
    return t;
  }
  quantizeClamped(e, t, s) {
    const i = this.quantize(e);
    for (let n = 0; n < i.length; ++n)
      i[n] = Math.min(s, Math.max(t, i[n]));
    return i;
  }
}
class Wi {
  constructor() {
    if (this.curves = [], this._type = pu, arguments.length > 1)
      for (let e = 0; e < arguments.length; e++)
        this.curves.push(new ms(arguments[e]));
    else if (arguments.length === 0)
      this.curves.push(new ms());
    else {
      const e = arguments[0];
      if (typeof e == "number")
        for (let t = 0; t < e; t++)
          this.curves.push(new ms());
      else
        for (let t = 0; t < e.length; t++)
          this.curves.push(new ms(e[t]));
    }
  }
  get length() {
    return this.curves.length;
  }
  set type(e) {
    this._type = e;
    for (let t = 0; t < this.curves.length; t++)
      this.curves[t].type = e;
  }
  get type() {
    return this._type;
  }
  get(e) {
    return this.curves[e];
  }
  value(e, t = []) {
    const s = this.curves.length;
    t.length = s;
    for (let i = 0; i < s; i++)
      t[i] = this.curves[i].value(e);
    return t;
  }
  clone() {
    const e = new this.constructor();
    e.curves = [];
    for (let t = 0; t < this.curves.length; t++)
      e.curves.push(this.curves[t].clone());
    return e._type = this._type, e;
  }
  quantize(e) {
    e = Math.max(e, 2);
    const t = this.curves.length, s = new Float32Array(e * t), i = 1 / (e - 1);
    for (let n = 0; n < t; n++) {
      const a = new g_(this.curves[n]);
      for (let o = 0; o < e; o++)
        s[o * t + n] = a.evaluate(i * o);
    }
    return s;
  }
  quantizeClamped(e, t, s) {
    const i = this.quantize(e);
    for (let n = 0; n < i.length; ++n)
      i[n] = Math.min(s, Math.max(t, i[n]));
    return i;
  }
}
class v {
  constructor(e = 0, t = 0, s = 0) {
    this.x = void 0, this.y = void 0, this.z = void 0, e.length === 3 ? (this.x = e[0], this.y = e[1], this.z = e[2]) : (this.x = e, this.y = t, this.z = s);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  add2(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  cross(e, t) {
    const s = e.x, i = e.y, n = e.z, a = t.x, o = t.y, h = t.z;
    return this.x = i * h - o * n, this.y = n * a - h * s, this.z = s * o - a * i, this;
  }
  distance(e) {
    const t = this.x - e.x, s = this.y - e.y, i = this.z - e.z;
    return Math.sqrt(t * t + s * s + i * i);
  }
  div(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  div2(e, t) {
    return this.x = e.x / t.x, this.y = e.y / t.y, this.z = e.z / t.z, this;
  }
  divScalar(e) {
    return this.x /= e, this.y /= e, this.z /= e, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  equals(e) {
    return this.x === e.x && this.y === e.y && this.z === e.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  lerp(e, t, s) {
    return this.x = e.x + s * (t.x - e.x), this.y = e.y + s * (t.y - e.y), this.z = e.z + s * (t.z - e.z), this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  mul2(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  mulScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  normalize() {
    const e = this.x * this.x + this.y * this.y + this.z * this.z;
    if (e > 0) {
      const t = 1 / Math.sqrt(e);
      this.x *= t, this.y *= t, this.z *= t;
    }
    return this;
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  min(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), this;
  }
  max(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), this;
  }
  project(e) {
    const t = this.x * e.x + this.y * e.y + this.z * e.z, s = e.x * e.x + e.y * e.y + e.z * e.z, i = t / s;
    return this.x = e.x * i, this.y = e.y * i, this.z = e.z * i, this;
  }
  set(e, t, s) {
    return this.x = e, this.y = t, this.z = s, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  sub2(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}]`;
  }
}
v.ZERO = Object.freeze(new v(0, 0, 0));
v.ONE = Object.freeze(new v(1, 1, 1));
v.UP = Object.freeze(new v(0, 1, 0));
v.DOWN = Object.freeze(new v(0, -1, 0));
v.RIGHT = Object.freeze(new v(1, 0, 0));
v.LEFT = Object.freeze(new v(-1, 0, 0));
v.FORWARD = Object.freeze(new v(0, 0, -1));
v.BACK = Object.freeze(new v(0, 0, 1));
class is {
  constructor() {
    this.data = new Float32Array(9), this.data[0] = this.data[4] = this.data[8] = 1;
  }
  clone() {
    const e = this.constructor;
    return new e().copy(this);
  }
  copy(e) {
    const t = e.data, s = this.data;
    return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], s[6] = t[6], s[7] = t[7], s[8] = t[8], this;
  }
  set(e) {
    const t = this.data;
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this;
  }
  equals(e) {
    const t = this.data, s = e.data;
    return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8];
  }
  isIdentity() {
    const e = this.data;
    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 1 && e[5] === 0 && e[6] === 0 && e[7] === 0 && e[8] === 1;
  }
  setIdentity() {
    const e = this.data;
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, this;
  }
  toString() {
    return "[" + this.data.join(", ") + "]";
  }
  transpose() {
    const e = this.data;
    let t;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  setFromMat4(e) {
    const t = e.data, s = this.data;
    return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[4], s[4] = t[5], s[5] = t[6], s[6] = t[8], s[7] = t[9], s[8] = t[10], this;
  }
  transformVector(e, t = new v()) {
    const s = this.data, i = e.x, n = e.y, a = e.z;
    return t.x = i * s[0] + n * s[3] + a * s[6], t.y = i * s[1] + n * s[4] + a * s[7], t.z = i * s[2] + n * s[5] + a * s[8], t;
  }
}
is.IDENTITY = Object.freeze(new is());
is.ZERO = Object.freeze(new is().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));
class q {
  constructor(e = 0, t = 0) {
    this.x = void 0, this.y = void 0, e.length === 2 ? (this.x = e[0], this.y = e[1]) : (this.x = e, this.y = t);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  add2(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  distance(e) {
    const t = this.x - e.x, s = this.y - e.y;
    return Math.sqrt(t * t + s * s);
  }
  div(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  div2(e, t) {
    return this.x = e.x / t.x, this.y = e.y / t.y, this;
  }
  divScalar(e) {
    return this.x /= e, this.y /= e, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  equals(e) {
    return this.x === e.x && this.y === e.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  lerp(e, t, s) {
    return this.x = e.x + s * (t.x - e.x), this.y = e.y + s * (t.y - e.y), this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  mul2(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this;
  }
  mulScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  normalize() {
    const e = this.x * this.x + this.y * this.y;
    if (e > 0) {
      const t = 1 / Math.sqrt(e);
      this.x *= t, this.y *= t;
    }
    return this;
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  min(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), this;
  }
  max(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), this;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  sub2(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  toString() {
    return `[${this.x}, ${this.y}]`;
  }
  static angleRad(e, t) {
    return Math.atan2(e.x * t.y - e.y * t.x, e.x * t.x + e.y * t.y);
  }
}
q.ZERO = Object.freeze(new q(0, 0));
q.ONE = Object.freeze(new q(1, 1));
q.UP = Object.freeze(new q(0, 1));
q.DOWN = Object.freeze(new q(0, -1));
q.RIGHT = Object.freeze(new q(1, 0));
q.LEFT = Object.freeze(new q(-1, 0));
class Z {
  constructor(e = 0, t = 0, s = 0, i = 0) {
    this.x = void 0, this.y = void 0, this.z = void 0, this.w = void 0, e.length === 4 ? (this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3]) : (this.x = e, this.y = t, this.z = s, this.w = i);
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  add2(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  div(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  div2(e, t) {
    return this.x = e.x / t.x, this.y = e.y / t.y, this.z = e.z / t.z, this.w = e.w / t.w, this;
  }
  divScalar(e) {
    return this.x /= e, this.y /= e, this.z /= e, this.w /= e, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  equals(e) {
    return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  lerp(e, t, s) {
    return this.x = e.x + s * (t.x - e.x), this.y = e.y + s * (t.y - e.y), this.z = e.z + s * (t.z - e.z), this.w = e.w + s * (t.w - e.w), this;
  }
  mul(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  mul2(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this.w = e.w * t.w, this;
  }
  mulScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  normalize() {
    const e = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    if (e > 0) {
      const t = 1 / Math.sqrt(e);
      this.x *= t, this.y *= t, this.z *= t, this.w *= t;
    }
    return this;
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  min(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this;
  }
  max(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this;
  }
  set(e, t, s, i) {
    return this.x = e, this.y = t, this.z = s, this.w = i, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  sub2(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
  }
}
Z.ZERO = Object.freeze(new Z(0, 0, 0, 0));
Z.ONE = Object.freeze(new Z(1, 1, 1, 1));
const Kr = new q(), en = new v(), Mi = new v(), Ei = new v(), po = new v();
class j {
  constructor() {
    this.data = new Float32Array(16), this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
  }
  static _getPerspectiveHalfSize(e, t, s, i, n) {
    n ? (e.x = i * Math.tan(t * Math.PI / 360), e.y = e.x / s) : (e.y = i * Math.tan(t * Math.PI / 360), e.x = e.y * s);
  }
  add2(e, t) {
    const s = e.data, i = t.data, n = this.data;
    return n[0] = s[0] + i[0], n[1] = s[1] + i[1], n[2] = s[2] + i[2], n[3] = s[3] + i[3], n[4] = s[4] + i[4], n[5] = s[5] + i[5], n[6] = s[6] + i[6], n[7] = s[7] + i[7], n[8] = s[8] + i[8], n[9] = s[9] + i[9], n[10] = s[10] + i[10], n[11] = s[11] + i[11], n[12] = s[12] + i[12], n[13] = s[13] + i[13], n[14] = s[14] + i[14], n[15] = s[15] + i[15], this;
  }
  add(e) {
    return this.add2(this, e);
  }
  clone() {
    const e = this.constructor;
    return new e().copy(this);
  }
  copy(e) {
    const t = e.data, s = this.data;
    return s[0] = t[0], s[1] = t[1], s[2] = t[2], s[3] = t[3], s[4] = t[4], s[5] = t[5], s[6] = t[6], s[7] = t[7], s[8] = t[8], s[9] = t[9], s[10] = t[10], s[11] = t[11], s[12] = t[12], s[13] = t[13], s[14] = t[14], s[15] = t[15], this;
  }
  equals(e) {
    const t = this.data, s = e.data;
    return t[0] === s[0] && t[1] === s[1] && t[2] === s[2] && t[3] === s[3] && t[4] === s[4] && t[5] === s[5] && t[6] === s[6] && t[7] === s[7] && t[8] === s[8] && t[9] === s[9] && t[10] === s[10] && t[11] === s[11] && t[12] === s[12] && t[13] === s[13] && t[14] === s[14] && t[15] === s[15];
  }
  isIdentity() {
    const e = this.data;
    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1;
  }
  mul2(e, t) {
    const s = e.data, i = t.data, n = this.data, a = s[0], o = s[1], h = s[2], l = s[3], c = s[4], d = s[5], u = s[6], f = s[7], m = s[8], _ = s[9], p = s[10], g = s[11], b = s[12], x = s[13], y = s[14], S = s[15];
    let C, w, M, T;
    return C = i[0], w = i[1], M = i[2], T = i[3], n[0] = a * C + c * w + m * M + b * T, n[1] = o * C + d * w + _ * M + x * T, n[2] = h * C + u * w + p * M + y * T, n[3] = l * C + f * w + g * M + S * T, C = i[4], w = i[5], M = i[6], T = i[7], n[4] = a * C + c * w + m * M + b * T, n[5] = o * C + d * w + _ * M + x * T, n[6] = h * C + u * w + p * M + y * T, n[7] = l * C + f * w + g * M + S * T, C = i[8], w = i[9], M = i[10], T = i[11], n[8] = a * C + c * w + m * M + b * T, n[9] = o * C + d * w + _ * M + x * T, n[10] = h * C + u * w + p * M + y * T, n[11] = l * C + f * w + g * M + S * T, C = i[12], w = i[13], M = i[14], T = i[15], n[12] = a * C + c * w + m * M + b * T, n[13] = o * C + d * w + _ * M + x * T, n[14] = h * C + u * w + p * M + y * T, n[15] = l * C + f * w + g * M + S * T, this;
  }
  mulAffine2(e, t) {
    const s = e.data, i = t.data, n = this.data, a = s[0], o = s[1], h = s[2], l = s[4], c = s[5], d = s[6], u = s[8], f = s[9], m = s[10], _ = s[12], p = s[13], g = s[14];
    let b, x, y;
    return b = i[0], x = i[1], y = i[2], n[0] = a * b + l * x + u * y, n[1] = o * b + c * x + f * y, n[2] = h * b + d * x + m * y, n[3] = 0, b = i[4], x = i[5], y = i[6], n[4] = a * b + l * x + u * y, n[5] = o * b + c * x + f * y, n[6] = h * b + d * x + m * y, n[7] = 0, b = i[8], x = i[9], y = i[10], n[8] = a * b + l * x + u * y, n[9] = o * b + c * x + f * y, n[10] = h * b + d * x + m * y, n[11] = 0, b = i[12], x = i[13], y = i[14], n[12] = a * b + l * x + u * y + _, n[13] = o * b + c * x + f * y + p, n[14] = h * b + d * x + m * y + g, n[15] = 1, this;
  }
  mul(e) {
    return this.mul2(this, e);
  }
  transformPoint(e, t = new v()) {
    const s = this.data, i = e.x, n = e.y, a = e.z;
    return t.x = i * s[0] + n * s[4] + a * s[8] + s[12], t.y = i * s[1] + n * s[5] + a * s[9] + s[13], t.z = i * s[2] + n * s[6] + a * s[10] + s[14], t;
  }
  transformVector(e, t = new v()) {
    const s = this.data, i = e.x, n = e.y, a = e.z;
    return t.x = i * s[0] + n * s[4] + a * s[8], t.y = i * s[1] + n * s[5] + a * s[9], t.z = i * s[2] + n * s[6] + a * s[10], t;
  }
  transformVec4(e, t = new Z()) {
    const s = this.data, i = e.x, n = e.y, a = e.z, o = e.w;
    return t.x = i * s[0] + n * s[4] + a * s[8] + o * s[12], t.y = i * s[1] + n * s[5] + a * s[9] + o * s[13], t.z = i * s[2] + n * s[6] + a * s[10] + o * s[14], t.w = i * s[3] + n * s[7] + a * s[11] + o * s[15], t;
  }
  setLookAt(e, t, s) {
    Ei.sub2(e, t).normalize(), Mi.copy(s).normalize(), en.cross(Mi, Ei).normalize(), Mi.cross(Ei, en);
    const i = this.data;
    return i[0] = en.x, i[1] = en.y, i[2] = en.z, i[3] = 0, i[4] = Mi.x, i[5] = Mi.y, i[6] = Mi.z, i[7] = 0, i[8] = Ei.x, i[9] = Ei.y, i[10] = Ei.z, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  setFrustum(e, t, s, i, n, a) {
    const o = 2 * n, h = t - e, l = i - s, c = a - n, d = this.data;
    return d[0] = o / h, d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = o / l, d[6] = 0, d[7] = 0, d[8] = (t + e) / h, d[9] = (i + s) / l, d[10] = (-a - n) / c, d[11] = -1, d[12] = 0, d[13] = 0, d[14] = -o * a / c, d[15] = 0, this;
  }
  setPerspective(e, t, s, i, n) {
    return j._getPerspectiveHalfSize(Kr, e, t, s, n), this.setFrustum(-Kr.x, Kr.x, -Kr.y, Kr.y, s, i);
  }
  setOrtho(e, t, s, i, n, a) {
    const o = this.data;
    return o[0] = 2 / (t - e), o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 / (i - s), o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = -2 / (a - n), o[11] = 0, o[12] = -(t + e) / (t - e), o[13] = -(i + s) / (i - s), o[14] = -(a + n) / (a - n), o[15] = 1, this;
  }
  setFromAxisAngle(e, t) {
    t *= U.DEG_TO_RAD;
    const s = e.x, i = e.y, n = e.z, a = Math.cos(t), o = Math.sin(t), h = 1 - a, l = h * s, c = h * i, d = this.data;
    return d[0] = l * s + a, d[1] = l * i + o * n, d[2] = l * n - o * i, d[3] = 0, d[4] = l * i - o * n, d[5] = c * i + a, d[6] = c * n + o * s, d[7] = 0, d[8] = l * n + o * i, d[9] = c * n - s * o, d[10] = h * n * n + a, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, this;
  }
  setTranslate(e, t, s) {
    const i = this.data;
    return i[0] = 1, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = 1, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = 1, i[11] = 0, i[12] = e, i[13] = t, i[14] = s, i[15] = 1, this;
  }
  setScale(e, t, s) {
    const i = this.data;
    return i[0] = e, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = t, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = s, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this;
  }
  setViewport(e, t, s, i) {
    const n = this.data;
    return n[0] = s * 0.5, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = i * 0.5, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 0.5, n[11] = 0, n[12] = e + s * 0.5, n[13] = t + i * 0.5, n[14] = 0.5, n[15] = 1, this;
  }
  invert() {
    const e = this.data, t = e[0], s = e[1], i = e[2], n = e[3], a = e[4], o = e[5], h = e[6], l = e[7], c = e[8], d = e[9], u = e[10], f = e[11], m = e[12], _ = e[13], p = e[14], g = e[15], b = t * o - s * a, x = t * h - i * a, y = t * l - n * a, S = s * h - i * o, C = s * l - n * o, w = i * l - n * h, M = c * _ - d * m, T = c * p - u * m, A = c * g - f * m, L = d * p - u * _, O = d * g - f * _, I = u * g - f * p, D = b * I - x * O + y * L + S * A - C * T + w * M;
    if (D === 0)
      this.setIdentity();
    else {
      const G = 1 / D;
      e[0] = (o * I - h * O + l * L) * G, e[1] = (-s * I + i * O - n * L) * G, e[2] = (_ * w - p * C + g * S) * G, e[3] = (-d * w + u * C - f * S) * G, e[4] = (-a * I + h * A - l * T) * G, e[5] = (t * I - i * A + n * T) * G, e[6] = (-m * w + p * y - g * x) * G, e[7] = (c * w - u * y + f * x) * G, e[8] = (a * O - o * A + l * M) * G, e[9] = (-t * O + s * A - n * M) * G, e[10] = (m * C - _ * y + g * b) * G, e[11] = (-c * C + d * y - f * b) * G, e[12] = (-a * L + o * T - h * M) * G, e[13] = (t * L - s * T + i * M) * G, e[14] = (-m * S + _ * x - p * b) * G, e[15] = (c * S - d * x + u * b) * G;
    }
    return this;
  }
  set(e) {
    const t = this.data;
    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this;
  }
  setIdentity() {
    const e = this.data;
    return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  setTRS(e, t, s) {
    const i = t.x, n = t.y, a = t.z, o = t.w, h = s.x, l = s.y, c = s.z, d = i + i, u = n + n, f = a + a, m = i * d, _ = i * u, p = i * f, g = n * u, b = n * f, x = a * f, y = o * d, S = o * u, C = o * f, w = this.data;
    return w[0] = (1 - (g + x)) * h, w[1] = (_ + C) * h, w[2] = (p - S) * h, w[3] = 0, w[4] = (_ - C) * l, w[5] = (1 - (m + x)) * l, w[6] = (b + y) * l, w[7] = 0, w[8] = (p + S) * c, w[9] = (b - y) * c, w[10] = (1 - (m + g)) * c, w[11] = 0, w[12] = e.x, w[13] = e.y, w[14] = e.z, w[15] = 1, this;
  }
  transpose() {
    let e;
    const t = this.data;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  invertTo3x3(e) {
    const t = this.data, s = e.data, i = t[0], n = t[1], a = t[2], o = t[4], h = t[5], l = t[6], c = t[8], d = t[9], u = t[10], f = u * h - l * d, m = -u * n + a * d, _ = l * n - a * h, p = -u * o + l * c, g = u * i - a * c, b = -l * i + a * o, x = d * o - h * c, y = -d * i + n * c, S = h * i - n * o, C = i * f + n * p + a * x;
    if (C === 0)
      return this;
    const w = 1 / C;
    return s[0] = w * f, s[1] = w * m, s[2] = w * _, s[3] = w * p, s[4] = w * g, s[5] = w * b, s[6] = w * x, s[7] = w * y, s[8] = w * S, this;
  }
  getTranslation(e = new v()) {
    return e.set(this.data[12], this.data[13], this.data[14]);
  }
  getX(e = new v()) {
    return e.set(this.data[0], this.data[1], this.data[2]);
  }
  getY(e = new v()) {
    return e.set(this.data[4], this.data[5], this.data[6]);
  }
  getZ(e = new v()) {
    return e.set(this.data[8], this.data[9], this.data[10]);
  }
  getScale(e = new v()) {
    return this.getX(en), this.getY(Mi), this.getZ(Ei), e.set(en.length(), Mi.length(), Ei.length()), e;
  }
  setFromEulerAngles(e, t, s) {
    e *= U.DEG_TO_RAD, t *= U.DEG_TO_RAD, s *= U.DEG_TO_RAD;
    const i = Math.sin(-e), n = Math.cos(-e), a = Math.sin(-t), o = Math.cos(-t), h = Math.sin(-s), l = Math.cos(-s), c = this.data;
    return c[0] = o * l, c[1] = -o * h, c[2] = a, c[3] = 0, c[4] = n * h + l * i * a, c[5] = n * l - i * a * h, c[6] = -o * i, c[7] = 0, c[8] = i * h - n * l * a, c[9] = l * i + n * a * h, c[10] = n * o, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, this;
  }
  getEulerAngles(e = new v()) {
    this.getScale(po);
    const t = po.x, s = po.y, i = po.z;
    if (t === 0 || s === 0 || i === 0)
      return e.set(0, 0, 0);
    const n = this.data, a = Math.asin(-n[2] / t), o = Math.PI * 0.5;
    let h, l;
    return a < o ? a > -o ? (h = Math.atan2(n[6] / s, n[10] / i), l = Math.atan2(n[1] / t, n[0] / t)) : (l = 0, h = -Math.atan2(n[4] / s, n[5] / s)) : (l = 0, h = Math.atan2(n[4] / s, n[5] / s)), e.set(h, a, l).mulScalar(U.RAD_TO_DEG);
  }
  toString() {
    return "[" + this.data.join(", ") + "]";
  }
}
j.IDENTITY = Object.freeze(new j());
j.ZERO = Object.freeze(new j().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
class ee {
  constructor(e = 0, t = 0, s = 0, i = 1) {
    this.x = void 0, this.y = void 0, this.z = void 0, this.w = void 0, e.length === 4 ? (this.x = e[0], this.y = e[1], this.z = e[2], this.w = e[3]) : (this.x = e, this.y = t, this.z = s, this.w = i);
  }
  clone() {
    const e = this.constructor;
    return new e(this.x, this.y, this.z, this.w);
  }
  conjugate() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  equals(e) {
    return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
  }
  getAxisAngle(e) {
    let t = Math.acos(this.w) * 2;
    const s = Math.sin(t / 2);
    return s !== 0 ? (e.x = this.x / s, e.y = this.y / s, e.z = this.z / s, (e.x < 0 || e.y < 0 || e.z < 0) && (e.x *= -1, e.y *= -1, e.z *= -1, t *= -1)) : (e.x = 1, e.y = 0, e.z = 0), t * U.RAD_TO_DEG;
  }
  getEulerAngles(e = new v()) {
    let t, s, i;
    const n = this.x, a = this.y, o = this.z, h = this.w, l = 2 * (h * a - n * o);
    return l <= -0.99999 ? (t = 2 * Math.atan2(n, h), s = -Math.PI / 2, i = 0) : l >= 0.99999 ? (t = 2 * Math.atan2(n, h), s = Math.PI / 2, i = 0) : (t = Math.atan2(2 * (h * n + a * o), 1 - 2 * (n * n + a * a)), s = Math.asin(l), i = Math.atan2(2 * (h * o + n * a), 1 - 2 * (a * a + o * o))), e.set(t, s, i).mulScalar(U.RAD_TO_DEG);
  }
  invert() {
    return this.conjugate().normalize();
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  mul(e) {
    const t = this.x, s = this.y, i = this.z, n = this.w, a = e.x, o = e.y, h = e.z, l = e.w;
    return this.x = n * a + t * l + s * h - i * o, this.y = n * o + s * l + i * a - t * h, this.z = n * h + i * l + t * o - s * a, this.w = n * l - t * a - s * o - i * h, this;
  }
  mul2(e, t) {
    const s = e.x, i = e.y, n = e.z, a = e.w, o = t.x, h = t.y, l = t.z, c = t.w;
    return this.x = a * o + s * c + i * l - n * h, this.y = a * h + i * c + n * o - s * l, this.z = a * l + n * c + s * h - i * o, this.w = a * c - s * o - i * h - n * l, this;
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this.x = this.y = this.z = 0, this.w = 1) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  set(e, t, s, i) {
    return this.x = e, this.y = t, this.z = s, this.w = i, this;
  }
  setFromAxisAngle(e, t) {
    t *= 0.5 * U.DEG_TO_RAD;
    const s = Math.sin(t), i = Math.cos(t);
    return this.x = s * e.x, this.y = s * e.y, this.z = s * e.z, this.w = i, this;
  }
  setFromEulerAngles(e, t, s) {
    if (e instanceof v) {
      const d = e;
      e = d.x, t = d.y, s = d.z;
    }
    const i = 0.5 * U.DEG_TO_RAD;
    e *= i, t *= i, s *= i;
    const n = Math.sin(e), a = Math.cos(e), o = Math.sin(t), h = Math.cos(t), l = Math.sin(s), c = Math.cos(s);
    return this.x = n * h * c - a * o * l, this.y = a * o * c + n * h * l, this.z = a * h * l - n * o * c, this.w = a * h * c + n * o * l, this;
  }
  setFromMat4(e) {
    let t, s, i, n, a, o, h, l, c, d, u, f, m, _;
    if (e = e.data, t = e[0], s = e[1], i = e[2], n = e[4], a = e[5], o = e[6], h = e[8], l = e[9], c = e[10], f = t * t + s * s + i * i, f === 0)
      return this;
    if (f = 1 / Math.sqrt(f), m = n * n + a * a + o * o, m === 0)
      return this;
    if (m = 1 / Math.sqrt(m), _ = h * h + l * l + c * c, _ === 0)
      return this;
    _ = 1 / Math.sqrt(_), t *= f, s *= f, i *= f, n *= m, a *= m, o *= m, h *= _, l *= _, c *= _;
    const p = t + a + c;
    return p >= 0 ? (d = Math.sqrt(p + 1), this.w = d * 0.5, d = 0.5 / d, this.x = (o - l) * d, this.y = (h - i) * d, this.z = (s - n) * d) : t > a ? t > c ? (u = t - (a + c) + 1, u = Math.sqrt(u), this.x = u * 0.5, u = 0.5 / u, this.w = (o - l) * u, this.y = (s + n) * u, this.z = (i + h) * u) : (u = c - (t + a) + 1, u = Math.sqrt(u), this.z = u * 0.5, u = 0.5 / u, this.w = (s - n) * u, this.x = (h + i) * u, this.y = (l + o) * u) : a > c ? (u = a - (c + t) + 1, u = Math.sqrt(u), this.y = u * 0.5, u = 0.5 / u, this.w = (h - i) * u, this.z = (o + l) * u, this.x = (n + s) * u) : (u = c - (t + a) + 1, u = Math.sqrt(u), this.z = u * 0.5, u = 0.5 / u, this.w = (s - n) * u, this.x = (h + i) * u, this.y = (l + o) * u), this;
  }
  slerp(e, t, s) {
    const i = e.x, n = e.y, a = e.z, o = e.w;
    let h = t.x, l = t.y, c = t.z, d = t.w, u = o * d + i * h + n * l + a * c;
    if (u < 0 && (d = -d, h = -h, l = -l, c = -c, u = -u), Math.abs(u) >= 1)
      return this.w = o, this.x = i, this.y = n, this.z = a, this;
    const f = Math.acos(u), m = Math.sqrt(1 - u * u);
    if (Math.abs(m) < 1e-3)
      return this.w = o * 0.5 + d * 0.5, this.x = i * 0.5 + h * 0.5, this.y = n * 0.5 + l * 0.5, this.z = a * 0.5 + c * 0.5, this;
    const _ = Math.sin((1 - s) * f) / m, p = Math.sin(s * f) / m;
    return this.w = o * _ + d * p, this.x = i * _ + h * p, this.y = n * _ + l * p, this.z = a * _ + c * p, this;
  }
  transformVector(e, t = new v()) {
    const s = e.x, i = e.y, n = e.z, a = this.x, o = this.y, h = this.z, l = this.w, c = l * s + o * n - h * i, d = l * i + h * s - a * n, u = l * n + a * i - o * s, f = -a * s - o * i - h * n;
    return t.x = c * l + f * -a + d * -h - u * -o, t.y = d * l + f * -o + u * -a - c * -h, t.z = u * l + f * -h + c * -o - d * -a, t;
  }
  toString() {
    return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
  }
}
ee.IDENTITY = Object.freeze(new ee(0, 0, 0, 1));
ee.ZERO = Object.freeze(new ee(0, 0, 0, 0));
const Wn = new v(), qn = new v(), bf = new v(), wf = new v(), v0 = new v();
class Pe {
  constructor(e = new v(), t = new v(0.5, 0.5, 0.5)) {
    this.center = void 0, this.halfExtents = void 0, this._min = new v(), this._max = new v(), this.center = e, this.halfExtents = t;
  }
  add(e) {
    const t = this.center, s = t.x, i = t.y, n = t.z, a = this.halfExtents, o = a.x, h = a.y, l = a.z;
    let c = s - o, d = s + o, u = i - h, f = i + h, m = n - l, _ = n + l;
    const p = e.center, g = p.x, b = p.y, x = p.z, y = e.halfExtents, S = y.x, C = y.y, w = y.z, M = g - S, T = g + S, A = b - C, L = b + C, O = x - w, I = x + w;
    M < c && (c = M), T > d && (d = T), A < u && (u = A), L > f && (f = L), O < m && (m = O), I > _ && (_ = I), t.x = (c + d) * 0.5, t.y = (u + f) * 0.5, t.z = (m + _) * 0.5, a.x = (d - c) * 0.5, a.y = (f - u) * 0.5, a.z = (_ - m) * 0.5;
  }
  copy(e) {
    this.center.copy(e.center), this.halfExtents.copy(e.halfExtents);
  }
  clone() {
    return new Pe(this.center.clone(), this.halfExtents.clone());
  }
  intersects(e) {
    const t = this.getMax(), s = this.getMin(), i = e.getMax(), n = e.getMin();
    return s.x <= i.x && t.x >= n.x && s.y <= i.y && t.y >= n.y && s.z <= i.z && t.z >= n.z;
  }
  _intersectsRay(e, t) {
    const s = Wn.copy(this.getMin()).sub(e.origin), i = qn.copy(this.getMax()).sub(e.origin), n = e.direction;
    n.x === 0 ? (s.x = s.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, i.x = i.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.x /= n.x, i.x /= n.x), n.y === 0 ? (s.y = s.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, i.y = i.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.y /= n.y, i.y /= n.y), n.z === 0 ? (s.z = s.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE, i.z = i.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE) : (s.z /= n.z, i.z /= n.z);
    const a = bf.set(Math.min(s.x, i.x), Math.min(s.y, i.y), Math.min(s.z, i.z)), o = wf.set(Math.max(s.x, i.x), Math.max(s.y, i.y), Math.max(s.z, i.z)), h = Math.min(Math.min(o.x, o.y), o.z), l = Math.max(Math.max(a.x, a.y), a.z), c = h >= l && l >= 0;
    return c && t.copy(e.direction).mulScalar(l).add(e.origin), c;
  }
  _fastIntersectsRay(e) {
    const t = Wn, s = qn, i = bf, n = wf, a = v0, o = e.direction;
    return t.sub2(e.origin, this.center), n.set(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)), i.mul2(t, o), !(n.x > this.halfExtents.x && i.x >= 0 || n.y > this.halfExtents.y && i.y >= 0 || n.z > this.halfExtents.z && i.z >= 0 || (a.set(Math.abs(o.x), Math.abs(o.y), Math.abs(o.z)), s.cross(o, t), s.set(Math.abs(s.x), Math.abs(s.y), Math.abs(s.z)), s.x > this.halfExtents.y * a.z + this.halfExtents.z * a.y) || s.y > this.halfExtents.x * a.z + this.halfExtents.z * a.x || s.z > this.halfExtents.x * a.y + this.halfExtents.y * a.x);
  }
  intersectsRay(e, t) {
    return t ? this._intersectsRay(e, t) : this._fastIntersectsRay(e);
  }
  setMinMax(e, t) {
    this.center.add2(t, e).mulScalar(0.5), this.halfExtents.sub2(t, e).mulScalar(0.5);
  }
  getMin() {
    return this._min.copy(this.center).sub(this.halfExtents);
  }
  getMax() {
    return this._max.copy(this.center).add(this.halfExtents);
  }
  containsPoint(e) {
    const t = this.getMin(), s = this.getMax();
    return !(e.x < t.x || e.x > s.x || e.y < t.y || e.y > s.y || e.z < t.z || e.z > s.z);
  }
  setFromTransformedAabb(e, t, s = !1) {
    const i = e.center, n = e.halfExtents, a = t.data;
    let o = a[0], h = a[4], l = a[8], c = a[1], d = a[5], u = a[9], f = a[2], m = a[6], _ = a[10];
    if (s) {
      let p = o * o + h * h + l * l;
      if (p > 0) {
        const g = 1 / Math.sqrt(p);
        o *= g, h *= g, l *= g;
      }
      if (p = c * c + d * d + u * u, p > 0) {
        const g = 1 / Math.sqrt(p);
        c *= g, d *= g, u *= g;
      }
      if (p = f * f + m * m + _ * _, p > 0) {
        const g = 1 / Math.sqrt(p);
        f *= g, m *= g, _ *= g;
      }
    }
    this.center.set(a[12] + o * i.x + h * i.y + l * i.z, a[13] + c * i.x + d * i.y + u * i.z, a[14] + f * i.x + m * i.y + _ * i.z), this.halfExtents.set(Math.abs(o) * n.x + Math.abs(h) * n.y + Math.abs(l) * n.z, Math.abs(c) * n.x + Math.abs(d) * n.y + Math.abs(u) * n.z, Math.abs(f) * n.x + Math.abs(m) * n.y + Math.abs(_) * n.z);
  }
  static computeMinMax(e, t, s, i = e.length / 3) {
    if (i > 0) {
      t.set(e[0], e[1], e[2]), s.set(e[0], e[1], e[2]);
      for (let n = 1; n < i; n++) {
        const a = e[n * 3 + 0], o = e[n * 3 + 1], h = e[n * 3 + 2];
        a < t.x && (t.x = a), o < t.y && (t.y = o), h < t.z && (t.z = h), a > s.x && (s.x = a), o > s.y && (s.y = o), h > s.z && (s.z = h);
      }
    }
  }
  compute(e, t) {
    Pe.computeMinMax(e, Wn, qn, t), this.setMinMax(Wn, qn);
  }
  intersectsBoundingSphere(e) {
    return this._distanceToBoundingSphereSq(e) <= e.radius * e.radius;
  }
  _distanceToBoundingSphereSq(e) {
    const t = this.getMin(), s = this.getMax();
    let i = 0;
    const n = ["x", "y", "z"];
    for (let a = 0; a < 3; ++a) {
      let o = 0;
      const h = e.center[n[a]], l = t[n[a]], c = s[n[a]];
      let d = 0;
      h < l && (d = l - h, o += d * d), h > c && (d = h - c, o += d * d), i += o;
    }
    return i;
  }
  _expand(e, t) {
    Wn.add2(this.getMin(), e), qn.add2(this.getMax(), t), this.setMinMax(Wn, qn);
  }
}
const _o = new v(), S0 = new v();
class pl {
  constructor(e = new v(), t = 0.5) {
    this.center = void 0, this.radius = void 0, this.center = e, this.radius = t;
  }
  containsPoint(e) {
    const t = _o.sub2(e, this.center).lengthSq(), s = this.radius;
    return t < s * s;
  }
  intersectsRay(e, t) {
    const s = _o.copy(e.origin).sub(this.center), i = s.dot(S0.copy(e.direction).normalize()), n = s.dot(s) - this.radius * this.radius;
    if (n > 0 && i > 0)
      return !1;
    const a = i * i - n;
    if (a < 0)
      return !1;
    const o = Math.abs(-i - Math.sqrt(a));
    return t && t.copy(e.direction).mulScalar(o).add(e.origin), !0;
  }
  intersectsBoundingSphere(e) {
    _o.sub2(e.center, this.center);
    const t = e.radius + this.radius;
    return _o.lengthSq() <= t * t;
  }
}
class b0 {
  constructor() {
    this.planes = [];
    for (let e = 0; e < 6; e++)
      this.planes[e] = [];
  }
  setFromMat4(e) {
    const t = e.data;
    let s;
    const i = this.planes;
    s = i[0], s[0] = t[3] - t[0], s[1] = t[7] - t[4], s[2] = t[11] - t[8], s[3] = t[15] - t[12];
    let n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]);
    s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n, s = i[1], s[0] = t[3] + t[0], s[1] = t[7] + t[4], s[2] = t[11] + t[8], s[3] = t[15] + t[12], n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]), s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n, s = i[2], s[0] = t[3] + t[1], s[1] = t[7] + t[5], s[2] = t[11] + t[9], s[3] = t[15] + t[13], n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]), s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n, s = i[3], s[0] = t[3] - t[1], s[1] = t[7] - t[5], s[2] = t[11] - t[9], s[3] = t[15] - t[13], n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]), s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n, s = i[4], s[0] = t[3] - t[2], s[1] = t[7] - t[6], s[2] = t[11] - t[10], s[3] = t[15] - t[14], n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]), s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n, s = i[5], s[0] = t[3] + t[2], s[1] = t[7] + t[6], s[2] = t[11] + t[10], s[3] = t[15] + t[14], n = Math.sqrt(s[0] * s[0] + s[1] * s[1] + s[2] * s[2]), s[0] /= n, s[1] /= n, s[2] /= n, s[3] /= n;
  }
  containsPoint(e) {
    let t, s;
    for (t = 0; t < 6; t++)
      if (s = this.planes[t], s[0] * e.x + s[1] * e.y + s[2] * e.z + s[3] <= 0)
        return !1;
    return !0;
  }
  containsSphere(e) {
    let t = 0, s, i;
    const n = e.radius, a = e.center, o = a.x, h = a.y, l = a.z, c = this.planes;
    let d;
    for (i = 0; i < 6; i++) {
      if (d = c[i], s = d[0] * o + d[1] * h + d[2] * l + d[3], s <= -n)
        return 0;
      s > n && t++;
    }
    return t === 6 ? 2 : 1;
  }
}
class od {
  constructor(e, t) {
    this.origin = new v(), this.direction = v.FORWARD.clone(), e && this.origin.copy(e), t && this.direction.copy(t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.set(e.origin, e.direction);
  }
  clone() {
    return new this.constructor(this.origin, this.direction);
  }
}
const w0 = new v();
class T0 {
  constructor(e, t) {
    this.point = new v(), this.normal = v.BACK.clone(), e && this.point.copy(e), t && this.normal.copy(t);
  }
  set(e, t) {
    return this.point.copy(e), this.normal.copy(t), this;
  }
  intersectsLine(e, t, s) {
    const i = -this.normal.dot(this.point), n = this.normal.dot(e) + i, a = this.normal.dot(t) + i, o = n / (n - a), h = o >= 0 && o <= 1;
    return h && s && s.lerp(e, t, o), h;
  }
  intersectsRay(e, t) {
    const s = w0.sub2(this.point, e.origin), i = this.normal.dot(s) / this.normal.dot(e.direction), n = i >= 0;
    return n && t && t.copy(e.direction).mulScalar(i).add(e.origin), n;
  }
  copy(e) {
    return this.set(e.point, e.normal);
  }
  clone() {
    return new this.constructor(this.point, this.normal);
  }
}
const _l = "linear", gl = "inverse", y_ = "exponential", xt = 0, he = 1, _u = 2, yn = 0, We = 1, Tf = 2, go = 4, Cf = 5, yo = 6, xo = 8, ot = 0, Af = 3, Mf = 4, ns = 0, Na = 1, C0 = 2, A0 = 3, Ca = 1, Aa = 2, Ah = 4, Ft = 0, Br = 1, Mh = 2, x_ = 3, Be = 0, rt = 1, yl = 2, xl = 3, vl = 4, Ln = 5, M0 = 0, gu = 1, Eh = 2, Sl = 3, E0 = 4, R0 = 5, L0 = 6, Mn = 7, v_ = 0, pi = 1, Pn = 2, yu = 0, bl = 1, wl = 2, Tl = 3, xu = 4, Cl = 5, Si = 6, ye = 7, Fr = 8, Rh = 9, In = 10, za = 11, Pt = 12, Ua = 13, vt = 14, S_ = 15, Va = 16, Al = 17, Ml = 18, vu = 19, Su = 20, to = 21, bu = 22, wu = 23, Ga = 24, Ha = 25, El = 26, Rl = 27, b_ = 28, w_ = 29, Tu = 30;
function P0(r) {
  return r >= Fr && r <= In || r >= to && r <= Tu;
}
const so = 0, Ll = 1, T_ = 2, C_ = 3, Es = 4, jr = 5, Dn = 6, et = "POSITION", Gt = "NORMAL", qs = "TANGENT", Xs = "BLENDWEIGHT", ts = "BLENDINDICES", It = "COLOR", Ef = "TEXCOORD", rs = "TEXCOORD0", Zi = "TEXCOORD1", Pl = "TEXCOORD2", Il = "TEXCOORD3", Dl = "TEXCOORD4", Bl = "TEXCOORD5", Fl = "TEXCOORD6", Ol = "TEXCOORD7", I0 = "ATTR", Lh = "ATTR0", hd = "ATTR1", A_ = "ATTR2", M_ = "ATTR3", E_ = "ATTR4", D0 = "ATTR5", B0 = "ATTR6", F0 = "ATTR7", En = "ATTR8", Rn = "ATTR9", ld = "ATTR10", cd = "ATTR11", Ma = "ATTR12", Ea = "ATTR13", Ra = "ATTR14", bn = "ATTR15", O0 = 1, us = 0, k0 = 2, N0 = 3, z0 = 5, U0 = 2, Rs = "default", _i = "rgbm", Cu = "rgbe", R_ = "rgbp", kl = "swizzleGGGR", Au = "2d", V0 = "cube", G0 = "3d", H0 = "float", W0 = "unfilterable-float", q0 = "none", dd = "cube", Rf = "equirect", X0 = "octahedral", Nl = 0, gi = 1, zl = 2, Bn = 3, L_ = 4, P_ = 5, Ie = 6, uh = 0, Ph = 1, Or = 2, kr = 3, Nr = 4, zr = 5, La = 6, Pa = 7, Ia = 8, ud = 9, fd = 10, md = 11, Ih = 12, Dh = 13, Ur = 14, j0 = 15, $0 = 16, Ul = 17, Y0 = 18, K0 = 19, Z0 = 20, Vl = 21, Gl = 22, Mu = 23, J0 = 24, Q0 = ["bool", "int", "float", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bec2", "bec3", "bec4", "mat2", "mat3", "mat4", "sampler2D", "samplerCube", "", "sampler2DShadow", "samplerCubeShadow", "sampler3D", "", "", ""], I_ = "webgl", Et = "webgpu", D_ = 1, pd = 2, B_ = 0, _d = 1, Eu = "default", ex = ["view", "mesh"], Ar = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array], Bh = [1, 1, 2, 2, 4, 4, 4], gd = [Uint8Array, Uint16Array, Uint32Array], tx = [1, 2, 4], ut = [];
ut[yu] = 1;
ut[bl] = 1;
ut[wl] = 2;
ut[Tl] = 2;
ut[xu] = 2;
ut[Cl] = 2;
ut[Si] = 4;
ut[ye] = 4;
ut[za] = 8;
ut[Pt] = 8;
ut[Ua] = 16;
ut[vt] = 16;
ut[S_] = 4;
ut[Va] = 4;
ut[Al] = 4;
ut[Ml] = 4;
ut[vu] = 4;
ut[Su] = 4;
const De = {};
De[et] = 0;
De[Gt] = 1;
De[Xs] = 2;
De[ts] = 3;
De[It] = 4;
De[rs] = 5;
De[Zi] = 6;
De[Pl] = 7;
De[Il] = 8;
De[Dl] = 9;
De[Bl] = 10;
De[Fl] = 11;
De[Ol] = 12;
De[qs] = 13;
De[Lh] = 0;
De[hd] = 1;
De[A_] = 2;
De[M_] = 3;
De[E_] = 4;
De[D0] = 5;
De[B0] = 6;
De[F0] = 7;
De[En] = 8;
De[Rn] = 9;
De[ld] = 10;
De[cd] = 11;
De[Ma] = 12;
De[Ea] = 13;
De[Ra] = 14;
De[bn] = 15;
const sx = "1.55";
class F_ {
  constructor() {
    this.globalId = 0, this.revision = 0;
  }
  equals(e) {
    return this.globalId === e.globalId && this.revision === e.revision;
  }
  copy(e) {
    this.globalId = e.globalId, this.revision = e.revision;
  }
  reset() {
    this.globalId = 0, this.revision = 0;
  }
}
let Lf = 0;
class ix {
  constructor() {
    Lf++, this.version = new F_(), this.version.globalId = Lf;
  }
  increment() {
    this.version.revision++;
  }
}
class nx {
  constructor(e) {
    this.name = e, this.value = null, this.versionObject = new ix();
  }
  toJSON(e) {
  }
  setValue(e) {
    this.value = e, this.versionObject.increment();
  }
  getValue() {
    return this.value;
  }
}
class rx {
  constructor(e) {
    this.name = e, this.variables = /* @__PURE__ */ new Map();
  }
  resolve(e) {
    return this.variables.has(e) || this.variables.set(e, new nx(e)), this.variables.get(e);
  }
  removeValue(e) {
    for (const t in this.variables) {
      const s = this.variables[t];
      s.value === e && (s.value = null);
    }
  }
}
let ax = 0;
class yi {
  constructor(e, t, s, i = ns, n) {
    this.device = e, this.format = t, this.numVertices = s, this.usage = i, this.id = ax++, this.impl = e.createVertexBufferImpl(this, t), this.numBytes = t.verticesByteSize ? t.verticesByteSize : t.size * s, this.adjustVramSizeTracking(e._vram, this.numBytes), n ? this.setData(n) : this.storage = new ArrayBuffer(this.numBytes), this.device.buffers.push(this);
  }
  destroy() {
    const e = this.device, t = e.buffers.indexOf(this);
    t !== -1 && e.buffers.splice(t, 1), this.impl.initialized && (this.impl.destroy(e), this.adjustVramSizeTracking(e._vram, -this.storage.byteLength));
  }
  adjustVramSizeTracking(e, t) {
    e.vb += t;
  }
  loseContext() {
    this.impl.loseContext();
  }
  getFormat() {
    return this.format;
  }
  getUsage() {
    return this.usage;
  }
  getNumVertices() {
    return this.numVertices;
  }
  lock() {
    return this.storage;
  }
  unlock() {
    this.impl.unlock(this);
  }
  setData(e) {
    return e.byteLength !== this.numBytes ? !1 : (this.storage = e, this.unlock(), !0);
  }
}
function Wa(r) {
  let e = 0;
  for (let t = 0, s = r.length; t < s; t++)
    e = (e << 5) - e + r.charCodeAt(t), e |= 0;
  return e;
}
class Ot {
  constructor(e, t, s) {
    this.device = e, this._elements = [], this.hasUv0 = !1, this.hasUv1 = !1, this.hasColor = !1, this.hasTangents = !1, this.verticesByteSize = 0, this.vertexCount = s, this.interleaved = s === void 0, this.instancing = !1, this.size = t.reduce((a, o) => a + Math.ceil(o.components * Bh[o.type] / 4) * 4, 0);
    let i = 0, n;
    for (let a = 0, o = t.length; a < o; a++) {
      const h = t[a];
      n = h.components * Bh[h.type], s && (i = U.roundUp(i, n));
      const l = {
        name: h.semantic,
        offset: s ? i : h.hasOwnProperty("offset") ? h.offset : i,
        stride: s ? n : h.hasOwnProperty("stride") ? h.stride : this.size,
        dataType: h.type,
        numComponents: h.components,
        normalize: h.normalize === void 0 ? !1 : h.normalize,
        size: n
      };
      this._elements.push(l), s ? i += n * s : i += Math.ceil(n / 4) * 4, h.semantic === rs ? this.hasUv0 = !0 : h.semantic === Zi ? this.hasUv1 = !0 : h.semantic === It ? this.hasColor = !0 : h.semantic === qs && (this.hasTangents = !0);
    }
    s && (this.verticesByteSize = i), this._evaluateHash();
  }
  get elements() {
    return this._elements;
  }
  static getDefaultInstancingFormat(e) {
    return Ot._defaultInstancingFormat || (Ot._defaultInstancingFormat = new Ot(e, [{
      semantic: Ma,
      components: 4,
      type: Ie
    }, {
      semantic: Ea,
      components: 4,
      type: Ie
    }, {
      semantic: Ra,
      components: 4,
      type: Ie
    }, {
      semantic: bn,
      components: 4,
      type: Ie
    }])), Ot._defaultInstancingFormat;
  }
  update() {
    this._evaluateHash();
  }
  _evaluateHash() {
    let e;
    const t = [];
    let s;
    const i = [], n = this._elements.length;
    for (let a = 0; a < n; a++) {
      const o = this._elements[a];
      e = o.name, e += o.dataType, e += o.numComponents, e += o.normalize, t.push(e), s = e, s += o.offset, s += o.stride, s += o.size, i.push(s);
    }
    t.sort(), this.batchingHash = Wa(t.join()), this.renderingingHashString = i.join("_"), this.renderingingHash = Wa(this.renderingingHashString);
  }
}
Ot._defaultInstancingFormat = null;
const Pf = "resizecanvas";
class Ru extends _e {
  constructor(e) {
    super(), this.canvas = void 0, this.deviceType = void 0, this.scope = void 0, this.boneLimit = void 0, this.maxAnisotropy = void 0, this.maxCubeMapSize = void 0, this.maxTextureSize = void 0, this.maxVolumeSize = void 0, this.precision = void 0, this.renderTarget = null, this.insideRenderPass = !1, this.supportsInstancing = void 0, this.supportsUniformBuffers = !1, this.textureFloatRenderable = void 0, this.textureHalfFloatRenderable = void 0, this.quadVertexBuffer = void 0, this.canvas = e, this._width = 0, this._height = 0, this._maxPixelRatio = lt.browser ? Math.min(1, window.devicePixelRatio) : 1, this.shaders = [], this.buffers = [], this.textures = [], this.targets = [], this._vram = {
      tex: 0,
      vb: 0,
      ib: 0,
      ub: 0
    }, this._shaderStats = {
      vsCompiled: 0,
      fsCompiled: 0,
      linked: 0,
      materialShaders: 0,
      compileTime: 0
    }, this.initializeContextCaches(), this._drawCallsPerFrame = 0, this._shaderSwitchesPerFrame = 0, this._primsPerFrame = [];
    for (let t = so; t <= Dn; t++)
      this._primsPerFrame[t] = 0;
    this._renderTargetCreationTime = 0, this.scope = new rx("Device"), this.textureBias = this.scope.resolve("textureBias"), this.textureBias.setValue(0);
  }
  postInit() {
    const e = new Ot(this, [{
      semantic: et,
      components: 2,
      type: Ie
    }]), t = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this.quadVertexBuffer = new yi(this, e, 4, ns, t);
  }
  destroy() {
    var e;
    this.fire("destroy"), (e = this.quadVertexBuffer) == null || e.destroy(), this.quadVertexBuffer = null;
  }
  onDestroyShader(e) {
    this.fire("destroy:shader", e);
    const t = this.shaders.indexOf(e);
    t !== -1 && this.shaders.splice(t, 1);
  }
  postDestroy() {
    this.scope = null, this.canvas = null;
  }
  toJSON(e) {
  }
  initializeContextCaches() {
    this.indexBuffer = null, this.vertexBuffers = [], this.shader = null, this.renderTarget = null;
  }
  initializeRenderState() {
    this.vx = this.vy = this.vw = this.vh = 0, this.sx = this.sy = this.sw = this.sh = 0;
  }
  setRenderTarget(e) {
    this.renderTarget = e;
  }
  setIndexBuffer(e) {
    this.indexBuffer = e;
  }
  setVertexBuffer(e) {
    e && this.vertexBuffers.push(e);
  }
  getRenderTarget() {
    return this.renderTarget;
  }
  initRenderTarget(e) {
    e.initialized || (e.init(), this.targets.push(e));
  }
  _isBrowserInterface(e) {
    return this._isImageBrowserInterface(e) || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement;
  }
  _isImageBrowserInterface(e) {
    return typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLImageElement < "u" && e instanceof HTMLImageElement;
  }
  resizeCanvas(e, t) {
    this._width = e, this._height = t;
    const s = Math.min(this._maxPixelRatio, lt.browser ? window.devicePixelRatio : 1);
    e = Math.floor(e * s), t = Math.floor(t * s), (this.canvas.width !== e || this.canvas.height !== t) && (this.canvas.width = e, this.canvas.height = t, this.fire(Pf, e, t));
  }
  setResolution(e, t) {
    this._width = e, this._height = t, this.canvas.width = e, this.canvas.height = t, this.fire(Pf, e, t);
  }
  updateClientRect() {
    this.clientRect = this.canvas.getBoundingClientRect();
  }
  get width() {
    return this.canvas.width;
  }
  get height() {
    return this.canvas.height;
  }
  set fullscreen(e) {
  }
  get fullscreen() {
    return !1;
  }
  set maxPixelRatio(e) {
    this._maxPixelRatio = e, this.resizeCanvas(this._width, this._height);
  }
  get maxPixelRatio() {
    return this._maxPixelRatio;
  }
  getBoneLimit() {
    return this.boneLimit;
  }
  setBoneLimit(e) {
    this.boneLimit = e;
  }
}
const ox = {
  depth: !0,
  face: 0
};
let hx = 0;
class Dt {
  constructor(e) {
    var t, s;
    this.id = hx++;
    const i = arguments[1], n = arguments[2];
    if (e instanceof Ru ? (this._colorBuffer = i, e = n) : this._colorBuffer = e.colorBuffer, this._colorBuffer && (this._colorBuffer._isRenderTarget = !0), e = e !== void 0 ? e : ox, this._depthBuffer = e.depthBuffer, this._face = e.face !== void 0 ? e.face : 0, this._depthBuffer) {
      const l = this._depthBuffer._format;
      l === Va ? (this._depth = !0, this._stencil = !1) : l === Al ? (this._depth = !0, this._stencil = !0) : (this._depth = !1, this._stencil = !1);
    } else
      this._depth = e.depth !== void 0 ? e.depth : !0, this._stencil = e.stencil !== void 0 ? e.stencil : !1;
    const a = ((t = this._colorBuffer) == null ? void 0 : t.device) || ((s = this._depthBuffer) == null ? void 0 : s.device) || e.graphicsDevice;
    if (this._device = a, this._samples = e.samples !== void 0 ? Math.min(e.samples, this._device.maxSamples) : 1, this.autoResolve = e.autoResolve !== void 0 ? e.autoResolve : !0, this.name = e.name, !this.name) {
      var o;
      this.name = (o = this._colorBuffer) == null ? void 0 : o.name;
    }
    if (!this.name) {
      var h;
      this.name = (h = this._depthBuffer) == null ? void 0 : h.name;
    }
    this.name || (this.name = "Untitled"), this.flipY = !!e.flipY, this.impl = a.createRenderTargetImpl(this);
  }
  destroy() {
    const e = this._device;
    if (e) {
      const t = e.targets.indexOf(this);
      t !== -1 && e.targets.splice(t, 1), e.renderTarget === this && e.setRenderTarget(null), this.destroyFrameBuffers();
    }
  }
  destroyFrameBuffers() {
    const e = this._device;
    e && this.impl.destroy(e);
  }
  destroyTextureBuffers() {
    this._depthBuffer && (this._depthBuffer.destroy(), this._depthBuffer = null), this._colorBuffer && (this._colorBuffer.destroy(), this._colorBuffer = null);
  }
  init() {
    this.impl.init(this._device, this);
  }
  get initialized() {
    return this.impl.initialized;
  }
  loseContext() {
    this.impl.loseContext();
  }
  resolve(e = !0, t = !!this._depthBuffer) {
    this._device && this._samples > 1 && this.impl.resolve(this._device, this, e, t);
  }
  copy(e, t, s) {
    if (!this._device)
      if (e._device)
        this._device = e._device;
      else
        return !1;
    return this._device.copyRenderTarget(e, this, t, s);
  }
  get samples() {
    return this._samples;
  }
  get depth() {
    return this._depth;
  }
  get stencil() {
    return this._stencil;
  }
  get colorBuffer() {
    return this._colorBuffer;
  }
  get depthBuffer() {
    return this._depthBuffer;
  }
  get face() {
    return this._face;
  }
  get width() {
    var e, t;
    return ((e = this._colorBuffer) == null ? void 0 : e.width) || ((t = this._depthBuffer) == null ? void 0 : t.width) || this._device.width;
  }
  get height() {
    var e, t;
    return ((e = this._colorBuffer) == null ? void 0 : e.height) || ((t = this._depthBuffer) == null ? void 0 : t.height) || this._device.height;
  }
}
const Bt = [];
Bt[Or] = 1;
Bt[kr] = 2;
Bt[Nr] = 3;
Bt[zr] = 4;
Bt[Ph] = 1;
Bt[La] = 2;
Bt[Pa] = 3;
Bt[Ia] = 4;
Bt[uh] = 1;
Bt[ud] = 2;
Bt[fd] = 3;
Bt[md] = 4;
Bt[Ih] = 8;
Bt[Dh] = 12;
Bt[Ur] = 16;
class O_ {
  constructor(e, t, s = 1) {
    if (this.name = void 0, this.type = void 0, this.byteSize = void 0, this.offset = void 0, this.scopeId = void 0, this.count = void 0, this.shortName = e, this.name = s > 1 ? `${e}[0]` : e, this.type = t, this.updateType = t, s > 1)
      switch (t) {
        case Or:
          this.updateType = Ul;
          break;
        case kr:
          this.updateType = Vl;
          break;
        case Nr:
          this.updateType = Gl;
          break;
        case zr:
          this.updateType = Mu;
          break;
        case Ur:
          this.updateType = J0;
          break;
      }
    this.count = s;
    let i = Bt[t];
    s > 1 && (i = U.roundUp(i, 4)), this.byteSize = s * i * 4;
  }
  calculateOffset(e) {
    let t = this.byteSize <= 8 ? this.byteSize : 16;
    this.count > 1 && (t = 16), e = U.roundUp(e, t), this.offset = e / 4;
  }
}
class k_ {
  constructor(e, t) {
    this.byteSize = 0, this.map = /* @__PURE__ */ new Map(), this.scope = e.scope, this.uniforms = t;
    let s = 0;
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      n.calculateOffset(s), s = n.offset * 4 + n.byteSize, n.scopeId = this.scope.resolve(n.name), this.map.set(n.name, n);
    }
    this.byteSize = U.roundUp(s, 16);
  }
  get(e) {
    return this.map.get(e);
  }
  getShaderDeclaration(e, t) {
    const s = ex[e];
    let i = `layout(set = ${e}, binding = ${t}, std140) uniform ub_${s} {
`;
    return this.uniforms.forEach((n) => {
      const a = Q0[n.type];
      i += `    ${a} ${n.shortName}${n.count !== 1 ? `[${n.count}]` : ""};
`;
    }), i + `};
`;
  }
}
let lx = 0;
const cx = {
  [Au]: "texture2D",
  [V0]: "textureCube",
  [G0]: "texture3D"
};
class N_ {
  constructor(e, t) {
    this.name = e, this.visibility = t;
  }
}
class dx {
  constructor(e, t, s = Au, i = H0) {
    this.scopeId = void 0, this.name = e, this.visibility = t, this.textureDimension = s, this.sampleType = i;
  }
}
class z_ {
  constructor(e, t, s) {
    this.id = lx++, this.device = e, this.bufferFormats = t, this.bufferFormatsMap = /* @__PURE__ */ new Map(), t.forEach((n, a) => this.bufferFormatsMap.set(n.name, a)), this.textureFormats = s;
    const i = e.scope;
    this.textureFormatsMap = /* @__PURE__ */ new Map(), s.forEach((n, a) => {
      this.textureFormatsMap.set(n.name, a), n.scopeId = i.resolve(n.name);
    }), this.impl = e.createBindGroupFormatImpl(this);
  }
  destroy() {
    this.impl.destroy();
  }
  getTexture(e) {
    const t = this.textureFormatsMap.get(e);
    return t !== void 0 ? this.textureFormats[t] : null;
  }
  getShaderDeclarationTextures(e) {
    let t = "", s = this.bufferFormats.length;
    return this.textureFormats.forEach((i) => {
      const n = cx[i.textureDimension];
      t += `layout(set = ${e}, binding = ${s++}) uniform ${n} ${i.name};
layout(set = ${e}, binding = ${s++}) uniform sampler ${i.name}_sampler;
`;
    }), t;
  }
  loseContext() {
  }
}
let wt = null, ux = 0;
class ue {
  constructor(e, t) {
    this.id = ux++, this.device = e, this.name = null, this._width = 4, this._height = 4, this._depth = 1, this._format = ye, this.type = Rs, this.projection = q0, this._cubemap = !1, this._volume = !1, this.fixCubemapSeams = !1, this._flipY = !1, this._premultiplyAlpha = !1, this._isRenderTarget = !1, this._mipmaps = !0, this._minFilter = Ln, this._magFilter = rt, this._anisotropy = 1, this._addressU = xt, this._addressV = xt, this._addressW = xt, this._compareOnRead = !1, this._compareFunc = gu, t !== void 0 && (t.name !== void 0 && (this.name = t.name), this._width = t.width !== void 0 ? t.width : this._width, this._height = t.height !== void 0 ? t.height : this._height, this._format = t.format !== void 0 ? t.format : this._format, t.hasOwnProperty("type") ? this.type = t.type : t.hasOwnProperty("rgbm") ? this.type = t.rgbm ? _i : Rs : t.hasOwnProperty("swizzleGGGR") && (this.type = t.swizzleGGGR ? kl : Rs), t.mipmaps !== void 0 ? this._mipmaps = t.mipmaps : this._mipmaps = t.autoMipmap !== void 0 ? t.autoMipmap : this._mipmaps, this._levels = t.levels, this._cubemap = t.cubemap !== void 0 ? t.cubemap : this._cubemap, this.fixCubemapSeams = t.fixCubemapSeams !== void 0 ? t.fixCubemapSeams : this.fixCubemapSeams, this._cubemap ? this.projection = dd : t.projection && t.projection !== dd && (this.projection = t.projection), this._minFilter = t.minFilter !== void 0 ? t.minFilter : this._minFilter, this._magFilter = t.magFilter !== void 0 ? t.magFilter : this._magFilter, this._anisotropy = t.anisotropy !== void 0 ? t.anisotropy : this._anisotropy, this._addressU = t.addressU !== void 0 ? t.addressU : this._addressU, this._addressV = t.addressV !== void 0 ? t.addressV : this._addressV, this._compareOnRead = t.compareOnRead !== void 0 ? t.compareOnRead : this._compareOnRead, this._compareFunc = t._compareFunc !== void 0 ? t._compareFunc : this._compareFunc, this._flipY = t.flipY !== void 0 ? t.flipY : this._flipY, this._premultiplyAlpha = t.premultiplyAlpha !== void 0 ? t.premultiplyAlpha : this._premultiplyAlpha, e.webgl2 && (this._depth = t.depth !== void 0 ? t.depth : this._depth, this._volume = t.volume !== void 0 ? t.volume : this._volume, this._addressW = t.addressW !== void 0 ? t.addressW : this._addressW)), this._compressed = P0(this._format), this._invalid = !1, this._lockedLevel = -1, this._levels || (this._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null]), this.dirtyAll(), this._gpuSize = 0, this.impl = e.createTextureImpl(this), e.textures.push(this);
  }
  destroy() {
    if (this.device) {
      const e = this.device, t = e.textures.indexOf(this);
      t !== -1 && e.textures.splice(t, 1), e.scope.removeValue(this), this.impl.destroy(e), this.adjustVramSizeTracking(e._vram, -this._gpuSize), this._levels = null, this.device = null;
    }
  }
  loseContext() {
    this.impl.loseContext(), this.dirtyAll();
  }
  adjustVramSizeTracking(e, t) {
    e.tex += t;
  }
  set minFilter(e) {
    this._minFilter !== e && (this._minFilter = e, this._parameterFlags |= 1);
  }
  get minFilter() {
    return this._minFilter;
  }
  set magFilter(e) {
    this._magFilter !== e && (this._magFilter = e, this._parameterFlags |= 2);
  }
  get magFilter() {
    return this._magFilter;
  }
  set addressU(e) {
    this._addressU !== e && (this._addressU = e, this._parameterFlags |= 4);
  }
  get addressU() {
    return this._addressU;
  }
  set addressV(e) {
    this._addressV !== e && (this._addressV = e, this._parameterFlags |= 8);
  }
  get addressV() {
    return this._addressV;
  }
  set addressW(e) {
    this.device.webgl2 && this._volume && e !== this._addressW && (this._addressW = e, this._parameterFlags |= 16);
  }
  get addressW() {
    return this._addressW;
  }
  set compareOnRead(e) {
    this._compareOnRead !== e && (this._compareOnRead = e, this._parameterFlags |= 32);
  }
  get compareOnRead() {
    return this._compareOnRead;
  }
  set compareFunc(e) {
    this._compareFunc !== e && (this._compareFunc = e, this._parameterFlags |= 64);
  }
  get compareFunc() {
    return this._compareFunc;
  }
  set anisotropy(e) {
    this._anisotropy !== e && (this._anisotropy = e, this._parameterFlags |= 128);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set autoMipmap(e) {
    this._mipmaps = e;
  }
  get autoMipmap() {
    return this._mipmaps;
  }
  set mipmaps(e) {
    this._mipmaps !== e && (this._mipmaps = e, e && (this._needsMipmapsUpload = !0));
  }
  get mipmaps() {
    return this._mipmaps;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get depth() {
    return this._depth;
  }
  get format() {
    return this._format;
  }
  get cubemap() {
    return this._cubemap;
  }
  get gpuSize() {
    const e = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
    return ue.calcGpuSize(this._width, this._height, this._depth, this._format, e, this._cubemap);
  }
  get volume() {
    return this._volume;
  }
  set flipY(e) {
    this._flipY !== e && (this._flipY = e, this._needsUpload = !0);
  }
  get flipY() {
    return this._flipY;
  }
  set premultiplyAlpha(e) {
    this._premultiplyAlpha !== e && (this._premultiplyAlpha = e, this._needsUpload = !0);
  }
  get premultiplyAlpha() {
    return this._premultiplyAlpha;
  }
  get pot() {
    return U.powerOfTwo(this._width) && U.powerOfTwo(this._height);
  }
  get encoding() {
    switch (this.type) {
      case _i:
        return "rgbm";
      case Cu:
        return "rgbe";
      case R_:
        return "rgbp";
      default:
        return this.format === za || this.format === Ua || this.format === Pt || this.format === vt ? "linear" : "srgb";
    }
  }
  static calcGpuSize(e, t, s, i, n, a) {
    var o;
    wt || (wt = [], wt[to] = 8, wt[bu] = 8, wt[Ga] = 8, wt[Ha] = 8, wt[El] = 8, wt[Rl] = 8, wt[Fr] = 8, wt[w_] = 8, wt[wu] = 16, wt[Rh] = 16, wt[In] = 16, wt[b_] = 16, wt[Tu] = 16);
    const h = (o = ut[i]) != null ? o : 0, l = wt.hasOwnProperty(i) ? wt[i] : 0;
    let c = 0;
    for (; ; ) {
      if (h > 0)
        c += e * t * s * h;
      else {
        let d = Math.floor((e + 3) / 4);
        const u = Math.floor((t + 3) / 4), f = Math.floor((s + 3) / 4);
        (i === Ga || i === Ha) && (d = Math.max(Math.floor(d / 2), 1)), c += d * u * f * l;
      }
      if (!n || e === 1 && t === 1 && s === 1)
        break;
      e = Math.max(Math.floor(e / 2), 1), t = Math.max(Math.floor(t / 2), 1), s = Math.max(Math.floor(s / 2), 1);
    }
    return c * (a ? 6 : 1);
  }
  dirtyAll() {
    this._levelsUpdated = this._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0], this._needsUpload = !0, this._needsMipmapsUpload = this._mipmaps, this._mipmapsUploaded = !1, this._parameterFlags = 255;
  }
  lock(e = {}) {
    if (e.level === void 0 && (e.level = 0), e.face === void 0 && (e.face = 0), e.mode === void 0 && (e.mode = U0), this._lockedLevel = e.level, this._levels[e.level] === null)
      switch (this._format) {
        case yu:
        case bl:
          this._levels[e.level] = new Uint8Array(this._width * this._height * this._depth);
          break;
        case wl:
          this._levels[e.level] = new Uint8Array(this._width * this._height * this._depth * 2);
          break;
        case Tl:
        case xu:
        case Cl:
          this._levels[e.level] = new Uint16Array(this._width * this._height * this._depth);
          break;
        case Si:
          this._levels[e.level] = new Uint8Array(this._width * this._height * this._depth * 3);
          break;
        case ye:
          this._levels[e.level] = new Uint8Array(this._width * this._height * this._depth * 4);
          break;
        case Fr:
          this._levels[e.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 8 * this._depth);
          break;
        case Rh:
        case In:
          this._levels[e.level] = new Uint8Array(Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4) * 16 * this._depth);
          break;
        case za:
          this._levels[e.level] = new Uint16Array(this._width * this._height * this._depth * 3);
          break;
        case Ua:
          this._levels[e.level] = new Float32Array(this._width * this._height * this._depth * 3);
          break;
        case Pt:
          this._levels[e.level] = new Uint16Array(this._width * this._height * this._depth * 4);
          break;
        case vt:
          this._levels[e.level] = new Float32Array(this._width * this._height * this._depth * 4);
          break;
      }
    return this._levels[e.level];
  }
  setSource(e, t = 0) {
    let s = !1, i, n;
    if (this._cubemap) {
      if (e[0]) {
        i = e[0].width || 0, n = e[0].height || 0;
        for (let a = 0; a < 6; a++) {
          const o = e[a];
          if (!o || o.width !== i || o.height !== n || !this.device._isBrowserInterface(o)) {
            s = !0;
            break;
          }
        }
      } else
        s = !0;
      if (!s)
        for (let a = 0; a < 6; a++)
          this._levels[t][a] !== e[a] && (this._levelsUpdated[t][a] = !0);
    } else
      this.device._isBrowserInterface(e) || (s = !0), s || (e !== this._levels[t] && (this._levelsUpdated[t] = !0), i = e.width, n = e.height);
    if (s)
      if (this._width = 4, this._height = 4, this._cubemap)
        for (let a = 0; a < 6; a++)
          this._levels[t][a] = null, this._levelsUpdated[t][a] = !0;
      else
        this._levels[t] = null, this._levelsUpdated[t] = !0;
    else
      t === 0 && (this._width = i, this._height = n), this._levels[t] = e;
    (this._invalid !== s || !s) && (this._invalid = s, this.upload());
  }
  getSource(e = 0) {
    return this._levels[e];
  }
  unlock() {
    this._lockedLevel, this.upload(), this._lockedLevel = -1;
  }
  upload() {
    var e, t;
    this._needsUpload = !0, this._needsMipmapsUpload = this._mipmaps, (e = (t = this.impl).uploadImmediate) == null || e.call(t, this.device, this);
  }
  getDds() {
    let e = 128, t = 0;
    for (; this._levels[t]; ) {
      if (this.cubemap)
        for (let x = 0; x < 6; x++) {
          if (!this._levels[t][x])
            return;
          const y = this._levels[t][x].length;
          if (!y)
            return;
          e += y;
        }
      else {
        const x = this._levels[t].length;
        if (!x)
          return;
        e += x;
      }
      e += this._levels[t].length, t++;
    }
    const s = new ArrayBuffer(e), i = new Uint32Array(s, 0, 128 / 4), n = 542327876, a = 124, o = 528391, h = 131072, l = 32, c = 65, d = 4096, u = 4194304, f = 8, m = 65024;
    let _ = o;
    this._levels.length > 1 && (_ |= h);
    let p = d;
    this._levels.length > 1 && (p |= u), (this._levels.length > 1 || this.cubemap) && (p |= f);
    const g = this.cubemap ? m : 0;
    i[0] = n, i[1] = a, i[2] = _, i[3] = this.height, i[4] = this.width, i[5] = this.width * this.height * 4, i[6] = 0, i[7] = this._levels.length;
    for (let x = 0; x < 11; x++)
      i[8 + x] = 0;
    i[19] = l, i[20] = c, i[21] = 0, i[22] = 32, i[23] = 16711680, i[24] = 65280, i[25] = 255, i[26] = 4278190080, i[27] = p, i[28] = g, i[29] = 0, i[30] = 0, i[31] = 0;
    let b = 128;
    if (this.cubemap)
      for (let x = 0; x < 6; x++)
        for (let y = 0; y < this._levels.length; y++) {
          const S = this._levels[y][x], C = new Uint8Array(s, b, S.length);
          for (let w = 0; w < S.length; w++)
            C[w] = S[w];
          b += S.length;
        }
    else
      for (let x = 0; x < this._levels.length; x++) {
        const y = this._levels[x], S = new Uint8Array(s, b, y.length);
        for (let C = 0; C < y.length; C++)
          S[C] = y[C];
        b += y.length;
      }
    return s;
  }
}
class U_ {
  constructor() {
    this.bufferId = null;
  }
  destroy(e) {
    this.bufferId && (e.gl.deleteBuffer(this.bufferId), this.bufferId = null);
  }
  get initialized() {
    return !!this.bufferId;
  }
  loseContext() {
    this.bufferId = null;
  }
  unlock(e, t, s, i) {
    const n = e.gl;
    this.bufferId || (this.bufferId = n.createBuffer());
    let a;
    switch (t) {
      case ns:
        a = n.STATIC_DRAW;
        break;
      case Na:
        a = n.DYNAMIC_DRAW;
        break;
      case C0:
        a = n.STREAM_DRAW;
        break;
      case A0:
        e.webgl2 ? a = n.DYNAMIC_COPY : a = n.STATIC_DRAW;
        break;
    }
    n.bindBuffer(s, this.bufferId), n.bufferData(s, i, a);
  }
}
class fx extends U_ {
  constructor(...e) {
    super(...e), this.vao = null;
  }
  destroy(e) {
    super.destroy(e), e.boundVao = null, e.gl.bindVertexArray(null);
  }
  loseContext() {
    super.loseContext(), this.vao = null;
  }
  unlock(e) {
    const t = e.device;
    super.unlock(t, e.usage, t.gl.ARRAY_BUFFER, e.storage);
  }
}
class mx extends U_ {
  constructor(e) {
    super();
    const t = e.device.gl, s = e.format;
    s === v_ ? this.glFormat = t.UNSIGNED_BYTE : s === pi ? this.glFormat = t.UNSIGNED_SHORT : s === Pn && (this.glFormat = t.UNSIGNED_INT);
  }
  unlock(e) {
    const t = e.device;
    super.unlock(t, e.usage, t.gl.ELEMENT_ARRAY_BUFFER, e.storage);
  }
}
class If {
  constructor(e, t, s, i) {
    if (this.locationId = i, this.scopeId = e.scope.resolve(t), this.version = new F_(), t.substring(t.length - 3) === "[0]")
      switch (s) {
        case Or:
          s = Ul;
          break;
        case kr:
          s = Vl;
          break;
        case Nr:
          s = Gl;
          break;
        case zr:
          s = Mu;
          break;
      }
    this.dataType = s, this.value = [null, null, null, null], this.array = [];
  }
}
class Ji {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  get(e, t) {
    return this._cache.has(e) || (this._cache.set(e, t()), e.on("destroy", () => {
      this.remove(e);
    }), e.on("devicelost", () => {
      var s;
      (s = this._cache.get(e)) == null || s.loseContext == null || s.loseContext(e);
    })), this._cache.get(e);
  }
  remove(e) {
    var t;
    (t = this._cache.get(e)) == null || t.destroy == null || t.destroy(e), this._cache.delete(e);
  }
}
const px = ["gl_VertexID", "gl_InstanceID", "gl_DrawID", "gl_BaseVertex", "gl_BaseInstance"];
class _x {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  destroy(e) {
    this.map.forEach((t) => {
      e.gl.deleteShader(t);
    });
  }
  loseContext(e) {
    this.map.clear();
  }
}
class gx {
  constructor() {
    this.shaders = [];
  }
  loseContext(e) {
    this.shaders = [];
  }
}
const yx = new Ji(), xx = new Ji(), vx = new Ji();
class qa {
  constructor(e) {
    this.compileDuration = 0, this.init(), this.compile(e.device, e), qa.getBatchShaders(e.device).push(e), e.device.shaders.push(e);
  }
  destroy(e) {
    this.glProgram && (e.device.gl.deleteProgram(this.glProgram), this.glProgram = null);
  }
  init() {
    this.uniforms = [], this.samplers = [], this.attributes = [], this.glProgram = null, this.glVertexShader = null, this.glFragmentShader = null;
  }
  static getBatchShaders(e) {
    return vx.get(e, () => new gx()).shaders;
  }
  static endShaderBatch(e) {
    const t = qa.getBatchShaders(e);
    t.forEach((s) => s.impl.link(e, s)), t.length = 0;
  }
  loseContext() {
    this.init();
  }
  restoreContext(e, t) {
    this.compile(e, t);
  }
  compile(e, t) {
    const s = t.definition;
    this.glVertexShader = this._compileShaderSource(e, s.vshader, !0), this.glFragmentShader = this._compileShaderSource(e, s.fshader, !1);
  }
  link(e, t) {
    if (this.glProgram)
      return;
    const s = e.gl, i = s.createProgram();
    this.glProgram = i, s.attachShader(i, this.glVertexShader), s.attachShader(i, this.glFragmentShader);
    const n = t.definition, a = n.attributes;
    if (e.webgl2 && n.useTransformFeedback) {
      const o = [];
      for (const h in a)
        a.hasOwnProperty(h) && o.push("out_" + h);
      s.transformFeedbackVaryings(i, o, s.INTERLEAVED_ATTRIBS);
    }
    for (const o in a)
      if (a.hasOwnProperty(o)) {
        const h = a[o], l = De[h];
        s.bindAttribLocation(i, l, o);
      }
    s.linkProgram(i);
  }
  _compileShaderSource(e, t, s) {
    const i = e.gl, a = (s ? yx : xx).get(e, () => new _x());
    let o = a.map.get(t);
    return o || (o = i.createShader(s ? i.VERTEX_SHADER : i.FRAGMENT_SHADER), i.shaderSource(o, t), i.compileShader(o), a.map.set(t, o)), o;
  }
  finalize(e, t) {
    this.glProgram || this.link(e, t);
    const s = e.gl, i = this.glProgram, n = t.definition;
    if (!s.getProgramParameter(i, s.LINK_STATUS)) {
      if (!this._isCompiled(e, t, this.glVertexShader, n.vshader, "vertex") || !this._isCompiled(e, t, this.glFragmentShader, n.fshader, "fragment"))
        return !1;
      const c = "Failed to link shader program. Error: " + s.getProgramInfoLog(i);
      return console.error(c), !1;
    }
    let o = 0;
    const h = s.getProgramParameter(i, s.ACTIVE_ATTRIBUTES);
    for (; o < h; ) {
      const c = s.getActiveAttrib(i, o++), d = s.getAttribLocation(i, c.name);
      if (px.indexOf(c.name) !== -1)
        continue;
      n.attributes[c.name] === void 0 && (console.error(`Vertex shader attribute "${c.name}" is not mapped to a semantic in shader definition, shader [${t.label}]`, t), t.failed = !0);
      const u = new If(e, n.attributes[c.name], e.pcUniformType[c.type], d);
      this.attributes.push(u);
    }
    o = 0;
    const l = s.getProgramParameter(i, s.ACTIVE_UNIFORMS);
    for (; o < l; ) {
      const c = s.getActiveUniform(i, o++), d = s.getUniformLocation(i, c.name), u = new If(e, c.name, e.pcUniformType[c.type], d);
      c.type === s.SAMPLER_2D || c.type === s.SAMPLER_CUBE || e.webgl2 && (c.type === s.SAMPLER_2D_SHADOW || c.type === s.SAMPLER_CUBE_SHADOW || c.type === s.SAMPLER_3D) ? this.samplers.push(u) : this.uniforms.push(u);
    }
    return t.ready = !0, !0;
  }
  _isCompiled(e, t, s, i, n) {
    const a = e.gl;
    if (!a.getShaderParameter(s, a.COMPILE_STATUS)) {
      const o = a.getShaderInfoLog(s), [h, l] = this._processError(i, o), c = `Failed to compile ${n} shader:

${o}
${h}`;
      return console.error(c), !1;
    }
    return !0;
  }
  _processError(e, t) {
    const s = {};
    let i = "";
    if (e) {
      const n = e.split(`
`);
      let a = 0, o = n.length;
      if (t && t.startsWith("ERROR:")) {
        const h = t.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);
        h && (s.message = h[3], s.line = parseInt(h[2], 10), a = Math.max(0, s.line - 6), o = Math.min(n.length, s.line + 5));
      }
      for (let h = a; h < o; h++)
        i += h + 1 + ":	" + n[h] + `
`;
      s.source = e;
    }
    return [i, s];
  }
}
function Df(r, e) {
  const t = r.width, s = r.height;
  if (t > e || s > e) {
    const i = e / Math.max(t, s), n = Math.floor(t * i), a = Math.floor(s * i), o = document.createElement("canvas");
    return o.width = n, o.height = a, o.getContext("2d").drawImage(r, 0, 0, t, s, 0, 0, n, a), o;
  }
  return r;
}
class Sx {
  constructor() {
    this._glTexture = null, this._glTarget = void 0, this._glFormat = void 0, this._glInternalFormat = void 0, this._glPixelType = void 0;
  }
  destroy(e) {
    if (this._glTexture) {
      for (let t = 0; t < e.textureUnits.length; t++) {
        const s = e.textureUnits[t];
        for (let i = 0; i < s.length; i++)
          s[i] === this._glTexture && (s[i] = null);
      }
      e.gl.deleteTexture(this._glTexture), this._glTexture = null;
    }
  }
  loseContext() {
    this._glTexture = null;
  }
  initialize(e, t) {
    const s = e.gl;
    switch (this._glTexture = s.createTexture(), this._glTarget = t._cubemap ? s.TEXTURE_CUBE_MAP : t._volume ? s.TEXTURE_3D : s.TEXTURE_2D, t._format) {
      case yu:
        this._glFormat = s.ALPHA, this._glInternalFormat = s.ALPHA, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case bl:
        this._glFormat = s.LUMINANCE, this._glInternalFormat = s.LUMINANCE, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case wl:
        this._glFormat = s.LUMINANCE_ALPHA, this._glInternalFormat = s.LUMINANCE_ALPHA, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case Tl:
        this._glFormat = s.RGB, this._glInternalFormat = s.RGB, this._glPixelType = s.UNSIGNED_SHORT_5_6_5;
        break;
      case xu:
        this._glFormat = s.RGBA, this._glInternalFormat = s.RGBA, this._glPixelType = s.UNSIGNED_SHORT_5_5_5_1;
        break;
      case Cl:
        this._glFormat = s.RGBA, this._glInternalFormat = s.RGBA, this._glPixelType = s.UNSIGNED_SHORT_4_4_4_4;
        break;
      case Si:
        this._glFormat = s.RGB, this._glInternalFormat = e.webgl2 ? s.RGB8 : s.RGB, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case ye:
        this._glFormat = s.RGBA, this._glInternalFormat = e.webgl2 ? s.RGBA8 : s.RGBA, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case Fr:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
        break;
      case Rh:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        break;
      case In:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        break;
      case to:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
        break;
      case Ga:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        break;
      case Ha:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        break;
      case El:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        break;
      case Rl:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        break;
      case bu:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
        break;
      case wu:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
        break;
      case b_:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
        break;
      case w_:
        this._glFormat = s.RGB, this._glInternalFormat = e.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
        break;
      case Tu:
        this._glFormat = s.RGBA, this._glInternalFormat = e.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
        break;
      case za:
        this._glFormat = s.RGB, e.webgl2 ? (this._glInternalFormat = s.RGB16F, this._glPixelType = s.HALF_FLOAT) : (this._glInternalFormat = s.RGB, this._glPixelType = e.extTextureHalfFloat.HALF_FLOAT_OES);
        break;
      case Pt:
        this._glFormat = s.RGBA, e.webgl2 ? (this._glInternalFormat = s.RGBA16F, this._glPixelType = s.HALF_FLOAT) : (this._glInternalFormat = s.RGBA, this._glPixelType = e.extTextureHalfFloat.HALF_FLOAT_OES);
        break;
      case Ua:
        this._glFormat = s.RGB, e.webgl2 ? this._glInternalFormat = s.RGB32F : this._glInternalFormat = s.RGB, this._glPixelType = s.FLOAT;
        break;
      case vt:
        this._glFormat = s.RGBA, e.webgl2 ? this._glInternalFormat = s.RGBA32F : this._glInternalFormat = s.RGBA, this._glPixelType = s.FLOAT;
        break;
      case S_:
        this._glFormat = s.RED, this._glInternalFormat = s.R32F, this._glPixelType = s.FLOAT;
        break;
      case Va:
        e.webgl2 ? (this._glFormat = s.DEPTH_COMPONENT, this._glInternalFormat = s.DEPTH_COMPONENT32F, this._glPixelType = s.FLOAT) : (this._glFormat = s.DEPTH_COMPONENT, this._glInternalFormat = s.DEPTH_COMPONENT, this._glPixelType = s.UNSIGNED_SHORT);
        break;
      case Al:
        this._glFormat = s.DEPTH_STENCIL, e.webgl2 ? (this._glInternalFormat = s.DEPTH24_STENCIL8, this._glPixelType = s.UNSIGNED_INT_24_8) : (this._glInternalFormat = s.DEPTH_STENCIL, this._glPixelType = e.extDepthTexture.UNSIGNED_INT_24_8_WEBGL);
        break;
      case Ml:
        this._glFormat = s.RGB, this._glInternalFormat = s.R11F_G11F_B10F, this._glPixelType = s.UNSIGNED_INT_10F_11F_11F_REV;
        break;
      case vu:
        this._glFormat = s.RGB, this._glInternalFormat = s.SRGB8, this._glPixelType = s.UNSIGNED_BYTE;
        break;
      case Su:
        this._glFormat = s.RGBA, this._glInternalFormat = s.SRGB8_ALPHA8, this._glPixelType = s.UNSIGNED_BYTE;
        break;
    }
  }
  upload(e, t) {
    const s = e.gl;
    if (!t._needsUpload && (t._needsMipmapsUpload && t._mipmapsUploaded || !t.pot))
      return;
    let i = 0, n, a;
    const o = Math.log2(Math.max(t._width, t._height)) + 1;
    for (; t._levels[i] || i === 0; ) {
      if (!t._needsUpload && i === 0) {
        i++;
        continue;
      } else if (i && (!t._needsMipmapsUpload || !t._mipmaps))
        break;
      if (n = t._levels[i], i === 1 && !t._compressed && t._levels.length < o && (s.generateMipmap(this._glTarget), t._mipmapsUploaded = !0), t._cubemap) {
        let h;
        if (e._isBrowserInterface(n[0]))
          for (h = 0; h < 6; h++) {
            if (!t._levelsUpdated[0][h])
              continue;
            let l = n[h];
            e._isImageBrowserInterface(l) && (l.width > e.maxCubeMapSize || l.height > e.maxCubeMapSize) && (l = Df(l, e.maxCubeMapSize), i === 0 && (t._width = l.width, t._height = l.height)), e.setUnpackFlipY(!1), e.setUnpackPremultiplyAlpha(t._premultiplyAlpha), s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + h, i, this._glInternalFormat, this._glFormat, this._glPixelType, l);
          }
        else
          for (a = 1 / Math.pow(2, i), h = 0; h < 6; h++) {
            if (!t._levelsUpdated[0][h])
              continue;
            const l = n[h];
            t._compressed ? s.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + h, i, this._glInternalFormat, Math.max(t._width * a, 1), Math.max(t._height * a, 1), 0, l) : (e.setUnpackFlipY(!1), e.setUnpackPremultiplyAlpha(t._premultiplyAlpha), s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + h, i, this._glInternalFormat, Math.max(t._width * a, 1), Math.max(t._height * a, 1), 0, this._glFormat, this._glPixelType, l));
          }
      } else
        t._volume ? (a = 1 / Math.pow(2, i), t._compressed ? s.compressedTexImage3D(s.TEXTURE_3D, i, this._glInternalFormat, Math.max(t._width * a, 1), Math.max(t._height * a, 1), Math.max(t._depth * a, 1), 0, n) : (e.setUnpackFlipY(!1), e.setUnpackPremultiplyAlpha(t._premultiplyAlpha), s.texImage3D(s.TEXTURE_3D, i, this._glInternalFormat, Math.max(t._width * a, 1), Math.max(t._height * a, 1), Math.max(t._depth * a, 1), 0, this._glFormat, this._glPixelType, n))) : (e._isBrowserInterface(n) ? (e._isImageBrowserInterface(n) && (n.width > e.maxTextureSize || n.height > e.maxTextureSize) && (n = Df(n, e.maxTextureSize), i === 0 && (t._width = n.width, t._height = n.height)), e.setUnpackFlipY(t._flipY), e.setUnpackPremultiplyAlpha(t._premultiplyAlpha), s.texImage2D(s.TEXTURE_2D, i, this._glInternalFormat, this._glFormat, this._glPixelType, n)) : (a = 1 / Math.pow(2, i), t._compressed ? s.compressedTexImage2D(s.TEXTURE_2D, i, this._glInternalFormat, Math.max(Math.floor(t._width * a), 1), Math.max(Math.floor(t._height * a), 1), 0, n) : (e.setUnpackFlipY(!1), e.setUnpackPremultiplyAlpha(t._premultiplyAlpha), s.texImage2D(s.TEXTURE_2D, i, this._glInternalFormat, Math.max(t._width * a, 1), Math.max(t._height * a, 1), 0, this._glFormat, this._glPixelType, n))), i === 0 ? t._mipmapsUploaded = !1 : t._mipmapsUploaded = !0);
      i++;
    }
    if (t._needsUpload)
      if (t._cubemap)
        for (let h = 0; h < 6; h++)
          t._levelsUpdated[0][h] = !1;
      else
        t._levelsUpdated[0] = !1;
    !t._compressed && t._mipmaps && t._needsMipmapsUpload && (t.pot || e.webgl2) && t._levels.length === 1 && (s.generateMipmap(this._glTarget), t._mipmapsUploaded = !0), t._gpuSize && t.adjustVramSizeTracking(e._vram, -t._gpuSize), t._gpuSize = t.gpuSize, t.adjustVramSizeTracking(e._vram, t._gpuSize);
  }
}
class bx {
  constructor() {
    this._glFrameBuffer = null, this._glDepthBuffer = null, this._glResolveFrameBuffer = null, this._glMsaaColorBuffer = null, this._glMsaaDepthBuffer = null;
  }
  destroy(e) {
    const t = e.gl;
    this._glFrameBuffer && (t.deleteFramebuffer(this._glFrameBuffer), this._glFrameBuffer = null), this._glDepthBuffer && (t.deleteRenderbuffer(this._glDepthBuffer), this._glDepthBuffer = null), this._glResolveFrameBuffer && (t.deleteFramebuffer(this._glResolveFrameBuffer), this._glResolveFrameBuffer = null), this._glMsaaColorBuffer && (t.deleteRenderbuffer(this._glMsaaColorBuffer), this._glMsaaColorBuffer = null), this._glMsaaDepthBuffer && (t.deleteRenderbuffer(this._glMsaaDepthBuffer), this._glMsaaDepthBuffer = null);
  }
  get initialized() {
    return this._glFrameBuffer !== null;
  }
  init(e, t) {
    const s = e.gl;
    this._glFrameBuffer = s.createFramebuffer(), e.setFramebuffer(this._glFrameBuffer);
    const i = t._colorBuffer;
    i && (i.impl._glTexture || (i._width = Math.min(i.width, e.maxRenderBufferSize), i._height = Math.min(i.height, e.maxRenderBufferSize), e.setTexture(i, 0)), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, i._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, i.impl._glTexture, 0));
    const n = t._depthBuffer;
    if (n)
      n.impl._glTexture || (n._width = Math.min(n.width, e.maxRenderBufferSize), n._height = Math.min(n.height, e.maxRenderBufferSize), e.setTexture(n, 0)), t._stencil ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, n._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, t._depthBuffer.impl._glTexture, 0) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, n._cubemap ? s.TEXTURE_CUBE_MAP_POSITIVE_X + t._face : s.TEXTURE_2D, t._depthBuffer.impl._glTexture, 0);
    else if (t._depth && !(t._samples > 1 && e.webgl2)) {
      if (this._glDepthBuffer || (this._glDepthBuffer = s.createRenderbuffer()), s.bindRenderbuffer(s.RENDERBUFFER, this._glDepthBuffer), t._stencil)
        s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, this._glDepthBuffer);
      else {
        const o = e.webgl2 ? s.DEPTH_COMPONENT32F : s.DEPTH_COMPONENT16;
        s.renderbufferStorage(s.RENDERBUFFER, o, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, this._glDepthBuffer);
      }
      s.bindRenderbuffer(s.RENDERBUFFER, null);
    }
    e.webgl2 && t._samples > 1 && (this._glResolveFrameBuffer = this._glFrameBuffer, this._glFrameBuffer = s.createFramebuffer(), e.setFramebuffer(this._glFrameBuffer), i && (this._glMsaaColorBuffer || (this._glMsaaColorBuffer = s.createRenderbuffer()), s.bindRenderbuffer(s.RENDERBUFFER, this._glMsaaColorBuffer), s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, i.impl._glInternalFormat, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, this._glMsaaColorBuffer)), t._depth && (this._glMsaaDepthBuffer || (this._glMsaaDepthBuffer = s.createRenderbuffer()), s.bindRenderbuffer(s.RENDERBUFFER, this._glMsaaDepthBuffer), t._stencil ? (s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, s.DEPTH24_STENCIL8, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, this._glMsaaDepthBuffer)) : (s.renderbufferStorageMultisample(s.RENDERBUFFER, t._samples, s.DEPTH_COMPONENT32F, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, this._glMsaaDepthBuffer))));
  }
  _checkFbo(e, t, s = "") {
    const i = e.gl;
    switch (i.checkFramebufferStatus(i.FRAMEBUFFER)) {
      case i.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        break;
      case i.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        break;
      case i.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        break;
      case i.FRAMEBUFFER_UNSUPPORTED:
        break;
    }
  }
  loseContext() {
    this._glFrameBuffer = null, this._glDepthBuffer = null, this._glResolveFrameBuffer = null, this._glMsaaColorBuffer = null, this._glMsaaDepthBuffer = null;
  }
  resolve(e, t, s, i) {
    if (e.webgl2) {
      const n = e.gl;
      n.bindFramebuffer(n.READ_FRAMEBUFFER, this._glFrameBuffer), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, this._glResolveFrameBuffer), n.blitFramebuffer(0, 0, t.width, t.height, 0, 0, t.width, t.height, (s ? n.COLOR_BUFFER_BIT : 0) | (i ? n.DEPTH_BUFFER_BIT : 0), n.NEAREST), n.bindFramebuffer(n.FRAMEBUFFER, this._glFrameBuffer);
    }
  }
}
var V_ = `
#define texture2DBias texture2D

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passsed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2D name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#ifndef SUPPORTS_TEXLOD

// fallback for lod instructions
#define texture2DLodEXT texture2D
#define texture2DProjLodEXT textureProj
#define textureCubeLodEXT textureCube
#define textureShadow texture2D

#else

#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))

#endif

`, G_ = `
#define varying in
out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor
#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad

// sample shadows using textureGrad to remove derivates in the dynamic loops (which are used by
// clustered lighting) - as DirectX shader compiler tries to unroll the loops and takes long time
// to compile the shader. Using textureLod would be even better, but WebGl does not translate it to
// lod instruction for DirectX correctly and uses SampleCmp instead of SampleCmpLevelZero or similar.
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passsed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#define GL2
#define SUPPORTS_TEXLOD
`, H_ = `
#define attribute in
#define varying out
#define texture2D texture
#define GL2
#define VERTEXSHADER
`, W_ = `

// texelFetch support and others
#extension GL_EXT_samplerless_texture_functions : require

layout(location = 0) out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor

#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) texture(sampler2DShadow(res, res ## _sampler), uv)

// TODO: implement other texture sampling macros
// #define texture2DProj textureProj
// #define texture2DProjLodEXT textureProjLod
// #define texture2DGradEXT textureGrad
// #define texture2DProjGradEXT textureProjGrad
// #define textureCubeGradEXT textureGrad

// pass / accept shadow map as a function parameter, passes both the texture as well as sampler
// as the combined sampler can be only created at a point of use
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler

#define GL2
#define WEBGPU
#define SUPPORTS_TEXLOD
`, q_ = `
#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)

#define GL2
#define WEBGPU
#define VERTEXSHADER
`, Bf = `

// convert clip space position into texture coordinates to sample scene grab textures
vec2 getGrabScreenPos(vec4 clipPos) {
		vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}

// convert uv coordinates to sample image effect texture (render target texture rendered without
// forward renderer which does the flip in the projection matrix)
vec2 getImageEffectUV(vec2 uv) {
		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}
`;
const wx = {
  vertex_position: et,
  vertex_normal: Gt,
  vertex_tangent: qs,
  vertex_texCoord0: rs,
  vertex_texCoord1: Zi,
  vertex_texCoord2: Pl,
  vertex_texCoord3: Il,
  vertex_texCoord4: Dl,
  vertex_texCoord5: Bl,
  vertex_texCoord6: Fl,
  vertex_texCoord7: Ol,
  vertex_color: It,
  vertex_boneIndices: ts,
  vertex_boneWeights: Xs
};
class pt {
  static createDefinition(e, t) {
    var s, i;
    const n = (u, f, m, _) => e.deviceType === Et ? u : e.webgl2 ? f : pt.gl1Extensions(e, t) + m, a = (s = t.name) != null ? s : "Untitled", o = t.vertexDefines || n(q_, H_, ""), h = pt.versionCode(e) + o + Bf + pt.getShaderNameCode(a) + t.vertexCode, l = t.fragmentDefines || n(W_, G_, V_), c = (t.fragmentPreamble || "") + pt.versionCode(e) + pt.precisionCode(e) + `
` + l + Bf + pt.getShaderNameCode(a) + (t.fragmentCode || pt.dummyFragmentCode()), d = (i = t.attributes) != null ? i : pt.collectAttributes(t.vertexCode);
    return {
      name: a,
      attributes: d,
      vshader: h,
      fshader: c,
      useTransformFeedback: t.useTransformFeedback
    };
  }
  static getShaderNameCode(e) {
    return `#define SHADER_NAME ${e}
`;
  }
  static gl1Extensions(e, t, s) {
    let i;
    return s ? i = t.vertexExtensions ? `${t.vertexExtensions}
` : "" : (i = t.fragmentExtensions ? `${t.fragmentExtensions}
` : "", e.extStandardDerivatives && (i += `#extension GL_OES_standard_derivatives : enable
`), e.extTextureLod && (i += `#extension GL_EXT_shader_texture_lod : enable
`, i += `#define SUPPORTS_TEXLOD
`)), i;
  }
  static dummyFragmentCode() {
    return "void main(void) {gl_FragColor = vec4(0.0);}";
  }
  static versionCode(e) {
    return e.deviceType === Et ? `#version 450
` : e.webgl2 ? `#version 300 es
` : "";
  }
  static precisionCode(e, t) {
    let s = "";
    t && t !== "highp" && t !== "mediump" && t !== "lowp" && (t = null), t && (t === "highp" && e.maxPrecision !== "highp" && (t = "mediump"), t === "mediump" && e.maxPrecision === "lowp" && (t = "lowp"));
    const i = t || e.precision;
    return e.deviceType === I_ ? (s = `precision ${i} float;
`, e.webgl2 && (s += `precision ${i} sampler2DShadow;
`)) : s = `precision ${i} float;
precision ${i} int;
`, s;
  }
  static collectAttributes(e) {
    const t = {};
    let s = 0, i = e.indexOf("attribute");
    for (; i >= 0 && !(i > 0 && e[i - 1] === "/"); ) {
      const n = e.indexOf(";", i), a = e.lastIndexOf(" ", n), o = e.substring(a + 1, n), h = wx[o];
      h !== void 0 ? t[o] = h : (t[o] = "ATTR" + s, s++), i = e.indexOf("attribute", i + 1);
    }
    return t;
  }
}
const Ri = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g, Ff = /define[ \t]+([^\n]+)\r?(?:\n|$)/g, Of = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g, kf = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g, rc = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g, ac = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g, Nf = /([\w-]+)/, Tx = /(!|\s)?defined\(([\w-]+)\)/, Cx = /[><=|&+-]/g;
class ki {
  static run(e) {
    return e = e.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1"), e = e.split(/\r?\n/).map((t) => t.trimEnd()).join(`
`), e = this._preprocess(e), e !== null && (e = e.split(/\r?\n/).map((t) => t.trim() === "" ? "" : t).join(`
`), e = e.replace(/(\n\n){3,}/gm, `

`)), e;
  }
  static _preprocess(e) {
    const t = e, s = [];
    let i = !1;
    const n = /* @__PURE__ */ new Map();
    let a;
    for (; (a = Ri.exec(e)) !== null; ) {
      const o = a[1];
      switch (o) {
        case "define": {
          Ff.lastIndex = a.index;
          const h = Ff.exec(e);
          i || (i = h === null);
          const l = h[1];
          Nf.lastIndex = h.index;
          const d = Nf.exec(l)[1];
          let u = l.substring(d.length).trim();
          u === "" && (u = "true"), ki._keep(s) && n.set(d, u), Ri.lastIndex = h.index + h[0].length;
          break;
        }
        case "undef": {
          kf.lastIndex = a.index;
          const h = kf.exec(e), l = h[1].trim();
          ki._keep(s) && n.delete(l), Ri.lastIndex = h.index + h[0].length;
          break;
        }
        case "extension": {
          Of.lastIndex = a.index;
          const h = Of.exec(e);
          if (i || (i = h === null), h) {
            const l = h[1];
            ki._keep(s) && n.set(l, "true");
          }
          Ri.lastIndex = h.index + h[0].length;
          break;
        }
        case "ifdef":
        case "ifndef":
        case "if": {
          rc.lastIndex = a.index;
          const h = rc.exec(e), l = h[2], c = ki.evaluate(l, n);
          i || (i = c.error);
          let d = c.result;
          o === "ifndef" && (d = !d), s.push({
            anyKeep: d,
            keep: d,
            start: a.index,
            end: rc.lastIndex
          }), Ri.lastIndex = h.index + h[0].length;
          break;
        }
        case "endif":
        case "else":
        case "elif": {
          ac.lastIndex = a.index;
          const h = ac.exec(e), l = s.pop(), c = l.keep ? e.substring(l.end, a.index) : "";
          e = e.substring(0, l.start) + c + e.substring(ac.lastIndex), Ri.lastIndex = l.start + c.length;
          const d = h[1];
          if (d === "else" || d === "elif") {
            let u = !1;
            if (!l.anyKeep)
              if (d === "else")
                u = !l.keep;
              else {
                const f = ki.evaluate(h[2], n);
                u = f.result, i || (i = f.error);
              }
            s.push({
              anyKeep: l.anyKeep || u,
              keep: u,
              start: Ri.lastIndex,
              end: Ri.lastIndex
            });
          }
          break;
        }
      }
    }
    return i ? (console.warn("Failed to preprocess shader: ", {
      source: t
    }), t) : e;
  }
  static _keep(e) {
    for (let t = 0; t < e.length; t++)
      if (!e[t].keep)
        return !1;
    return !0;
  }
  static evaluate(e, t) {
    const s = Cx.exec(e) === null;
    let i = !1;
    const n = Tx.exec(e);
    n && (i = n[1] === "!", e = n[2]), e = e.trim();
    let a = t.has(e);
    return i && (a = !a), {
      result: a,
      error: !s
    };
  }
}
let Ax = 0;
class Vr {
  constructor(e, t) {
    this.meshUniformBufferFormat = void 0, this.meshBindGroupFormat = void 0, this.id = Ax++, this.device = e, this.definition = t, this.name = t.name || "Untitled", t.vshader = ki.run(t.vshader), t.fshader = ki.run(t.fshader), this.init(), this.impl = e.createShaderImpl(this);
  }
  init() {
    this.ready = !1, this.failed = !1;
  }
  get label() {
    return `Shader Id ${this.id} ${this.name}`;
  }
  destroy() {
    this.device.onDestroyShader(this), this.impl.destroy(this);
  }
  loseContext() {
    this.init(), this.impl.loseContext();
  }
  restoreContext() {
    this.impl.restoreContext(this.device, this);
  }
}
const Xn = [], yd = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`, Mx = `
void main(void) { 
		gl_FragColor = vec4(2147483648.0);
}
`, Ex = `
uniform sampler2D source;
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
void main(void) {
		float c = texture2D(source, vec2(0.0)).r;
		float diff = abs(c - 2147483648.0) / 2147483648.0;
		gl_FragColor = packFloat(diff);
}
`, Rx = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`;
function xd(r, e, t) {
  const s = r.renderTarget;
  r.setRenderTarget(e), r.updateBegin();
  const i = r.getDepthTest(), n = r.getDepthWrite(), a = r.getCullMode(), o = r.writeRed, h = r.writeGreen, l = r.writeBlue, c = r.writeAlpha;
  r.setDepthTest(!1), r.setDepthWrite(!1), r.setCullMode(Ft), r.setColorWrite(!0, !0, !0, !0), r.setVertexBuffer(r.quadVertexBuffer, 0), r.setShader(t), r.draw({
    type: jr,
    base: 0,
    count: 4,
    indexed: !1
  }), r.setDepthTest(i), r.setDepthWrite(n), r.setCullMode(a), r.setColorWrite(o, h, l, c), r.updateEnd(), r.setRenderTarget(s), r.updateBegin();
}
function zf(r, e) {
  let t = !0;
  const s = r.createTexture();
  r.bindTexture(r.TEXTURE_2D, s), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 2, 2, 0, r.RGBA, e, null);
  const i = r.createFramebuffer();
  return r.bindFramebuffer(r.FRAMEBUFFER, i), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, s, 0), r.checkFramebufferStatus(r.FRAMEBUFFER) !== r.FRAMEBUFFER_COMPLETE && (t = !1), r.bindTexture(r.TEXTURE_2D, null), r.deleteTexture(s), r.bindFramebuffer(r.FRAMEBUFFER, null), r.deleteFramebuffer(i), t;
}
function Lx(r, e) {
  let t = !0;
  const s = r.createTexture();
  r.bindTexture(r.TEXTURE_2D, s), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE);
  const i = new Uint16Array(4 * 2 * 2);
  return r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 2, 2, 0, r.RGBA, e, i), r.getError() !== r.NO_ERROR && (t = !1, console.log("Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support")), r.bindTexture(r.TEXTURE_2D, null), r.deleteTexture(s), t;
}
function Px(r) {
  if (!r.textureFloatRenderable)
    return !1;
  const e = new Vr(r, pt.createDefinition(r, {
    name: "ptest1",
    vertexCode: yd,
    fragmentCode: Mx
  })), t = new Vr(r, pt.createDefinition(r, {
    name: "ptest2",
    vertexCode: yd,
    fragmentCode: Ex
  })), s = {
    format: vt,
    width: 1,
    height: 1,
    mipmaps: !1,
    minFilter: Be,
    magFilter: Be,
    name: "testFHP"
  }, i = new ue(r, s), n = new Dt({
    colorBuffer: i,
    depth: !1
  });
  xd(r, n, e), s.format = ye;
  const a = new ue(r, s), o = new Dt({
    colorBuffer: a,
    depth: !1
  });
  r.constantTexSource.setValue(i), xd(r, o, t);
  const h = r.activeFramebuffer;
  r.setFramebuffer(o.impl._glFrameBuffer);
  const l = new Uint8Array(4);
  r.readPixels(0, 0, 1, 1, l), r.setFramebuffer(h);
  const c = l[0] / 255, d = l[1] / 255, u = l[2] / 255, f = l[3] / 255, m = c / (256 * 256 * 256) + d / (256 * 256) + u / 256 + f;
  return i.destroy(), n.destroy(), a.destroy(), o.destroy(), e.destroy(), t.destroy(), m === 0;
}
function Ix(r) {
  const e = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 8, 6, 0, 0, 0, 31, 21, 196, 137, 0, 0, 0, 13, 73, 68, 65, 84, 120, 218, 99, 100, 100, 98, 182, 7, 0, 0, 89, 0, 71, 67, 133, 148, 237, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130]);
  return createImageBitmap(new Blob([e], {
    type: "image/png"
  }), {
    premultiplyAlpha: "none"
  }).then((t) => {
    const s = new ue(r, {
      width: 1,
      height: 1,
      format: ye,
      mipmaps: !1,
      levels: [t]
    }), i = new Dt({
      colorBuffer: s,
      depth: !1
    });
    r.setFramebuffer(i.impl._glFrameBuffer), r.initRenderTarget(i);
    const n = new Uint8ClampedArray(4);
    return r.gl.readPixels(0, 0, 1, 1, r.gl.RGBA, r.gl.UNSIGNED_BYTE, n), i.destroy(), s.destroy(), n[0] === 1 && n[1] === 2 && n[2] === 3 && n[3] === 63;
  }).catch((t) => !1);
}
class Dx extends Ru {
  constructor(e, t = {}) {
    super(e), this.gl = void 0, this.webgl2 = void 0, this.deviceType = I_, this.defaultFramebuffer = null, this.updateClientRect(), this.contextLost = !1, this._contextLostHandler = (p) => {
      p.preventDefault(), this.contextLost = !0, this.loseContext(), this.fire("devicelost");
    }, this._contextRestoredHandler = () => {
      this.restoreContext(), this.contextLost = !1, this.fire("devicerestored");
    }, t.stencil = !0, t.powerPreference || (t.powerPreference = "high-performance");
    const s = typeof navigator < "u" && navigator.userAgent;
    this.forceDisableMultisampling = s && s.includes("AppleWebKit") && (s.includes("15.4") || s.includes("15_4")), this.forceDisableMultisampling && (t.antialias = !1);
    const n = (t.preferWebGl2 !== void 0 ? t.preferWebGl2 : !0) ? ["webgl2", "webgl", "experimental-webgl"] : ["webgl", "experimental-webgl"];
    let a = null;
    for (let p = 0; p < n.length; p++)
      if (a = e.getContext(n[p], t), a) {
        this.webgl2 = n[p] === "webgl2";
        break;
      }
    if (this.gl = a, !a)
      throw new Error("WebGL not supported");
    const o = a.getParameter(a.ALPHA_BITS);
    this.framebufferFormat = o ? ye : Si;
    const h = lt.browser && !!window.chrome, l = lt.browser && navigator.appVersion.indexOf("Mac") !== -1;
    this._tempEnableSafariTextureUnitWorkaround = lt.browser && !!window.safari, this._tempMacChromeBlitFramebufferWorkaround = l && h && !t.alpha, this.webgl2 || e0(a), e.addEventListener("webglcontextlost", this._contextLostHandler, !1), e.addEventListener("webglcontextrestored", this._contextRestoredHandler, !1), this.initializeExtensions(), this.initializeCapabilities(), this.initializeRenderState(), this.initializeContextCaches(), this.supportsImageBitmap = null, typeof ImageBitmap < "u" && Ix(this).then((p) => {
      this.supportsImageBitmap = p;
    }), this.defaultClearOptions = {
      color: [0, 0, 0, 1],
      depth: 1,
      stencil: 0,
      flags: Ca | Aa
    }, this.glAddress = [a.REPEAT, a.CLAMP_TO_EDGE, a.MIRRORED_REPEAT], this.glBlendEquation = [a.FUNC_ADD, a.FUNC_SUBTRACT, a.FUNC_REVERSE_SUBTRACT, this.webgl2 ? a.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : a.FUNC_ADD, this.webgl2 ? a.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : a.FUNC_ADD], this.glBlendFunction = [a.ZERO, a.ONE, a.SRC_COLOR, a.ONE_MINUS_SRC_COLOR, a.DST_COLOR, a.ONE_MINUS_DST_COLOR, a.SRC_ALPHA, a.SRC_ALPHA_SATURATE, a.ONE_MINUS_SRC_ALPHA, a.DST_ALPHA, a.ONE_MINUS_DST_ALPHA, a.CONSTANT_COLOR, a.ONE_MINUS_CONSTANT_COLOR, a.CONSTANT_ALPHA, a.ONE_MINUS_CONSTANT_ALPHA], this.glComparison = [a.NEVER, a.LESS, a.EQUAL, a.LEQUAL, a.GREATER, a.NOTEQUAL, a.GEQUAL, a.ALWAYS], this.glStencilOp = [a.KEEP, a.ZERO, a.REPLACE, a.INCR, a.INCR_WRAP, a.DECR, a.DECR_WRAP, a.INVERT], this.glClearFlag = [0, a.COLOR_BUFFER_BIT, a.DEPTH_BUFFER_BIT, a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT, a.STENCIL_BUFFER_BIT, a.STENCIL_BUFFER_BIT | a.COLOR_BUFFER_BIT, a.STENCIL_BUFFER_BIT | a.DEPTH_BUFFER_BIT, a.STENCIL_BUFFER_BIT | a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT], this.glCull = [0, a.BACK, a.FRONT, a.FRONT_AND_BACK], this.glFilter = [a.NEAREST, a.LINEAR, a.NEAREST_MIPMAP_NEAREST, a.NEAREST_MIPMAP_LINEAR, a.LINEAR_MIPMAP_NEAREST, a.LINEAR_MIPMAP_LINEAR], this.glPrimitive = [a.POINTS, a.LINES, a.LINE_LOOP, a.LINE_STRIP, a.TRIANGLES, a.TRIANGLE_STRIP, a.TRIANGLE_FAN], this.glType = [a.BYTE, a.UNSIGNED_BYTE, a.SHORT, a.UNSIGNED_SHORT, a.INT, a.UNSIGNED_INT, a.FLOAT], this.pcUniformType = {}, this.pcUniformType[a.BOOL] = uh, this.pcUniformType[a.INT] = Ph, this.pcUniformType[a.FLOAT] = Or, this.pcUniformType[a.FLOAT_VEC2] = kr, this.pcUniformType[a.FLOAT_VEC3] = Nr, this.pcUniformType[a.FLOAT_VEC4] = zr, this.pcUniformType[a.INT_VEC2] = La, this.pcUniformType[a.INT_VEC3] = Pa, this.pcUniformType[a.INT_VEC4] = Ia, this.pcUniformType[a.BOOL_VEC2] = ud, this.pcUniformType[a.BOOL_VEC3] = fd, this.pcUniformType[a.BOOL_VEC4] = md, this.pcUniformType[a.FLOAT_MAT2] = Ih, this.pcUniformType[a.FLOAT_MAT3] = Dh, this.pcUniformType[a.FLOAT_MAT4] = Ur, this.pcUniformType[a.SAMPLER_2D] = j0, this.pcUniformType[a.SAMPLER_CUBE] = $0, this.webgl2 && (this.pcUniformType[a.SAMPLER_2D_SHADOW] = Y0, this.pcUniformType[a.SAMPLER_CUBE_SHADOW] = K0, this.pcUniformType[a.SAMPLER_3D] = Z0), this.targetToSlot = {}, this.targetToSlot[a.TEXTURE_2D] = 0, this.targetToSlot[a.TEXTURE_CUBE_MAP] = 1, this.targetToSlot[a.TEXTURE_3D] = 2;
    let c, d, u, f, m;
    this.commitFunction = [], this.commitFunction[uh] = function(p, g) {
      p.value !== g && (a.uniform1i(p.locationId, g), p.value = g);
    }, this.commitFunction[Ph] = this.commitFunction[uh], this.commitFunction[Or] = function(p, g) {
      p.value !== g && (a.uniform1f(p.locationId, g), p.value = g);
    }, this.commitFunction[kr] = function(p, g) {
      m = p.value, c = g[0], d = g[1], (m[0] !== c || m[1] !== d) && (a.uniform2fv(p.locationId, g), m[0] = c, m[1] = d);
    }, this.commitFunction[Nr] = function(p, g) {
      m = p.value, c = g[0], d = g[1], u = g[2], (m[0] !== c || m[1] !== d || m[2] !== u) && (a.uniform3fv(p.locationId, g), m[0] = c, m[1] = d, m[2] = u);
    }, this.commitFunction[zr] = function(p, g) {
      m = p.value, c = g[0], d = g[1], u = g[2], f = g[3], (m[0] !== c || m[1] !== d || m[2] !== u || m[3] !== f) && (a.uniform4fv(p.locationId, g), m[0] = c, m[1] = d, m[2] = u, m[3] = f);
    }, this.commitFunction[La] = function(p, g) {
      m = p.value, c = g[0], d = g[1], (m[0] !== c || m[1] !== d) && (a.uniform2iv(p.locationId, g), m[0] = c, m[1] = d);
    }, this.commitFunction[ud] = this.commitFunction[La], this.commitFunction[Pa] = function(p, g) {
      m = p.value, c = g[0], d = g[1], u = g[2], (m[0] !== c || m[1] !== d || m[2] !== u) && (a.uniform3iv(p.locationId, g), m[0] = c, m[1] = d, m[2] = u);
    }, this.commitFunction[fd] = this.commitFunction[Pa], this.commitFunction[Ia] = function(p, g) {
      m = p.value, c = g[0], d = g[1], u = g[2], f = g[3], (m[0] !== c || m[1] !== d || m[2] !== u || m[3] !== f) && (a.uniform4iv(p.locationId, g), m[0] = c, m[1] = d, m[2] = u, m[3] = f);
    }, this.commitFunction[md] = this.commitFunction[Ia], this.commitFunction[Ih] = function(p, g) {
      a.uniformMatrix2fv(p.locationId, !1, g);
    }, this.commitFunction[Dh] = function(p, g) {
      a.uniformMatrix3fv(p.locationId, !1, g);
    }, this.commitFunction[Ur] = function(p, g) {
      a.uniformMatrix4fv(p.locationId, !1, g);
    }, this.commitFunction[Ul] = function(p, g) {
      a.uniform1fv(p.locationId, g);
    }, this.commitFunction[Vl] = function(p, g) {
      a.uniform2fv(p.locationId, g);
    }, this.commitFunction[Gl] = function(p, g) {
      a.uniform3fv(p.locationId, g);
    }, this.commitFunction[Mu] = function(p, g) {
      a.uniform4fv(p.locationId, g);
    }, this.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;
    let _ = this.vertexUniformsCount;
    _ -= 4 * 4, _ -= 8, _ -= 1, _ -= 4 * 4, this.boneLimit = Math.floor(_ / 3), this.boneLimit = Math.min(this.boneLimit, 128), this.unmaskedRenderer === "Mali-450 MP" && (this.boneLimit = 34), this.constantTexSource = this.scope.resolve("source"), this.extTextureFloat ? this.webgl2 ? this.textureFloatRenderable = !!this.extColorBufferFloat : this.textureFloatRenderable = zf(a, a.FLOAT) : this.textureFloatRenderable = !1, this.extColorBufferHalfFloat ? this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat : this.extTextureHalfFloat ? this.webgl2 ? this.textureHalfFloatRenderable = !!this.extColorBufferFloat : this.textureHalfFloatRenderable = zf(a, this.extTextureHalfFloat.HALF_FLOAT_OES) : this.textureHalfFloatRenderable = !1, this.supportsMorphTargetTexturesCore = this.maxPrecision === "highp" && this.maxVertexTextures >= 2, this.supportsDepthShadow = this.webgl2, this._textureFloatHighPrecision = void 0, this._textureHalfFloatUpdatable = void 0, this.areaLightLutFormat = ye, this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear ? this.areaLightLutFormat = Pt : this.extTextureFloat && this.extTextureFloatLinear && (this.areaLightLutFormat = vt), this.postInit();
  }
  destroy() {
    super.destroy();
    const e = this.gl;
    this.webgl2 && this.feedback && e.deleteTransformFeedback(this.feedback), this.clearVertexArrayObjectCache(), this.canvas.removeEventListener("webglcontextlost", this._contextLostHandler, !1), this.canvas.removeEventListener("webglcontextrestored", this._contextRestoredHandler, !1), this._contextLostHandler = null, this._contextRestoredHandler = null, this.gl = null, super.postDestroy();
  }
  createVertexBufferImpl(e, t) {
    return new fx();
  }
  createIndexBufferImpl(e) {
    return new mx(e);
  }
  createShaderImpl(e) {
    return new qa(e);
  }
  createTextureImpl(e) {
    return new Sx();
  }
  createRenderTargetImpl(e) {
    return new bx();
  }
  getPrecision() {
    const e = this.gl;
    let t = "highp";
    if (e.getShaderPrecisionFormat) {
      const s = e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT), i = e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT), n = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT), a = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT), o = s.precision > 0 && n.precision > 0, h = i.precision > 0 && a.precision > 0;
      o || (h ? t = "mediump" : t = "lowp");
    }
    return t;
  }
  initializeExtensions() {
    const e = this.gl, t = e.getSupportedExtensions(), s = function() {
      for (let n = 0; n < arguments.length; n++)
        if (t.indexOf(arguments[n]) !== -1)
          return e.getExtension(arguments[n]);
      return null;
    };
    if (this.webgl2)
      this.extBlendMinmax = !0, this.extDrawBuffers = !0, this.extInstancing = !0, this.extStandardDerivatives = !0, this.extTextureFloat = !0, this.extTextureHalfFloat = !0, this.extTextureLod = !0, this.extUintElement = !0, this.extVertexArrayObject = !0, this.extColorBufferFloat = s("EXT_color_buffer_float"), this.extDisjointTimerQuery = s("EXT_disjoint_timer_query_webgl2", "EXT_disjoint_timer_query"), this.extDepthTexture = !0;
    else {
      if (this.extBlendMinmax = s("EXT_blend_minmax"), this.extDrawBuffers = s("EXT_draw_buffers"), this.extInstancing = s("ANGLE_instanced_arrays"), this.extInstancing) {
        const i = this.extInstancing;
        e.drawArraysInstanced = i.drawArraysInstancedANGLE.bind(i), e.drawElementsInstanced = i.drawElementsInstancedANGLE.bind(i), e.vertexAttribDivisor = i.vertexAttribDivisorANGLE.bind(i);
      }
      if (this.extStandardDerivatives = s("OES_standard_derivatives"), this.extTextureFloat = s("OES_texture_float"), this.extTextureHalfFloat = s("OES_texture_half_float"), this.extTextureLod = s("EXT_shader_texture_lod"), this.extUintElement = s("OES_element_index_uint"), this.extVertexArrayObject = s("OES_vertex_array_object"), this.extVertexArrayObject) {
        const i = this.extVertexArrayObject;
        e.createVertexArray = i.createVertexArrayOES.bind(i), e.deleteVertexArray = i.deleteVertexArrayOES.bind(i), e.isVertexArray = i.isVertexArrayOES.bind(i), e.bindVertexArray = i.bindVertexArrayOES.bind(i);
      }
      this.extColorBufferFloat = null, this.extDisjointTimerQuery = null, this.extDepthTexture = e.getExtension("WEBGL_depth_texture");
    }
    this.extDebugRendererInfo = s("WEBGL_debug_renderer_info"), this.extTextureFloatLinear = s("OES_texture_float_linear"), this.extTextureHalfFloatLinear = s("OES_texture_half_float_linear"), this.extFloatBlend = s("EXT_float_blend"), this.extTextureFilterAnisotropic = s("EXT_texture_filter_anisotropic", "WEBKIT_EXT_texture_filter_anisotropic"), this.extCompressedTextureETC1 = s("WEBGL_compressed_texture_etc1"), this.extCompressedTextureETC = s("WEBGL_compressed_texture_etc"), this.extCompressedTexturePVRTC = s("WEBGL_compressed_texture_pvrtc", "WEBKIT_WEBGL_compressed_texture_pvrtc"), this.extCompressedTextureS3TC = s("WEBGL_compressed_texture_s3tc", "WEBKIT_WEBGL_compressed_texture_s3tc"), this.extCompressedTextureATC = s("WEBGL_compressed_texture_atc"), this.extCompressedTextureASTC = s("WEBGL_compressed_texture_astc"), this.extParallelShaderCompile = s("KHR_parallel_shader_compile"), this.extColorBufferHalfFloat = s("EXT_color_buffer_half_float");
  }
  initializeCapabilities() {
    const e = this.gl;
    let t;
    const s = typeof navigator < "u" ? navigator.userAgent : "";
    this.maxPrecision = this.precision = this.getPrecision();
    const i = e.getContextAttributes();
    this.supportsMsaa = i.antialias, this.supportsStencil = i.stencil, this.supportsInstancing = !!this.extInstancing, this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxCubeMapSize = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), this.maxRenderBufferSize = e.getParameter(e.MAX_RENDERBUFFER_SIZE), this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.maxCombinedTextures = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.vertexUniformsCount = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), this.fragmentUniformsCount = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), this.webgl2 ? (this.maxDrawBuffers = e.getParameter(e.MAX_DRAW_BUFFERS), this.maxColorAttachments = e.getParameter(e.MAX_COLOR_ATTACHMENTS), this.maxVolumeSize = e.getParameter(e.MAX_3D_TEXTURE_SIZE)) : (t = this.extDrawBuffers, this.maxDrawBuffers = t ? e.getParameter(t.MAX_DRAW_BUFFERS_EXT) : 1, this.maxColorAttachments = t ? e.getParameter(t.MAX_COLOR_ATTACHMENTS_EXT) : 1, this.maxVolumeSize = 1), t = this.extDebugRendererInfo, this.unmaskedRenderer = t ? e.getParameter(t.UNMASKED_RENDERER_WEBGL) : "", this.unmaskedVendor = t ? e.getParameter(t.UNMASKED_VENDOR_WEBGL) : "";
    const n = /SM-[a-zA-Z0-9]+/;
    this.supportsGpuParticles = !(this.unmaskedVendor === "ARM" && s.match(n)), t = this.extTextureFilterAnisotropic, this.maxAnisotropy = t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1, this.samples = e.getParameter(e.SAMPLES), this.maxSamples = this.webgl2 && !this.forceDisableMultisampling ? e.getParameter(e.MAX_SAMPLES) : 1, this.supportsAreaLights = this.webgl2 || !lt.android, this.supportsTextureFetch = this.webgl2, this.maxTextures <= 8 && (this.supportsAreaLights = !1);
  }
  initializeRenderState() {
    super.initializeRenderState();
    const e = this.gl;
    this.blending = !1, e.disable(e.BLEND), this.blendSrc = We, this.blendDst = yn, this.blendSrcAlpha = We, this.blendDstAlpha = yn, this.separateAlphaBlend = !1, this.blendEquation = ot, this.blendAlphaEquation = ot, this.separateAlphaEquation = !1, e.blendFunc(e.ONE, e.ZERO), e.blendEquation(e.FUNC_ADD), this.blendColor = new z(0, 0, 0, 0), e.blendColor(0, 0, 0, 0), this.writeRed = !0, this.writeGreen = !0, this.writeBlue = !0, this.writeAlpha = !0, e.colorMask(!0, !0, !0, !0), this.cullMode = Br, e.enable(e.CULL_FACE), e.cullFace(e.BACK), this.depthTest = !0, e.enable(e.DEPTH_TEST), this.depthFunc = Sl, e.depthFunc(e.LEQUAL), this.depthWrite = !0, e.depthMask(!0), this.stencil = !1, e.disable(e.STENCIL_TEST), this.stencilFuncFront = this.stencilFuncBack = Mn, this.stencilRefFront = this.stencilRefBack = 0, this.stencilMaskFront = this.stencilMaskBack = 255, e.stencilFunc(e.ALWAYS, 0, 255), this.stencilFailFront = this.stencilFailBack = us, this.stencilZfailFront = this.stencilZfailBack = us, this.stencilZpassFront = this.stencilZpassBack = us, this.stencilWriteMaskFront = 255, this.stencilWriteMaskBack = 255, e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.stencilMask(255), this.alphaToCoverage = !1, this.raster = !0, this.webgl2 && (e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.disable(e.RASTERIZER_DISCARD)), this.depthBiasEnabled = !1, e.disable(e.POLYGON_OFFSET_FILL), this.clearDepth = 1, e.clearDepth(1), this.clearColor = new z(0, 0, 0, 0), e.clearColor(0, 0, 0, 0), this.clearStencil = 0, e.clearStencil(0), this.webgl2 ? e.hint(e.FRAGMENT_SHADER_DERIVATIVE_HINT, e.NICEST) : this.extStandardDerivatives && e.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, e.NICEST), e.enable(e.SCISSOR_TEST), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), this.unpackFlipY = !1, e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), this.unpackPremultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_ALIGNMENT, 1);
  }
  initializeContextCaches() {
    super.initializeContextCaches(), this._vaoMap = /* @__PURE__ */ new Map(), this.boundVao = null, this.activeFramebuffer = null, this.feedback = null, this.transformFeedbackBuffer = null, this.textureUnit = 0, this.textureUnits = [];
    for (let e = 0; e < this.maxCombinedTextures; e++)
      this.textureUnits.push([null, null, null]);
  }
  loseContext() {
    for (const e of this.shaders)
      e.loseContext();
    for (const e of this.textures)
      e.loseContext();
    for (const e of this.buffers)
      e.loseContext();
    for (const e of this.targets)
      e.loseContext();
  }
  restoreContext() {
    this.initializeExtensions(), this.initializeCapabilities(), this.initializeRenderState(), this.initializeContextCaches();
    for (const e of this.shaders)
      e.restoreContext();
    for (const e of this.buffers)
      e.unlock();
  }
  endShaderBatch() {
    qa.endShaderBatch(this);
  }
  setViewport(e, t, s, i) {
    (this.vx !== e || this.vy !== t || this.vw !== s || this.vh !== i) && (this.gl.viewport(e, t, s, i), this.vx = e, this.vy = t, this.vw = s, this.vh = i);
  }
  setScissor(e, t, s, i) {
    (this.sx !== e || this.sy !== t || this.sw !== s || this.sh !== i) && (this.gl.scissor(e, t, s, i), this.sx = e, this.sy = t, this.sw = s, this.sh = i);
  }
  setFramebuffer(e) {
    if (this.activeFramebuffer !== e) {
      const t = this.gl;
      t.bindFramebuffer(t.FRAMEBUFFER, e), this.activeFramebuffer = e;
    }
  }
  copyRenderTarget(e, t, s, i) {
    const n = this.gl;
    if (!this.webgl2 && i)
      return !1;
    if (s) {
      if (t) {
        if (e && (!e._colorBuffer || !t._colorBuffer || e._colorBuffer._format !== t._colorBuffer._format))
          return !1;
      } else if (!e._colorBuffer)
        return !1;
    }
    if (i && e && !e._depth && (!e._depthBuffer || !t._depthBuffer || e._depthBuffer._format !== t._depthBuffer._format))
      return !1;
    if (this.webgl2 && t) {
      const a = this.renderTarget;
      this.renderTarget = t, this.updateBegin(), n.bindFramebuffer(n.READ_FRAMEBUFFER, e ? e.impl._glFrameBuffer : null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, t.impl._glFrameBuffer);
      const o = e ? e.width : t.width, h = e ? e.height : t.height;
      n.blitFramebuffer(0, 0, o, h, 0, 0, o, h, (s ? n.COLOR_BUFFER_BIT : 0) | (i ? n.DEPTH_BUFFER_BIT : 0), n.NEAREST), this.renderTarget = a, n.bindFramebuffer(n.FRAMEBUFFER, a ? a.impl._glFrameBuffer : null);
    } else {
      const a = this.getCopyShader();
      this.constantTexSource.setValue(e._colorBuffer), xd(this, t, a);
    }
    return !0;
  }
  getCopyShader() {
    return this._copyShader || (this._copyShader = new Vr(this, pt.createDefinition(this, {
      name: "outputTex2D",
      vertexCode: yd,
      fragmentCode: Rx
    }))), this._copyShader;
  }
  startPass(e) {
    this.setRenderTarget(e.renderTarget), this.updateBegin();
    const t = e.colorOps, s = e.depthStencilOps;
    if (t.clear || s.clearDepth || s.clearStencil) {
      const i = e.renderTarget, n = i ? i.width : this.width, a = i ? i.height : this.height;
      this.setViewport(0, 0, n, a), this.setScissor(0, 0, n, a);
      let o = 0;
      const h = {};
      t.clear && (o |= Ca, h.color = [t.clearValue.r, t.clearValue.g, t.clearValue.b, t.clearValue.a]), s.clearDepth && (o |= Aa, h.depth = s.clearDepthValue), s.clearStencil && (o |= Ah, h.stencil = s.clearStencilValue), h.flags = o, this.clear(h);
    }
    this.insideRenderPass = !0;
  }
  endPass(e) {
    this.unbindVertexArray();
    const t = this.renderTarget;
    if (t) {
      if (this.webgl2) {
        Xn.length = 0;
        const s = this.gl;
        e.colorOps.store || e.colorOps.resolve || Xn.push(s.COLOR_ATTACHMENT0), e.depthStencilOps.storeDepth || Xn.push(s.DEPTH_ATTACHMENT), e.depthStencilOps.storeStencil || Xn.push(s.STENCIL_ATTACHMENT), Xn.length > 0 && e.fullSizeClearRect && s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Xn);
      }
      if (e.colorOps.resolve && this.webgl2 && e.samples > 1 && t.autoResolve && t.resolve(!0, !1), e.colorOps.mipmaps) {
        const s = t._colorBuffer;
        s && s.impl._glTexture && s.mipmaps && (s.pot || this.webgl2) && (this.activeTexture(this.maxCombinedTextures - 1), this.bindTexture(s), this.gl.generateMipmap(s.impl._glTarget));
      }
    }
    this.insideRenderPass = !1;
  }
  updateBegin() {
    if (this.boundVao = null, this._tempEnableSafariTextureUnitWorkaround)
      for (let t = 0; t < this.textureUnits.length; ++t)
        for (let s = 0; s < 3; ++s)
          this.textureUnits[t][s] = null;
    const e = this.renderTarget;
    e ? e.impl.initialized ? this.setFramebuffer(e.impl._glFrameBuffer) : this.initRenderTarget(e) : this.setFramebuffer(this.defaultFramebuffer);
  }
  updateEnd() {
    this.unbindVertexArray();
    const e = this.renderTarget;
    if (e) {
      this.webgl2 && e._samples > 1 && e.autoResolve && e.resolve();
      const t = e._colorBuffer;
      t && t.impl._glTexture && t.mipmaps && (t.pot || this.webgl2) && (this.activeTexture(this.maxCombinedTextures - 1), this.bindTexture(t), this.gl.generateMipmap(t.impl._glTarget));
    }
  }
  setUnpackFlipY(e) {
    if (this.unpackFlipY !== e) {
      this.unpackFlipY = e;
      const t = this.gl;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e);
    }
  }
  setUnpackPremultiplyAlpha(e) {
    if (this.unpackPremultiplyAlpha !== e) {
      this.unpackPremultiplyAlpha = e;
      const t = this.gl;
      t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e);
    }
  }
  activeTexture(e) {
    this.textureUnit !== e && (this.gl.activeTexture(this.gl.TEXTURE0 + e), this.textureUnit = e);
  }
  bindTexture(e) {
    const t = e.impl, s = t._glTarget, i = t._glTexture, n = this.textureUnit, a = this.targetToSlot[s];
    this.textureUnits[n][a] !== i && (this.gl.bindTexture(s, i), this.textureUnits[n][a] = i);
  }
  bindTextureOnUnit(e, t) {
    const s = e.impl, i = s._glTarget, n = s._glTexture, a = this.targetToSlot[i];
    this.textureUnits[t][a] !== n && (this.activeTexture(t), this.gl.bindTexture(i, n), this.textureUnits[t][a] = n);
  }
  setTextureParameters(e) {
    const t = this.gl, s = e._parameterFlags, i = e.impl._glTarget;
    if (s & 1) {
      let n = e._minFilter;
      (!e.pot && !this.webgl2 || !e._mipmaps || e._compressed && e._levels.length === 1) && (n === yl || n === xl ? n = Be : (n === vl || n === Ln) && (n = rt)), t.texParameteri(i, t.TEXTURE_MIN_FILTER, this.glFilter[n]);
    }
    if (s & 2 && t.texParameteri(i, t.TEXTURE_MAG_FILTER, this.glFilter[e._magFilter]), s & 4 && (this.webgl2 ? t.texParameteri(i, t.TEXTURE_WRAP_S, this.glAddress[e._addressU]) : t.texParameteri(i, t.TEXTURE_WRAP_S, this.glAddress[e.pot ? e._addressU : he])), s & 8 && (this.webgl2 ? t.texParameteri(i, t.TEXTURE_WRAP_T, this.glAddress[e._addressV]) : t.texParameteri(i, t.TEXTURE_WRAP_T, this.glAddress[e.pot ? e._addressV : he])), s & 16 && this.webgl2 && t.texParameteri(i, t.TEXTURE_WRAP_R, this.glAddress[e._addressW]), s & 32 && this.webgl2 && t.texParameteri(i, t.TEXTURE_COMPARE_MODE, e._compareOnRead ? t.COMPARE_REF_TO_TEXTURE : t.NONE), s & 64 && this.webgl2 && t.texParameteri(i, t.TEXTURE_COMPARE_FUNC, this.glComparison[e._compareFunc]), s & 128) {
      const n = this.extTextureFilterAnisotropic;
      n && t.texParameterf(i, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.max(1, Math.min(Math.round(e._anisotropy), this.maxAnisotropy)));
    }
  }
  setTexture(e, t) {
    e.impl._glTexture || e.impl.initialize(this, e), e._parameterFlags > 0 || e._needsUpload || e._needsMipmapsUpload ? (this.activeTexture(t), this.bindTexture(e), e._parameterFlags && (this.setTextureParameters(e), e._parameterFlags = 0), (e._needsUpload || e._needsMipmapsUpload) && (e.impl.upload(this, e), e._needsUpload = !1, e._needsMipmapsUpload = !1)) : this.bindTextureOnUnit(e, t);
  }
  createVertexArray(e) {
    let t, s;
    const i = e.length > 1;
    if (i) {
      t = "";
      for (let n = 0; n < e.length; n++) {
        const a = e[n];
        t += a.id + a.format.renderingingHash;
      }
      s = this._vaoMap.get(t);
    }
    if (!s) {
      const n = this.gl;
      s = n.createVertexArray(), n.bindVertexArray(s), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null);
      for (let a = 0; a < e.length; a++) {
        const o = e[a];
        n.bindBuffer(n.ARRAY_BUFFER, o.impl.bufferId);
        const h = o.format.elements;
        for (let l = 0; l < h.length; l++) {
          const c = h[l], d = De[c.name];
          n.vertexAttribPointer(d, c.numComponents, this.glType[c.dataType], c.normalize, c.stride, c.offset), n.enableVertexAttribArray(d), o.format.instancing && n.vertexAttribDivisor(d, 1);
        }
      }
      n.bindVertexArray(null), n.bindBuffer(n.ARRAY_BUFFER, null), i && this._vaoMap.set(t, s);
    }
    return s;
  }
  unbindVertexArray() {
    this.boundVao && (this.boundVao = null, this.gl.bindVertexArray(null));
  }
  setBuffers() {
    const e = this.gl;
    let t;
    if (this.vertexBuffers.length === 1) {
      const i = this.vertexBuffers[0];
      i.impl.vao || (i.impl.vao = this.createVertexArray(this.vertexBuffers)), t = i.impl.vao;
    } else
      t = this.createVertexArray(this.vertexBuffers);
    this.boundVao !== t && (this.boundVao = t, e.bindVertexArray(t)), this.vertexBuffers.length = 0;
    const s = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, s);
  }
  draw(e, t, s) {
    const i = this.gl;
    let n, a, o, h, l, c, d, u;
    const f = this.shader;
    if (!f)
      return;
    const m = f.impl.samplers, _ = f.impl.uniforms;
    s || this.setBuffers();
    let p = 0;
    for (let x = 0, y = m.length; x < y; x++) {
      if (n = m[x], a = n.scopeId.value, !a)
        return;
      if (a instanceof ue)
        o = a, this.setTexture(o, p), n.slot !== p && (i.uniform1i(n.locationId, p), n.slot = p), p++;
      else {
        n.array.length = 0, h = a.length;
        for (let S = 0; S < h; S++)
          o = a[S], this.setTexture(o, p), n.array[S] = p, p++;
        i.uniform1iv(n.locationId, n.array);
      }
    }
    for (let x = 0, y = _.length; x < y; x++)
      l = _[x], c = l.scopeId, d = l.version, u = c.versionObject.version, (d.globalId !== u.globalId || d.revision !== u.revision) && (d.globalId = u.globalId, d.revision = u.revision, c.value !== null && this.commitFunction[l.dataType](l, c.value));
    this.webgl2 && this.transformFeedbackBuffer && (i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId), i.beginTransformFeedback(i.POINTS));
    const g = this.glPrimitive[e.type], b = e.count;
    if (e.indexed) {
      const x = this.indexBuffer, y = x.impl.glFormat, S = e.base * x.bytesPerIndex;
      t > 0 ? i.drawElementsInstanced(g, b, y, S, t) : i.drawElements(g, b, y, S);
    } else {
      const x = e.base;
      t > 0 ? i.drawArraysInstanced(g, x, b, t) : i.drawArrays(g, x, b);
    }
    this.webgl2 && this.transformFeedbackBuffer && (i.endTransformFeedback(), i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, 0, null)), this._drawCallsPerFrame++;
  }
  clear(e) {
    const t = this.defaultClearOptions;
    e = e || t;
    const s = e.flags === void 0 ? t.flags : e.flags;
    if (s !== 0) {
      const i = this.gl;
      if (s & Ca) {
        const n = e.color === void 0 ? t.color : e.color;
        this.setClearColor(n[0], n[1], n[2], n[3]), this.setColorWrite(!0, !0, !0, !0);
      }
      if (s & Aa) {
        const n = e.depth === void 0 ? t.depth : e.depth;
        this.setClearDepth(n), this.setDepthWrite(!0);
      }
      if (s & Ah) {
        const n = e.stencil === void 0 ? t.stencil : e.stencil;
        this.setClearStencil(n);
      }
      i.clear(this.glClearFlag[s]);
    }
  }
  readPixels(e, t, s, i, n) {
    const a = this.gl;
    a.readPixels(e, t, s, i, a.RGBA, a.UNSIGNED_BYTE, n);
  }
  setClearDepth(e) {
    e !== this.clearDepth && (this.gl.clearDepth(e), this.clearDepth = e);
  }
  setClearColor(e, t, s, i) {
    const n = this.clearColor;
    (e !== n.r || t !== n.g || s !== n.b || i !== n.a) && (this.gl.clearColor(e, t, s, i), this.clearColor.set(e, t, s, i));
  }
  setClearStencil(e) {
    e !== this.clearStencil && (this.gl.clearStencil(e), this.clearStencil = e);
  }
  getDepthTest() {
    return this.depthTest;
  }
  setDepthTest(e) {
    if (this.depthTest !== e) {
      const t = this.gl;
      e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.depthTest = e;
    }
  }
  setDepthFunc(e) {
    this.depthFunc !== e && (this.gl.depthFunc(this.glComparison[e]), this.depthFunc = e);
  }
  getDepthWrite() {
    return this.depthWrite;
  }
  setDepthWrite(e) {
    this.depthWrite !== e && (this.gl.depthMask(e), this.depthWrite = e);
  }
  setColorWrite(e, t, s, i) {
    (this.writeRed !== e || this.writeGreen !== t || this.writeBlue !== s || this.writeAlpha !== i) && (this.gl.colorMask(e, t, s, i), this.writeRed = e, this.writeGreen = t, this.writeBlue = s, this.writeAlpha = i);
  }
  setAlphaToCoverage(e) {
    this.webgl2 && this.alphaToCoverage !== e && (this.alphaToCoverage = e, e ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE) : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE));
  }
  setTransformFeedbackBuffer(e) {
    if (this.transformFeedbackBuffer !== e && (this.transformFeedbackBuffer = e, this.webgl2)) {
      const t = this.gl;
      e ? (this.feedback || (this.feedback = t.createTransformFeedback()), t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, this.feedback)) : t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null);
    }
  }
  setRaster(e) {
    this.raster !== e && (this.raster = e, this.webgl2 && (e ? this.gl.disable(this.gl.RASTERIZER_DISCARD) : this.gl.enable(this.gl.RASTERIZER_DISCARD)));
  }
  setDepthBias(e) {
    this.depthBiasEnabled !== e && (this.depthBiasEnabled = e, e ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL));
  }
  setDepthBiasValues(e, t) {
    this.gl.polygonOffset(t, e);
  }
  getBlending() {
    return this.blending;
  }
  setBlending(e) {
    if (this.blending !== e) {
      const t = this.gl;
      e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.blending = e;
    }
  }
  setStencilTest(e) {
    if (this.stencil !== e) {
      const t = this.gl;
      e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.stencil = e;
    }
  }
  setStencilFunc(e, t, s) {
    (this.stencilFuncFront !== e || this.stencilRefFront !== t || this.stencilMaskFront !== s || this.stencilFuncBack !== e || this.stencilRefBack !== t || this.stencilMaskBack !== s) && (this.gl.stencilFunc(this.glComparison[e], t, s), this.stencilFuncFront = this.stencilFuncBack = e, this.stencilRefFront = this.stencilRefBack = t, this.stencilMaskFront = this.stencilMaskBack = s);
  }
  setStencilFuncFront(e, t, s) {
    if (this.stencilFuncFront !== e || this.stencilRefFront !== t || this.stencilMaskFront !== s) {
      const i = this.gl;
      i.stencilFuncSeparate(i.FRONT, this.glComparison[e], t, s), this.stencilFuncFront = e, this.stencilRefFront = t, this.stencilMaskFront = s;
    }
  }
  setStencilFuncBack(e, t, s) {
    if (this.stencilFuncBack !== e || this.stencilRefBack !== t || this.stencilMaskBack !== s) {
      const i = this.gl;
      i.stencilFuncSeparate(i.BACK, this.glComparison[e], t, s), this.stencilFuncBack = e, this.stencilRefBack = t, this.stencilMaskBack = s;
    }
  }
  setStencilOperation(e, t, s, i) {
    (this.stencilFailFront !== e || this.stencilZfailFront !== t || this.stencilZpassFront !== s || this.stencilFailBack !== e || this.stencilZfailBack !== t || this.stencilZpassBack !== s) && (this.gl.stencilOp(this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]), this.stencilFailFront = this.stencilFailBack = e, this.stencilZfailFront = this.stencilZfailBack = t, this.stencilZpassFront = this.stencilZpassBack = s), (this.stencilWriteMaskFront !== i || this.stencilWriteMaskBack !== i) && (this.gl.stencilMask(i), this.stencilWriteMaskFront = i, this.stencilWriteMaskBack = i);
  }
  setStencilOperationFront(e, t, s, i) {
    (this.stencilFailFront !== e || this.stencilZfailFront !== t || this.stencilZpassFront !== s) && (this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]), this.stencilFailFront = e, this.stencilZfailFront = t, this.stencilZpassFront = s), this.stencilWriteMaskFront !== i && (this.gl.stencilMaskSeparate(this.gl.FRONT, i), this.stencilWriteMaskFront = i);
  }
  setStencilOperationBack(e, t, s, i) {
    (this.stencilFailBack !== e || this.stencilZfailBack !== t || this.stencilZpassBack !== s) && (this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[e], this.glStencilOp[t], this.glStencilOp[s]), this.stencilFailBack = e, this.stencilZfailBack = t, this.stencilZpassBack = s), this.stencilWriteMaskBack !== i && (this.gl.stencilMaskSeparate(this.gl.BACK, i), this.stencilWriteMaskBack = i);
  }
  setBlendFunction(e, t) {
    (this.blendSrc !== e || this.blendDst !== t || this.separateAlphaBlend) && (this.gl.blendFunc(this.glBlendFunction[e], this.glBlendFunction[t]), this.blendSrc = e, this.blendDst = t, this.separateAlphaBlend = !1);
  }
  setBlendFunctionSeparate(e, t, s, i) {
    (this.blendSrc !== e || this.blendDst !== t || this.blendSrcAlpha !== s || this.blendDstAlpha !== i || !this.separateAlphaBlend) && (this.gl.blendFuncSeparate(this.glBlendFunction[e], this.glBlendFunction[t], this.glBlendFunction[s], this.glBlendFunction[i]), this.blendSrc = e, this.blendDst = t, this.blendSrcAlpha = s, this.blendDstAlpha = i, this.separateAlphaBlend = !0);
  }
  setBlendEquation(e) {
    (this.blendEquation !== e || this.separateAlphaEquation) && (this.gl.blendEquation(this.glBlendEquation[e]), this.blendEquation = e, this.separateAlphaEquation = !1);
  }
  setBlendEquationSeparate(e, t) {
    (this.blendEquation !== e || this.blendAlphaEquation !== t || !this.separateAlphaEquation) && (this.gl.blendEquationSeparate(this.glBlendEquation[e], this.glBlendEquation[t]), this.blendEquation = e, this.blendAlphaEquation = t, this.separateAlphaEquation = !0);
  }
  setBlendColor(e, t, s, i) {
    const n = this.blendColor;
    (e !== n.r || t !== n.g || s !== n.b || i !== n.a) && (this.gl.blendColor(e, t, s, i), n.set(e, t, s, i));
  }
  setCullMode(e) {
    if (this.cullMode !== e) {
      if (e === Ft)
        this.gl.disable(this.gl.CULL_FACE);
      else {
        this.cullMode === Ft && this.gl.enable(this.gl.CULL_FACE);
        const t = this.glCull[e];
        this.cullFace !== t && (this.gl.cullFace(t), this.cullFace = t);
      }
      this.cullMode = e;
    }
  }
  getCullMode() {
    return this.cullMode;
  }
  setShader(e) {
    if (e !== this.shader) {
      if (e.failed)
        return !1;
      if (!e.ready && !e.impl.finalize(this, e))
        return e.failed = !0, !1;
      this.shader = e, this.gl.useProgram(e.impl.glProgram), this.attributesInvalidated = !0;
    }
    return !0;
  }
  getHdrFormat(e, t, s, i) {
    const n = this.extTextureHalfFloat && (!t || this.textureHalfFloatRenderable) && (!s || this.textureHalfFloatUpdatable) && (!i || this.extTextureHalfFloatLinear), a = this.extTextureFloat && (!t || this.textureFloatRenderable) && (!i || this.extTextureFloatLinear);
    return n && a ? e ? vt : Pt : n ? Pt : a ? vt : null;
  }
  clearVertexArrayObjectCache() {
    const e = this.gl;
    this._vaoMap.forEach((t, s, i) => {
      e.deleteVertexArray(t);
    }), this._vaoMap.clear();
  }
  get width() {
    return this.gl.drawingBufferWidth || this.canvas.width;
  }
  get height() {
    return this.gl.drawingBufferHeight || this.canvas.height;
  }
  set fullscreen(e) {
    e ? this.gl.canvas.requestFullscreen() : document.exitFullscreen();
  }
  get fullscreen() {
    return !!document.fullscreenElement;
  }
  get textureFloatHighPrecision() {
    return this._textureFloatHighPrecision === void 0 && (this._textureFloatHighPrecision = Px(this)), this._textureFloatHighPrecision;
  }
  get textureHalfFloatUpdatable() {
    return this._textureHalfFloatUpdatable === void 0 && (this.webgl2 ? this._textureHalfFloatUpdatable = !0 : this._textureHalfFloatUpdatable = Lx(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES)), this._textureHalfFloatUpdatable;
  }
}
let Bx = 0;
class ji {
  constructor(e, t, s, i = ns, n) {
    this.device = e, this.format = t, this.numIndices = s, this.usage = i, this.id = Bx++, this.impl = e.createIndexBufferImpl(this);
    const a = tx[t];
    this.bytesPerIndex = a, this.numBytes = this.numIndices * a, n ? this.setData(n) : this.storage = new ArrayBuffer(this.numBytes), this.adjustVramSizeTracking(e._vram, this.numBytes), this.device.buffers.push(this);
  }
  destroy() {
    const e = this.device, t = e.buffers.indexOf(this);
    t !== -1 && e.buffers.splice(t, 1), this.device.indexBuffer === this && (this.device.indexBuffer = null), this.impl.initialized && (this.impl.destroy(e), this.adjustVramSizeTracking(e._vram, -this.storage.byteLength));
  }
  adjustVramSizeTracking(e, t) {
    e.ib += t;
  }
  loseContext() {
    this.impl.loseContext();
  }
  getFormat() {
    return this.format;
  }
  getNumIndices() {
    return this.numIndices;
  }
  lock() {
    return this.storage;
  }
  unlock() {
    this.impl.unlock(this);
  }
  setData(e) {
    return e.byteLength !== this.numBytes ? !1 : (this.storage = e, this.unlock(), !0);
  }
  _lockTypedArray() {
    const e = this.lock();
    return this.format === Pn ? new Uint32Array(e) : this.format === pi ? new Uint16Array(e) : new Uint8Array(e);
  }
  writeData(e, t) {
    const s = this._lockTypedArray();
    if (e.length > t)
      if (ArrayBuffer.isView(e))
        e = e.subarray(0, t), s.set(e);
      else
        for (let i = 0; i < t; i++)
          s[i] = e[i];
    else
      s.set(e);
    this.unlock();
  }
  readData(e) {
    const t = this._lockTypedArray(), s = this.numIndices;
    if (ArrayBuffer.isView(e))
      e.set(t);
    else {
      e.length = 0;
      for (let i = 0; i < s; i++)
        e[i] = t[i];
    }
    return s;
  }
}
function Fx(r) {
  this.array[this.index] = r;
}
function Ox(r, e) {
  this.array[this.index] = r, this.array[this.index + 1] = e;
}
function kx(r, e, t) {
  this.array[this.index] = r, this.array[this.index + 1] = e, this.array[this.index + 2] = t;
}
function Nx(r, e, t, s) {
  this.array[this.index] = r, this.array[this.index + 1] = e, this.array[this.index + 2] = t, this.array[this.index + 3] = s;
}
function zx(r, e, t) {
  this.array[r] = e[t];
}
function Ux(r, e, t) {
  this.array[r] = e[t], this.array[r + 1] = e[t + 1];
}
function Vx(r, e, t) {
  this.array[r] = e[t], this.array[r + 1] = e[t + 1], this.array[r + 2] = e[t + 2];
}
function Gx(r, e, t) {
  this.array[r] = e[t], this.array[r + 1] = e[t + 1], this.array[r + 2] = e[t + 2], this.array[r + 3] = e[t + 3];
}
function Hx(r, e, t) {
  e[t] = this.array[r];
}
function Wx(r, e, t) {
  e[t] = this.array[r], e[t + 1] = this.array[r + 1];
}
function qx(r, e, t) {
  e[t] = this.array[r], e[t + 1] = this.array[r + 1], e[t + 2] = this.array[r + 2];
}
function Xx(r, e, t) {
  e[t] = this.array[r], e[t + 1] = this.array[r + 1], e[t + 2] = this.array[r + 2], e[t + 3] = this.array[r + 3];
}
class jx {
  constructor(e, t, s) {
    switch (this.index = 0, this.numComponents = t.numComponents, s.interleaved ? this.array = new Ar[t.dataType](e, t.offset) : this.array = new Ar[t.dataType](e, t.offset, s.vertexCount * t.numComponents), this.stride = t.stride / this.array.constructor.BYTES_PER_ELEMENT, t.numComponents) {
      case 1:
        this.set = Fx, this.getToArray = Hx, this.setFromArray = zx;
        break;
      case 2:
        this.set = Ox, this.getToArray = Wx, this.setFromArray = Ux;
        break;
      case 3:
        this.set = kx, this.getToArray = qx, this.setFromArray = Vx;
        break;
      case 4:
        this.set = Nx, this.getToArray = Xx, this.setFromArray = Gx;
        break;
    }
  }
  get(e) {
    return this.array[this.index + e];
  }
  set(e, t, s, i) {
  }
  getToArray(e, t, s) {
  }
  setFromArray(e, t, s) {
  }
}
class Da {
  constructor(e) {
    this.vertexBuffer = e, this.vertexFormatSize = e.getFormat().size, this.buffer = this.vertexBuffer.lock(), this.accessors = [], this.element = {};
    const t = this.vertexBuffer.getFormat();
    for (let s = 0; s < t.elements.length; s++) {
      const i = t.elements[s];
      this.accessors[s] = new jx(this.buffer, i, t), this.element[i.name] = this.accessors[s];
    }
  }
  next(e = 1) {
    let t = 0;
    const s = this.accessors, i = this.accessors.length;
    for (; t < i; ) {
      const n = s[t++];
      n.index += e * n.stride;
    }
  }
  end() {
    this.vertexBuffer.unlock();
  }
  writeData(e, t, s) {
    const i = this.element[e];
    if (i) {
      s > this.vertexBuffer.numVertices && (s = this.vertexBuffer.numVertices);
      const n = i.numComponents;
      if (this.vertexBuffer.getFormat().interleaved) {
        let a = 0;
        for (let o = 0; o < s; o++)
          i.setFromArray(a, t, o * n), a += i.stride;
      } else if (t.length > s * n) {
        const a = s * n;
        if (ArrayBuffer.isView(t))
          t = t.subarray(0, a), i.array.set(t);
        else
          for (let o = 0; o < a; o++)
            i.array[o] = t[o];
      } else
        i.array.set(t);
    }
  }
  readData(e, t) {
    const s = this.element[e];
    let i = 0;
    if (s) {
      i = this.vertexBuffer.numVertices;
      let n;
      const a = s.numComponents;
      if (this.vertexBuffer.getFormat().interleaved) {
        Array.isArray(t) && (t.length = 0), s.index = 0;
        let o = 0;
        for (n = 0; n < i; n++)
          s.getToArray(o, t, n * a), o += s.stride;
      } else if (ArrayBuffer.isView(t))
        t.set(s.array);
      else {
        t.length = 0;
        const o = i * a;
        for (n = 0; n < o; n++)
          t[n] = s.array[n];
      }
    }
    return i;
  }
}
const $x = "mousedown", Yx = "mousemove", Kx = "mouseup", X_ = "mousewheel", Zx = -1;
function vd() {
  return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
}
class yr {
  constructor(e, t) {
    let s = {
      x: 0,
      y: 0
    };
    if (t) {
      if (t instanceof yr)
        throw Error("Expected MouseEvent");
      s = e._getTargetCoords(t);
    } else
      t = {};
    if (s)
      this.x = s.x, this.y = s.y;
    else if (vd())
      this.x = 0, this.y = 0;
    else
      return;
    this.wheelDelta = 0, t.type === "wheel" && (t.deltaY > 0 ? this.wheelDelta = 1 : t.deltaY < 0 && (this.wheelDelta = -1)), vd() ? (this.dx = t.movementX || t.webkitMovementX || t.mozMovementX || 0, this.dy = t.movementY || t.webkitMovementY || t.mozMovementY || 0) : (this.dx = this.x - e._lastX, this.dy = this.y - e._lastY), t.type === "mousedown" || t.type === "mouseup" ? this.button = t.button : this.button = Zx, this.buttons = e._buttons.slice(0), this.element = t.target, this.ctrlKey = t.ctrlKey || !1, this.altKey = t.altKey || !1, this.shiftKey = t.shiftKey || !1, this.metaKey = t.metaKey || !1, this.event = t;
  }
}
class Jx extends _e {
  constructor(e) {
    super(), this._lastX = 0, this._lastY = 0, this._buttons = [!1, !1, !1], this._lastbuttons = [!1, !1, !1], this._upHandler = this._handleUp.bind(this), this._downHandler = this._handleDown.bind(this), this._moveHandler = this._handleMove.bind(this), this._wheelHandler = this._handleWheel.bind(this), this._contextMenuHandler = (t) => {
      t.preventDefault();
    }, this._target = null, this._attached = !1, this.attach(e);
  }
  static isPointerLocked() {
    return vd();
  }
  attach(e) {
    if (this._target = e, this._attached)
      return;
    this._attached = !0;
    const t = lt.passiveEvents ? {
      passive: !1
    } : !1;
    window.addEventListener("mouseup", this._upHandler, t), window.addEventListener("mousedown", this._downHandler, t), window.addEventListener("mousemove", this._moveHandler, t), window.addEventListener("wheel", this._wheelHandler, t);
  }
  detach() {
    if (!this._attached)
      return;
    this._attached = !1, this._target = null;
    const e = lt.passiveEvents ? {
      passive: !1
    } : !1;
    window.removeEventListener("mouseup", this._upHandler, e), window.removeEventListener("mousedown", this._downHandler, e), window.removeEventListener("mousemove", this._moveHandler, e), window.removeEventListener("wheel", this._wheelHandler, e);
  }
  disableContextMenu() {
    this._target && this._target.addEventListener("contextmenu", this._contextMenuHandler);
  }
  enableContextMenu() {
    this._target && this._target.removeEventListener("contextmenu", this._contextMenuHandler);
  }
  enablePointerLock(e, t) {
    if (!document.body.requestPointerLock) {
      t && t();
      return;
    }
    const s = () => {
      e(), document.removeEventListener("pointerlockchange", s);
    }, i = () => {
      t(), document.removeEventListener("pointerlockerror", i);
    };
    e && document.addEventListener("pointerlockchange", s, !1), t && document.addEventListener("pointerlockerror", i, !1), document.body.requestPointerLock();
  }
  disablePointerLock(e) {
    if (!document.exitPointerLock)
      return;
    const t = () => {
      e(), document.removeEventListener("pointerlockchange", t);
    };
    e && document.addEventListener("pointerlockchange", t, !1), document.exitPointerLock();
  }
  update() {
    this._lastbuttons[0] = this._buttons[0], this._lastbuttons[1] = this._buttons[1], this._lastbuttons[2] = this._buttons[2];
  }
  isPressed(e) {
    return this._buttons[e];
  }
  wasPressed(e) {
    return this._buttons[e] && !this._lastbuttons[e];
  }
  wasReleased(e) {
    return !this._buttons[e] && this._lastbuttons[e];
  }
  _handleUp(e) {
    this._buttons[e.button] = !1;
    const t = new yr(this, e);
    t.event && this.fire(Kx, t);
  }
  _handleDown(e) {
    this._buttons[e.button] = !0;
    const t = new yr(this, e);
    t.event && this.fire($x, t);
  }
  _handleMove(e) {
    const t = new yr(this, e);
    t.event && (this.fire(Yx, t), this._lastX = t.x, this._lastY = t.y);
  }
  _handleWheel(e) {
    const t = new yr(this, e);
    t.event && this.fire(X_, t);
  }
  _getTargetCoords(e) {
    const t = this._target.getBoundingClientRect(), s = Math.floor(t.left), i = Math.floor(t.top);
    return e.clientX < s || e.clientX >= s + this._target.clientWidth || e.clientY < i || e.clientY >= i + this._target.clientHeight ? null : {
      x: e.clientX - s,
      y: e.clientY - i
    };
  }
}
class ve {
  get(e, t, s) {
    return typeof t == "function" && (s = t, t = {}), this.request("GET", e, t, s);
  }
  post(e, t, s, i) {
    return typeof s == "function" && (i = s, s = {}), s.postdata = t, this.request("POST", e, s, i);
  }
  put(e, t, s, i) {
    return typeof s == "function" && (i = s, s = {}), s.postdata = t, this.request("PUT", e, s, i);
  }
  del(e, t, s) {
    return typeof t == "function" && (s = t, t = {}), this.request("DELETE", e, t, s);
  }
  request(e, t, s, i) {
    let n, a, o, h = !1;
    if (typeof s == "function" && (i = s, s = {}), s.retry && (s = Object.assign({
      retries: 0,
      maxRetries: 5
    }, s)), s.callback = i, s.async == null && (s.async = !0), s.headers == null && (s.headers = {}), s.postdata != null)
      if (s.postdata instanceof Document)
        o = s.postdata;
      else if (s.postdata instanceof FormData)
        o = s.postdata;
      else if (s.postdata instanceof Object) {
        let c = s.headers["Content-Type"];
        switch (c === void 0 && (s.headers["Content-Type"] = ve.ContentType.FORM_URLENCODED, c = s.headers["Content-Type"]), c) {
          case ve.ContentType.FORM_URLENCODED: {
            o = "";
            let d = !0;
            for (const u in s.postdata)
              if (s.postdata.hasOwnProperty(u)) {
                d ? d = !1 : o += "&";
                const f = encodeURIComponent(u), m = encodeURIComponent(s.postdata[u]);
                o += `${f}=${m}`;
              }
            break;
          }
          default:
          case ve.ContentType.JSON:
            c == null && (s.headers["Content-Type"] = ve.ContentType.JSON), o = JSON.stringify(s.postdata);
            break;
        }
      } else
        o = s.postdata;
    if (s.cache === !1) {
      const c = Xi();
      n = new nc(t), n.query ? n.query = n.query + "&ts=" + c : n.query = "ts=" + c, t = n.toString();
    }
    s.query && (n = new nc(t), a = Hi(n.getQuery(), s.query), n.setQuery(a), t = n.toString());
    const l = new XMLHttpRequest();
    l.open(e, t, s.async), l.withCredentials = s.withCredentials !== void 0 ? s.withCredentials : !1, l.responseType = s.responseType || this._guessResponseType(t);
    for (const c in s.headers)
      s.headers.hasOwnProperty(c) && l.setRequestHeader(c, s.headers[c]);
    l.onreadystatechange = () => {
      this._onReadyStateChange(e, t, s, l);
    }, l.onerror = () => {
      this._onError(e, t, s, l), h = !0;
    };
    try {
      l.send(o);
    } catch (c) {
      h || s.error(l.status, l, c);
    }
    return l;
  }
  _guessResponseType(e) {
    const t = new nc(e), s = me.getExtension(t.path);
    return ve.binaryExtensions.indexOf(s) >= 0 ? ve.ResponseType.ARRAY_BUFFER : s === ".xml" ? ve.ResponseType.DOCUMENT : ve.ResponseType.TEXT;
  }
  _isBinaryContentType(e) {
    return [ve.ContentType.BASIS, ve.ContentType.BIN, ve.ContentType.DDS, ve.ContentType.GLB, ve.ContentType.MP3, ve.ContentType.MP4, ve.ContentType.OGG, ve.ContentType.OPUS, ve.ContentType.WAV].indexOf(e) >= 0;
  }
  _isBinaryResponseType(e) {
    return e === ve.ResponseType.ARRAY_BUFFER || e === ve.ResponseType.BLOB || e === ve.ResponseType.JSON;
  }
  _onReadyStateChange(e, t, s, i) {
    if (i.readyState === 4)
      switch (i.status) {
        case 0: {
          i.responseURL && i.responseURL.startsWith("file:///") ? this._onSuccess(e, t, s, i) : this._onError(e, t, s, i);
          break;
        }
        case 200:
        case 201:
        case 206:
        case 304: {
          this._onSuccess(e, t, s, i);
          break;
        }
        default: {
          this._onError(e, t, s, i);
          break;
        }
      }
  }
  _onSuccess(e, t, s, i) {
    let n, a;
    const o = i.getResponseHeader("Content-Type");
    o && (a = o.split(";")[0].trim());
    try {
      a === ve.ContentType.JSON || t.split("?")[0].endsWith(".json") ? n = JSON.parse(i.responseText) : this._isBinaryContentType(a) || this._isBinaryResponseType(i.responseType) ? n = i.response : i.responseType === ve.ResponseType.DOCUMENT || a === ve.ContentType.XML ? n = i.responseXML : n = i.responseText, s.callback(null, n);
    } catch (h) {
      s.callback(h);
    }
  }
  _onError(e, t, s, i) {
    if (!s.retrying)
      if (s.retry && s.retries < s.maxRetries) {
        s.retries++, s.retrying = !0;
        const n = U.clamp(Math.pow(2, s.retries) * ve.retryDelay, 0, s.maxRetryDelay || 5e3);
        console.log(`${e}: ${t} - Error ${i.status}. Retrying in ${n} ms`), setTimeout(() => {
          s.retrying = !1, this.request(e, t, s, s.callback);
        }, n);
      } else
        s.callback(i.status === 0 ? "Network error" : i.status, null);
  }
}
ve.ContentType = {
  AAC: "audio/aac",
  BASIS: "image/basis",
  BIN: "application/octet-stream",
  DDS: "image/dds",
  FORM_URLENCODED: "application/x-www-form-urlencoded",
  GIF: "image/gif",
  GLB: "model/gltf-binary",
  JPEG: "image/jpeg",
  JSON: "application/json",
  MP3: "audio/mpeg",
  MP4: "audio/mp4",
  OGG: "audio/ogg",
  OPUS: 'audio/ogg; codecs="opus"',
  PNG: "image/png",
  TEXT: "text/plain",
  WAV: "audio/x-wav",
  XML: "application/xml"
};
ve.ResponseType = {
  TEXT: "text",
  ARRAY_BUFFER: "arraybuffer",
  BLOB: "blob",
  DOCUMENT: "document",
  JSON: "json"
};
ve.binaryExtensions = [".model", ".wav", ".ogg", ".mp3", ".mp4", ".m4a", ".aac", ".dds", ".basis", ".glb", ".opus"];
ve.retryDelay = 100;
const $e = new ve();
function bi() {
  return typeof AudioContext < "u" || typeof webkitAudioContext < "u";
}
class Fh {
  constructor(e, t, s = {}) {
    if (this.volume = s.volume === void 0 ? 1 : s.volume, this.loop = s.loop === void 0 ? !1 : s.loop, this.pitch = s.pitch === void 0 ? 1 : s.pitch, this.sound = t, this.paused = !1, this.suspended = !1, this.manager = e, this.source = null, bi()) {
      this.startTime = 0, this.startOffset = 0;
      const i = e.context;
      this.gain = i.createGain();
    } else
      t.audio && (this.source = t.audio.cloneNode(!1), this.source.pause());
  }
  getVolume() {
    return this.volume;
  }
  getLoop() {
    return this.loop;
  }
  setLoop(e) {
    this.loop = e, this.source && (this.source.loop = e);
  }
  getPitch() {
    return this.pitch;
  }
  onManagerVolumeChange() {
    this.setVolume(this.getVolume());
  }
  onManagerSuspend() {
    this.isPlaying() && !this.suspended && (this.suspended = !0, this.pause());
  }
  onManagerResume() {
    this.suspended && (this.suspended = !1, this.unpause());
  }
  play() {
    if (this.source)
      throw new Error("Call stop() before calling play()");
    this._createSource(), this.source && (this.startTime = this.manager.context.currentTime, this.source.start(0, this.startOffset % this.source.buffer.duration), this.setVolume(this.volume), this.setLoop(this.loop), this.setPitch(this.pitch), this.manager.on("volumechange", this.onManagerVolumeChange, this), this.manager.on("suspend", this.onManagerSuspend, this), this.manager.on("resume", this.onManagerResume, this), this.manager.suspended && this.onManagerSuspend());
  }
  pause() {
    this.source && (this.paused = !0, this.startOffset += this.manager.context.currentTime - this.startTime, this.source.stop(0), this.source = null);
  }
  unpause() {
    if (this.source || !this.paused) {
      console.warn("Call pause() before unpausing.");
      return;
    }
    this._createSource(), this.source && (this.startTime = this.manager.context.currentTime, this.source.start(0, this.startOffset % this.source.buffer.duration), this.setVolume(this.volume), this.setLoop(this.loop), this.setPitch(this.pitch), this.paused = !1);
  }
  stop() {
    this.source && (this.source.stop(0), this.source = null), this.manager.off("volumechange", this.onManagerVolumeChange, this), this.manager.off("suspend", this.onManagerSuspend, this), this.manager.off("resume", this.onManagerResume, this);
  }
  setVolume(e) {
    e = U.clamp(e, 0, 1), this.volume = e, this.gain && (this.gain.gain.value = e * this.manager.volume);
  }
  setPitch(e) {
    this.pitch = e, this.source && (this.source.playbackRate.value = e);
  }
  isPlaying() {
    return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
  }
  getDuration() {
    return this.source ? this.source.buffer.duration : 0;
  }
  _createSource() {
    const e = this.manager.context;
    this.sound.buffer && (this.source = e.createBufferSource(), this.source.buffer = this.sound.buffer, this.source.connect(this.gain), this.gain.connect(e.destination), this.loop || (this.source.onended = this.pause.bind(this)));
  }
}
bi() || Object.assign(Fh.prototype, {
  play: function() {
    this.source && (this.paused = !1, this.setVolume(this.volume), this.setLoop(this.loop), this.setPitch(this.pitch), this.source.play()), this.manager.on("volumechange", this.onManagerVolumeChange, this), this.manager.on("suspend", this.onManagerSuspend, this), this.manager.on("resume", this.onManagerResume, this), this.manager.suspended && this.onManagerSuspend();
  },
  pause: function() {
    this.source && (this.paused = !0, this.source.pause());
  },
  unpause: function() {
    this.source && (this.paused = !1, this.source.play());
  },
  stop: function() {
    this.source && this.source.pause(), this.manager.off("volumechange", this.onManagerVolumeChange, this), this.manager.off("suspend", this.onManagerSuspend, this), this.manager.off("resume", this.onManagerResume, this);
  },
  setVolume: function(r) {
    r = U.clamp(r, 0, 1), this.volume = r, this.source && (this.source.volume = r * this.manager.volume);
  },
  setPitch: function(r) {
    this.pitch = r, this.source && (this.source.playbackRate = r);
  },
  getDuration: function() {
    return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
  },
  isPlaying: function() {
    return !this.source.paused;
  }
});
const Qx = 1e4;
class Vi extends Fh {
  constructor(e, t, s) {
    super(e, t, s), this.position = new v(), this.velocity = new v(), bi() ? this.panner = e.context.createPanner() : (this.maxDistance = Qx, this.minDistance = 1, this.rollOffFactor = 1, this.distanceModel = gl);
  }
  getPosition() {
    return this.position;
  }
  setPosition(e) {
    this.position.copy(e);
    const t = this.panner;
    "positionX" in t ? (t.positionX.value = e.x, t.positionY.value = e.y, t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z);
  }
  getVelocity() {
    return this.velocity;
  }
  setVelocity(e) {
    this.velocity.copy(e);
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    this.panner.maxDistance = e;
  }
  getMinDistance() {
    return this.panner.refDistance;
  }
  setMinDistance(e) {
    this.panner.refDistance = e;
  }
  getRollOffFactor() {
    return this.panner.rolloffFactor;
  }
  setRollOffFactor(e) {
    this.panner.rolloffFactor = e;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    this.panner.distanceModel = e;
  }
  _createSource() {
    const e = this.manager.context;
    this.source = e.createBufferSource(), this.source.buffer = this.sound.buffer, this.source.connect(this.panner), this.panner.connect(this.gain), this.gain.connect(e.destination), this.loop || (this.source.onended = this.pause.bind(this));
  }
}
if (!bi()) {
  let r = new v();
  const e = function(s, i, n, a, o, h) {
    r = r.sub2(s, i);
    const l = r.length();
    if (l < n)
      return 1;
    if (l > a)
      return 0;
    let c = 0;
    return h === _l ? c = 1 - o * (l - n) / (a - n) : h === gl ? c = n / (n + o * (l - n)) : h === y_ && (c = Math.pow(l / n, -o)), U.clamp(c, 0, 1);
  };
  Object.assign(Vi.prototype, {
    setPosition: function(t) {
      if (this.position.copy(t), this.source) {
        const i = this.manager.listener.getPosition(), n = e(i, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel), a = this.getVolume();
        this.source.volume = a * n;
      }
    },
    getMaxDistance: function() {
      return this.maxDistance;
    },
    setMaxDistance: function(t) {
      this.maxDistance = t;
    },
    getMinDistance: function() {
      return this.minDistance;
    },
    setMinDistance: function(t) {
      this.minDistance = t;
    },
    getRollOffFactor: function() {
      return this.rollOffFactor;
    },
    setRollOffFactor: function(t) {
      this.rollOffFactor = t;
    },
    getDistanceModel: function() {
      return this.distanceModel;
    },
    setDistanceModel: function(t) {
      this.distanceModel = t;
    }
  });
}
class ev {
  constructor(e) {
    this._manager = e, this.position = new v(), this.velocity = new v(), this.orientation = new j();
  }
  getPosition() {
    return this.position;
  }
  setPosition(e) {
    this.position.copy(e);
    const t = this.listener;
    t && ("positionX" in t ? (t.positionX.value = e.x, t.positionY.value = e.y, t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z));
  }
  getVelocity() {
    return this.velocity;
  }
  setVelocity(e) {
  }
  setOrientation(e) {
    this.orientation.copy(e);
    const t = this.listener;
    if (t) {
      const s = e.data;
      "forwardX" in t ? (t.forwardX.value = -s[8], t.forwardY.value = -s[9], t.forwardZ.value = -s[10], t.upX.value = s[4], t.upY.value = s[5], t.upZ.value = s[6]) : t.setOrientation && t.setOrientation(-s[8], -s[9], -s[10], s[4], s[5], s[6]);
    }
  }
  getOrientation() {
    return this.orientation;
  }
  get listener() {
    const e = this._manager.context;
    return e ? e.listener : null;
  }
}
const vo = "running", Uf = ["click", "touchstart", "mousedown"];
class tv extends _e {
  constructor() {
    super(), this._context = null, this.AudioContext = typeof AudioContext < "u" && AudioContext || typeof webkitAudioContext < "u" && webkitAudioContext, this.AudioContext, this._unlockHandlerFunc = this._unlockHandler.bind(this), this._userSuspended = !1, this.listener = new ev(this), this._volume = 1;
  }
  set volume(e) {
    e = U.clamp(e, 0, 1), this._volume = e, this.fire("volumechange", e);
  }
  get volume() {
    return this._volume;
  }
  get suspended() {
    return this._userSuspended;
  }
  get context() {
    return !this._context && this.AudioContext && (this._context = new this.AudioContext(), this._context.state !== vo && this._registerUnlockListeners()), this._context;
  }
  suspend() {
    this._userSuspended || (this._userSuspended = !0, this._context && this._context.state === vo && this._suspend());
  }
  resume() {
    this._userSuspended && (this._userSuspended = !1, this._context && this._context.state !== vo && this._resume());
  }
  destroy() {
    if (this.fire("destroy"), this._context) {
      var e;
      this._removeUnlockListeners(), (e = this._context) == null || e.close(), this._context = null;
    }
  }
  playSound(e, t = {}) {
    let s = null;
    return Fh && (s = new Fh(this, e, t), s.play()), s;
  }
  playSound3d(e, t, s = {}) {
    let i = null;
    return Vi && (i = new Vi(this, e, s), i.setPosition(t), s.volume && i.setVolume(s.volume), s.loop && i.setLoop(s.loop), s.maxDistance && i.setMaxDistance(s.maxDistance), s.minDistance && i.setMinDistance(s.minDistance), s.rollOffFactor && i.setRollOffFactor(s.rollOffFactor), s.distanceModel && i.setDistanceModel(s.distanceModel), i.play()), i;
  }
  _resume() {
    this._context.resume().then(() => {
      const e = this._context.createBufferSource();
      e.buffer = this._context.createBuffer(1, 1, this._context.sampleRate), e.connect(this._context.destination), e.start(0), e.onended = (t) => {
        e.disconnect(0), this.fire("resume");
      };
    }, (e) => {
    }).catch((e) => {
    });
  }
  _suspend() {
    this._context.suspend().then(() => {
      this.fire("suspend");
    }, (e) => {
    }).catch((e) => {
    });
  }
  _unlockHandler() {
    this._removeUnlockListeners(), !this._userSuspended && this._context.state !== vo && this._resume();
  }
  _registerUnlockListeners() {
    Uf.forEach((e) => {
      window.addEventListener(e, this._unlockHandlerFunc, !1);
    });
  }
  _removeUnlockListeners() {
    Uf.forEach((e) => {
      window.removeEventListener(e, this._unlockHandlerFunc, !1);
    });
  }
}
class sv {
  constructor(e) {
    this.audio = void 0, this.buffer = void 0, e instanceof Audio ? this.audio = e : this.buffer = e;
  }
  get duration() {
    let e = 0;
    return this.buffer ? e = this.buffer.duration : this.audio && (e = this.audio.duration), e || 0;
  }
}
const Nt = 0, xr = 1, Ts = 2;
function zt(r, e) {
  return r % e || 0;
}
class xn extends _e {
  constructor(e, t, s) {
    super(), this.source = null, this._manager = e, this._volume = s.volume !== void 0 ? U.clamp(Number(s.volume) || 0, 0, 1) : 1, this._pitch = s.pitch !== void 0 ? Math.max(0.01, Number(s.pitch) || 0) : 1, this._loop = !!(s.loop !== void 0 && s.loop), this._sound = t, this._state = Ts, this._suspended = !1, this._suspendEndEvent = 0, this._suspendInstanceEvents = !1, this._playWhenLoaded = !0, this._startTime = Math.max(0, Number(s.startTime) || 0), this._duration = Math.max(0, Number(s.duration) || 0), this._startOffset = null, this._onPlayCallback = s.onPlay, this._onPauseCallback = s.onPause, this._onResumeCallback = s.onResume, this._onStopCallback = s.onStop, this._onEndCallback = s.onEnd, bi() ? (this._startedAt = 0, this._currentTime = 0, this._currentOffset = 0, this._inputNode = null, this._connectorNode = null, this._firstNode = null, this._lastNode = null, this._waitingContextSuspension = !1, this._initializeNodes(), this._endedHandler = this._onEnded.bind(this)) : (this._isReady = !1, this._loadedMetadataHandler = this._onLoadedMetadata.bind(this), this._timeUpdateHandler = this._onTimeUpdate.bind(this), this._endedHandler = this._onEnded.bind(this), this._createSource());
  }
  set currentTime(e) {
    if (!(e < 0))
      if (this._state === Nt) {
        const t = this._suspendInstanceEvents;
        this._suspendInstanceEvents = !0, this.stop(), this._startOffset = e, this.play(), this._suspendInstanceEvents = t;
      } else
        this._startOffset = e, this._currentTime = e;
  }
  get currentTime() {
    return this._startOffset !== null ? this._startOffset : this._state === xr ? this._currentTime : this._state === Ts || !this.source ? 0 : (this._updateCurrentTime(), this._currentTime);
  }
  set duration(e) {
    this._duration = Math.max(0, Number(e) || 0);
    const t = this._state === Nt;
    this.stop(), t && this.play();
  }
  get duration() {
    return this._sound ? this._duration ? zt(this._duration, this._sound.duration) : this._sound.duration : 0;
  }
  get isPaused() {
    return this._state === xr;
  }
  get isPlaying() {
    return this._state === Nt;
  }
  get isStopped() {
    return this._state === Ts;
  }
  get isSuspended() {
    return this._suspended;
  }
  set loop(e) {
    this._loop = !!e, this.source && (this.source.loop = this._loop);
  }
  get loop() {
    return this._loop;
  }
  set pitch(e) {
    this._currentOffset = this.currentTime, this._startedAt = this._manager.context.currentTime, this._pitch = Math.max(Number(e) || 0, 0.01), this.source && (this.source.playbackRate.value = this._pitch);
  }
  get pitch() {
    return this._pitch;
  }
  set sound(e) {
    this._sound = e, this._state !== Ts ? this.stop() : this._createSource();
  }
  get sound() {
    return this._sound;
  }
  set startTime(e) {
    this._startTime = Math.max(0, Number(e) || 0);
    const t = this._state === Nt;
    this.stop(), t && this.play();
  }
  get startTime() {
    return this._startTime;
  }
  set volume(e) {
    e = U.clamp(e, 0, 1), this._volume = e, this.gain && (this.gain.gain.value = e * this._manager.volume);
  }
  get volume() {
    return this._volume;
  }
  _onPlay() {
    this.fire("play"), this._onPlayCallback && this._onPlayCallback(this);
  }
  _onPause() {
    this.fire("pause"), this._onPauseCallback && this._onPauseCallback(this);
  }
  _onResume() {
    this.fire("resume"), this._onResumeCallback && this._onResumeCallback(this);
  }
  _onStop() {
    this.fire("stop"), this._onStopCallback && this._onStopCallback(this);
  }
  _onEnded() {
    if (this._suspendEndEvent > 0) {
      this._suspendEndEvent--;
      return;
    }
    this.fire("end"), this._onEndCallback && this._onEndCallback(this), this.stop();
  }
  _onManagerVolumeChange() {
    this.volume = this._volume;
  }
  _onManagerSuspend() {
    this._state === Nt && !this._suspended && (this._suspended = !0, this.pause());
  }
  _onManagerResume() {
    this._suspended && (this._suspended = !1, this.resume());
  }
  _initializeNodes() {
    this.gain = this._manager.context.createGain(), this._inputNode = this.gain, this._connectorNode = this.gain, this._connectorNode.connect(this._manager.context.destination);
  }
  play() {
    return this._state !== Ts && this.stop(), this._state = Nt, this._playWhenLoaded = !1, this._waitingContextSuspension ? !1 : this._manager.suspended ? (this._manager.once("resume", this._playAudioImmediate, this), this._waitingContextSuspension = !0, !1) : (this._playAudioImmediate(), !0);
  }
  _playAudioImmediate() {
    if (this._waitingContextSuspension = !1, this._state !== Nt)
      return;
    this.source || this._createSource();
    let e = zt(this._startOffset, this.duration);
    e = zt(this._startTime + e, this._sound.duration), this._startOffset = null, this._duration ? this.source.start(0, e, this._duration) : this.source.start(0, e), this._startedAt = this._manager.context.currentTime, this._currentTime = 0, this._currentOffset = e, this.volume = this._volume, this.loop = this._loop, this.pitch = this._pitch, this._manager.on("volumechange", this._onManagerVolumeChange, this), this._manager.on("suspend", this._onManagerSuspend, this), this._manager.on("resume", this._onManagerResume, this), this._manager.on("destroy", this._onManagerDestroy, this), this._suspendInstanceEvents || this._onPlay();
  }
  pause() {
    return this._playWhenLoaded = !1, this._state !== Nt ? !1 : (this._state = xr, this._waitingContextSuspension || (this._updateCurrentTime(), this._suspendEndEvent++, this.source.stop(0), this.source = null, this._startOffset = null, this._suspendInstanceEvents || this._onPause()), !0);
  }
  resume() {
    if (this._state !== xr)
      return !1;
    if (this._state = Nt, this._waitingContextSuspension)
      return !0;
    this.source || this._createSource();
    let e = this.currentTime;
    return this._startOffset !== null && (e = zt(this._startOffset, this.duration), e = zt(this._startTime + e, this._sound.duration), this._startOffset = null), this._duration ? this.source.start(0, e, this._duration) : this.source.start(0, e), this._startedAt = this._manager.context.currentTime, this._currentOffset = e, this.volume = this._volume, this.loop = this._loop, this.pitch = this._pitch, this._playWhenLoaded = !1, this._suspendInstanceEvents || this._onResume(), !0;
  }
  stop() {
    if (this._playWhenLoaded = !1, this._state === Ts)
      return !1;
    const e = this._state === Nt;
    return this._state = Ts, this._waitingContextSuspension || (this._manager.off("volumechange", this._onManagerVolumeChange, this), this._manager.off("suspend", this._onManagerSuspend, this), this._manager.off("resume", this._onManagerResume, this), this._manager.off("destroy", this._onManagerDestroy, this), this._startedAt = 0, this._currentTime = 0, this._currentOffset = 0, this._startOffset = null, this._suspendEndEvent++, e && this.source && this.source.stop(0), this.source = null, this._suspendInstanceEvents || this._onStop()), !0;
  }
  setExternalNodes(e, t) {
    if (!e) {
      console.error("The firstNode must be a valid Audio Node");
      return;
    }
    t || (t = e);
    const s = this._manager.context.destination;
    this._firstNode !== e && (this._firstNode ? this._connectorNode.disconnect(this._firstNode) : this._connectorNode.disconnect(s), this._firstNode = e, this._connectorNode.connect(e)), this._lastNode !== t && (this._lastNode && this._lastNode.disconnect(s), this._lastNode = t, this._lastNode.connect(s));
  }
  clearExternalNodes() {
    const e = this._manager.context.destination;
    this._firstNode && (this._connectorNode.disconnect(this._firstNode), this._firstNode = null), this._lastNode && (this._lastNode.disconnect(e), this._lastNode = null), this._connectorNode.connect(e);
  }
  getExternalNodes() {
    return [this._firstNode, this._lastNode];
  }
  _createSource() {
    if (!this._sound)
      return null;
    const e = this._manager.context;
    return this._sound.buffer && (this.source = e.createBufferSource(), this.source.buffer = this._sound.buffer, this.source.connect(this._inputNode), this.source.onended = this._endedHandler, this.source.loopStart = zt(this._startTime, this.source.buffer.duration), this._duration && (this.source.loopEnd = Math.max(this.source.loopStart, zt(this._startTime + this._duration, this.source.buffer.duration)))), this.source;
  }
  _updateCurrentTime() {
    this._currentTime = zt((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
  }
  _onManagerDestroy() {
    this.source && this._state === Nt && (this.source.stop(0), this.source = null);
  }
}
bi() || (Object.assign(xn.prototype, {
  play: function() {
    return this._state !== Ts && this.stop(), !this.source && !this._createSource() ? !1 : (this.volume = this._volume, this.pitch = this._pitch, this.loop = this._loop, this.source.play(), this._state = Nt, this._playWhenLoaded = !1, this._manager.on("volumechange", this._onManagerVolumeChange, this), this._manager.on("suspend", this._onManagerSuspend, this), this._manager.on("resume", this._onManagerResume, this), this._manager.on("destroy", this._onManagerDestroy, this), this._manager.suspended && this._onManagerSuspend(), this._suspendInstanceEvents || this._onPlay(), !0);
  },
  pause: function() {
    return !this.source || this._state !== Nt ? !1 : (this._suspendEndEvent++, this.source.pause(), this._playWhenLoaded = !1, this._state = xr, this._startOffset = null, this._suspendInstanceEvents || this._onPause(), !0);
  },
  resume: function() {
    return !this.source || this._state !== xr ? !1 : (this._state = Nt, this._playWhenLoaded = !1, this.source.paused && (this.source.play(), this._suspendInstanceEvents || this._onResume()), !0);
  },
  stop: function() {
    return !this.source || this._state === Ts ? !1 : (this._manager.off("volumechange", this._onManagerVolumeChange, this), this._manager.off("suspend", this._onManagerSuspend, this), this._manager.off("resume", this._onManagerResume, this), this._manager.off("destroy", this._onManagerDestroy, this), this._suspendEndEvent++, this.source.pause(), this._playWhenLoaded = !1, this._state = Ts, this._startOffset = null, this._suspendInstanceEvents || this._onStop(), !0);
  },
  setExternalNodes: function() {
  },
  clearExternalNodes: function() {
  },
  getExternalNodes: function() {
    return [null, null];
  },
  _onLoadedMetadata: function() {
    this.source.removeEventListener("loadedmetadata", this._loadedMetadataHandler), this._isReady = !0;
    let r = zt(this._startOffset, this.duration);
    r = zt(this._startTime + r, this._sound.duration), this._startOffset = null, this.source.currentTime = r;
  },
  _createSource: function() {
    return this._sound && this._sound.audio && (this._isReady = !1, this.source = this._sound.audio.cloneNode(!0), this.source.addEventListener("loadedmetadata", this._loadedMetadataHandler), this.source.addEventListener("timeupdate", this._timeUpdateHandler), this.source.onended = this._endedHandler), this.source;
  },
  _onTimeUpdate: function() {
    this._duration && this.source.currentTime > zt(this._startTime + this._duration, this.source.duration) && (this.loop ? this.source.currentTime = zt(this._startTime, this.source.duration) : (this.source.removeEventListener("timeupdate", this._timeUpdateHandler), this.source.pause(), this._onEnded()));
  },
  _onManagerDestroy: function() {
    this.source && this.source.pause();
  }
}), Object.defineProperty(xn.prototype, "volume", {
  get: function() {
    return this._volume;
  },
  set: function(r) {
    r = U.clamp(r, 0, 1), this._volume = r, this.source && (this.source.volume = r * this._manager.volume);
  }
}), Object.defineProperty(xn.prototype, "pitch", {
  get: function() {
    return this._pitch;
  },
  set: function(r) {
    this._pitch = Math.max(Number(r) || 0, 0.01), this.source && (this.source.playbackRate = this._pitch);
  }
}), Object.defineProperty(xn.prototype, "sound", {
  get: function() {
    return this._sound;
  },
  set: function(r) {
    this.stop(), this._sound = r;
  }
}), Object.defineProperty(xn.prototype, "currentTime", {
  get: function() {
    return this._startOffset !== null ? this._startOffset : this._state === Ts || !this.source ? 0 : this.source.currentTime - this._startTime;
  },
  set: function(r) {
    r < 0 || (this._startOffset = r, this.source && this._isReady && (this.source.currentTime = zt(this._startTime + zt(r, this.duration), this._sound.duration), this._startOffset = null));
  }
}));
const iv = 1e4;
class fr extends xn {
  constructor(e, t, s = {}) {
    super(e, t, s), this._position = new v(), this._velocity = new v(), s.position && (this.position = s.position), this.maxDistance = s.maxDistance !== void 0 ? Number(s.maxDistance) : iv, this.refDistance = s.refDistance !== void 0 ? Number(s.refDistance) : 1, this.rollOffFactor = s.rollOffFactor !== void 0 ? Number(s.rollOffFactor) : 1, this.distanceModel = s.distanceModel !== void 0 ? s.distanceModel : _l;
  }
  _initializeNodes() {
    this.gain = this._manager.context.createGain(), this.panner = this._manager.context.createPanner(), this.panner.connect(this.gain), this._inputNode = this.panner, this._connectorNode = this.gain, this._connectorNode.connect(this._manager.context.destination);
  }
  set position(e) {
    this._position.copy(e);
    const t = this.panner;
    "positionX" in t ? (t.positionX.value = e.x, t.positionY.value = e.y, t.positionZ.value = e.z) : t.setPosition && t.setPosition(e.x, e.y, e.z);
  }
  get position() {
    return this._position;
  }
  set velocity(e) {
    this._velocity.copy(e);
  }
  get velocity() {
    return this._velocity;
  }
  set maxDistance(e) {
    this.panner.maxDistance = e;
  }
  get maxDistance() {
    return this.panner.maxDistance;
  }
  set refDistance(e) {
    this.panner.refDistance = e;
  }
  get refDistance() {
    return this.panner.refDistance;
  }
  set rollOffFactor(e) {
    this.panner.rolloffFactor = e;
  }
  get rollOffFactor() {
    return this.panner.rolloffFactor;
  }
  set distanceModel(e) {
    this.panner.distanceModel = e;
  }
  get distanceModel() {
    return this.panner.distanceModel;
  }
}
if (!bi()) {
  let r = new v();
  const e = function(s, i, n, a, o, h) {
    r = r.sub2(s, i);
    const l = r.length();
    if (l < n)
      return 1;
    if (l > a)
      return 0;
    let c = 0;
    return h === _l ? c = 1 - o * (l - n) / (a - n) : h === gl ? c = n / (n + o * (l - n)) : h === y_ && (c = Math.pow(l / n, -o)), U.clamp(c, 0, 1);
  };
  Object.defineProperty(fr.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(t) {
      if (this._position.copy(t), this.source) {
        const i = this._manager.listener.getPosition(), n = e(i, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel), a = this.volume;
        this.source.volume = a * n * this._manager.volume;
      }
    }
  }), Object.defineProperty(fr.prototype, "maxDistance", {
    get: function() {
      return this._maxDistance;
    },
    set: function(t) {
      this._maxDistance = t;
    }
  }), Object.defineProperty(fr.prototype, "refDistance", {
    get: function() {
      return this._refDistance;
    },
    set: function(t) {
      this._refDistance = t;
    }
  }), Object.defineProperty(fr.prototype, "rollOffFactor", {
    get: function() {
      return this._rollOffFactor;
    },
    set: function(t) {
      this._rollOffFactor = t;
    }
  }), Object.defineProperty(fr.prototype, "distanceModel", {
    get: function() {
      return this._distanceModel;
    },
    set: function(t) {
      this._distanceModel = t;
    }
  });
}
const nv = 0, Oh = 1, Vt = 2, ss = 3, $i = 4, kh = 5, Nh = 6, Sd = 7, bd = 8, wd = 9, Td = 10, Hl = "none", rv = "linear", Lu = 2, av = 0, ov = 2, j_ = 15, wi = 0, kt = 1, Pu = 2, zh = 3, Xa = 4, de = 0, Se = 1, Ee = 2, hv = 3, Mt = 0, lv = 1, cv = 2, dv = 3, Iu = 0, uv = 1, gt = 0, Os = 1, li = 2, zs = 3, Us = 4, fv = 5, Zr = 6, zn = {};
zn[gt] = "PCF3";
zn[Os] = "VSM8";
zn[li] = "VSM16";
zn[zs] = "VSM32";
zn[Us] = "PCF5";
zn[fv] = "PCF1";
const Du = 1, Cd = 0, $_ = 0, Ds = 0, mv = 1, fh = 0, pv = 1, Bs = 0, Mr = 1, Ba = 0, Rt = 1, So = 2, _v = 0, gv = 1, Hs = 0, Wl = 1, yv = "mul", Uh = 0, Y_ = 1, xv = 2, Vh = 3, Gh = 0, vv = 1, Sv = 2, bv = 3, wv = 4, Tv = 0, ja = 1, Ad = 2, Md = 1, Hh = 2, K_ = 4, Z_ = 8, J_ = 16, Q_ = 32, Wh = 64, Bu = 128, qh = 256, eg = 512, Xh = 1024, jh = 2048, $h = 4096, Fu = 8192, Vs = 0, Gr = 1, Ou = 2, ci = 0, Ed = 1, Gs = 1, di = 2, ui = 4, Er = 0, fi = 1, As = 2, Hr = 3, vn = 4, oc = "forward", Cv = "depth", Av = "pick", Vf = "shadow", Ni = 0, ht = 1, it = 2, mh = 1, bo = 0, Rd = 0, Mv = 1, Ev = 2, Gf = 3, Rv = 4, Lv = 5, Hf = 1, mr = 2, Wf = 4, Pv = 8, ku = 0, Ld = 1, xe = 0, Oe = 1;
class Nu {
  constructor() {
    this._refCount = 0;
  }
  incRefCount() {
    this._refCount++;
  }
  decRefCount() {
    this._refCount--;
  }
  get refCount() {
    return this._refCount;
  }
}
class xi {
  static set(e) {
    xi._graphicsDevice = e;
  }
  static get() {
    return xi._graphicsDevice;
  }
}
xi._graphicsDevice = null;
let Iv = 0;
class Fs {
  constructor() {
    this.initDefaults();
  }
  initDefaults() {
    this.recreate = !1, this.verticesUsage = ns, this.indicesUsage = ns, this.maxVertices = 0, this.maxIndices = 0, this.vertexCount = 0, this.indexCount = 0, this.vertexStreamsUpdated = !1, this.indexStreamUpdated = !1, this.vertexStreamDictionary = {}, this.indices = null;
  }
  _changeVertexCount(e, t) {
    this.vertexCount || (this.vertexCount = e);
  }
}
Fs.DEFAULT_COMPONENTS_POSITION = 3;
Fs.DEFAULT_COMPONENTS_NORMAL = 3;
Fs.DEFAULT_COMPONENTS_UV = 2;
Fs.DEFAULT_COMPONENTS_COLORS = 4;
class Dv {
  constructor(e, t, s, i) {
    this.data = e, this.componentCount = t, this.dataType = s, this.dataTypeNormalize = i;
  }
}
class _s extends Nu {
  constructor(e) {
    super(), this.id = Iv++, this.device = e || xi.get(), this.vertexBuffer = null, this.indexBuffer = [null], this.primitive = [{
      type: 0,
      base: 0,
      count: 0
    }], this.skin = null, this._morph = null, this._geometryData = null, this._aabb = new Pe(), this.boneAabb = null;
  }
  set morph(e) {
    e !== this._morph && (this._morph && this._morph.decRefCount(), this._morph = e, e && e.incRefCount());
  }
  get morph() {
    return this._morph;
  }
  set aabb(e) {
    this._aabb = e;
  }
  get aabb() {
    return this._aabb;
  }
  destroy() {
    const e = this.morph;
    e && (this.morph = null, e.refCount < 1 && e.destroy()), this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = null);
    for (let t = 0; t < this.indexBuffer.length; t++)
      this._destroyIndexBuffer(t);
    this.indexBuffer.length = 0, this._geometryData = null;
  }
  _destroyIndexBuffer(e) {
    this.indexBuffer[e] && (this.indexBuffer[e].destroy(), this.indexBuffer[e] = null);
  }
  _initBoneAabbs(e) {
    this.boneAabb = [], this.boneUsed = [];
    let t, s, i, n, a;
    const o = [], h = [], l = this.boneUsed, c = this.skin.boneNames.length;
    let d, u, f;
    for (let y = 0; y < c; y++)
      o[y] = new v(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), h[y] = new v(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    const m = new Da(this.vertexBuffer), _ = m.element[et], p = m.element[Xs], g = m.element[ts], b = this.vertexBuffer.numVertices;
    for (let y = 0; y < b; y++) {
      for (let S = 0; S < 4; S++)
        if (p.array[p.index + S] > 0) {
          const w = g.array[g.index + S];
          if (l[w] = !0, t = _.array[_.index], s = _.array[_.index + 1], i = _.array[_.index + 2], n = h[w], a = o[w], a.x > t && (a.x = t), a.y > s && (a.y = s), a.z > i && (a.z = i), n.x < t && (n.x = t), n.y < s && (n.y = s), n.z < i && (n.z = i), e) {
            let M = d = t, T = u = s, A = f = i;
            for (let L = 0; L < e.length; L++) {
              const O = e[L], I = O.deltaPositions[y * 3], D = O.deltaPositions[y * 3 + 1], G = O.deltaPositions[y * 3 + 2];
              I < 0 ? M += I : d += I, D < 0 ? T += D : u += D, G < 0 ? A += G : f += G;
            }
            a.x > M && (a.x = M), a.y > T && (a.y = T), a.z > A && (a.z = A), n.x < d && (n.x = d), n.y < u && (n.y = u), n.z < f && (n.z = f);
          }
        }
      m.next();
    }
    const x = this.vertexBuffer.getFormat().elements.find((y) => y.name === et);
    if (x && x.normalize) {
      const y = (() => {
        switch (x.dataType) {
          case Nl:
            return (S) => Math.max(S / 127, -1);
          case gi:
            return (S) => S / 255;
          case zl:
            return (S) => Math.max(S / 32767, -1);
          case Bn:
            return (S) => S / 65535;
          default:
            return (S) => S;
        }
      })();
      for (let S = 0; S < c; S++)
        if (l[S]) {
          const C = o[S], w = h[S];
          C.set(y(C.x), y(C.y), y(C.z)), w.set(y(w.x), y(w.y), y(w.z));
        }
    }
    for (let y = 0; y < c; y++) {
      const S = new Pe();
      S.setMinMax(o[y], h[y]), this.boneAabb.push(S);
    }
  }
  _initGeometryData() {
    this._geometryData || (this._geometryData = new Fs(), this.vertexBuffer && (this._geometryData.vertexCount = this.vertexBuffer.numVertices, this._geometryData.maxVertices = this.vertexBuffer.numVertices), this.indexBuffer.length > 0 && this.indexBuffer[0] && (this._geometryData.indexCount = this.indexBuffer[0].numIndices, this._geometryData.maxIndices = this.indexBuffer[0].numIndices));
  }
  clear(e, t, s = 0, i = 0) {
    this._initGeometryData(), this._geometryData.initDefaults(), this._geometryData.recreate = !0, this._geometryData.maxVertices = s, this._geometryData.maxIndices = i, this._geometryData.verticesUsage = e ? ns : Na, this._geometryData.indicesUsage = t ? ns : Na;
  }
  setVertexStream(e, t, s, i, n = Ie, a = !1) {
    this._initGeometryData();
    const o = i || t.length / s;
    this._geometryData._changeVertexCount(o, e), this._geometryData.vertexStreamsUpdated = !0, this._geometryData.vertexStreamDictionary[e] = new Dv(t, s, n, a);
  }
  getVertexStream(e, t) {
    let s = 0, i = !1;
    if (this._geometryData) {
      const n = this._geometryData.vertexStreamDictionary[e];
      n && (i = !0, s = this._geometryData.vertexCount, ArrayBuffer.isView(t) ? t.set(n.data) : (t.length = 0, t.push(n.data)));
    }
    return i || this.vertexBuffer && (s = new Da(this.vertexBuffer).readData(e, t)), s;
  }
  setPositions(e, t = Fs.DEFAULT_COMPONENTS_POSITION, s) {
    this.setVertexStream(et, e, t, s, Ie, !1);
  }
  setNormals(e, t = Fs.DEFAULT_COMPONENTS_NORMAL, s) {
    this.setVertexStream(Gt, e, t, s, Ie, !1);
  }
  setUvs(e, t, s = Fs.DEFAULT_COMPONENTS_UV, i) {
    this.setVertexStream(Ef + e, t, s, i, Ie, !1);
  }
  setColors(e, t = Fs.DEFAULT_COMPONENTS_COLORS, s) {
    this.setVertexStream(It, e, t, s, Ie, !1);
  }
  setColors32(e, t) {
    this.setVertexStream(It, e, Fs.DEFAULT_COMPONENTS_COLORS, t, gi, !0);
  }
  setIndices(e, t) {
    this._initGeometryData(), this._geometryData.indexStreamUpdated = !0, this._geometryData.indices = e, this._geometryData.indexCount = t || e.length;
  }
  getPositions(e) {
    return this.getVertexStream(et, e);
  }
  getNormals(e) {
    return this.getVertexStream(Gt, e);
  }
  getUvs(e, t) {
    return this.getVertexStream(Ef + e, t);
  }
  getColors(e) {
    return this.getVertexStream(It, e);
  }
  getIndices(e) {
    let t = 0;
    if (this._geometryData && this._geometryData.indices) {
      const s = this._geometryData.indices;
      t = this._geometryData.indexCount, ArrayBuffer.isView(e) ? e.set(s) : (e.length = 0, e.push(s));
    } else
      this.indexBuffer.length > 0 && this.indexBuffer[0] && (t = this.indexBuffer[0].readData(e));
    return t;
  }
  update(e = Es, t = !0) {
    if (this._geometryData) {
      if (t) {
        const n = this._geometryData.vertexStreamDictionary[et];
        n && n.componentCount === 3 && this._aabb.compute(n.data, this._geometryData.vertexCount);
      }
      let s = this._geometryData.recreate;
      this._geometryData.vertexCount > this._geometryData.maxVertices && (s = !0, this._geometryData.maxVertices = this._geometryData.vertexCount), s && this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = null);
      let i = this._geometryData.recreate;
      this._geometryData.indexCount > this._geometryData.maxIndices && (i = !0, this._geometryData.maxIndices = this._geometryData.indexCount), i && this.indexBuffer.length > 0 && this.indexBuffer[0] && (this.indexBuffer[0].destroy(), this.indexBuffer[0] = null), this._geometryData.vertexStreamsUpdated && this._updateVertexBuffer(), this._geometryData.indexStreamUpdated && this._updateIndexBuffer(), this.primitive[0].type = e, this.indexBuffer.length > 0 && this.indexBuffer[0] ? this._geometryData.indexStreamUpdated && (this.primitive[0].count = this._geometryData.indexCount, this.primitive[0].indexed = !0) : this._geometryData.vertexStreamsUpdated && (this.primitive[0].count = this._geometryData.vertexCount, this.primitive[0].indexed = !1), this._geometryData.vertexCount = 0, this._geometryData.indexCount = 0, this._geometryData.vertexStreamsUpdated = !1, this._geometryData.indexStreamUpdated = !1, this._geometryData.recreate = !1, this.updateRenderStates();
    }
  }
  _buildVertexFormat(e) {
    const t = [];
    for (const s in this._geometryData.vertexStreamDictionary) {
      const i = this._geometryData.vertexStreamDictionary[s];
      t.push({
        semantic: s,
        components: i.componentCount,
        type: i.dataType,
        normalize: i.dataTypeNormalize
      });
    }
    return new Ot(this.device, t, e);
  }
  _updateVertexBuffer() {
    if (!this.vertexBuffer) {
      const s = this._geometryData.maxVertices, i = this._buildVertexFormat(s);
      this.vertexBuffer = new yi(this.device, i, s, this._geometryData.verticesUsage);
    }
    const e = new Da(this.vertexBuffer), t = this._geometryData.vertexCount;
    for (const s in this._geometryData.vertexStreamDictionary) {
      const i = this._geometryData.vertexStreamDictionary[s];
      e.writeData(s, i.data, t), delete this._geometryData.vertexStreamDictionary[s];
    }
    e.end();
  }
  _updateIndexBuffer() {
    if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
      const t = this._geometryData.maxVertices > 65535 ? Pn : pi;
      this.indexBuffer[0] = new ji(this.device, t, this._geometryData.maxIndices, this._geometryData.indicesUsage);
    }
    const e = this._geometryData.indices;
    e && (this.indexBuffer[0].writeData(e, this._geometryData.indexCount), this._geometryData.indices = null);
  }
  prepareRenderState(e) {
    e === Rt ? this.generateWireframe() : e === So && (this.primitive[So] = {
      type: so,
      base: 0,
      count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
      indexed: !1
    });
  }
  updateRenderStates() {
    this.primitive[So] && this.prepareRenderState(So), this.primitive[Rt] && this.prepareRenderState(Rt);
  }
  generateWireframe() {
    this._destroyIndexBuffer(Rt);
    const e = [];
    let t;
    if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
      const n = [[0, 1], [1, 2], [2, 0]], a = this.primitive[Ba].base, o = this.primitive[Ba].count, h = this.indexBuffer[Ba], l = new gd[h.format](h.storage), c = {};
      for (let d = a; d < a + o; d += 3)
        for (let u = 0; u < 3; u++) {
          const f = l[d + n[u][0]], m = l[d + n[u][1]], _ = f > m ? m << 16 | f : f << 16 | m;
          c[_] === void 0 && (c[_] = 0, e.push(f, m));
        }
      t = h.format;
    } else {
      for (let n = 0; n < this.vertexBuffer.numVertices; n += 3)
        e.push(n, n + 1, n + 1, n + 2, n + 2, n);
      t = e.length > 65535 ? Pn : pi;
    }
    const s = new ji(this.vertexBuffer.device, t, e.length);
    new gd[s.format](s.storage).set(e), s.unlock(), this.primitive[Rt] = {
      type: Ll,
      base: 0,
      count: e.length,
      indexed: !0
    }, this.indexBuffer[Rt] = s;
  }
}
const Jt = 4 / 64, ls = 1 - Jt * 2, Jr = [];
function Bv(r, e) {
  const t = e.length / 3, s = r.length / 3, i = new v(), n = new v(), a = new v(), o = new v(), h = new v(), l = new v(), c = [];
  for (let d = 0; d < r.length; d++)
    c[d] = 0;
  for (let d = 0; d < t; d++) {
    const u = e[d * 3], f = e[d * 3 + 1], m = e[d * 3 + 2];
    i.set(r[u * 3], r[u * 3 + 1], r[u * 3 + 2]), n.set(r[f * 3], r[f * 3 + 1], r[f * 3 + 2]), a.set(r[m * 3], r[m * 3 + 1], r[m * 3 + 2]), o.sub2(n, i), h.sub2(a, i), l.cross(o, h).normalize(), c[u * 3] += l.x, c[u * 3 + 1] += l.y, c[u * 3 + 2] += l.z, c[f * 3] += l.x, c[f * 3 + 1] += l.y, c[f * 3 + 2] += l.z, c[m * 3] += l.x, c[m * 3 + 1] += l.y, c[m * 3 + 2] += l.z;
  }
  for (let d = 0; d < s; d++) {
    const u = c[d * 3], f = c[d * 3 + 1], m = c[d * 3 + 2], _ = 1 / Math.sqrt(u * u + f * f + m * m);
    c[d * 3] *= _, c[d * 3 + 1] *= _, c[d * 3 + 2] *= _;
  }
  return c;
}
function Un(r, e, t, s) {
  const i = s.length / 3, n = r.length / 3, a = new v(), o = new v(), h = new v(), l = new q(), c = new q(), d = new q(), u = new v(), f = new v(), m = new Float32Array(n * 3), _ = new Float32Array(n * 3), p = [];
  for (let S = 0; S < i; S++) {
    const C = s[S * 3], w = s[S * 3 + 1], M = s[S * 3 + 2];
    a.set(r[C * 3], r[C * 3 + 1], r[C * 3 + 2]), o.set(r[w * 3], r[w * 3 + 1], r[w * 3 + 2]), h.set(r[M * 3], r[M * 3 + 1], r[M * 3 + 2]), l.set(t[C * 2], t[C * 2 + 1]), c.set(t[w * 2], t[w * 2 + 1]), d.set(t[M * 2], t[M * 2 + 1]);
    const T = o.x - a.x, A = h.x - a.x, L = o.y - a.y, O = h.y - a.y, I = o.z - a.z, D = h.z - a.z, G = c.x - l.x, X = d.x - l.x, E = c.y - l.y, P = d.y - l.y, B = G * P - X * E;
    if (B === 0)
      u.set(0, 1, 0), f.set(1, 0, 0);
    else {
      const k = 1 / B;
      u.set((P * T - E * A) * k, (P * L - E * O) * k, (P * I - E * D) * k), f.set((G * A - X * T) * k, (G * O - X * L) * k, (G * D - X * I) * k);
    }
    m[C * 3 + 0] += u.x, m[C * 3 + 1] += u.y, m[C * 3 + 2] += u.z, m[w * 3 + 0] += u.x, m[w * 3 + 1] += u.y, m[w * 3 + 2] += u.z, m[M * 3 + 0] += u.x, m[M * 3 + 1] += u.y, m[M * 3 + 2] += u.z, _[C * 3 + 0] += f.x, _[C * 3 + 1] += f.y, _[C * 3 + 2] += f.z, _[w * 3 + 0] += f.x, _[w * 3 + 1] += f.y, _[w * 3 + 2] += f.z, _[M * 3 + 0] += f.x, _[M * 3 + 1] += f.y, _[M * 3 + 2] += f.z;
  }
  const g = new v(), b = new v(), x = new v(), y = new v();
  for (let S = 0; S < n; S++) {
    x.set(e[S * 3], e[S * 3 + 1], e[S * 3 + 2]), g.set(m[S * 3], m[S * 3 + 1], m[S * 3 + 2]), b.set(_[S * 3], _[S * 3 + 1], _[S * 3 + 2]);
    const C = x.dot(g);
    y.copy(x).mulScalar(C), y.sub2(g, y).normalize(), p[S * 4] = y.x, p[S * 4 + 1] = y.y, p[S * 4 + 2] = y.z, y.cross(x, g), p[S * 4 + 3] = y.dot(b) < 0 ? -1 : 1;
  }
  return p;
}
function vi(r, e, t) {
  const s = new _s(r);
  return s.setPositions(e), t && (t.normals && s.setNormals(t.normals), t.tangents && s.setVertexStream(qs, t.tangents, 4), t.colors && s.setColors32(t.colors), t.uvs && s.setUvs(0, t.uvs), t.uvs1 && s.setUvs(1, t.uvs1), t.blendIndices && s.setVertexStream(ts, t.blendIndices, 4, t.blendIndices.length / 4, gi), t.blendWeights && s.setVertexStream(Xs, t.blendWeights, 4), t.indices && s.setIndices(t.indices)), s.update(), s;
}
function Fv(r, e) {
  const t = e && e.tubeRadius !== void 0 ? e.tubeRadius : 0.2, s = e && e.ringRadius !== void 0 ? e.ringRadius : 0.3, i = e && e.segments !== void 0 ? e.segments : 30, n = e && e.sides !== void 0 ? e.sides : 20, a = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, o = [], h = [], l = [], c = [];
  for (let u = 0; u <= n; u++)
    for (let f = 0; f <= i; f++) {
      const m = Math.cos(2 * Math.PI * f / i) * (s + t * Math.cos(2 * Math.PI * u / n)), _ = Math.sin(2 * Math.PI * u / n) * t, p = Math.sin(2 * Math.PI * f / i) * (s + t * Math.cos(2 * Math.PI * u / n)), g = Math.cos(2 * Math.PI * f / i) * Math.cos(2 * Math.PI * u / n), b = Math.sin(2 * Math.PI * u / n), x = Math.sin(2 * Math.PI * f / i) * Math.cos(2 * Math.PI * u / n), y = u / n, S = 1 - f / i;
      if (o.push(m, _, p), h.push(g, b, x), l.push(y, 1 - S), u < n && f < i) {
        const C = u * (i + 1) + f, w = (u + 1) * (i + 1) + f, M = u * (i + 1) + (f + 1), T = (u + 1) * (i + 1) + (f + 1);
        c.push(C, w, M), c.push(w, T, M);
      }
    }
  const d = {
    normals: h,
    uvs: l,
    uvs1: l,
    indices: c
  };
  return a && (d.tangents = Un(o, h, l, c)), vi(r, o, d);
}
function zu(r, e, t, s, i, n) {
  const a = new v(), o = new v(), h = new v(), l = new v(), c = new v(), d = new v(), u = [], f = [], m = [], _ = [], p = [];
  let g;
  if (t > 0)
    for (let b = 0; b <= s; b++)
      for (let x = 0; x <= i; x++) {
        const y = x / i * 2 * Math.PI - Math.PI, S = Math.sin(y), C = Math.cos(y);
        c.set(S * r, -t / 2, C * r), l.set(S * e, t / 2, C * e), a.lerp(c, l, b / s), o.sub2(l, c).normalize(), d.set(C, 0, -S), h.cross(d, o).normalize(), u.push(a.x, a.y, a.z), f.push(h.x, h.y, h.z);
        let w = x / i, M = b / s;
        m.push(w, 1 - M);
        const T = M;
        if (M = w, w = T, w = w * ls + Jt, M = M * ls + Jt, w /= 3, _.push(w, 1 - M), b < s && x < i) {
          const A = b * (i + 1) + x, L = b * (i + 1) + (x + 1), O = (b + 1) * (i + 1) + x, I = (b + 1) * (i + 1) + (x + 1);
          p.push(A, L, O), p.push(L, I, O);
        }
      }
  if (n) {
    const b = Math.floor(i / 2), x = i, y = t / 2;
    for (let S = 0; S <= b; S++) {
      const C = S * Math.PI * 0.5 / b, w = Math.sin(C), M = Math.cos(C);
      for (let T = 0; T <= x; T++) {
        const A = T * 2 * Math.PI / x - Math.PI / 2, L = Math.sin(A), I = Math.cos(A) * w, D = M, G = L * w;
        let X = 1 - T / x, E = 1 - S / b;
        u.push(I * e, D * e + y, G * e), f.push(I, D, G), m.push(X, 1 - E), X = X * ls + Jt, E = E * ls + Jt, X /= 3, E /= 3, X += 1 / 3, _.push(X, 1 - E);
      }
    }
    g = (s + 1) * (i + 1);
    for (let S = 0; S < b; ++S)
      for (let C = 0; C < x; ++C) {
        const w = S * (x + 1) + C, M = w + x + 1;
        p.push(g + w + 1, g + M, g + w), p.push(g + w + 1, g + M + 1, g + M);
      }
    for (let S = 0; S <= b; S++) {
      const C = Math.PI * 0.5 + S * Math.PI * 0.5 / b, w = Math.sin(C), M = Math.cos(C);
      for (let T = 0; T <= x; T++) {
        const A = T * 2 * Math.PI / x - Math.PI / 2, L = Math.sin(A), I = Math.cos(A) * w, D = M, G = L * w;
        let X = 1 - T / x, E = 1 - S / b;
        u.push(I * e, D * e - y, G * e), f.push(I, D, G), m.push(X, 1 - E), X = X * ls + Jt, E = E * ls + Jt, X /= 3, E /= 3, X += 2 / 3, _.push(X, 1 - E);
      }
    }
    g = (s + 1) * (i + 1) + (x + 1) * (b + 1);
    for (let S = 0; S < b; ++S)
      for (let C = 0; C < x; ++C) {
        const w = S * (x + 1) + C, M = w + x + 1;
        p.push(g + w + 1, g + M, g + w), p.push(g + w + 1, g + M + 1, g + M);
      }
  } else {
    if (g = (s + 1) * (i + 1), r > 0)
      for (let b = 0; b < i; b++) {
        const x = b / i * 2 * Math.PI, y = Math.sin(x), S = -t / 2, C = Math.cos(x);
        let w = 1 - (y + 1) / 2, M = (C + 1) / 2;
        u.push(y * r, S, C * r), f.push(0, -1, 0), m.push(w, 1 - M), w = w * ls + Jt, M = M * ls + Jt, w /= 3, M /= 3, w += 1 / 3, _.push(w, 1 - M), b > 1 && p.push(g, g + b, g + b - 1);
      }
    if (g += i, e > 0)
      for (let b = 0; b < i; b++) {
        const x = b / i * 2 * Math.PI, y = Math.sin(x), S = t / 2, C = Math.cos(x);
        let w = 1 - (y + 1) / 2, M = (C + 1) / 2;
        u.push(y * e, S, C * e), f.push(0, 1, 0), m.push(w, 1 - M), w = w * ls + Jt, M = M * ls + Jt, w /= 3, M /= 3, w += 2 / 3, _.push(w, 1 - M), b > 1 && p.push(g, g + b - 1, g + b);
      }
  }
  return {
    positions: u,
    normals: f,
    uvs: m,
    uvs1: _,
    indices: p
  };
}
function Ov(r, e) {
  let t = e && (e.radius || e.baseRadius);
  t = t !== void 0 ? t : 0.5;
  const s = e && e.height !== void 0 ? e.height : 1, i = e && e.heightSegments !== void 0 ? e.heightSegments : 5, n = e && e.capSegments !== void 0 ? e.capSegments : 20, a = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, o = zu(t, t, s, i, n, !1);
  return a && (o.tangents = Un(o.positions, o.normals, o.uvs, o.indices)), vi(r, o.positions, o);
}
function kv(r, e) {
  const t = e && e.radius !== void 0 ? e.radius : 0.3, s = e && e.height !== void 0 ? e.height : 1, i = e && e.heightSegments !== void 0 ? e.heightSegments : 1, n = e && e.sides !== void 0 ? e.sides : 20, a = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, o = zu(t, t, s - 2 * t, i, n, !0);
  return a && (o.tangents = Un(o.positions, o.normals, o.uvs, o.indices)), vi(r, o.positions, o);
}
function Uu(r, e) {
  const t = e && e.baseRadius !== void 0 ? e.baseRadius : 0.5, s = e && e.peakRadius !== void 0 ? e.peakRadius : 0, i = e && e.height !== void 0 ? e.height : 1, n = e && e.heightSegments !== void 0 ? e.heightSegments : 5, a = e && e.capSegments !== void 0 ? e.capSegments : 18, o = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, h = zu(t, s, i, n, a, !1);
  return o && (h.tangents = Un(h.positions, h.normals, h.uvs, h.indices)), vi(r, h.positions, h);
}
function wn(r, e) {
  const t = e && e.radius !== void 0 ? e.radius : 0.5, s = e && e.latitudeBands !== void 0 ? e.latitudeBands : 16, i = e && e.longitudeBands !== void 0 ? e.longitudeBands : 16, n = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, a = [], o = [], h = [], l = [];
  for (let d = 0; d <= s; d++) {
    const u = d * Math.PI / s, f = Math.sin(u), m = Math.cos(u);
    for (let _ = 0; _ <= i; _++) {
      const p = _ * 2 * Math.PI / i - Math.PI / 2, g = Math.sin(p), x = Math.cos(p) * f, y = m, S = g * f, C = 1 - _ / i, w = 1 - d / s;
      a.push(x * t, y * t, S * t), o.push(x, y, S), h.push(C, 1 - w);
    }
  }
  for (let d = 0; d < s; ++d)
    for (let u = 0; u < i; ++u) {
      const f = d * (i + 1) + u, m = f + i + 1;
      l.push(f + 1, m, f), l.push(f + 1, m + 1, m);
    }
  const c = {
    normals: o,
    uvs: h,
    uvs1: h,
    indices: l
  };
  return n && (c.tangents = Un(a, o, h, l)), vi(r, a, c);
}
function Nv(r, e) {
  const t = e && e.halfExtents !== void 0 ? e.halfExtents : new q(0.5, 0.5), s = e && e.widthSegments !== void 0 ? e.widthSegments : 5, i = e && e.lengthSegments !== void 0 ? e.lengthSegments : 5, n = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, a = [], o = [], h = [], l = [];
  let c = 0;
  for (let u = 0; u <= s; u++)
    for (let f = 0; f <= i; f++) {
      const m = -t.x + 2 * t.x * u / s, _ = 0, p = -(-t.y + 2 * t.y * f / i), g = u / s, b = f / i;
      a.push(m, _, p), o.push(0, 1, 0), h.push(g, 1 - b), u < s && f < i && (l.push(c + i + 1, c + 1, c), l.push(c + i + 1, c + i + 2, c + 1)), c++;
    }
  const d = {
    normals: o,
    uvs: h,
    uvs1: h,
    indices: l
  };
  return n && (d.tangents = Un(a, o, h, l)), vi(r, a, d);
}
function tg(r, e) {
  const t = e && e.halfExtents !== void 0 ? e.halfExtents : new v(0.5, 0.5, 0.5), s = e && e.widthSegments !== void 0 ? e.widthSegments : 1, i = e && e.lengthSegments !== void 0 ? e.lengthSegments : 1, n = e && e.heightSegments !== void 0 ? e.heightSegments : 1, a = e && e.calculateTangents !== void 0 ? e.calculateTangents : !1, o = [new v(-t.x, -t.y, t.z), new v(t.x, -t.y, t.z), new v(t.x, t.y, t.z), new v(-t.x, t.y, t.z), new v(t.x, -t.y, -t.z), new v(-t.x, -t.y, -t.z), new v(-t.x, t.y, -t.z), new v(t.x, t.y, -t.z)], h = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]], l = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]], c = {
    FRONT: 0,
    BACK: 1,
    TOP: 2,
    BOTTOM: 3,
    RIGHT: 4,
    LEFT: 5
  }, d = [], u = [], f = [], m = [], _ = [];
  let p = 0;
  const g = (x, y, S) => {
    const C = new v(), w = new v(), M = new v(), T = new v();
    for (let A = 0; A <= y; A++)
      for (let L = 0; L <= S; L++) {
        C.lerp(o[h[x][0]], o[h[x][1]], A / y), w.lerp(o[h[x][0]], o[h[x][2]], L / S), M.sub2(w, o[h[x][0]]), T.add2(C, M);
        let O = A / y, I = L / S;
        d.push(T.x, T.y, T.z), u.push(l[x][0], l[x][1], l[x][2]), f.push(O, 1 - I), O = O * ls + Jt, I = I * ls + Jt, O /= 3, I /= 3, O += x % 3 / 3, I += Math.floor(x / 3) / 3, m.push(O, 1 - I), A < y && L < S && (_.push(p + S + 1, p + 1, p), _.push(p + S + 1, p + S + 2, p + 1)), p++;
      }
  };
  g(c.FRONT, s, n), g(c.BACK, s, n), g(c.TOP, s, i), g(c.BOTTOM, s, i), g(c.RIGHT, i, n), g(c.LEFT, i, n);
  const b = {
    normals: u,
    uvs: f,
    uvs1: m,
    indices: _
  };
  return a && (b.tangents = Un(d, u, f, _)), vi(r, d, b);
}
function sg(r, e) {
  let t = null;
  for (let s = 0; s < Jr.length; s++)
    Jr[s].type === e && Jr[s].device === r && (t = Jr[s].primData);
  if (!t) {
    let s, i;
    switch (e) {
      case "box":
        s = tg(r, {
          halfExtents: new v(0.5, 0.5, 0.5)
        }), i = {
          x: 2,
          y: 2,
          z: 2,
          uv: 2 / 3
        };
        break;
      case "capsule":
        s = kv(r, {
          radius: 0.5,
          height: 2
        }), i = {
          x: Math.PI * 2,
          y: Math.PI,
          z: Math.PI * 2,
          uv: 1 / 3 + 1 / 3 / 3 * 2
        };
        break;
      case "cone":
        s = Uu(r, {
          baseRadius: 0.5,
          peakRadius: 0,
          height: 1
        }), i = {
          x: 2.54,
          y: 2.54,
          z: 2.54,
          uv: 1 / 3 + 1 / 3 / 3
        };
        break;
      case "cylinder":
        s = Ov(r, {
          radius: 0.5,
          height: 1
        }), i = {
          x: Math.PI,
          y: 0.79 * 2,
          z: Math.PI,
          uv: 1 / 3 + 1 / 3 / 3 * 2
        };
        break;
      case "plane":
        s = Nv(r, {
          halfExtents: new q(0.5, 0.5),
          widthSegments: 1,
          lengthSegments: 1
        }), i = {
          x: 0,
          y: 1,
          z: 0,
          uv: 1
        };
        break;
      case "sphere":
        s = wn(r, {
          radius: 0.5
        }), i = {
          x: Math.PI,
          y: Math.PI,
          z: Math.PI,
          uv: 1
        };
        break;
      case "torus":
        s = Fv(r, {
          tubeRadius: 0.2,
          ringRadius: 0.3
        }), i = {
          x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
          y: 0.4,
          z: 0.4,
          uv: 1
        };
        break;
      default:
        throw new Error("Invalid primitive type: " + e);
    }
    s.incRefCount(), t = {
      mesh: s,
      area: i
    }, Jr.push({
      type: e,
      device: r,
      primData: t
    });
  }
  return t;
}
class zv {
  constructor() {
    this.clearValue = new z(0, 0, 0, 1), this.clear = !1, this.store = !1, this.resolve = !0, this.mipmaps = !1;
  }
}
class Uv {
  constructor() {
    this.clearDepthValue = 1, this.clearStencilValue = 0, this.clearDepth = !1, this.clearStencil = !1, this.storeDepth = !1, this.storeStencil = !1;
  }
}
class vr {
  constructor(e, t) {
    this.name = void 0, this.renderTarget = void 0, this.samples = 0, this.colorOps = void 0, this.depthStencilOps = void 0, this.requiresCubemaps = !0, this.fullSizeClearRect = !0, this.before = void 0, this.after = void 0, this.device = e, this.execute = t;
  }
  init(e) {
    var t, s;
    this.renderTarget = e || null, this.colorOps = new zv(), this.depthStencilOps = new Uv(), this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1), this.samples === 1 && (this.colorOps.store = !0, this.colorOps.resolve = !1), (t = this.renderTarget) != null && (s = t.colorBuffer) != null && s.mipmaps && (this.colorOps.mipmaps = !0);
  }
  setClearColor(e) {
    this.colorOps.clearValue.copy(e), this.colorOps.clear = !0;
  }
  setClearDepth(e) {
    this.depthStencilOps.clearDepthValue = e, this.depthStencilOps.clearDepth = !0;
  }
  setClearStencil(e) {
    this.depthStencilOps.clearStencilValue = e, this.depthStencilOps.clearStencil = !0;
  }
  render() {
    var e, t;
    const s = this.device, i = this.renderTarget !== void 0;
    (e = this.before) == null || e.call(this), i && s.startPass(this), this.execute(), i && s.endPass(this), (t = this.after) == null || t.call(this);
  }
}
let Vv = 0;
class Vu {
  constructor(e, t, s) {
    this.id = Vv++, this.device = e, this.format = t, this.dirty = !0, this.impl = e.createBindGroupImpl(this), this.textures = [], this.uniformBuffers = [], this.defaultUniformBuffer = s, s && this.setUniformBuffer(Eu, s);
  }
  destroy() {
    this.impl.destroy(), this.impl = null, this.format = null, this.defaultUniformBuffer = null;
  }
  setUniformBuffer(e, t) {
    const s = this.format.bufferFormatsMap.get(e);
    this.uniformBuffers[s] !== t && (this.uniformBuffers[s] = t, this.dirty = !0);
  }
  setTexture(e, t) {
    const s = this.format.textureFormatsMap.get(e);
    this.textures[s] !== t && (this.textures[s] = t, this.dirty = !0);
  }
  update() {
    const e = this.format.textureFormats;
    for (let t = 0; t < e.length; t++) {
      const s = e[t], i = s.scopeId.value;
      this.setTexture(s.name, i);
    }
    this.dirty && (this.dirty = !1, this.impl.update(this));
  }
}
class $r {
  constructor(e, t) {
    this.uniformFormats = [], this.bindGroupFormats = [], this.uniformFormats[_d] = e, this.bindGroupFormats[_d] = t;
  }
  hasUniform(e) {
    for (let t = 0; t < this.uniformFormats.length; t++) {
      const s = this.uniformFormats[t];
      if (s != null && s.get(e))
        return !0;
    }
    return !1;
  }
  hasTexture(e) {
    for (let t = 0; t < this.bindGroupFormats.length; t++) {
      const s = this.bindGroupFormats[t];
      if (s != null && s.getTexture(e))
        return !0;
    }
    return !1;
  }
  generateKey() {
    return JSON.stringify(this);
  }
}
const Wt = [];
Wt[Or] = function(r, e, t) {
  const s = r.storageFloat32;
  s[t] = e;
};
Wt[kr] = (r, e, t) => {
  const s = r.storageFloat32;
  s[t] = e[0], s[t + 1] = e[1];
};
Wt[Nr] = (r, e, t) => {
  const s = r.storageFloat32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 2] = e[2];
};
Wt[zr] = (r, e, t) => {
  const s = r.storageFloat32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 2] = e[2], s[t + 3] = e[3];
};
Wt[Ph] = function(r, e, t) {
  const s = r.storageInt32;
  s[t] = e;
};
Wt[La] = function(r, e, t) {
  const s = r.storageInt32;
  s[t] = e[0], s[t + 1] = e[1];
};
Wt[Pa] = function(r, e, t) {
  const s = r.storageInt32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 2] = e[2];
};
Wt[Ia] = function(r, e, t) {
  const s = r.storageInt32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 2] = e[2], s[t + 3] = e[3];
};
Wt[Ih] = (r, e, t) => {
  const s = r.storageFloat32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 4] = e[2], s[t + 5] = e[3], s[t + 8] = e[4], s[t + 9] = e[5];
};
Wt[Dh] = (r, e, t) => {
  const s = r.storageFloat32;
  s[t] = e[0], s[t + 1] = e[1], s[t + 2] = e[2], s[t + 4] = e[3], s[t + 5] = e[4], s[t + 6] = e[5], s[t + 8] = e[6], s[t + 9] = e[7], s[t + 10] = e[8];
};
Wt[Ul] = function(r, e, t, s) {
  const i = r.storageFloat32;
  for (let n = 0; n < s; n++)
    i[t + n * 4] = e[n];
};
Wt[Vl] = (r, e, t, s) => {
  const i = r.storageFloat32;
  for (let n = 0; n < s; n++)
    i[t + n * 4] = e[n * 2], i[t + n * 4 + 1] = e[n * 2 + 1];
};
Wt[Gl] = (r, e, t, s) => {
  const i = r.storageFloat32;
  for (let n = 0; n < s; n++)
    i[t + n * 4] = e[n * 3], i[t + n * 4 + 1] = e[n * 3 + 1], i[t + n * 4 + 2] = e[n * 3 + 2];
};
class Gu {
  constructor(e, t) {
    this.device = e, this.format = t, this.impl = e.createUniformBufferImpl(this), this.storage = new ArrayBuffer(t.byteSize), this.storageFloat32 = new Float32Array(this.storage), this.storageInt32 = new Int32Array(this.storage), e._vram.ub += this.format.byteSize;
  }
  destroy() {
    const e = this.device;
    this.impl.destroy(e), e._vram.ub -= this.format.byteSize;
  }
  loseContext() {
    this.impl.loseContext();
  }
  setUniform(e) {
    const t = e.offset, s = e.scopeId.value;
    if (s != null) {
      const i = Wt[e.updateType];
      i ? i(this, s, t, e.count) : this.storageFloat32.set(s, t);
    }
  }
  set(e) {
    const t = this.format.map.get(e);
    t && this.setUniform(t);
  }
  update() {
    const e = this.format.uniforms;
    for (let t = 0; t < e.length; t++)
      this.setUniform(e[t]);
    this.impl.unlock(this);
  }
}
var Gv = `
uniform float alpha_ref;

void alphaTest(float a) {
		if (a < alpha_ref) discard;
}
`, Hv = `
void addAmbient() {
		dDiffuseLight += light_globalAmbient;
}
`, Wv = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif

void addAmbient() {
		vec3 dir = normalize(cubeMapRotate(dNormalW) * vec3(-1.0, 1.0, 1.0));
		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);

		vec4 raw = texture2D(texture_envAtlas, uv);
		vec3 linear = $DECODE(raw);
		dDiffuseLight += processEnvironment(linear);
}
`, qv = `
uniform vec3 ambientSH[9];

void addAmbient() {
		vec3 n = cubeMapRotate(dNormalW);

		vec3 color =
				ambientSH[0] +
				ambientSH[1] * n.x +
				ambientSH[2] * n.y +
				ambientSH[3] * n.z +
				ambientSH[4] * n.x * n.z +
				ambientSH[5] * n.z * n.y +
				ambientSH[6] * n.y * n.x +
				ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
				ambientSH[8] * (n.x * n.x - n.y * n.y);

		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`, Xv = `

void getAO() {
		dAo = 1.0;

		#ifdef MAPTEXTURE
		dAo *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dAo *= saturate(vVertexColor.$VC);
		#endif
}
`, jv = `
void occludeDiffuse() {
		dDiffuseLight *= dAo;
}
`, $v = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular() {
		// approximated specular occlusion from AO
		float specPow = exp2(dGlossiness * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);
		specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
}
`, Yv = `
void occludeSpecular() {
		// approximated specular occlusion from AO
		float specPow = exp2(dGlossiness * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(dNormalW, dViewDirW) + dAo, 0.01*specPow) - 1.0 + dAo);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
}
`, Kv = `
void occludeSpecular() {
		dSpecularLight *= dAo;
		dReflection *= dAo;
}
`, Zv = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular() {
		float specOcc = mix(1.0, dAo, material_occludeSpecularIntensity);
		dSpecularLight *= specOcc;
		dReflection *= specOcc;
}
`, Jv = `
uniform vec3 view_position;

uniform vec3 light_globalAmbient;

float square(float x) {
		return x*x;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 saturate(vec3 x) {
		return clamp(x, vec3(0.0), vec3(1.0));
}
`, Qv = `
attribute vec3 vertex_position;
attribute vec3 vertex_normal;
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;

vec3 dPositionW;
mat4 dModelMatrix;
mat3 dNormalMatrix;
`, eS = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`, tS = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`, sS = `
#define NINESLICED
#define NINESLICETILED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`, iS = `
#define SHADOWBIAS

float getShadowBias(float resolution, float maxBias) {
		return maxBias;
}
`, nS = `
varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

#ifdef GAUSS
uniform float weight[SAMPLES];
#endif

#ifdef PACKED
float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}
#endif

void main(void) {
		vec3 moments = vec3(0.0);
		vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
		for (int i=0; i<SAMPLES; i++) {
				vec4 c = texture2D(source, uv + pixelOffset * float(i));

				#ifdef PACKED
				c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
				#endif

				#ifdef GAUSS
				moments += c.xyz * weight[i];
				#else
				moments += c.xyz;
				#endif
		}

		#ifndef GAUSS
		moments /= float(SAMPLES);
		#endif

		#ifdef PACKED
		gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
		#else
		gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
		#endif
}
`, rS = `
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif

void getClearCoat() {
		ccSpecularity = 1.0;

		#ifdef MAPFLOAT
		ccSpecularity *= material_clearCoat;
		#endif

		#ifdef MAPTEXTURE
		ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccSpecularity *= saturate(vVertexColor.$VC);
		#endif
}
`, aS = `
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif

void getClearCoatGlossiness() {
		ccGlossiness = 1.0;

		#ifdef MAPFLOAT
		ccGlossiness *= material_clearCoatGloss;
		#endif

		#ifdef MAPTEXTURE
		ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		ccGlossiness = 1.0 - ccGlossiness;
		#endif

		ccGlossiness += 0.0000001;
}
`, oS = `
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif

void getClearCoatNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
		ccNormalW = normalize(dTBN * normalMap);
#else
		ccNormalW = dVertexNormalW;
#endif
}
`, hS = `
// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.
// Additionally offset to a tile in atlas within 3x3 subdivision is provided
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
		vec3 vAbs = abs(dir);
		float ma;
		vec2 uv;
		if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back

				faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
				ma = 0.5 / vAbs.z;
				uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);

				tileOffset.x = 2.0;
				tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;

		} else if(vAbs.y >= vAbs.x) {  // top index 2, bottom index 3

				faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
				ma = 0.5 / vAbs.y;
				uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);

				tileOffset.x = 1.0;
				tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;

		} else {    // left / right

				faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
				ma = 0.5 / vAbs.x;
				uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);

				tileOffset.x = 0.0;
				tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;

		}
		return uv * ma + 0.5;
}

// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {

		float faceIndex;
		vec2 tileOffset;
		vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);

		// move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas
		float atlasFaceSize = omniAtlasViewport.z;
		float tileSize = shadowTextureResolution * atlasFaceSize;
		float offset = shadowEdgePixels / tileSize;
		uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);

		// scale uv coordinates to cube face area within the viewport
		uv *= atlasFaceSize;

		// offset into face of the atlas (3x3 grid)
		uv += tileOffset * atlasFaceSize;

		// offset into the atlas viewport
		uv += omniAtlasViewport.xy;

		return uv;
}
`, lS = `
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
		return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}

// getCookie2D for clustered lighting including channel selector
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 projPos = transform * vec4(worldPosition, 1.0);
		return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}

// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
		return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`, cS = `
// Clustered Omni Sampling using atlas

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				return textureShadow(shadowMap, vec3(uv, shadowZ));
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				dShadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowParams.xyz);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowOmniClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				dShadowCoord = vec3(uv, shadowZ);
				return getShadowPCF5x5(shadowMap, shadowParams.xyz);
		}

		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				// no filter shadow sampling
				float depth = unpackFloat(textureShadow(shadowMap, uv));
				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				return depth > shadowZ ? 1.0 : 0.0;
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				// pcf3
				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				dShadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowParams.xyz);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 dir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);

				// pcf3
				float shadowZ = length(dir) * shadowParams.w + shadowParams.z;
				dShadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowParams.xyz);
		}

		#endif

#endif


// Clustered Spot Sampling using atlas

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(sampler2DShadow shadowMap, vec4 shadowParams) {
				return textureShadow(shadowMap, dShadowCoord);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(sampler2DShadow shadowMap, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowSpotClusteredPCF5(sampler2DShadow shadowMap, vec4 shadowParams) {
				return getShadowPCF5x5(shadowMap, shadowParams.xyz);
		}
		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec4 shadowParams) {

				float depth = unpackFloat(textureShadow(shadowMap, dShadowCoord.xy));

				return depth > dShadowCoord.z ? 1.0 : 0.0;

		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowParams);
		}

		#endif

#endif
`, dS = `
uniform sampler2D clusterWorldTexture;
uniform sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;

// complex ifdef expression are not supported, handle it here
// defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)
#if defined(CLUSTER_COOKIES)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif

#ifdef CLUSTER_SHADOWS
		#ifdef GL2
				// TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2
				uniform sampler2DShadow shadowAtlasTexture;
		#else
				uniform sampler2D shadowAtlasTexture;
		#endif
#endif

#ifdef CLUSTER_COOKIES
		uniform sampler2D cookieAtlasTexture;
#endif

#ifdef GL2
		uniform int clusterMaxCells;
#else
		uniform float clusterMaxCells;
		uniform vec4 lightsTextureInvSize;
#endif

uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;

// structure storing light properties of a clustered light
// it's sorted to have all vectors aligned to 4 floats to limit padding
struct ClusterLightData {

		// area light sizes / orientation
		vec3 halfWidth;

		// type of the light (spot or omni)
		float lightType;

		// area light sizes / orientation
		vec3 halfHeight;

		#ifdef GL2
				// light index
				int lightIndex;
		#else
				// v coordinate to look up the light textures - this is the same as lightIndex but in 0..1 range
				float lightV;
		#endif

		// world space position
		vec3 position;

		// area light shape
		float shape;

		// world space direction (spot light only)
		vec3 direction;

		// light follow mode
		float falloffMode;

		// color
		vec3 color;

		// 0.0 if the light doesn't cast shadows
		float shadowIntensity;

		// atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)
		vec3 omniAtlasViewport;

		// range of the light
		float range;

		// channel mask - one of the channels has 1, the others are 0
		vec4 cookieChannelMask;

		// shadow bias values
		float shadowBias;
		float shadowNormalBias;

		// spot light inner and outer angle cosine
		float innerConeAngleCos;
		float outerConeAngleCos;

		// 1.0 if the light has a cookie texture
		float cookie;

		// 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask
		float cookieRgb;

		// intensity of the cookie
		float cookieIntensity;

		// light mask
		float mask;
};

// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to
// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members
// of the structure if further similar issues are observed.

// shadow (spot light only) / cookie projection matrix
mat4 lightProjectionMatrix;

// macros for light properties
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )

// macros to test light shape
// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )

// macro to test light mask (mesh accepts dynamic vs lightmapped lights)
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
		// accept lights marked as dynamic or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask < 0.75)
#else
		// accept lights marked as lightmapped or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask > 0.25)
#endif

vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
		return vec4(
				bytes2floatRange4(d0, -2.0, 2.0),
				bytes2floatRange4(d1, -2.0, 2.0),
				bytes2floatRange4(d2, -2.0, 2.0),
				bytes2floatRange4(d3, -2.0, 2.0)
		);
}

#ifdef GL2

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
		}

#else

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);
		}

#endif

void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {

		// light index
		#ifdef GL2
				clusterLightData.lightIndex = int(lightIndex);
		#else
				clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;
		#endif

		// shared data from 8bit texture
		vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
		clusterLightData.lightType = lightInfo.x;
		clusterLightData.shape = lightInfo.y;
		clusterLightData.falloffMode = lightInfo.z;
		clusterLightData.shadowIntensity = lightInfo.w;

		// color
		vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
		vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
		clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;

		// cookie
		clusterLightData.cookie = colorB.z;

		// light mask
		clusterLightData.mask = colorB.w;

		#ifdef CLUSTER_TEXTURE_FLOAT

				vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
				clusterLightData.position = lightPosRange.xyz;
				clusterLightData.range = lightPosRange.w;

				// spot light direction
				vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
				clusterLightData.direction = lightDir_Unused.xyz;

		#else   // 8bit

				vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);
				vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);
				vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);
				clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;

				vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);
				clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;

				// spot light direction
				vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);
				vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);
				vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);
				clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;

		#endif
}

void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {

		// spot light cos angles
		vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
		clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
		clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}

void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
		#else
				vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);
				vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);
				clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));
		#endif
}

void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
				clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
		#else
				vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);
				vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);
				vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);
				clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));

				vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);
				vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);
				vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);
				clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));
		#endif
}

void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
		
		// shadow matrix
		#ifdef CLUSTER_TEXTURE_FLOAT
				vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
				vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
				vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
				vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
		#else
				vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);
				vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);
				vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);
				vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);
				vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);

				vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);
				vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);
				vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);
				vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);
				vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);

				vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);
				vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);
				vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);
				vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);
				vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);

				vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);
				vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);
				vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);
				vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);
				vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));
		#endif
		
		lightProjectionMatrix = mat4(m0, m1, m2, m3);
}

void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
		
		// shadow biases
		vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
		clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
		clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}

void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {

		vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
		clusterLightData.cookieIntensity = cookieA.x;
		clusterLightData.cookieRgb = cookieA.y;

		clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}

void evaluateLight(ClusterLightData light) {

		dAtten3 = vec3(1.0);

		// evaluate omni part of the light
		getLightDirPoint(light.position);

		#ifdef CLUSTER_AREALIGHTS

		// distance attenuation
		if (isClusteredLightArea(light)) { // area light

				// area lights
				decodeClusterLightAreaData(light);

				// handle light shape
				if (isClusteredLightRect(light)) {
						calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
				} else if (isClusteredLightDisk(light)) {
						calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
				} else { // sphere
						calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
				}

				dAtten = getFalloffWindow(light.range);

		} else

		#endif

		{   // punctual light

				if (isClusteredLightFalloffLinear(light))
						dAtten = getFalloffLinear(light.range);
				else
						dAtten = getFalloffInvSquared(light.range);
		}

		if (dAtten > 0.00001) {

				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// handle light shape
						if (isClusteredLightRect(light)) {
								dAttenD = getRectLightDiffuse() * 16.0;
						} else if (isClusteredLightDisk(light)) {
								dAttenD = getDiskLightDiffuse() * 16.0;
						} else { // sphere
								dAttenD = getSphereLightDiffuse() * 16.0;
						}

				} else

				#endif

				{
						dAtten *= getLightDiffuse();
				}

				// spot light falloff
				if (isClusteredLightSpot(light)) {
						decodeClusterLightSpot(light);
						dAtten *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos);
				}

				#if defined(CLUSTER_COOKIES_OR_SHADOWS)

				if (dAtten > 0.00001) {

						// shadow / cookie
						if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {

								// shared shadow / cookie data depends on light type
								if (isClusteredLightSpot(light)) {
										decodeClusterLightProjectionMatrixData(light);
								} else {
										decodeClusterLightOmniAtlasViewport(light);
								}

								float shadowTextureResolution = shadowAtlasParams.x;
								float shadowEdgePixels = shadowAtlasParams.y;

								#ifdef CLUSTER_COOKIES

								// cookie
								if (isClusteredLightCookie(light)) {
										decodeClusterLightCookieData(light);

										if (isClusteredLightSpot(light)) {
												dAtten3 = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
										} else {
												dAtten3 = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
										}
								}

								#endif

								#ifdef CLUSTER_SHADOWS

								// shadow
								if (isClusteredLightCastShadow(light)) {
										decodeClusterLightShadowData(light);

										vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);

										if (isClusteredLightSpot(light)) {

												// spot shadow
												getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams);
												
												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowSpotClusteredPCF1(shadowAtlasTexture, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowSpotClusteredPCF3(shadowAtlasTexture, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowSpotClusteredPCF5(shadowAtlasTexture, shadowParams);
												#endif
												dAtten *= mix(1.0, shadow, light.shadowIntensity);

										} else {

												// omni shadow
												normalOffsetPointShadow(shadowParams);  // normalBias adjusted for distance

												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowOmniClusteredPCF1(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowOmniClusteredPCF3(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowOmniClusteredPCF5(shadowAtlasTexture, shadowParams, light.omniAtlasViewport, shadowEdgePixels, dLightDirW);
												#endif
												dAtten *= mix(1.0, shadow, light.shadowIntensity);
										}
								}

								#endif
						}
				}

				#endif

				// diffuse / specular / clearcoat
				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// area light diffuse
						{
								vec3 areaDiffuse = (dAttenD * dAtten) * light.color * dAtten3;

								#if defined(LIT_SPECULAR)
										#if defined(LIT_CONSERVE_ENERGY)
												areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
										#endif
								#endif

								// area light diffuse - it does not mix diffuse lighting into specular attenuation
								dDiffuseLight += areaDiffuse;
						}

						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								// area light specular
								float areaLightSpecular;

								if (isClusteredLightRect(light)) {
										areaLightSpecular = getRectLightSpecular();
								} else if (isClusteredLightDisk(light)) {
										areaLightSpecular = getDiskLightSpecular();
								} else { // sphere
										areaLightSpecular = getSphereLightSpecular();
								}

								dSpecularLight += dLTCSpecFres * areaLightSpecular * dAtten * light.color * dAtten3;

								#ifdef LIT_CLEARCOAT

										// area light specular clear coat
										float areaLightSpecularCC;

										if (isClusteredLightRect(light)) {
												areaLightSpecularCC = getRectLightSpecularCC();
										} else if (isClusteredLightDisk(light)) {
												areaLightSpecularCC = getDiskLightSpecularCC();
										} else { // sphere
												areaLightSpecularCC = getSphereLightSpecularCC();
										}

										ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * dAtten * light.color  * dAtten3;

								#endif

						#endif

				} else

				#endif

				{    // punctual light

						// punctual light diffuse
						{
								vec3 punctualDiffuse = dAtten * light.color * dAtten3;

								#if defined(CLUSTER_AREALIGHTS)
								#if defined(LIT_SPECULAR)
								#if defined(LIT_CONSERVE_ENERGY)
										punctualDiffuse = mix(punctualDiffuse, vec3(0), dSpecularity);
								#endif
								#endif
								#endif

								dDiffuseLight += punctualDiffuse;
						}
	 
						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								vec3 halfDir = normalize(-dLightDirNormW + dViewDirW);
								
								// specular
								#ifdef LIT_SPECULAR_FRESNEL
										dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * getFresnel(dot(dViewDirW, halfDir), dSpecularity);
								#else
										dSpecularLight += getLightSpecular(halfDir) * dAtten * light.color * dAtten3 * dSpecularity;
								#endif

								#ifdef LIT_CLEARCOAT
										#ifdef LIT_SPECULAR_FRESNEL
												ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3 * getFresnelCC(dot(dViewDirW, halfDir));
										#else
												ccSpecularLight += getLightSpecularCC(halfDir) * dAtten * light.color * dAtten3;
										#endif
								#endif

								#ifdef LIT_SHEEN
										sSpecularLight += getLightSpecularSheen(halfDir) * dAtten * light.color * dAtten3;
								#endif

						#endif
				}
		}
}

void evaluateClusterLight(float lightIndex) {

		// decode core light data from textures
		ClusterLightData clusterLightData;
		decodeClusterLightCore(clusterLightData, lightIndex);

		// evaluate light if it uses accepted light mask
		if (acceptLightMask(clusterLightData))
				evaluateLight(clusterLightData);
}

void addClusteredLights() {
		// world space position to 3d integer cell cordinates in the cluster structure
		vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);

		// no lighting when cell coordinate is out of range
		if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {

				// cell index (mapping from 3d cell coordinates to linear memory)
				float cellIndex = dot(clusterCellsDot, cellCoords);

				// convert cell index to uv coordinates
				float clusterV = floor(cellIndex * clusterTextureSize.y);
				float clusterU = cellIndex - (clusterV * clusterTextureSize.x);

				#ifdef GL2

						// loop over maximum number of light cells
						for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {

								// using a single channel texture with data in alpha channel
								float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;
								evaluateClusterLight(lightIndex * 255.0); 
						}

				#else

						clusterV = (clusterV + 0.5) * clusterTextureSize.z;

						// loop over maximum possible number of supported light cells
						const float maxLightCells = 256.0;
						for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {

								float lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;

								if (lightIndex <= 0.0)
										return;
								
								evaluateClusterLight(lightIndex * 255.0); 

								// end of the cell array
								if (lightCellIndex >= clusterMaxCells) {
										break;
								}
						}

				#endif
		}
}
`, uS = `
vec3 combineColor() {
		vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
		ret += (dDiffuseLight - light_globalAmbient) * dAlbedo + material_ambient * light_globalAmbient;
#else
		ret += dAlbedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
		ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
		ret += dReflection.rgb * dReflection.a;
#endif

#ifdef LIT_SHEEN
		float sheenScaling = 1.0 - max(max(sSpecularity.r, sSpecularity.g), sSpecularity.b) * 0.157;
		ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sSpecularity;
#endif
#ifdef LIT_CLEARCOAT
		float clearCoatScaling = 1.0 - ccFresnel * ccSpecularity;
		ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * ccSpecularity;
#endif

		return ret;
}
`, fS = `
// light cookie functionality for non-clustered lights
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
		return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`, mS = `
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;

vec3 cubeMapProject(vec3 nrdir) {
		nrdir = cubeMapRotate(nrdir);

		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;

		vec3 rbminmax;
		rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
		rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
		rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;

		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);

		vec3 posonbox = vPositionW + nrdir * fa;
		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
		return normalize(posonbox - envBoxPos);
}
`, pS = `
vec3 cubeMapProject(vec3 dir) {
		return cubeMapRotate(dir);
}
`, _S = `
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif

vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
		return refDir * cubeMapRotationMatrix;
#else
		return refDir;
#endif
}
`, ig = `
vec3 decodeLinear(vec4 raw) {
		return raw.rgb;
}

float decodeGamma(float raw) {
		return pow(raw, 2.2);
}

vec3 decodeGamma(vec3 raw) {
		return pow(raw, vec3(2.2));
}

vec3 decodeGamma(vec4 raw) {
		return pow(raw.xyz, vec3(2.2));
}

vec3 decodeRGBM(vec4 raw) {
		vec3 color = (8.0 * raw.a) * raw.rgb;
		return color * color;
}

vec3 decodeRGBP(vec4 raw) {
		vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
		return color * color;
}

vec3 decodeRGBE(vec4 raw) {
		if (raw.a == 0.0) {
				return vec3(0.0, 0.0, 0.0);
		} else {
				return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
		}
}

vec4 passThrough(vec4 raw) {
		return raw;
}
`, gS = `
vec3 detailMode_mul(vec3 c1, vec3 c2) {
		return c1 * c2;
}

vec3 detailMode_add(vec3 c1, vec3 c2) {
		return c1 + c2;
}

// https://en.wikipedia.org/wiki/Blend_modes#Screen
vec3 detailMode_screen(vec3 c1, vec3 c2) {
		return 1.0 - (1.0 - c1)*(1.0 - c2);
}

// https://en.wikipedia.org/wiki/Blend_modes#Overlay
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
		return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}

vec3 detailMode_min(vec3 c1, vec3 c2) {
		return min(c1, c2);
}

vec3 detailMode_max(vec3 c1, vec3 c2) {
		return max(c1, c2);
}
`, yS = `
#ifdef MAPCOLOR
uniform vec3 material_diffuse;
#endif

void getAlbedo() {
		dAlbedo = vec3(1.0);

#ifdef MAPCOLOR
		dAlbedo *= material_diffuse.rgb;
#endif

#ifdef MAPTEXTURE
		vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		dAlbedo *= addAlbedoDetail(albedoBase);
#endif

#ifdef MAPVERTEX
		dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`, xS = `
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
		vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
		return albedo;
#endif
}
`, vS = `
#ifdef MAPCOLOR
uniform vec3 material_emissive;
#endif

#ifdef MAPFLOAT
uniform float material_emissiveIntensity;
#endif

void getEmission() {
		dEmission = vec3(1.0);

		#ifdef MAPFLOAT
		dEmission *= material_emissiveIntensity;
		#endif

		#ifdef MAPCOLOR
		dEmission *= material_emissive;
		#endif

		#ifdef MAPTEXTURE
		dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
		#endif
}
`, ng = `
vec4 encodeLinear(vec3 source) {
		return vec4(source, 1.0);
}

vec4 encodeGamma(vec3 source) {
		return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}

vec4 encodeRGBM(vec3 source) { // modified RGBM
		vec4 result;
		result.rgb = pow(source.rgb, vec3(0.5));
		result.rgb *= 1.0 / 8.0;

		result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
		result.a = ceil(result.a * 255.0) / 255.0;

		result.rgb /= result.a;
		return result;
}

vec4 encodeRGBP(vec3 source) {
		// convert incoming linear to gamma(ish)
		vec3 gamma = pow(source, vec3(0.5));

		// calculate the maximum component clamped to 1..8
		float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));

		// calculate storage factor
		float v = 1.0 - ((maxVal - 1.0) / 7.0);

		// round the value for storage in 8bit channel
		v = ceil(v * 255.0) / 255.0;

		return vec4(gamma / (-v * 7.0 + 8.0), v);    
}

vec4 encodeRGBE(vec3 source) {
		float maxVal = max(source.x, max(source.y, source.z));
		if (maxVal < 1e-32) {
				return vec4(0, 0, 0, 0);
		} else {
				float e = ceil(log2(maxVal));
				return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
		}
}
`, SS = `
		gl_FragColor.rgb = combineColor();

		gl_FragColor.rgb += dEmission;
		gl_FragColor.rgb = addFog(gl_FragColor.rgb);

		#ifndef HDR
		gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
		gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
		#endif
`, bS = `
`, wS = `
// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;

// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).
vec2 mapUv(vec2 uv, vec4 rect) {
		return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
								mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}

// map a normalized equirect UV and roughness level to the correct atlas rect.
vec2 mapRoughnessUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}

// map shiny level UV
vec2 mapShinyUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`, TS = `
vec3 processEnvironment(vec3 color) {
		return color;
}
`, CS = `
uniform float skyboxIntensity;

vec3 processEnvironment(vec3 color) {
		return color * skyboxIntensity;
}
`, AS = `
`, MS = `
`, ES = `
float getFalloffWindow(float lightRadius) {
		float sqrDist = dot(dLightDirW, dLightDirW);
		float invRadius = 1.0 / lightRadius;
		return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}

float getFalloffInvSquared(float lightRadius) {
		float sqrDist = dot(dLightDirW, dLightDirW);
		float falloff = 1.0 / (sqrDist + 1.0);
		float invRadius = 1.0 / lightRadius;

		falloff *= 16.0;
		falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );

		return falloff;
}
`, RS = `
float getFalloffLinear(float lightRadius) {
		float d = length(dLightDirW);
		return max(((lightRadius - d) / lightRadius), 0.0);
}
`, LS = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		return vec;
}

vec3 fixSeams(vec3 vec) {
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		return vec;
}

vec3 calcSeam(vec3 vec) {
		return vec3(0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec;
}
`, PS = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		vec3 avec = abs(vec);
		float scale = 1.0 - exp2(mipmapIndex) / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeams(vec3 vec) {
		vec3 avec = abs(vec);
		float scale = 1.0 - 1.0 / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		vec3 avec = abs(vec);
		float scale = invRecMipSize;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 calcSeam(vec3 vec) {
		vec3 avec = abs(vec);
		float M = max(avec.x, max(avec.y, avec.z));
		return vec3(avec.x != M ? 1.0 : 0.0,
								avec.y != M ? 1.0 : 0.0,
								avec.z != M ? 1.0 : 0.0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec * (seam * -scale + vec3(1.0));
}
`, IS = `
// float unpacking functionality, complimentary to float-packing.js
float bytes2float2(vec2 data) {
		return dot(data, vec2(1.0, 1.0 / 255.0));
}

float bytes2float3(vec3 data) {
		return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}

float bytes2float4(vec4 data) {
		return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}

float bytes2floatRange2(vec2 data, float min, float max) {
		return mix(min, max, bytes2float2(data));
}

float bytes2floatRange3(vec3 data, float min, float max) {
		return mix(min, max, bytes2float3(data));
}

float bytes2floatRange4(vec4 data, float min, float max) {
		return mix(min, max, bytes2float4(data));
}

float mantissaExponent2Float(vec4 pack)
{
		float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
		float exponent = floor(pack.w * 255.0 - 127.0);
		return value * exp2(exponent);
}
`, DS = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`, BS = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * depth * fog_density * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`, FS = `
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = (fog_end - depth) / (fog_end - fog_start);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`, OS = `
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		return color;
}
`, kS = `
// Schlick's approximation
vec3 getFresnel(float cosTheta, vec3 f0) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		float glossSq = dGlossiness * dGlossiness;
		vec3 ret = f0 + (max(vec3(glossSq), f0) - f0) * fresnel;
		#ifdef LIT_IRIDESCENCE
				return mix(ret, dIridescenceFresnel, vec3(dIridescence));
		#else
				return ret;
		#endif    
}

float getFresnelCC(float cosTheta) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		return 0.04 + (1.0 - 0.04) * fresnel;
}
`, NS = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`, zS = `
attribute vec2 vertex_position;

varying vec2 vUv0;

void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`, US = `
float gammaCorrectInput(float color) {
		return color;
}

vec3 gammaCorrectInput(vec3 color) {
		return color;
}

vec4 gammaCorrectInput(vec4 color) {
		return color;
}

vec3 gammaCorrectOutput(vec3 color) {
		return color;
}
`, VS = `
float gammaCorrectInput(float color) {
		return decodeGamma(color);
}

vec3 gammaCorrectInput(vec3 color) {
		return decodeGamma(color);
}

vec4 gammaCorrectInput(vec4 color) {
		return vec4(decodeGamma(color.xyz), color.w);
}

vec3 gammaCorrectOutput(vec3 color) {
#ifdef HDR
		return color;
#else
		return pow(color + 0.0000001, vec3(1.0 / 2.2));
#endif
}
`, GS = `
#ifdef MAPFLOAT
uniform float material_gloss;
#endif

void getGlossiness() {
		dGlossiness = 1.0;

		#ifdef MAPFLOAT
		dGlossiness *= material_gloss;
		#endif

		#ifdef MAPTEXTURE
		dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		dGlossiness = 1.0 - dGlossiness;
		#endif

		dGlossiness += 0.0000001;
}
`, HS = `
uniform float material_iridescenceRefractionIndex;

#ifndef PI
#define PI 3.14159265
#endif

float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
		return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}

vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
		return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}

vec3 iridescence_fresnelToIor(vec3 f0) {
		vec3 sqrtF0 = sqrt(f0);
		return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

vec3 iridescence_sensitivity(float opd, vec3 shift) {
		float phase = 2.0 * PI * opd * 1.0e-9;
		const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
		const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
		const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

		vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
		xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
		xyz /= vec3(1.0685e-07);

		const mat3 XYZ_TO_REC709 = mat3(
				3.2404542, -0.9692660,  0.0556434,
			 -1.5371385,  1.8760108, -0.2040259,
			 -0.4985314,  0.0415560,  1.0572252
		);

		return XYZ_TO_REC709 * xyz;
}

float iridescence_fresnel(float cosTheta, float f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2;
		return f0 + (1.0 - f0) * x5;
} 

vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2; 
		return f0 + (vec3(1.0) - f0) * x5;
}

vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0) {

		float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, dIridescenceThickness));
		float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
		float cosTheta2Sq = 1.0 - sinTheta2Sq;

		if (cosTheta2Sq < 0.0) {
				return vec3(1.0);
		}

		float cosTheta2 = sqrt(cosTheta2Sq);

		float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
		float r12 = iridescence_fresnel(cosTheta, r0);
		float r21 = r12;
		float t121 = 1.0 - r12;

		float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
		float phi21 = PI - phi12;

		vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
		vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
		vec3 r23 = iridescence_fresnel(cosTheta2, r1);

		vec3 phi23 = vec3(0.0);
		if (baseIor[0] < iridescenceIor) phi23[0] = PI;
		if (baseIor[1] < iridescenceIor) phi23[1] = PI;
		if (baseIor[2] < iridescenceIor) phi23[2] = PI;
		float opd = 2.0 * iridescenceIor * dIridescenceThickness * cosTheta2;
		vec3 phi = vec3(phi21) + phi23; 

		vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
		vec3 r123 = sqrt(r123Sq);
		vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);

		vec3 c0 = r12 + rs;
		vec3 i = c0;

		vec3 cm = rs - t121;
		for (int m = 1; m <= 2; m++) {
				cm *= r123;
				vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
				i += cm * sm;
		}
		return max(i, vec3(0.0));
}

void getIridescence(float cosTheta) {
		dIridescenceFresnel = calcIridescence(1.0, cosTheta, dSpecularity);
}
`, WS = `
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif

void getIridescence() {
		float iridescence = 1.0;

		#ifdef MAPFLOAT
		iridescence *= material_iridescence;
		#endif

		#ifdef MAPTEXTURE
		iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		dIridescence = iridescence; 
}
`, qS = `
uniform float material_iridescenceThicknessMax;

#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif

void getIridescenceThickness() {

		#ifdef MAPTEXTURE
		float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
		#else
		float iridescenceThickness = material_iridescenceThicknessMax;
		#endif

		dIridescenceThickness = iridescenceThickness; 
}
`, XS = `
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
`, jS = `
float getLightDiffuse() {
		return max(dot(dNormalW, -dLightDirNormW), 0.0);
}
`, $S = `
void getLightDirPoint(vec3 lightPosW) {
		dLightDirW = vPositionW - lightPosW;
		dLightDirNormW = normalize(dLightDirW);
		dLightPosW = lightPosW;
}
`, YS = `
void addLightMap() {
		dDiffuseLight += dLightmap;
}
`, KS = `
void addLightMap() {
		if (dot(dLightmapDir, dLightmapDir) < 0.0001) {
				dDiffuseLight += dLightmap;
		} else {
				dLightDirNormW = dLightmapDir;

				float vlight = saturate(dot(dLightDirNormW, -dVertexNormalW));
				float flight = saturate(dot(dLightDirNormW, -dNormalW));
				float nlight = (flight / max(vlight, 0.01)) * 0.5;

				dDiffuseLight += dLightmap * nlight * 2.0;

				vec3 halfDirW = normalize(-dLightmapDir + dViewDirW);
				vec3 specularLight = dLightmap * getLightSpecular(halfDirW);

				#ifdef LIT_SPECULAR_FRESNEL
				specularLight *= getFresnel(dot(dViewDirW, halfDirW), dSpecularity);
				#endif

				dSpecularLight += specularLight;
		}
}
`, ZS = `
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;

void getLightMap() {
		dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;

		vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
		float dirDot = dot(dir, dir);
		dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`, JS = `
void getLightMap() {
		dLightmap = vec3(1.0);

		#ifdef MAPTEXTURE
		dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dLightmap *= saturate(vVertexColor.$VC);
		#endif
}
`, QS = `
// Anisotropic GGX
float calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {
		float PI = 3.141592653589793;
		float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);
		float anisotropy = material_anisotropy * roughness;
 
		float at = max((roughness + anisotropy), roughness / 4.0);
		float ab = max((roughness - anisotropy), roughness / 4.0);

		float NoH = dot(tNormalW, h);
		float ToH = dot(dTBN[0], h);
		float BoH = dot(dTBN[1], h);

		float a2 = at * ab;
		vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
		float v2 = dot(v, v);
		float w2 = a2 / v2;
		float D = a2 * w2 * w2 * (1.0 / PI);

		float ToV = dot(dTBN[0], dViewDirW);
		float BoV = dot(dTBN[1], dViewDirW);
		float ToL = dot(dTBN[0], -dLightDirNormW);
		float BoL = dot(dTBN[1], -dLightDirNormW);
		float NoV = dot(tNormalW, dViewDirW);
		float NoL = dot(tNormalW, -dLightDirNormW);

		float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
		float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
		float G = 0.5 / (lambdaV + lambdaL);

		return D * G;
}

float getLightSpecular(vec3 h) {
		return calcLightSpecular(dGlossiness, dNormalW, h);
}

#ifdef LIT_CLEARCOAT
float getLightSpecularCC(vec3 h) {
		return calcLightSpecular(ccGlossiness, ccNormalW, h);
}
#endif
`, eb = `
// Energy-conserving (hopefully) Blinn-Phong
float calcLightSpecular(float tGlossiness, vec3 tNormalW, vec3 h) {
		float nh = max( dot( h, tNormalW ), 0.0 );

		float specPow = exp2(tGlossiness * 11.0); // glossiness is linear, power is not; 0 - 2048

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		specPow = max(specPow, 0.0001);

		return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}

float getLightSpecular(vec3 h) {
		return calcLightSpecular(dGlossiness, dNormalW, h);
}

#ifdef LIT_CLEARCOAT
float getLightSpecularCC(vec3 h) {
		return calcLightSpecular(ccGlossiness, ccNormalW, h);
}
#endif
`, tb = `
float calcLightSpecular(float tGlossiness, vec3 tReflDirW, vec3 h) {
		float specPow = tGlossiness;

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		return pow(max(dot(tReflDirW, -dLightDirNormW), 0.0), specPow + 0.0001);
}

float getLightSpecular(vec3 h) {
		return calcLightSpecular(dGlossiness, dReflDirW, h);
}

#ifdef LIT_CLEARCOAT
float getLightSpecularCC(vec3 h) {
		return calcLightSpecular(ccGlossiness, ccReflDirW,h );
}
#endif
`, sb = `

float sheenD(vec3 normal, vec3 h, float roughness) {
		float invR = 1.0 / (roughness * roughness);
		float cos2h = max(dot(normal, h), 0.0);
		cos2h *= cos2h;
		float sin2h = max(1.0 - cos2h, 0.0078125);
		return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}

float sheenV(vec3 normal, vec3 view, vec3 light) {
		float NoV = max(dot(normal, view), 0.000001);
		float NoL = max(dot(normal, light), 0.000001);
		return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}

float getLightSpecularSheen(vec3 h) {
		float D = sheenD(dNormalW, h, sGlossiness);
		float V = sheenV(dNormalW, dViewDirW, -dLightDirNormW);
		return D * V;
}
`, ib = `
// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

mat3 transposeMat3( const in mat3 m ) {
		mat3 tmp;
		tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
		tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
		tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
		return tmp;
}

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;
		float dotNV = saturate( dot( N, V ) );
		// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
		vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
		uv = uv * LUT_SCALE + LUT_BIAS;
		return uv;
}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {
		// Real-Time Area Lighting: a Journey from Research to Production (p.102)
		// An approximation of the form factor of a horizon-clipped rectangle.
		float l = length( f );
		return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
		float x = dot( v1, v2 );
		float y = abs( x );
		// rational polynomial approximation to theta / sin( theta ) / 2PI
		float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
		float b = 3.4175940 + ( 4.1616724 + y ) * y;
		float v = a / b;
		float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
		return cross( v1, v2 ) * theta_sintheta;
}

struct Coords {
		vec3 coord0;
		vec3 coord1;
		vec3 coord2;
		vec3 coord3;
};

float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
		// bail if point is on back side of plane of light
		// assumes ccw winding order of light vertices
		vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
		vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
		
		vec3 lightNormal = cross( v1, v2 );
		// if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;
		float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));

		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize( V - N * dot( V, N ) );
		T2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system
		// compute transform
		mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
		// transform rect
		vec3 coords[ 4 ];
		coords[ 0 ] = mat * ( rectCoords.coord0 - P );
		coords[ 1 ] = mat * ( rectCoords.coord1 - P );
		coords[ 2 ] = mat * ( rectCoords.coord2 - P );
		coords[ 3 ] = mat * ( rectCoords.coord3 - P );
		// project rect onto sphere
		coords[ 0 ] = normalize( coords[ 0 ] );
		coords[ 1 ] = normalize( coords[ 1 ] );
		coords[ 2 ] = normalize( coords[ 2 ] );
		coords[ 3 ] = normalize( coords[ 3 ] );
		// calculate vector form factor
		vec3 vectorFormFactor = vec3( 0.0 );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
		// adjust for horizon clipping
		float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

		return result;
}

Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		Coords coords;
		coords.coord0 = lightPos + halfWidth - halfHeight;
		coords.coord1 = lightPos - halfWidth - halfHeight;
		coords.coord2 = lightPos - halfWidth + halfHeight;
		coords.coord3 = lightPos + halfWidth + halfHeight;
		return coords;
}

float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		// used for simple sphere light falloff
		// also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here
		dSphereRadius = max(length(halfWidth), length(halfHeight));

		// Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.
		vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
		vec3 w = normalize(cross(f, halfHeight));
		vec3 h = normalize(cross(f, w));

		return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}

// used for LTC LUT texture lookup
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float tGlossiness, vec3 tNormalW)
{
		float roughness = max((1.0 - tGlossiness) * (1.0 - tGlossiness), 0.001);
		return LTC_Uv( tNormalW, dViewDirW, roughness );
}

//used for energy conservation and to modulate specular
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 tSpecularity)
{
		vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t2 *= vec4(0.693103,1,1,1);
		t2 += vec4(0.306897,0,0,0);
		#endif

		return tSpecularity * t2.x + ( vec3( 1.0 ) - tSpecularity) * t2.y;
}

void calcLTCLightValues()
{
		dLTCUV = getLTCLightUV(dGlossiness, dNormalW);
		dLTCSpecFres = getLTCLightSpecFres(dLTCUV, dSpecularity); 

#ifdef LIT_CLEARCOAT
		ccLTCUV = getLTCLightUV(ccGlossiness, ccNormalW);
		ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(ccSpecularity));
#endif
}

void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}

// An extended version of the implementation from
// "How to solve a cubic equation, revisited"
// http://momentsingraphics.de/?p=105
vec3 SolveCubic(vec4 Coefficient)
{
		float pi = 3.14159;
		// Normalize the polynomial
		Coefficient.xyz /= Coefficient.w;
		// Divide middle coefficients by three
		Coefficient.yz /= 3.0;

		float A = Coefficient.w;
		float B = Coefficient.z;
		float C = Coefficient.y;
		float D = Coefficient.x;

		// Compute the Hessian and the discriminant
		vec3 Delta = vec3(
				-Coefficient.z * Coefficient.z + Coefficient.y,
				-Coefficient.y * Coefficient.z + Coefficient.x,
				dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
		);

		float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);

		vec3 RootsA, RootsD;

		vec2 xlc, xsc;

		// Algorithm A
		{
				float A_a = 1.0;
				float C_a = Delta.x;
				float D_a = -2.0 * B * Delta.x + Delta.y;

				// Take the cubic root of a normalized complex number
				float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;

				float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
				float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);

				float xl;
				if ((x_1a + x_3a) > 2.0 * B)
						xl = x_1a;
				else
						xl = x_3a;

				xlc = vec2(xl - B, A);
		}

		// Algorithm D
		{
				float A_d = D;
				float C_d = Delta.z;
				float D_d = -D * Delta.y + 2.0 * C * Delta.z;

				// Take the cubic root of a normalized complex number
				float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;

				float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
				float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);

				float xs;
				if (x_1d + x_3d < 2.0 * C)
						xs = x_1d;
				else
						xs = x_3d;

				xsc = vec2(-D, xs + C);
		}

		float E =  xlc.y * xsc.y;
		float F = -xlc.x * xsc.y - xlc.y * xsc.x;
		float G =  xlc.x * xsc.x;

		vec2 xmc = vec2(C * F - B * G, -B * F + C * E);

		vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);

		if (Root.x < Root.y && Root.x < Root.z)
				Root.xyz = Root.yxz;
		else if (Root.z < Root.x && Root.z < Root.y)
				Root.xyz = Root.xzy;

		return Root;
}

float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize(V - N * dot(V, N));
		T2 = cross(N, T1);

		// rotate area light in (T1, T2, N) basis
		//mat3 R = transpose(mat3(T1, T2, N));
		mat3 R = transposeMat3( mat3( T1, T2, N ) );
		// polygon (allocate 5 vertices for clipping)
		vec3 L_[ 3 ];
		L_[ 0 ] = R * ( points.coord0 - P );
		L_[ 1 ] = R * ( points.coord1 - P );
		L_[ 2 ] = R * ( points.coord2 - P );

		vec3 Lo_i = vec3(0);

		// init ellipse
		vec3 C  = 0.5 * (L_[0] + L_[2]);
		vec3 V1 = 0.5 * (L_[1] - L_[2]);
		vec3 V2 = 0.5 * (L_[1] - L_[0]);

		C  = Minv * C;
		V1 = Minv * V1;
		V2 = Minv * V2;

		//if(dot(cross(V1, V2), C) > 0.0)
		//    return 0.0;

		// compute eigenvectors of ellipse
		float a, b;
		float d11 = dot(V1, V1);
		float d22 = dot(V2, V2);
		float d12 = dot(V1, V2);
		if (abs(d12) / sqrt(d11 * d22) > 0.0001)
		{
				float tr = d11 + d22;
				float det = -d12 * d12 + d11 * d22;

				// use sqrt matrix to solve for eigenvalues
				det = sqrt(det);
				float u = 0.5 * sqrt(tr - 2.0 * det);
				float v = 0.5 * sqrt(tr + 2.0 * det);
				float e_max = (u + v) * (u + v);
				float e_min = (u - v) * (u - v);

				vec3 V1_, V2_;

				if (d11 > d22)
				{
						V1_ = d12 * V1 + (e_max - d11) * V2;
						V2_ = d12 * V1 + (e_min - d11) * V2;
				}
				else
				{
						V1_ = d12*V2 + (e_max - d22)*V1;
						V2_ = d12*V2 + (e_min - d22)*V1;
				}

				a = 1.0 / e_max;
				b = 1.0 / e_min;
				V1 = normalize(V1_);
				V2 = normalize(V2_);
		}
		else
		{
				a = 1.0 / dot(V1, V1);
				b = 1.0 / dot(V2, V2);
				V1 *= sqrt(a);
				V2 *= sqrt(b);
		}

		vec3 V3 = cross(V1, V2);
		if (dot(C, V3) < 0.0)
				V3 *= -1.0;

		float L  = dot(V3, C);
		float x0 = dot(V1, C) / L;
		float y0 = dot(V2, C) / L;

		float E1 = inversesqrt(a);
		float E2 = inversesqrt(b);

		a *= L * L;
		b *= L * L;

		float c0 = a * b;
		float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
		float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
		float c3 = 1.0;

		vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
		float e1 = roots.x;
		float e2 = roots.y;
		float e3 = roots.z;

		vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);

		mat3 rotate = mat3(V1, V2, V3);

		avgDir = rotate * avgDir;
		avgDir = normalize(avgDir);

		float L1 = sqrt(-e2 / e3);
		float L2 = sqrt(-e2 / e1);

		float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));
		
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;

		// use tabulated horizon-clipped sphere
		vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
		uv = uv*LUT_SCALE + LUT_BIAS;

		float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;

		return formFactor*scale;
}

float getRectLightDiffuse() {
		return LTC_EvaluateRect( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getDiskLightDiffuse() {
		return LTC_EvaluateDisk( dNormalW, dViewDirW, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getSphereLightDiffuse() {
		// NB: this could be improved further with distance based wrap lighting
		float falloff = dSphereRadius / (dot(dLightDirW, dLightDirW) + dSphereRadius);
		return getLightDiffuse()*falloff;
}

mat3 getLTCLightInvMat(vec2 uv)
{
		vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);
		t1 += vec4(0.0, -0.2976, -0.01381, 0.0);
		#endif

		return mat3(
				vec3( t1.x, 0, t1.y ),
				vec3(    0, 1,    0 ),
				vec3( t1.z, 0, t1.w )
		);
}

float calcRectLightSpecular(vec3 tNormalW, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateRect( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );
}

float getRectLightSpecular() {
		return calcRectLightSpecular(dNormalW, dLTCUV);
}

#ifdef LIT_CLEARCOAT
float getRectLightSpecularCC() {
		return calcRectLightSpecular(ccNormalW, ccLTCUV);
}
#endif

float calcDiskLightSpecular(vec3 tNormalW, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateDisk( tNormalW, dViewDirW, vPositionW, mInv, dLTCCoords );
}

float getDiskLightSpecular() {
		return calcDiskLightSpecular(dNormalW, dLTCUV);
}

#ifdef LIT_CLEARCOAT
float getDiskLightSpecularCC() {
		return calcDiskLightSpecular(ccNormalW, ccLTCUV);
}
#endif

float getSphereLightSpecular() {
		return calcDiskLightSpecular(dNormalW, dLTCUV);
}

#ifdef LIT_CLEARCOAT
float getSphereLightSpecularCC() {
		return calcDiskLightSpecular(ccNormalW, ccLTCUV);
}
#endif
`, nb = `
#ifdef MAPFLOAT
uniform float material_metalness;
#endif

void getMetalness() {
		float metalness = 1.0;

		#ifdef MAPFLOAT
		metalness *= material_metalness;
		#endif

		#ifdef MAPTEXTURE
		metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		metalness *= saturate(vVertexColor.$VC);
		#endif

		dMetalness = metalness;
}
`, rb = `
uniform sampler2D texture_msdfMap;

#ifdef GL_OES_standard_derivatives
#define USE_FWIDTH
#endif

#ifdef GL2
#define USE_FWIDTH
#endif

float median(float r, float g, float b) {
		return max(min(r, g), min(max(r, g), b));
}

float map (float min, float max, float v) {
		return (v - min) / (max - min);
}

uniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost
uniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF
uniform float font_textureWidth; // the width of the texture atlas

#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif

vec4 applyMsdf(vec4 color) {
		// sample the field
		vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
		vec2 uvShdw = vUv0 - shadow_offset;
		vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
		// get the signed distance value
		float sigDist = median(tsample.r, tsample.g, tsample.b);
		float sigDistShdw = median(ssample.r, ssample.g, ssample.b);

		// smoothing limit - smaller value makes for sharper but more aliased text, especially on angles
		// too large value (0.5) creates a dark glow around the letters
		float smoothingMax = 0.2;

		#ifdef USE_FWIDTH
		// smoothing depends on size of texture on screen
		vec2 w = fwidth(vUv0);
		float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
		#else
		float font_size = 16.0; // TODO fix this
		// smoothing gets smaller as the font size gets bigger
		// don't have fwidth we can approximate from font size, this doesn't account for scaling
		// so a big font scaled down will be wrong...
		float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);
		#endif

		float mapMin = 0.05;
		float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);

		// remap to a smaller range (used on smaller font sizes)
		float sigDistInner = map(mapMin, mapMax, sigDist);
		float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
		sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);

		float center = 0.5;
		// calculate smoothing and use to generate opacity
		float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
		float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
		float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);

		vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
		tcolor = mix(tcolor, color, inside);

		vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
		tcolor = mix(scolor, tcolor, outline);
		
		return tcolor;
}
`, ab = `

uniform float material_f0;

void getMetalnessModulate() {
		vec3 dielectricF0 = material_f0 * dSpecularity;
		dSpecularity = mix(dielectricF0, dAlbedo, dMetalness);
		dAlbedo *= 1.0 - dMetalness;
}
`, ob = `
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;

varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;

void unpackMsdfParams() {
		vec3 little = mod(vertex_outlineParameters, 256.);
		vec3 big = (vertex_outlineParameters - little) / 256.;

		outline_color.rb = little.xy / 255.;
		outline_color.ga = big.xy / 255.;

		// _outlineThicknessScale === 0.2
		outline_thickness = little.z / 255. * 0.2;

		little = mod(vertex_shadowParameters, 256.);
		big = (vertex_shadowParameters - little) / 256.;

		shadow_color.rb = little.xy / 255.;
		shadow_color.ga = big.xy / 255.;

		// vec2(little.z, big.z) / 127. - 1. remaps shadow offset from [0, 254] to [-1, 1]
		// _shadowOffsetScale === 0.005
		shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`, hb = `
#ifdef MORPHING_TEXTURE_BASED_NORMAL
uniform highp sampler2D morphNormalTex;
#endif

vec3 getNormal() {
		#ifdef SKIN
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		#elif defined(INSTANCING)
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		#else
		dNormalMatrix = matrix_normal;
		#endif

		vec3 tempNormal = vertex_normal;

		#ifdef MORPHING
		#ifdef MORPHING_NRM03
		tempNormal += morph_weights_a[0] * morph_nrm0;
		tempNormal += morph_weights_a[1] * morph_nrm1;
		tempNormal += morph_weights_a[2] * morph_nrm2;
		tempNormal += morph_weights_a[3] * morph_nrm3;
		#endif
		#ifdef MORPHING_NRM47
		tempNormal += morph_weights_b[0] * morph_nrm4;
		tempNormal += morph_weights_b[1] * morph_nrm5;
		tempNormal += morph_weights_b[2] * morph_nrm6;
		tempNormal += morph_weights_b[3] * morph_nrm7;
		#endif
		#endif

		#ifdef MORPHING_TEXTURE_BASED_NORMAL
		// apply morph offset from texture
		vec2 morphUV = getTextureMorphCoords();
		vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;
		tempNormal += morphNormal;
		#endif

		return normalize(dNormalMatrix * tempNormal);
}
`, lb = `
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;

vec3 blendNormals(vec3 n1, vec3 n2) {
		// https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented
		n1 += vec3(0, 0, 1);
		n2 *= vec3(-1, -1, 1);
		return n1 * dot(n1, n2) / n1.z - n2;
}
#endif

vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
		vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
		return blendNormals(normalMap, normalDetailMap);
#else
		return normalMap;
#endif
}
`, cb = `
vec3 getNormal() {
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`, db = `
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif

void getNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
		dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
		dNormalW = dVertexNormalW;
#endif
}
`, ub = `
vec3 getNormal() {
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`, fb = `
vec3 unpackNormal(vec4 nmap) {
		vec3 normal;
		normal.xy = nmap.wy * 2.0 - 1.0;
		normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
		return normal;
}
`, mb = `
vec3 unpackNormal(vec4 nmap) {
		return nmap.xyz * 2.0 - 1.0;
}
`, pb = `
#ifdef MAPFLOAT
uniform float material_opacity;
#endif

void getOpacity() {
		dAlpha = 1.0;

		#ifdef MAPFLOAT
		dAlpha *= material_opacity;
		#endif

		#ifdef MAPTEXTURE
		dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
		#endif
}
`, _b = `
gl_FragColor.a = dAlpha;
`, gb = `
		gl_FragColor.a = 1.0;
`, yb = `
gl_FragColor.rgb *= dAlpha;
gl_FragColor.a = dAlpha;
`, xb = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`, vb = `
// Packing a float in GLSL with multiplication and mod
// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);

		// combination of mod and multiplication and division works better
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
`, Sb = `

#ifdef MAPCOLOR
uniform vec3 material_sheen;
#endif

void getSheen() {
		vec3 sheenColor = vec3(1, 1, 1);

		#ifdef MAPCOLOR
		sheenColor *= material_sheen;
		#endif

		#ifdef MAPTEXTURE
		sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenColor *= saturate(vVertexColor.$VC);
		#endif

		sSpecularity = sheenColor;
}
`, bb = `
#ifdef MAPFLOAT
uniform float material_sheenGloss;
#endif

void getSheenGlossiness() {
		float sheenGlossiness = 1.0;

		#ifdef MAPFLOAT
		sheenGlossiness *= material_sheenGloss;
		#endif

		#ifdef MAPTEXTURE
		sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		sheenGlossiness = 1.0 - sheenGlossiness;
		#endif

		sheenGlossiness += 0.0000001;
		sGlossiness = sheenGlossiness;
}
`, wb = `
uniform float material_heightMapFactor;

void getParallax() {
		float parallaxScale = material_heightMapFactor;

		float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		height = height * parallaxScale - parallaxScale*0.5;
		vec3 viewDirT = dViewDirW * dTBN;

		viewDirT.z += 0.42;
		dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`, Tb = `
varying vec4 texCoordsAlphaLife;

uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

uniform float softening;
uniform float colorMult;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		float depth = dot(rgbaDepth, bitShift);
		return depth;
}
#endif

void main(void) {
		vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));
		vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));
		ramp.rgb *= colorMult;

		ramp.a += texCoordsAlphaLife.z;

		vec3 rgb = tex.rgb * ramp.rgb;
		float a  = tex.a * ramp.a;
`, Cb = `
vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {
		return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex,tc);
		vec4 b = texture2D(tex,tc + graphSampleSize);
		float c = fract(tc.x*graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a, b, c);
}

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
		float c = cos(pRotation);
		float s = sin(pRotation);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
		#ifdef SCREEN_SPACE
				vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
		#else
				vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		#endif

		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

vec2 safeNormalize(vec2 v) {
		float l = length(v);
		return (l > 1e-06) ? v / l : v;
}

void main(void) {
		vec3 meshLocalPos = particle_vertexData.xyz;
		float id = floor(particle_vertexData.w);

		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

		float uv = id / numParticlesPot;
		readInput(uv);

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		float particleLifetime = lifetime;

		if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
		vec2 quadXY = meshLocalPos.xy;
		float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);

		vec3 paramDiv;
		vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float scale = params.y;
		float scaleDiv = paramDiv.x;
		float alphaDiv = paramDiv.z;

		scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);

#ifndef USE_MESH
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
		texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif

		vec3 particlePos = inPos;
		vec3 particlePosMoved = vec3(0.0);

		mat2 rotMatrix;
`, Ab = `
		float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`, Mb = `
		float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`, Eb = `
		float animationIndex;

		if (animTexIndexParams.y == 1.0) {
				animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
		} else {
				animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
		}

		float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
		float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
		atlasX = fract(atlasX);

		texCoordsAlphaLife.xy *= animTexTilesParams.xy;
		texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`, Rb = `
void readInput(float uv) {
		vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));

		inPos = tex.xyz;
		inVel = tex2.xyz;
		inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
		inShow = tex.w >= 0.0;
		inLife = tex2.w;
}
`, Lb = `
//RG=X, BA=Y
//RG=Z, BA=A
//RGB=V, A=visMode
//RGBA=life

#define PI2 6.283185307179586

uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;

uniform float maxVel;

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}

void readInput(float uv) {
		vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
		vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
		vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));

		inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
		inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;

		inVel = tex2.xyz;
		inVel = (inVel - vec3(0.5)) * maxVel;

		inAngle = decodeFloatRG(tex1.ba) * PI2;
		inShow = tex2.a > 0.5;

		inLife = decodeFloatRGBA(tex3);
		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`, Pb = `
void writeOutput() {
		if (gl_FragCoord.y<1.0) {
				gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
		} else {
				gl_FragColor = vec4(outVel, outLife);
		}
}
`, Ib = `
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}

vec4 encodeFloatRGBA( float v ) {
		vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
		enc = fract(enc);
		enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
		return enc;
}

void writeOutput() {
		outPos = outPos * outBoundsMul + outBoundsAdd;
		outAngle = fract(outAngle / PI2);

		outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul

		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);

		if (gl_FragCoord.y < 1.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
		} else if (gl_FragCoord.y < 2.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
		} else if (gl_FragCoord.y < 3.0) {
				gl_FragColor = vec4(outVel, visMode*0.5+0.5);
		} else {
				gl_FragColor = encodeFloatRGBA(outLife);
		}
}
`, Db = `
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		vec3 pos = inBounds - vec3(0.5);

		vec3 posAbs = abs(pos);
		vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));

		vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;

		pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
		pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
		pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);

#ifndef LOCAL_SPACE
		return emitterPos + spawnBounds * pos;
#else
		return spawnBounds * pos;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity -= vec3(0, 0, initialVelocity);
}
`, Bb = `
		writeOutput();
}
`, Fb = `
varying vec2 vUv0;

uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;

uniform mat3 emitterMatrix, emitterMatrixInv;
uniform vec3 emitterScale;

uniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;
uniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;
uniform float startAngle, startAngle2;
uniform float initialVelocity;

uniform float graphSampleSize;
uniform float graphNumSamples;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;

vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`, Ob = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = -1.0;
		}
`, kb = `
		visMode = outLife < 0.0? -1.0: visMode;
`, Nb = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = 1.0;
		}
		visMode = outLife < 0.0? 1.0: visMode;
`, zb = `
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		float rnd4 = fract(rndFactor * 1000.0);
		vec3 norm = normalize(inBounds.xyz - vec3(0.5));
		float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
		return emitterPos + norm * r * spawnBoundsSphere;
#else
		return norm * r * spawnBoundsSphere;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`, Ub = `
float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

vec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex, tc);
		vec4 b = texture2D(tex, tc + graphSampleSize);
		float c = fract(tc.x * graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a.xyz, b.xyz, c);
}

#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
		vec4 p4 = fract(vec4(p) * HASHSCALE4);
		p4 += dot(p4, p4.wzxy+19.19);
		return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}

void main(void) {
		if (gl_FragCoord.x > numParticles) discard;

		readInput(vUv0.x);
		visMode = inShow? 1.0 : -1.0;

		vec4 rndFactor = hash41(gl_FragCoord.x + seed);

		float particleRate = rate + rateDiv * rndFactor.x;

		outLife = inLife + delta;
		float nlife = clamp(outLife / lifetime, 0.0, 1.0);

		vec3 localVelocityDiv;
		vec3 velocityDiv;
		vec3 paramDiv;
		vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);
		vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);
		vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float rotSpeed = params.x;
		float rotSpeedDiv = paramDiv.y;

		vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);
		float radialSpeed = radialParams.x;
		float radialSpeedDiv = radialParams.y;

		bool respawn = inLife <= 0.0 || outLife >= lifetime;
		inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
		inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;

#ifndef LOCAL_SPACE
		vec3 radialVel = inPos - emitterPos;
#else
		vec3 radialVel = inPos;
#endif
		radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
		radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;

		localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
		velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
		rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;

		addInitialVelocity(localVelocity, rndFactor.xyz);

#ifndef LOCAL_SPACE
		outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
		outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif

		outPos = inPos + outVel * delta;
		outAngle = inAngle + rotSpeed * delta;
`, Vb = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = billboard(particlePos, quadXY);
`, Gb = `
		dBlendModeFogFactor = 0.0;
		rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
		if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`, Hb = `
		rgb = mix(vec3(1.0), rgb, vec3(a));
		if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`, Wb = `
		if (a < 0.01) discard;
`, qb = `
attribute vec4 particle_vertexData;   // XYZ = world pos, W = life
attribute vec4 particle_vertexData2;  // X = angle, Y = scale, Z = alpha, W = velocity.x
attribute vec4 particle_vertexData3;  // XYZ = particle local pos, W = velocity.y
attribute float particle_vertexData4; // particle id
#ifndef USE_MESH
#define VDATA5TYPE vec2
#else
#define VDATA5TYPE vec4
#endif
attribute VDATA5TYPE particle_vertexData5; // VDATA4TYPE depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds, emitterScale, faceTangent, faceBinorm;
uniform sampler2D texLifeAndSourcePosOUT;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform vec3 emitterPos;

varying vec4 texCoordsAlphaLife;

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
		float c = cos(pRotation);
		float s = sin(pRotation);
		//vec4 rotationMatrix = vec4(c, -s, s, c);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

void main(void)
{
		vec3 particlePos = particle_vertexData.xyz;
		vec3 inPos = particlePos;
		vec3 vertPos = particle_vertexData3.xyz;
		vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);

		float id = floor(particle_vertexData4);
		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		vec2 quadXY = vertPos.xy;

#ifdef USE_MESH
		texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
		mat2 rotMatrix;

		float inAngle = particle_vertexData2.x;
		vec3 particlePosMoved = vec3(0.0);
		vec3 meshLocalPos = particle_vertexData3.xyz;
`, Xb = `
		localPos *= particle_vertexData2.y * emitterScale;
		localPos += particlePos;

		gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`, jb = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = customFace(particlePos, quadXY);
`, $b = `
		rgb = addFog(rgb);
		rgb = toneMap(rgb);
		rgb = gammaCorrectOutput(rgb);
		gl_FragColor = vec4(rgb, a);
}
`, Yb = `
		localPos *= scale * emitterScale;
		localPos += particlePos;

		#ifdef SCREEN_SPACE
		gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
		#else
		gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
		#endif
`, Kb = `
		vec3 negNormal = normal*0.5+0.5;
		vec3 posNormal = -normal*0.5+0.5;
		negNormal *= negNormal;
		posNormal *= posNormal;
`, Zb = `
attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor
#ifdef USE_MESH
attribute vec2 particle_uv;         // mesh UV
#endif

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform float numParticles, numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;
uniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;
uniform sampler2D particleTexOUT, particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

varying vec4 texCoordsAlphaLife;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`, Jb = `
		vec3 negNormal = max(normal, vec3(0.0));
		vec3 posNormal = max(-normal, vec3(0.0));
`, Qb = `
		vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
												negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
												negNormal.z*lightCube[4] + posNormal.z*lightCube[5];

		rgb *= light;
`, ew = `
		particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`, tw = `
		vec3 localPos = meshLocalPos;
		localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
		localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);

		billboard(particlePos, quadXY);
`, sw = `
		Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`, iw = `
		vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
		vec3 normal = ParticleMat * normalMap;
`, nw = `
		inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors

`, rw = `
		float depth = getLinearScreenDepth();
		float particleDepth = vDepth;
		float depthDiff = saturate(abs(particleDepth - depth) * softening);
		a *= depthDiff;
`, aw = `
		vDepth = getLinearDepth(localPos);
`, ow = `
		vec3 moveDir = inVel * stretch;
		vec3 posPrev = particlePos - moveDir;
		posPrev += particlePosMoved;

		vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);

		float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;

		particlePos = mix(particlePos, posPrev, interpolation);
`, hw = `
		mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
		ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`, lw = `
		vec3 origParticlePos = particlePos;
		particlePos -= matrix_model[3].xyz;
		particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
		particlePos += matrix_model[3].xyz;
		particlePosMoved = particlePos - origParticlePos;
`, cw = `
void getReflDir() {
		dReflDirW = normalize(-reflect(dViewDirW, dNormalW));
}
`, dw = `
void getReflDir() {
		float roughness = sqrt(1.0 - min(dGlossiness, 1.0));
		float anisotropy = material_anisotropy * roughness;
		vec3 anisotropicDirection = anisotropy >= 0.0 ? dTBN[1] : dTBN[0];
		vec3 anisotropicTangent = cross(anisotropicDirection, dViewDirW);
		vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
		vec3 bentNormal = normalize(mix(normalize(dNormalW), normalize(anisotropicNormal), anisotropy));
		dReflDirW = reflect(-dViewDirW, bentNormal);
}
`, uw = `
#ifdef LIT_CLEARCOAT
void addReflectionCC() {
		ccReflection += calcReflection(ccReflDirW, ccGlossiness);
}
#endif
`, fw = `
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
		vec3 lookupVec = fixSeams(cubeMapProject(tReflDirW));
		lookupVec.x *= -1.0;
		return $DECODE(textureCube(texture_cubeMap, lookupVec));
}

void addReflection() {   
		dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
}
`, mw = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
		vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - tGlossiness) * 5.0;
		float ilevel = floor(level);
		float flevel = level - ilevel;

		vec3 sharp = $DECODE(textureCube(texture_cubeMap, fixSeams(dir)));
		vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
		vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}

void addReflection() {   
		dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
}
`, pw = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;

// calculate mip level for shiny reflection given equirect coords uv.
float shinyMipLevel(vec2 uv) {
		vec2 dx = dFdx(uv);
		vec2 dy = dFdy(uv);

		// calculate second dF at 180 degrees
		vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
		vec2 dx2 = dFdx(uv2);
		vec2 dy2 = dFdy(uv2);

		// calculate min of both sets of dF to handle discontinuity at the azim edge
		float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));

		return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}

vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
		vec3 dir = cubeMapProject(tReflDirW) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - tGlossiness) * 5.0;
		float ilevel = floor(level);

		// accessing the shiny (top level) reflection - perform manual mipmap lookup
		float level2 = shinyMipLevel(uv * atlasSize);
		float ilevel2 = floor(level2);

		vec2 uv0, uv1;
		float weight;
		if (ilevel == 0.0) {
				uv0 = mapShinyUv(uv, ilevel2);
				uv1 = mapShinyUv(uv, ilevel2 + 1.0);
				weight = level2 - ilevel2;
		} else {
				// accessing rough reflection - just sample the same part twice
				uv0 = uv1 = mapRoughnessUv(uv, ilevel);
				weight = 0.0;
		}

		vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
		vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
		vec3 linear0 = mix(linearA, linearB, weight);
		vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(linear0, linear1, level - ilevel));
}

void addReflection() {   
		dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
}
`, _w = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
		vec3 reflDirV = (mat3(matrix_view) * tReflDirW).xyz;

		float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
		vec2 sphereMapUv = reflDirV.xy / m + 0.5;

		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection() {   
		dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
}
`, gw = `
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 tReflDirW, float tGlossiness) {
		vec3 reflDirV = vNormalV;

		vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;
		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection() {   
		dReflection += vec4(calcReflection(dReflDirW, dGlossiness), material_reflectivity);
}
`, yw = `

void addReflectionSheen() {
		float NoV = dot(dNormalW, dViewDirW);
		float alphaG = sGlossiness * sGlossiness;

		// Avoid using a LUT and approximate the values analytically
		float a = sGlossiness < 0.25 ? -339.2 * alphaG + 161.4 * sGlossiness - 25.9 : -8.48 * alphaG + 14.3 * sGlossiness - 9.95;
		float b = sGlossiness < 0.25 ? 44.0 * alphaG - 23.7 * sGlossiness + 3.26 : 1.97 * alphaG - 3.27 * sGlossiness + 0.72;
		float DG = exp( a * NoV + b ) + ( sGlossiness < 0.25 ? 0.0 : 0.1 * ( sGlossiness - 0.25 ) );
		sReflection += calcReflection(dNormalW, 0.0) * saturate(DG);
}
`, xw = `
uniform float material_refractionIndex;

vec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {
		float vn = dot(viewVec, Normal);
		float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
		vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;
		return refrVec;
}

void addRefraction() {
		// use same reflection code with refraction vector
		vec3 tmpDir = dReflDirW;
		vec4 tmpRefl = dReflection;
		dReflDirW = refract2(-dViewDirW, dNormalW, material_refractionIndex);
		dReflection = vec4(0);
		addReflection();
		dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * dAlbedo, dTransmission);
		dReflection = tmpRefl;
		dReflDirW = tmpDir;
}
`, vw = `
uniform float material_refractionIndex;
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;

vec3 refract2(vec3 viewVec, vec3 Normal, float IOR) {
		float vn = dot(viewVec, Normal);
		float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
		vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * Normal;
		return refrVec;
}

void addRefraction() {

		// Extract scale from the model transform
		vec3 modelScale;
		modelScale.x = length(vec3(matrix_model[0].xyz));
		modelScale.y = length(vec3(matrix_model[1].xyz));
		modelScale.z = length(vec3(matrix_model[2].xyz));

		// Calculate the refraction vector, scaled by the thickness and scale of the object
		vec3 refractionVector = normalize(refract(-dViewDirW, dNormalW, material_refractionIndex)) * dThickness * modelScale;

		// The refraction point is the entry point + vector to exit point
		vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);

		// Project to texture space so we can sample it
		vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;

		// use built-in getGrabScreenPos function to convert screen position to grab texture uv coords
		vec2 uv = getGrabScreenPos(projectionPoint);

		#ifdef SUPPORTS_TEXLOD
				// Use IOR and roughness to select mip
				float iorToRoughness = (1.0 - dGlossiness) * clamp((1.0 / material_refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
				float refractionLod = log2(uScreenSize.x) * iorToRoughness;
				vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
		#else
				vec3 refraction = texture2D(uSceneColorMap, uv).rgb;
		#endif

		// Transmittance is our final refraction color
		vec3 transmittance;
		if (material_invAttenuationDistance != 0.0)
		{
				vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
				transmittance = exp(-attenuation * length(refractionVector));
		}
		else
		{
				transmittance = refraction;
		}

		// Apply fresnel effect on refraction
		vec3 fresnel = vec3(1.0) - getFresnel(dot(dViewDirW, dNormalW), dSpecularity);
		dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, dTransmission);
}
`, Sw = `
// This shader requires the following #DEFINEs:
//
// PROCESS_FUNC - must be one of reproject, prefilter
// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear
// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear
// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral
// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral
//
// When filtering:
// NUM_SAMPLES - number of samples
// NUM_SAMPLES_SQRT - sqrt of number of samples

varying vec2 vUv0;

// source
#ifdef CUBEMAP_SOURCE
		uniform samplerCube sourceCube;
#else
		uniform sampler2D sourceTex;
#endif

#ifdef USE_SAMPLES_TEX
		// samples
		uniform sampler2D samplesTex;
		uniform vec2 samplesTexInverseSize;
#endif

// params:
// x - target cubemap face 0..6
// y - specular power (when prefiltering)
// z - source cubemap seam scale (0 to disable)
// w - target cubemap size for seam calc (0 to disable)
uniform vec4 params;

// params2:
// x - target image total pixels
// y - source cubemap size
uniform vec2 params2;

float targetFace() { return params.x; }
float specularPower() { return params.y; }
float sourceCubeSeamScale() { return params.z; }
float targetCubeSeamScale() { return params.w; }

float targetTotalPixels() { return params2.x; }
float sourceTotalPixels() { return params2.y; }

float PI = 3.141592653589793;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

${ig}
${ng}

//-- supported projections

vec3 modifySeams(vec3 dir, float scale) {
		vec3 adir = abs(dir);
		float M = max(max(adir.x, adir.y), adir.z);
		return dir / M * vec3(
				adir.x == M ? 1.0 : scale,
				adir.y == M ? 1.0 : scale,
				adir.z == M ? 1.0 : scale
		);
}

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec3 fromSpherical(vec2 uv) {
		return vec3(cos(uv.y) * sin(uv.x),
								sin(uv.y),
								cos(uv.y) * cos(uv.x));
}

vec3 getDirectionEquirect() {
		return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}

// octahedral code, based on http://jcgt.org/published/0003/02/01
// "Survey of Efficient Representations for Independent Unit Vectors" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer

float signNotZero(float k){
		return(k >= 0.0) ? 1.0 : -1.0;
}

vec2 signNotZero(vec2 v) {
		return vec2(signNotZero(v.x), signNotZero(v.y));
}

// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square
vec3 octDecode(vec2 o) {
		vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
		if (v.y < 0.0) {
				v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
		}
		return normalize(v);
}

vec3 getDirectionOctahedral() {
		return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}

// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square
vec2 octEncode(in vec3 v) {
		float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
		vec2 result = v.xz * (1.0 / l1norm);
		if (v.y < 0.0) {
				result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
		}
		return result;
}

/////////////////////////////////////////////////////////////////////

#ifdef CUBEMAP_SOURCE
		vec4 sampleCubemap(vec3 dir) {
				return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));
		}

		vec4 sampleCubemap(vec2 sph) {
		return sampleCubemap(fromSpherical(sph));
}

		vec4 sampleCubemap(vec3 dir, float mipLevel) {
				return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);
		}

		vec4 sampleCubemap(vec2 sph, float mipLevel) {
				return sampleCubemap(fromSpherical(sph), mipLevel);
		}
#else

		vec4 sampleEquirect(vec2 sph) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleEquirect(vec3 dir) {
				return sampleEquirect(toSpherical(dir));
		}

		vec4 sampleEquirect(vec2 sph, float mipLevel) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleEquirect(vec3 dir, float mipLevel) {
				return sampleEquirect(toSpherical(dir), mipLevel);
		}

		vec4 sampleOctahedral(vec3 dir) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleOctahedral(vec2 sph) {
				return sampleOctahedral(fromSpherical(sph));
		}

		vec4 sampleOctahedral(vec3 dir, float mipLevel) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleOctahedral(vec2 sph, float mipLevel) {
				return sampleOctahedral(fromSpherical(sph), mipLevel);
		}

#endif

vec3 getDirectionCubemap() {
		vec2 st = vUv0 * 2.0 - 1.0;
		float face = targetFace();

		vec3 vec;
		if (face == 0.0) {
				vec = vec3(1, -st.y, -st.x);
		} else if (face == 1.0) {
				vec = vec3(-1, -st.y, st.x);
		} else if (face == 2.0) {
				vec = vec3(st.x, 1, st.y);
		} else if (face == 3.0) {
				vec = vec3(st.x, -1, -st.y);
		} else if (face == 4.0) {
				vec = vec3(st.x, -st.y, 1);
		} else {
				vec = vec3(-st.x, -st.y, -1);
		}

		return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));
}

mat3 matrixFromVector(vec3 n) { // frisvad
		float a = 1.0 / (1.0 + n.z);
		float b = -n.x * n.y * a;
		vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
		vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
		return mat3(b1, b2, n);
}

mat3 matrixFromVectorSlow(vec3 n) {
		vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
		vec3 x = normalize(cross(up, n));
		vec3 y = cross(n, x);
		return mat3(x, y, n);
}

vec4 reproject() {
		if (NUM_SAMPLES <= 1) {
				// single sample
				return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
		} else {
				// multi sample
				vec3 t = TARGET_FUNC();
				vec3 tu = dFdx(t);
				vec3 tv = dFdy(t);

				vec3 result = vec3(0.0);
				for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
						for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
								result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
																														tu * (u / NUM_SAMPLES_SQRT - 0.5) +
																														tv * (v / NUM_SAMPLES_SQRT - 0.5))));
						}
				}
				return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
		}
}

vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);

#ifdef USE_SAMPLES_TEX
		void unpackSample(int i, out vec3 L, out float mipLevel) {
				float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
				float v = (floor(u) + 0.5) * samplesTexInverseSize.y;

				vec4 raw;
				raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);

				L.xyz = raw.xyz * 2.0 - 1.0;
				mipLevel = raw.w * 8.0;
		}

		// convolve an environment given pre-generated samples
		vec4 prefilterSamples() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
						totalWeight += L.z;
				}

				return ENCODE_FUNC(result / totalWeight);
		}

		// unweighted version of prefilterSamples
		vec4 prefilterSamplesUnweighted() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
				}

				return ENCODE_FUNC(result / float(NUM_SAMPLES));
		}
#endif

void main(void) {
		gl_FragColor = PROCESS_FUNC();
}
`, bw = `
uniform highp sampler2D uSceneDepthMap;

#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif



#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params; // 1 / camera_far,      camera_far,     camera_near,        is_ortho
#endif

#ifdef GL2
float linearizeDepth(float z) {
		if (camera_params.w == 0.0)
				return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
		else
				return camera_params.z + z * (camera_params.y - camera_params.z);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif
#endif

// Retrieves rendered linear camera depth by UV
float getLinearScreenDepth(vec2 uv) {
		#ifdef GL2
				return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
		#else
				return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;
		#endif
}

#ifndef VERTEXSHADER
// Retrieves rendered linear camera depth under the current pixel
float getLinearScreenDepth() {
		vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
		return getLinearScreenDepth(uv);
}
#endif

// Generates linear camera depth for the given world position
float getLinearDepth(vec3 pos) {
		return -(matrix_view * vec4(pos, 1.0)).z;
}
`, ww = `
const float maxCascades = 4.0;

// shadow matrix for selected cascade
mat4 cascadeShadowMat;

// function which selects a shadow projection matrix based on cascade distances 
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {

		// depth in 0 .. far plane range
		float depth = 1.0 / gl_FragCoord.w;

		// find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)
		float cascadeIndex = 0.0;
		for (float i = 0.0; i < maxCascades; i++) {
				if (depth < shadowCascadeDistances[int(i)]) {
						cascadeIndex = i;
						break;
				}
		}

		// limit to actual number of used cascades
		cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);

		// pick shadow matrix
		#ifdef GL2
				cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
		#else
				// webgl 1 does not allow non-cost index array lookup
				if (cascadeIndex == 0.0) {
						cascadeShadowMat = shadowMatrixPalette[0];
				}
				else if (cascadeIndex == 1.0) {
						cascadeShadowMat = shadowMatrixPalette[1];
				}
				else if (cascadeIndex == 2.0) {
						cascadeShadowMat = shadowMatrixPalette[2];
				}
				else {
						cascadeShadowMat = shadowMatrixPalette[3];
				}
		#endif
}

void fadeShadow(float shadowCascadeDistances[4]) {                  

		// if the pixel is past the shadow distance, remove shadow
		// this enforces straight line instead of corner of shadow which moves when camera rotates  
		float depth = 1.0 / gl_FragCoord.w;
		if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
				dShadowCoord.z = -9999999.0;
		}
}
`, Tw = `
void normalOffsetPointShadow(vec4 shadowParams) {
		float distScale = length(dLightDirW);
		vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale; //0.02
		vec3 dir = wPos - dLightPosW;
		dLightDirW = dir;
}
`, Cw = `
void _getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams, vec3 wPos) {
		dShadowCoord = (shadowMatrix * vec4(wPos, 1.0)).xyz;
		dShadowCoord.z = saturate(dShadowCoord.z) - 0.0001;

		#ifdef SHADOWBIAS
		dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);
		#endif
}

void _getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
		vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
		projPos.xy /= projPos.w;
		dShadowCoord.xy = projPos.xy;
		dShadowCoord.z = length(dLightDirW) * shadowParams.w;

		#ifdef SHADOWBIAS
		dShadowCoord.z += getShadowBias(shadowParams.x, shadowParams.z);
		#endif
}

void getShadowCoordOrtho(mat4 shadowMatrix, vec3 shadowParams) {
		_getShadowCoordOrtho(shadowMatrix, shadowParams, vPositionW);
}

void getShadowCoordPersp(mat4 shadowMatrix, vec4 shadowParams) {
		_getShadowCoordPersp(shadowMatrix, shadowParams, vPositionW);
}

void getShadowCoordPerspNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {
		float distScale = abs(dot(vPositionW - dLightPosW, dLightDirNormW)); // fov?
		vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0) * distScale;

		_getShadowCoordPersp(shadowMatrix, shadowParams, wPos);
}

void getShadowCoordOrthoNormalOffset(mat4 shadowMatrix, vec3 shadowParams) {
		vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y * clamp(1.0 - dot(dVertexNormalW, -dLightDirNormW), 0.0, 1.0); //0.08

		_getShadowCoordOrtho(shadowMatrix, shadowParams, wPos);
}
`, Aw = `
void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
		vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
		projPos.xyz /= projPos.w;
		dShadowCoord = projPos.xyz;
		// depth bias is already applied on render
}

void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams) {
		vec3 wPos = vPositionW + dVertexNormalW * shadowParams.y;
		_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}

void getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams) {
		_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, vPositionW);
}
`, Mw = `
float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec3 moments = texture2D(tex, texCoords).xyz;
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {
		return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {
		return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`, Ew = `
float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		float pixelSize = 1.0 / resolution;
		texCoords -= vec2(pixelSize);
		vec3 s00 = texture2D(tex, texCoords).xyz;
		vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
		vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
		vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
		vec2 fr = fract(texCoords * resolution);
		vec3 h0 = mix(s00, s10, fr.x);
		vec3 h1 = mix(s01, s11, fr.x);
		vec3 moments = mix(h0, h1, fr.y);
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(sampler2D shadowMap, vec3 shadowParams, float exponent) {
		return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(sampler2D shadowMap, vec4 shadowParams, float exponent) {
		return VSM$(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`, Rw = `
vec3 lessThan2(vec3 a, vec3 b) {
		return clamp((b - a)*1000.0, 0.0, 1.0); // softer version
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif

// ----- Direct/Spot Sampling -----

#ifdef GL2

float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {
		float z = dShadowCoord.z;
		vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;

		float sum = 0.0;

		float uw0 = (3.0 - 2.0 * s);
		float uw1 = (1.0 + 2.0 * s);

		float u0 = (2.0 - s) / uw0 - 1.0;
		float u1 = s / uw1 + 1.0;

		float vw0 = (3.0 - 2.0 * t);
		float vw1 = (1.0 + 2.0 * t);

		float v0 = (2.0 - t) / vw0 - 1.0;
		float v1 = t / vw1 + 1.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));

		sum *= 1.0f / 16.0;
		return sum;
}

float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowParams);
}

float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowParams.xyz);
}

#else // GL1

float _xgetShadowPCF3x3(mat3 depthKernel, sampler2D shadowMap, vec3 shadowParams) {
		mat3 shadowKernel;
		vec3 shadowCoord = dShadowCoord;
		vec3 shadowZ = vec3(shadowCoord.z);
		shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));

		vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {
		vec3 shadowCoord = dShadowCoord;

		float xoffset = 1.0 / shadowParams.x; // 1/shadow map width
		float dx0 = -xoffset;
		float dx1 = xoffset;

		mat3 depthKernel;
		depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));
		depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));
		depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));
		depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));
		depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));
		depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));
		depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));
		depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));

		return _xgetShadowPCF3x3(depthKernel, shadowMap, shadowParams);
}

float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowParams);
}

float getShadowSpotPCF3x3(sampler2D shadowMap, vec4 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowParams.xyz);
}
#endif


// ----- Omni Sampling -----

#ifndef WEBGPU

float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {

		vec3 tc = normalize(dir);
		vec3 tcAbs = abs(tc);

		vec4 dirX = vec4(1,0,0, tc.x);
		vec4 dirY = vec4(0,1,0, tc.y);
		float majorAxisLength = tc.z;
		if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
				dirX = vec4(0,0,1, tc.z);
				dirY = vec4(0,1,0, tc.y);
				majorAxisLength = tc.x;
		} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
				dirX = vec4(1,0,0, tc.x);
				dirY = vec4(0,0,1, tc.z);
				majorAxisLength = tc.y;
		}

		float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);

		vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
		vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
		vec3 dx0 = -xoffset;
		vec3 dy0 = -yoffset;
		vec3 dx1 = xoffset;
		vec3 dy1 = yoffset;

		mat3 shadowKernel;
		mat3 depthKernel;

		depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
		depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
		depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
		depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
		depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
		depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
		depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
		depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
		depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));

		vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);

		shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));

		vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;

		vec2 fractionalCoord = fract( uv * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float getShadowPointPCF3x3(samplerCube shadowMap, vec4 shadowParams) {
		return _getShadowPoint(shadowMap, shadowParams, dLightDirW);
}

#endif
`, Lw = `
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {
		// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/

		float z = dShadowCoord.z;
		vec2 uv = dShadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;


		float uw0 = (4.0 - 3.0 * s);
		float uw1 = 7.0;
		float uw2 = (1.0 + 3.0 * s);

		float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
		float u1 = (3.0 + s) / uw1;
		float u2 = s / uw2 + 2.0;

		float vw0 = (4.0 - 3.0 * t);
		float vw1 = 7.0;
		float vw2 = (1.0 + 3.0 * t);

		float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
		float v1 = (3.0 + t) / vw1;
		float v2 = t / vw2 + 2.0;

		float sum = 0.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		u2 = u2 * shadowMapSizeInv + base_uv.x;
		v2 = v2 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));

		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
		sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));

		sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
		sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
		sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));

		sum *= 1.0f / 144.0;

		sum = saturate(sum);

		return sum;
}

float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowParams);
}

float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowParams.xyz);
}
`, Pw = `
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * Z;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float VSM8(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec4 c = texture2D(tex, texCoords);
		vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
		return calculateVSM8(moments, Z, vsmBias);
}

float getShadowVSM8(sampler2D shadowMap, vec3 shadowParams, float exponent) {
		return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, dShadowCoord.z, shadowParams.y, 0.0);
}

float getShadowSpotVSM8(sampler2D shadowMap, vec4 shadowParams, float exponent) {
		return VSM8(shadowMap, dShadowCoord.xy, shadowParams.x, length(dLightDirW) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`, Iw = `
float linstep(float a, float b, float v) {
		return saturate((v - a) / (b - a));
}

float reduceLightBleeding(float pMax, float amount) {
	 // Remove the [0, amount] tail and linearly rescale (amount, 1].
	 return linstep(amount, 1.0, pMax);
}

float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
		// Compute variance
		float variance = moments.y - (moments.x * moments.x);
		variance = max(variance, minVariance);

		// Compute probabilistic upper bound
		float d = mean - moments.x;
		float pMax = variance / (variance + (d * d));

		pMax = reduceLightBleeding(pMax, lightBleedingReduction);

		// One-tailed Chebyshev
		return (mean <= moments.x ? 1.0 : pMax);
}

float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
		Z = 2.0 * Z - 1.0;
		float warpedDepth = exp(exponent * Z);

		moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);

		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * exponent * warpedDepth;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`, Dw = `
attribute float vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

mat4 getBoneMatrix(const in float i) {
		// read 4x3 matrix
		vec4 v1 = matrix_pose[int(3.0 * i)];
		vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];
		vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`, Bw = `
attribute float vertex_boneIndices;

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

mat4 getBoneMatrix(const in float i) {
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;

		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`, Fw = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

void getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {
		// read 4x3 matrix
		v1 = matrix_pose[int(3.0 * i)];
		v2 = matrix_pose[int(3.0 * i + 1.0)];
		v3 = matrix_pose[int(3.0 * i + 2.0)];
}

mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`, Ow = `

attribute vec4 vertex_boneWeights;

#ifdef WEBGPU
		attribute uvec4 vertex_boneIndices;
		#define BoneIndexFormat uint
		#define BoneIndexFormat4 uvec4
#else
		attribute vec4 vertex_boneIndices;
		#define BoneIndexFormat float
		#define BoneIndexFormat4 vec4
#endif

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

void getBoneMatrix(const in BoneIndexFormat index, out vec4 v1, out vec4 v2, out vec4 v3) {

		float i = float(index);
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;
		
		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}

mat4 getSkinMatrix(const in BoneIndexFormat4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`, kw = `
varying vec3 vViewDir;

uniform sampler2D texture_envAtlas;
uniform float mipLevel;

void main(void) {
		vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(normalize(dir));

		vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`, Nw = `
varying vec3 vViewDir;

uniform samplerCube texture_cubeMap;

void main(void) {
		vec3 dir=vViewDir;
		dir.x *= -1.0;

		vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`, zw = `
attribute vec3 aPosition;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;

varying vec3 vViewDir;

void main(void) {
		mat4 view = matrix_view;
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);

		// Force skybox to far Z, regardless of the clip planes on the camera
		// Subtract a tiny fudge factor to ensure floating point errors don't
		// still push pixels beyond far Z. See:
		// http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem

		gl_Position.z = gl_Position.w - 0.00001;
		vViewDir = aPosition * cubeMapRotationMatrix;
}
`, Uw = `

#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif

void getSpecularity() {
		vec3 specularColor = vec3(1,1,1);

		#ifdef MAPCOLOR
		specularColor *= material_specular;
		#endif

		#ifdef MAPTEXTURE
		specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		specularColor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularity = specularColor;
}
`, Vw = `
// equirectangular helper functions
const float PI = 3.141592653589793;

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec2 toSphericalUv(vec3 dir) {
		vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
		return vec2(uv.x, 1.0 - uv.y);
}
`, Gw = `

#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif

void getSpecularityFactor() {
		float specularityFactor = 1.0;

		#ifdef MAPFLOAT
		specularityFactor *= material_specularityFactor;
		#endif

		#ifdef MAPTEXTURE
		specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		specularityFactor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularityFactor = specularityFactor;
}
`, Hw = `
float getSpotEffect(vec3 lightSpotDirW, float lightInnerConeAngle, float lightOuterConeAngle) {
		float cosAngle = dot(dLightDirNormW, lightSpotDirW);
		return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`, Ww = `
void main(void) {
		dReflection = vec4(0);

		#ifdef LIT_CLEARCOAT
		ccSpecularLight = vec3(0);
		ccReflection = vec3(0);
		#endif
`, qw = `
void main(void) {
		gl_Position = getPosition();
`, Xw = `
		nineSlicedUv = vUv0;
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;

`, jw = `
		vec2 tileMask = step(vMask, vec2(0.99999));
		vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
		vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
		vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
		clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
		nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;
		
`, $w = `
float exponent = VSM_EXPONENT;

depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`, Yw = `
vec3 getTangent() {
		return normalize(dNormalMatrix * vertex_tangent.xyz);
}

vec3 getBinormal() {
		return cross(vNormalW, vTangentW) * vertex_tangent.w;
}

vec3 getObjectSpaceUp() {
		return normalize(dNormalMatrix * vec3(0, 1, 0));
}
`, Kw = `
void getTBN() {
		dTBN = mat3(normalize(dTangentW), normalize(dBinormalW), normalize(dVertexNormalW));
}
`, Zw = `
uniform float tbnBasis;

// http://www.thetenthplanet.de/archives/1180
void getTBN() {
		vec2 uv = $UV;

		// get edge vectors of the pixel triangle
		vec3 dp1 = dFdx( vPositionW );
		vec3 dp2 = dFdy( vPositionW );
		vec2 duv1 = dFdx( uv );
		vec2 duv2 = dFdy( uv );

		// solve the linear system
		vec3 dp2perp = cross( dp2, dVertexNormalW );
		vec3 dp1perp = cross( dVertexNormalW, dp1 );
		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

		// construct a scale-invariant frame
		float denom = max( dot(T,T), dot(B,B) );
		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
		dTBN = mat3(T * invmax, -B * invmax, dVertexNormalW );
}
`, Jw = `
void getTBN() {
		dTBN = mat3(dTangentW, dBinormalW, dVertexNormalW);
}
`, Qw = `
void getTBN() {

		vec3 B = cross(dVertexNormalW, vObjectSpaceUpW);
		vec3 T = cross(dVertexNormalW, B);

		if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW dVertexNormalW are parallel
		{
				float major=max(max(dVertexNormalW.x, dVertexNormalW.y),dVertexNormalW.z);

				if (dVertexNormalW.x==major)
				{
						B=cross(dVertexNormalW, vec3(0,1,0));
						T=cross(dVertexNormalW, B);
				}
				else if (dVertexNormalW.y==major)
				{
						B=cross(dVertexNormalW, vec3(0,0,1));
						T=cross(dVertexNormalW, B);
				}
				else if (dVertexNormalW.z==major)
				{
						B=cross(dVertexNormalW, vec3(1,0,0));
						T=cross(dVertexNormalW, B);
				}
		}

		dTBN = mat3(normalize(T), normalize(B), normalize(dVertexNormalW));
}
`, eT = `
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
		return gammaCorrectInput(texture2D(tex, uv));
}

vec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {
		return gammaCorrectInput(texture2D(tex, uv, bias));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}
`, tT = `
#ifdef MAPFLOAT
uniform float material_thickness;
#endif

void getThickness() {
		dThickness = 1.0;

		#ifdef MAPFLOAT
		dThickness *= material_thickness;
		#endif

		#ifdef MAPTEXTURE
		dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dThickness *= saturate(vVertexColor.$VC);
		#endif
}
`, sT = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		float tA = 2.51;
		float tB = 0.03;
		float tC = 2.43;
		float tD = 0.59;
		float tE = 0.14;
		vec3 x = color * exposure;
		return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`, iT = `
uniform float exposure;

// ACES approximation by Stephen Hill

// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
const mat3 ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
);

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat = mat3(
		 1.60475, -0.53108, -0.07367,
		-0.10208,  1.10813, -0.00605,
		-0.00327, -0.07276,  1.07602
);

vec3 RRTAndODTFit(vec3 v) {
		vec3 a = v * (v + 0.0245786) - 0.000090537;
		vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
		return a / b;
}

vec3 toneMap(vec3 color) {
		color *= exposure;
		color = color * ACESInputMat;

		// Apply RRT and ODT
		color = RRTAndODTFit(color);
		color = color * ACESOutputMat;

		// Clamp to [0, 1]
		color = clamp(color, 0.0, 1.0);

		return color;
}
`, nT = `
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;

uniform float exposure;

vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 toneMap(vec3 color) {
		color = uncharted2Tonemap(color * exposure);
		vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
		color = color * whiteScale;

		return color;
}
`, rT = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		color *= exposure;
		const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
		const float Scl = 1.25;

		vec3 h = max( vec3(0.0), color - vec3(0.004) );
		return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`, aT = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		return color * exposure;
}
`, oT = `
vec3 toneMap(vec3 color) {
		return color;
}
`, hT = `
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif

#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif

#ifdef MORPHING
uniform vec4 morph_weights_a;
uniform vec4 morph_weights_b;
#endif

#ifdef MORPHING_TEXTURE_BASED
uniform vec4 morph_tex_params;

vec2 getTextureMorphCoords() {
		float vertexId = morph_vertex_id;
		vec2 textureSize = morph_tex_params.xy;
		vec2 invTextureSize = morph_tex_params.zw;

		// turn vertexId into int grid coordinates
		float morphGridV = floor(vertexId * invTextureSize.x);
		float morphGridU = vertexId - (morphGridV * textureSize.x);

		// convert grid coordinates to uv coordinates with half pixel offset
		vec2 uv = (vec2(morphGridU, morphGridV) * invTextureSize) + (0.5 * invTextureSize);
		return getImageEffectUV(uv);
}
#endif

#ifdef MORPHING_TEXTURE_BASED_POSITION
uniform highp sampler2D morphPositionTex;
#endif

mat4 getModelMatrix() {
		#ifdef DYNAMICBATCH
		return getBoneMatrix(vertex_boneIndices);
		#elif defined(SKIN)
		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
		#elif defined(INSTANCING)
		return mat4(instance_line1, instance_line2, instance_line3, instance_line4);
		#else
		return matrix_model;
		#endif
}

vec4 getPosition() {
		dModelMatrix = getModelMatrix();
		vec3 localPos = vertex_position;

		#ifdef NINESLICED
		// outer and inner vertices are at the same position, scale both
		localPos.xz *= outerScale;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner

		localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5
		localPos = localPos.xzy;
		#endif

		#ifdef MORPHING
		#ifdef MORPHING_POS03
		localPos.xyz += morph_weights_a[0] * morph_pos0;
		localPos.xyz += morph_weights_a[1] * morph_pos1;
		localPos.xyz += morph_weights_a[2] * morph_pos2;
		localPos.xyz += morph_weights_a[3] * morph_pos3;
		#endif // MORPHING_POS03
		#ifdef MORPHING_POS47
		localPos.xyz += morph_weights_b[0] * morph_pos4;
		localPos.xyz += morph_weights_b[1] * morph_pos5;
		localPos.xyz += morph_weights_b[2] * morph_pos6;
		localPos.xyz += morph_weights_b[3] * morph_pos7;
		#endif // MORPHING_POS47
		#endif // MORPHING

		#ifdef MORPHING_TEXTURE_BASED_POSITION
		// apply morph offset from texture
		vec2 morphUV = getTextureMorphCoords();
		vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;
		localPos += morphPos;
		#endif

		vec4 posW = dModelMatrix * vec4(localPos, 1.0);
		#ifdef SCREENSPACE
		posW.zw = vec2(0.0, 1.0);
		#endif
		dPositionW = posW.xyz;

		vec4 screenPos;
		#ifdef UV1LAYOUT
		screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#else
		#ifdef SCREENSPACE
		screenPos = posW;
		screenPos.y *= projectionFlipY;
		#else
		screenPos = matrix_viewProjection * posW;
		#endif

		#ifdef PIXELSNAP
		// snap vertex to a pixel boundary
		screenPos.xy = (screenPos.xy * 0.5) + 0.5;
		screenPos.xy *= uScreenSize.xy;
		screenPos.xy = floor(screenPos.xy);
		screenPos.xy *= uScreenSize.zw;
		screenPos.xy = (screenPos.xy * 2.0) - 1.0;
		#endif
		#endif

		return screenPos;
}

vec3 getWorldPosition() {
		return dPositionW;
}
`, lT = `
attribute vec3 vertex_position;

uniform mat4 matrix_model;
uniform mat4 matrix_viewProjection;

vec3 dPositionW;
mat4 dModelMatrix;
`, cT = `

#ifdef MAPFLOAT
uniform float material_refraction;
#endif

void getRefraction() {
		float refraction = 1.0;

		#ifdef MAPFLOAT
		refraction = material_refraction;
		#endif

		#ifdef MAPTEXTURE
		refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		refraction *= saturate(vVertexColor.$VC);
		#endif

		dTransmission = refraction;
}
`, dT = `
#ifdef NINESLICED
vec2 getUv0() {
		vec2 uv = vertex_position.xz;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		uv = uv * -0.5 + 0.5;
		uv = uv * atlasRect.zw + atlasRect.xy;

		vMask = vertex_texCoord0.xy;

		return uv;
}
#else
vec2 getUv0() {
		return vertex_texCoord0;
}
#endif
`, uT = `
vec2 getUv1() {
		return vertex_texCoord1;
}
`, fT = `
void getViewDir() {
		dViewDirW = normalize(view_position - vPositionW);
}
`, mT = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

vec3 getViewNormal() {
		return mat3(matrix_view) * vNormalW;
}
`;
const N = {
  alphaTestPS: Gv,
  ambientConstantPS: Hv,
  ambientEnvPS: Wv,
  ambientSHPS: qv,
  aoPS: Xv,
  aoDiffuseOccPS: jv,
  aoSpecOccPS: $v,
  aoSpecOccConstPS: Yv,
  aoSpecOccConstSimplePS: Kv,
  aoSpecOccSimplePS: Zv,
  basePS: Jv,
  baseVS: Qv,
  baseNineSlicedPS: eS,
  baseNineSlicedVS: tS,
  baseNineSlicedTiledPS: sS,
  biasConstPS: iS,
  blurVSMPS: nS,
  clearCoatPS: rS,
  clearCoatGlossPS: aS,
  clearCoatNormalPS: oS,
  clusteredLightCookiesPS: lS,
  clusteredLightShadowsPS: cS,
  clusteredLightUtilsPS: hS,
  clusteredLightPS: dS,
  combinePS: uS,
  cookiePS: fS,
  cubeMapProjectBoxPS: mS,
  cubeMapProjectNonePS: pS,
  cubeMapRotatePS: _S,
  detailModesPS: gS,
  diffusePS: yS,
  diffuseDetailMapPS: xS,
  decodePS: ig,
  emissivePS: vS,
  encodePS: ng,
  endPS: SS,
  endVS: bS,
  envAtlasPS: wS,
  envConstPS: TS,
  envMultiplyPS: CS,
  extensionPS: AS,
  extensionVS: MS,
  falloffInvSquaredPS: ES,
  falloffLinearPS: RS,
  fixCubemapSeamsNonePS: LS,
  fixCubemapSeamsStretchPS: PS,
  floatUnpackingPS: IS,
  fogExpPS: DS,
  fogExp2PS: BS,
  fogLinearPS: FS,
  fogNonePS: OS,
  fresnelSchlickPS: kS,
  fullscreenQuadPS: NS,
  fullscreenQuadVS: zS,
  gamma1_0PS: US,
  gamma2_2PS: VS,
  gles2PS: V_,
  gles3PS: G_,
  gles3VS: H_,
  glossPS: GS,
  iridescenceDiffractionPS: HS,
  iridescencePS: WS,
  iridescenceThicknessPS: qS,
  instancingVS: XS,
  lightDiffuseLambertPS: jS,
  lightDirPointPS: $S,
  lightmapAddPS: YS,
  lightmapDirAddPS: KS,
  lightmapDirPS: ZS,
  lightmapSinglePS: JS,
  lightSpecularAnisoGGXPS: QS,
  lightSpecularBlinnPS: eb,
  lightSpecularPhongPS: tb,
  lightSheenPS: sb,
  ltcPS: ib,
  metalnessPS: nb,
  metalnessModulatePS: ab,
  msdfPS: rb,
  msdfVS: ob,
  normalVS: hb,
  normalDetailMapPS: lb,
  normalInstancedVS: cb,
  normalMapPS: db,
  normalSkinnedVS: ub,
  normalXYPS: fb,
  normalXYZPS: mb,
  opacityPS: pb,
  outputAlphaPS: _b,
  outputAlphaOpaquePS: gb,
  outputAlphaPremulPS: yb,
  outputTex2DPS: xb,
  packDepthPS: vb,
  sheenPS: Sb,
  sheenGlossPS: bb,
  parallaxPS: wb,
  particlePS: Tb,
  particleVS: Cb,
  particleAnimFrameClampVS: Ab,
  particleAnimFrameLoopVS: Mb,
  particleAnimTexVS: Eb,
  particleInputFloatPS: Rb,
  particleInputRgba8PS: Lb,
  particleOutputFloatPS: Pb,
  particleOutputRgba8PS: Ib,
  particleUpdaterAABBPS: Db,
  particleUpdaterEndPS: Bb,
  particleUpdaterInitPS: Fb,
  particleUpdaterNoRespawnPS: Ob,
  particleUpdaterOnStopPS: kb,
  particleUpdaterRespawnPS: Nb,
  particleUpdaterSpherePS: zb,
  particleUpdaterStartPS: Ub,
  particle_billboardVS: Vb,
  particle_blendAddPS: Gb,
  particle_blendMultiplyPS: Hb,
  particle_blendNormalPS: Wb,
  particle_cpuVS: qb,
  particle_cpu_endVS: Xb,
  particle_customFaceVS: jb,
  particle_endPS: $b,
  particle_endVS: Yb,
  particle_halflambertPS: Kb,
  particle_initVS: Zb,
  particle_lambertPS: Jb,
  particle_lightingPS: Qb,
  particle_localShiftVS: ew,
  particle_meshVS: tw,
  particle_normalVS: sw,
  particle_normalMapPS: iw,
  particle_pointAlongVS: nw,
  particle_softPS: rw,
  particle_softVS: aw,
  particle_stretchVS: ow,
  particle_TBNVS: hw,
  particle_wrapVS: lw,
  reflDirPS: cw,
  reflDirAnisoPS: dw,
  reflectionCCPS: uw,
  reflectionCubePS: fw,
  reflectionEnvHQPS: mw,
  reflectionEnvPS: pw,
  reflectionSpherePS: _w,
  reflectionSphereLowPS: gw,
  reflectionSheenPS: yw,
  refractionCubePS: xw,
  refractionDynamicPS: vw,
  reprojectPS: Sw,
  screenDepthPS: bw,
  shadowCascadesPS: ww,
  shadowCommonPS: Tw,
  shadowCoordPS: Cw,
  shadowCoordPerspZbufferPS: Aw,
  shadowEVSMPS: Mw,
  shadowEVSMnPS: Ew,
  shadowStandardPS: Rw,
  shadowStandardGL2PS: Lw,
  shadowVSM8PS: Pw,
  shadowVSM_commonPS: Iw,
  skinBatchConstVS: Dw,
  skinBatchTexVS: Bw,
  skinConstVS: Fw,
  skinTexVS: Ow,
  skyboxEnvPS: kw,
  skyboxHDRPS: Nw,
  skyboxVS: zw,
  specularPS: Uw,
  sphericalPS: Vw,
  specularityFactorPS: Gw,
  spotPS: Hw,
  startPS: Ww,
  startVS: qw,
  startNineSlicedPS: Xw,
  startNineSlicedTiledPS: jw,
  storeEVSMPS: $w,
  tangentBinormalVS: Yw,
  TBNPS: Kw,
  TBNderivativePS: Zw,
  TBNfastPS: Jw,
  TBNObjectSpacePS: Qw,
  textureSamplePS: eT,
  thicknessPS: tT,
  tonemappingAcesPS: sT,
  tonemappingAces2PS: iT,
  tonemappingFilmicPS: nT,
  tonemappingHejlPS: rT,
  tonemappingLinearPS: aT,
  tonemappingNonePS: oT,
  transformVS: hT,
  transformDeclVS: lT,
  transmissionPS: cT,
  uv0VS: dT,
  uv1VS: uT,
  viewDirPS: fT,
  viewNormalVS: mT,
  webgpuPS: W_,
  webgpuVS: q_
}, rg = new Ji();
function Vn(r) {
  return rg.get(r);
}
function pT(r, e) {
  rg.get(r, () => e);
}
function _T(r, e, t, s = !1) {
  return new Vr(r, pt.createDefinition(r, {
    name: `${e}_${t}`,
    vertexCode: N[e],
    fragmentCode: N[t],
    useTransformFeedback: s
  }));
}
function ps(r, e, t, s, i, n = !1) {
  const a = Vn(r);
  let o = a.getCachedShader(s);
  return o || (o = new Vr(r, pt.createDefinition(r, {
    name: s,
    vertexCode: e,
    fragmentCode: t,
    attributes: i,
    useTransformFeedback: n
  })), a.setCachedShader(s, o)), o;
}
function ag(r, e) {
  var t;
  const s = r.definition, n = `${(t = s.name) != null ? t : "shader"}-id-${r.id}`, a = {
    generateKey: function(c) {
      return n;
    },
    createShaderDefinition: function(c, d) {
      return s;
    }
  }, o = "shader", h = Vn(r.device);
  h.register(o, a);
  const l = h.getProgram(o, {}, e);
  return h.unregister(o), l;
}
N.createShader = _T;
N.createShaderFromCode = ps;
const gT = {
  type: jr,
  base: 0,
  count: 4,
  indexed: !1
}, Qr = new Z(), ea = new Z();
class yT {
  constructor(e) {
    this.uniformBuffer = void 0, this.bindGroup = void 0;
    const t = e.device;
    if (this.shader = e, t.supportsUniformBuffers) {
      const s = new $r();
      this.shader = ag(e, s);
      const i = this.shader.meshUniformBufferFormat;
      i && (this.uniformBuffer = new Gu(t, i));
      const n = this.shader.meshBindGroupFormat;
      this.bindGroup = new Vu(t, n, this.uniformBuffer);
    }
  }
  destroy() {
    var e, t;
    (e = this.uniformBuffer) == null || e.destroy(), this.uniformBuffer = null, (t = this.bindGroup) == null || t.destroy(), this.bindGroup = null;
  }
  render(e, t) {
    const s = this.shader.device;
    if (e) {
      var i;
      Qr.set(s.vx, s.vy, s.vw, s.vh), ea.set(s.sx, s.sy, s.sw, s.sh), t = (i = t) != null ? i : e, s.setViewport(e.x, e.y, e.z, e.w), s.setScissor(t.x, t.y, t.z, t.w);
    }
    s.setVertexBuffer(s.quadVertexBuffer, 0);
    const n = this.shader;
    if (s.setShader(n), s.supportsUniformBuffers) {
      const a = this.bindGroup;
      a.defaultUniformBuffer && a.defaultUniformBuffer.update(), a.update(), s.setBindGroup(B_, a);
    }
    s.draw(gT), e && (s.setViewport(Qr.x, Qr.y, Qr.z, Qr.w), s.setScissor(ea.x, ea.y, ea.z, ea.w));
  }
}
const xT = new Z();
function Yi(r, e, t, s, i, n = !1) {
  const a = r.getDepthTest(), o = r.getDepthWrite(), h = r.getCullMode(), l = r.writeRed, c = r.writeGreen, d = r.writeBlue, u = r.writeAlpha;
  r.setDepthTest(!1), r.setDepthWrite(!1), r.setCullMode(Ft), r.setColorWrite(!0, !0, !0, !0), n || r.setBlending(!1);
  const f = new yT(t);
  s || (s = xT, s.x = 0, s.y = 0, s.z = e ? e.width : r.width, s.w = e ? e.height : r.height);
  const m = new vr(r, () => {
    f.render(s, i);
  });
  m.init(e), m.colorOps.clear = !1, m.depthStencilOps.clearDepth = !1, r.deviceType === Et && (m.depthStencilOps.clearDepth = !0), m.render(), f.destroy(), r.setDepthTest(a), r.setDepthWrite(o), r.setCullMode(h), r.setColorWrite(l, c, d, u);
}
class Ut {
  static getType(e) {
    switch (e) {
      case Er:
      case fi:
        return oc;
      case As:
        return Cv;
      case Hr:
        return Av;
      default:
        return e >= vn && e < vn + Zr * hv ? Vf : oc;
    }
  }
  static isForward(e) {
    return this.getType(e) === oc;
  }
  static isShadow(e) {
    return this.getType(e) === Vf;
  }
  static toLightType(e) {
    const t = e - vn;
    return Math.floor(t / Zr);
  }
  static toShadowType(e) {
    const t = e - vn, s = Math.floor(t / Zr);
    return t - s * Zr;
  }
  static getShadow(e, t) {
    const s = t + e * Zr;
    return vn + s;
  }
  static getPassShaderDefine(e) {
    return e === Hr ? `#define PICK_PASS
` : e === As ? `#define DEPTH_PASS
` : Ut.isShadow(e) ? `#define SHADOW_PASS
` : "";
  }
}
function Yh(r, e) {
  return e || (e = N), r === Y_ || r === xv ? e.gamma2_2PS ? e.gamma2_2PS : N.gamma2_2PS : r === Vh ? `#define HDR
` + (e.gamma2_2PS ? e.gamma2_2PS : N.gamma2_2PS) : e.gamma1_0PS ? e.gamma1_0PS : N.gamma1_0PS;
}
function Kh(r, e) {
  return e || (e = N), r === vv ? e.tonemappingFilmicPS ? e.tonemappingFilmicPS : N.tonemappingFilmicPS : r === Gh ? e.tonemappingLinearPS ? e.tonemappingLinearPS : N.tonemappingLinearPS : r === Sv ? e.tonemappingHejlPS ? e.tonemappingHejlPS : N.tonemappingHejlPS : r === bv ? e.tonemappingAcesPS ? e.tonemappingAcesPS : N.tonemappingAcesPS : r === wv ? e.tonemappingAces2PS ? e.tonemappingAces2PS : N.tonemappingAces2PS : e.tonemapingNonePS ? e.tonemapingNonePS : N.tonemappingNonePS;
}
function og(r, e) {
  return e || (e = N), r === "linear" ? e.fogLinearPS ? e.fogLinearPS : N.fogLinearPS : r === "exp" ? e.fogExpPS ? e.fogExpPS : N.fogExpPS : r === "exp2" ? e.fogExp2PS ? e.fogExp2PS : N.fogExp2PS : e.fogNonePS ? e.fogNonePS : N.fogNonePS;
}
function hg(r, e) {
  return e || (e = N), r.supportsBoneTextures ? e.skinTexVS : "#define BONE_LIMIT " + r.getBoneLimit() + `
` + e.skinConstVS;
}
function Fa() {
  return `void main(void)
{
`;
}
function Sr() {
  return `}
`;
}
const vT = {
  generateKey: function(r) {
    let e = "basic";
    return r.fog && (e += "_fog"), r.alphaTest && (e += "_atst"), r.vertexColors && (e += "_vcol"), r.diffuseMap && (e += "_diff"), r.skin && (e += "_skin"), r.screenSpace && (e += "_ss"), r.useInstancing && (e += "_inst"), r.useMorphPosition && (e += "_morphp"), r.useMorphNormal && (e += "_morphn"), r.useMorphTextureBased && (e += "_morpht"), e += "_" + r.pass, e;
  },
  createShaderDefinition: function(r, e) {
    const t = {
      vertex_position: et
    };
    e.skin && (t.vertex_boneWeights = Xs, t.vertex_boneIndices = ts), e.vertexColors && (t.vertex_color = It), e.diffuseMap && (t.vertex_texCoord0 = rs);
    const s = Ut.getPassShaderDefine(e.pass);
    let i = s;
    i += N.transformDeclVS, e.skin ? (i += hg(r), i += N.transformSkinnedVS) : i += N.transformVS, e.vertexColors && (i += `attribute vec4 vertex_color;
`, i += `varying vec4 vColor;
`), e.diffuseMap && (i += `attribute vec2 vertex_texCoord0;
`, i += `varying vec2 vUv0;
`), e.pass === As && (i += `varying float vDepth;
`, i += `#ifndef VIEWMATRIX
`, i += `#define VIEWMATRIX
`, i += `uniform mat4 matrix_view;
`, i += `#endif
`, i += `#ifndef CAMERAPLANES
`, i += `#define CAMERAPLANES
`, i += `uniform vec4 camera_params;

`, i += `#endif
`), i += Fa(), i += `   gl_Position = getPosition();
`, e.pass === As && (i += `    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;
`), e.vertexColors && (i += `    vColor = vertex_color;
`), e.diffuseMap && (i += `    vUv0 = vertex_texCoord0;
`), i += Sr();
    let n = s;
    return e.vertexColors ? n += `varying vec4 vColor;
` : n += `uniform vec4 uColor;
`, e.diffuseMap && (n += `varying vec2 vUv0;
`, n += `uniform sampler2D texture_diffuseMap;
`), e.fog && (n += og(e.fog)), e.alphaTest && (n += N.alphaTestPS), e.pass === As && (n += `varying float vDepth;
`, n += N.packDepthPS), n += Fa(), e.vertexColors ? n += `    gl_FragColor = vColor;
` : n += `    gl_FragColor = uColor;
`, e.diffuseMap && (n += `    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);
`), e.alphaTest && (n += `   alphaTest(gl_FragColor.a);
`), e.pass !== Hr && (e.pass === As ? n += `    gl_FragColor = packFloat(vDepth);
` : e.fog && (n += `   glFragColor.rgb = addFog(gl_FragColor.rgb);
`)), n += Sr(), pt.createDefinition(r, {
      name: "BasicShader",
      attributes: t,
      vertexCode: i,
      fragmentCode: n
    });
  }
}, lg = new Ji();
function io(r) {
  return lg.get(r);
}
function ST(r, e) {
  lg.get(r, () => e);
}
let bT = 0;
class Ki {
  constructor() {
    this._shader = null, this.meshInstances = [], this.name = "Untitled", this.id = bT++, this.variants = {}, this.parameters = {}, this.alphaTest = 0, this.alphaToCoverage = !1, this.blend = !1, this.blendSrc = We, this.blendDst = yn, this.blendEquation = ot, this.separateAlphaBlend = !1, this.blendSrcAlpha = We, this.blendDstAlpha = yn, this.blendAlphaEquation = ot, this.cull = Br, this.depthTest = !0, this.depthFunc = Sl, this.depthWrite = !0, this.stencilFront = null, this.stencilBack = null, this.depthBias = 0, this.slopeDepthBias = 0, this.redWrite = !0, this.greenWrite = !0, this.blueWrite = !0, this.alphaWrite = !0, this._shaderVersion = 0, this._scene = null, this._dirtyBlend = !1, this.dirty = !0;
  }
  set shader(e) {
    this._shader = e;
  }
  get shader() {
    return this._shader;
  }
  get transparent() {
    return this.blend;
  }
  set blendType(e) {
    let t = !0;
    switch (e) {
      case ss:
        t = !1, this.blendSrc = We, this.blendDst = yn, this.blendEquation = ot;
        break;
      case Vt:
        this.blendSrc = yo, this.blendDst = xo, this.blendEquation = ot;
        break;
      case $i:
        this.blendSrc = We, this.blendDst = xo, this.blendEquation = ot;
        break;
      case Oh:
        this.blendSrc = We, this.blendDst = We, this.blendEquation = ot;
        break;
      case Nh:
        this.blendSrc = yo, this.blendDst = We, this.blendEquation = ot;
        break;
      case Sd:
        this.blendSrc = go, this.blendDst = Tf, this.blendEquation = ot;
        break;
      case bd:
        this.blendSrc = Cf, this.blendDst = We, this.blendEquation = ot;
        break;
      case kh:
        this.blendSrc = go, this.blendDst = yn, this.blendEquation = ot;
        break;
      case wd:
        this.blendSrc = We, this.blendDst = We, this.blendEquation = Af;
        break;
      case Td:
        this.blendSrc = We, this.blendDst = We, this.blendEquation = Mf;
        break;
    }
    this.blend !== t && (this.blend = t, this._scene ? this._scene.layers._dirtyBlend = !0 : this._dirtyBlend = !0), this._updateMeshInstanceKeys();
  }
  get blendType() {
    return this.blend ? this.blendSrc === yo && this.blendDst === xo && this.blendEquation === ot ? Vt : this.blendSrc === We && this.blendDst === We && this.blendEquation === ot ? Oh : this.blendSrc === yo && this.blendDst === We && this.blendEquation === ot ? Nh : this.blendSrc === go && this.blendDst === Tf && this.blendEquation === ot ? Sd : this.blendSrc === Cf && this.blendDst === We && this.blendEquation === ot ? bd : this.blendSrc === We && this.blendDst === We && this.blendEquation === Af ? wd : this.blendSrc === We && this.blendDst === We && this.blendEquation === Mf ? Td : this.blendSrc === go && this.blendDst === yn && this.blendEquation === ot ? kh : this.blendSrc === We && this.blendDst === xo && this.blendEquation === ot ? $i : Vt : ss;
  }
  copy(e) {
    return this.name = e.name, this._shader = e._shader, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.blend = e.blend, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.separateAlphaBlend = e.separateAlphaBlend, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendAlphaEquation = e.blendAlphaEquation, this.cull = e.cull, this.depthTest = e.depthTest, this.depthFunc = e.depthFunc, this.depthWrite = e.depthWrite, this.depthBias = e.depthBias, this.slopeDepthBias = e.slopeDepthBias, e.stencilFront && (this.stencilFront = e.stencilFront.clone()), e.stencilBack && (e.stencilFront === e.stencilBack ? this.stencilBack = this.stencilFront : this.stencilBack = e.stencilBack.clone()), this.redWrite = e.redWrite, this.greenWrite = e.greenWrite, this.blueWrite = e.blueWrite, this.alphaWrite = e.alphaWrite, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  _updateMeshInstanceKeys() {
    const e = this.meshInstances;
    for (let t = 0; t < e.length; t++)
      e[t].updateKey();
  }
  updateUniforms(e, t) {
  }
  getShaderVariant(e, t, s, i, n, a, o, h) {
    const l = new $r(o, h);
    return ag(this._shader, l);
  }
  update() {
    this.dirty = !0, this._shader && (this._shader.failed = !1);
  }
  clearParameters() {
    this.parameters = {};
  }
  getParameters() {
    return this.parameters;
  }
  clearVariants() {
    this.variants = {};
    const e = this.meshInstances, t = e.length;
    for (let s = 0; s < t; s++)
      e[s].clearShaders();
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    if (t === void 0 && typeof e == "object") {
      const i = e;
      if (i.length) {
        for (let n = 0; n < i.length; n++)
          this.setParameter(i[n]);
        return;
      }
      e = i.name, t = i.value;
    }
    const s = this.parameters[e];
    s ? s.data = t : this.parameters[e] = {
      scopeId: null,
      data: t
    };
  }
  deleteParameter(e) {
    this.parameters[e] && delete this.parameters[e];
  }
  setParameters(e, t) {
    const s = this.parameters;
    t === void 0 && (t = s);
    for (const i in t) {
      const n = s[i];
      n && (n.scopeId || (n.scopeId = e.scope.resolve(i)), n.scopeId.setValue(n.data));
    }
  }
  destroy() {
    this.variants = {}, this._shader = null;
    for (let e = 0; e < this.meshInstances.length; e++) {
      const t = this.meshInstances[e];
      if (t.clearShaders(), t._material = null, t.mesh) {
        const s = io(t.mesh.device);
        this !== s && (t.material = s);
      }
    }
    this.meshInstances.length = 0;
  }
  addMeshInstanceRef(e) {
    this.meshInstances.push(e);
  }
  removeMeshInstanceRef(e) {
    const t = this.meshInstances, s = t.indexOf(e);
    s !== -1 && t.splice(s, 1);
  }
}
class Tn extends Ki {
  constructor() {
    super(), this.color = new z(1, 1, 1, 1), this.colorUniform = new Float32Array(4), this.colorMap = null, this.vertexColors = !1;
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.colorMap = e.colorMap, this.vertexColors = e.vertexColors, this;
  }
  updateUniforms(e, t) {
    this.clearParameters(), this.colorUniform[0] = this.color.r, this.colorUniform[1] = this.color.g, this.colorUniform[2] = this.color.b, this.colorUniform[3] = this.color.a, this.setParameter("uColor", this.colorUniform), this.colorMap && this.setParameter("texture_diffuseMap", this.colorMap);
  }
  getShaderVariant(e, t, s, i, n, a, o, h) {
    if (this.updateShader)
      return this.updateShader(e, t, s, i, n, a), this.shader;
    const l = {
      skin: s && (s & Hh) !== 0,
      screenSpace: s && (s & qh) !== 0,
      useInstancing: s && (s & Q_) !== 0,
      useMorphPosition: s && (s & Xh) !== 0,
      useMorphNormal: s && (s & jh) !== 0,
      useMorphTextureBased: s && (s & $h) !== 0,
      alphaTest: this.alphaTest > 0,
      vertexColors: this.vertexColors,
      diffuseMap: !!this.colorMap,
      pass: n
    }, c = new $r(o, h), d = Vn(e);
    return d.register("basic", vT), d.getProgram("basic", l, c);
  }
}
class qf {
  constructor(e, t, s) {
    this.origMeshInstances = e, this._aabb = new Pe(), this.meshInstance = null, this.dynamic = t, this.batchGroupId = s;
  }
  destroy(e, t) {
    this.meshInstance && (this.removeFromLayers(e, t), this.meshInstance.destroy(), this.meshInstance = null);
  }
  addToLayers(e, t) {
    for (let s = 0; s < t.length; s++) {
      const i = e.layers.getLayerById(t[s]);
      i && i.addMeshInstances([this.meshInstance]);
    }
  }
  removeFromLayers(e, t) {
    for (let s = 0; s < t.length; s++) {
      const i = e.layers.getLayerById(t[s]);
      i && i.removeMeshInstances([this.meshInstance]);
    }
  }
  updateBoundingBox() {
    this._aabb.copy(this.origMeshInstances[0].aabb);
    for (let e = 1; e < this.origMeshInstances.length; e++)
      this._aabb.add(this.origMeshInstances[e].aabb);
    this.meshInstance.aabb = this._aabb, this.meshInstance._aabbVer = 0;
  }
}
class nt {
  constructor(e, t, s, i, n = [wi]) {
    this.dynamic = s, this.maxAabbSize = i, this.id = e, this.name = t, this.layers = n, this._ui = !1, this._sprite = !1, this._obj = {
      model: [],
      element: [],
      sprite: [],
      render: []
    };
  }
}
nt.MODEL = "model";
nt.ELEMENT = "element";
nt.SPRITE = "sprite";
nt.RENDER = "render";
const Xf = new j();
class no {
  constructor(e) {
    this.bones = void 0, this._dirty = !0, this._rootBone = null, this._skinUpdateIndex = -1, this._updateBeforeCull = !0, e && this.initSkin(e);
  }
  set rootBone(e) {
    this._rootBone = e;
  }
  get rootBone() {
    return this._rootBone;
  }
  init(e, t) {
    if (e.supportsBoneTextures) {
      const s = t * 3;
      let i = Math.ceil(Math.sqrt(s));
      i = U.roundUp(i, 3);
      const n = Math.ceil(s / i);
      this.boneTexture = new ue(e, {
        width: i,
        height: n,
        format: vt,
        mipmaps: !1,
        minFilter: Be,
        magFilter: Be,
        name: "skin"
      }), this.matrixPalette = this.boneTexture.lock();
    } else
      this.matrixPalette = new Float32Array(t * 12);
  }
  destroy() {
    this.boneTexture && (this.boneTexture.destroy(), this.boneTexture = null);
  }
  resolve(e, t) {
    this.rootBone = e;
    const s = this.skin, i = [];
    for (let n = 0; n < s.boneNames.length; n++) {
      const a = s.boneNames[n];
      let o = e.findByName(a);
      o || (o = t), i.push(o);
    }
    this.bones = i;
  }
  initSkin(e) {
    this.skin = e, this.bones = [];
    const t = e.inverseBindPose.length;
    this.init(e.device, t), this.matrices = [];
    for (let s = 0; s < t; s++)
      this.matrices[s] = new j();
  }
  uploadBones(e) {
    e.supportsBoneTextures && (this.boneTexture.lock(), this.boneTexture.unlock());
  }
  _updateMatrices(e, t) {
    if (this._skinUpdateIndex !== t) {
      this._skinUpdateIndex = t, Xf.copy(e.getWorldTransform()).invert();
      for (let s = this.bones.length - 1; s >= 0; s--)
        this.matrices[s].mulAffine2(Xf, this.bones[s].getWorldTransform()), this.matrices[s].mulAffine2(this.matrices[s], this.skin.inverseBindPose[s]);
    }
  }
  updateMatrices(e, t) {
    this._updateBeforeCull && this._updateMatrices(e, t);
  }
  updateMatrixPalette(e, t) {
    this._updateMatrices(e, t);
    const s = this.matrixPalette, i = this.bones.length;
    for (let n = 0; n < i; n++) {
      const a = this.matrices[n].data, o = n * 12;
      s[o] = a[0], s[o + 1] = a[4], s[o + 2] = a[8], s[o + 3] = a[12], s[o + 4] = a[1], s[o + 5] = a[5], s[o + 6] = a[9], s[o + 7] = a[13], s[o + 8] = a[2], s[o + 9] = a[6], s[o + 10] = a[10], s[o + 11] = a[14];
    }
    this.uploadBones(this.skin.device);
  }
}
class jf extends no {
  constructor(e, t, s) {
    super();
    const i = t.length;
    this.init(e, i), this.device = e, this.rootNode = s, this.bones = t;
  }
  updateMatrices(e, t) {
  }
  updateMatrixPalette(e, t) {
    const s = this.matrixPalette, i = this.bones.length;
    for (let n = 0; n < i; n++) {
      const a = this.bones[n].getWorldTransform().data, o = n * 12;
      s[o] = a[0], s[o + 1] = a[4], s[o + 2] = a[8], s[o + 3] = a[12], s[o + 4] = a[1], s[o + 5] = a[5], s[o + 6] = a[9], s[o + 7] = a[13], s[o + 8] = a[2], s[o + 9] = a[6], s[o + 10] = a[10], s[o + 11] = a[14];
    }
    this.uploadBones(this.device);
  }
}
const $f = new j(), hc = new v(), Yf = new ee(), lc = new ee(), Kf = new v(), Zf = new v(), wT = new j(), TT = new ee(), qt = new v(), Jf = new j(), Xt = new ee(), jn = new ee(), Qf = new j(), cc = new v(), wo = new v();
class bt extends _e {
  constructor(e = "Untitled") {
    super(), this.name = e, this.tags = new __(this), this._labels = {}, this.localPosition = new v(), this.localRotation = new ee(), this.localScale = new v(1, 1, 1), this.localEulerAngles = new v(), this.position = new v(), this.rotation = new ee(), this.eulerAngles = new v(), this._scale = null, this.localTransform = new j(), this._dirtyLocal = !1, this._aabbVer = 0, this._frozen = !1, this.worldTransform = new j(), this._dirtyWorld = !1, this._normalMatrix = new is(), this._dirtyNormal = !0, this._right = null, this._up = null, this._forward = null, this._parent = null, this._children = [], this._graphDepth = 0, this._enabled = !0, this._enabledInHierarchy = !1, this.scaleCompensation = !1;
  }
  get right() {
    return this._right || (this._right = new v()), this.getWorldTransform().getX(this._right).normalize();
  }
  get up() {
    return this._up || (this._up = new v()), this.getWorldTransform().getY(this._up).normalize();
  }
  get forward() {
    return this._forward || (this._forward = new v()), this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
  }
  get normalMatrix() {
    const e = this._normalMatrix;
    return this._dirtyNormal && (this.getWorldTransform().invertTo3x3(e), e.transpose(), this._dirtyNormal = !1), e;
  }
  set enabled(e) {
    if (this._enabled !== e) {
      var t;
      this._enabled = e, (e && (t = this._parent) != null && t.enabled || !e) && this._notifyHierarchyStateChanged(this, e);
    }
  }
  get enabled() {
    return this._enabled && this._enabledInHierarchy;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    let e = this._parent;
    if (!e)
      return "";
    let t = this.name;
    for (; e && e._parent; )
      t = `${e.name}/${t}`, e = e._parent;
    return t;
  }
  get root() {
    let e = this;
    for (; e._parent; )
      e = e._parent;
    return e;
  }
  get children() {
    return this._children;
  }
  get graphDepth() {
    return this._graphDepth;
  }
  _notifyHierarchyStateChanged(e, t) {
    e._onHierarchyStateChanged(t);
    const s = e._children;
    for (let i = 0, n = s.length; i < n; i++)
      s[i]._enabled && this._notifyHierarchyStateChanged(s[i], t);
  }
  _onHierarchyStateChanged(e) {
    this._enabledInHierarchy = e, e && !this._frozen && this._unfreezeParentToRoot();
  }
  _cloneInternal(e) {
    e.name = this.name;
    const t = this.tags._list;
    e.tags.clear();
    for (let s = 0; s < t.length; s++)
      e.tags.add(t[s]);
    e._labels = Object.assign({}, this._labels), e.localPosition.copy(this.localPosition), e.localRotation.copy(this.localRotation), e.localScale.copy(this.localScale), e.localEulerAngles.copy(this.localEulerAngles), e.position.copy(this.position), e.rotation.copy(this.rotation), e.eulerAngles.copy(this.eulerAngles), e.localTransform.copy(this.localTransform), e._dirtyLocal = this._dirtyLocal, e.worldTransform.copy(this.worldTransform), e._dirtyWorld = this._dirtyWorld, e._dirtyNormal = this._dirtyNormal, e._aabbVer = this._aabbVer + 1, e._enabled = this._enabled, e.scaleCompensation = this.scaleCompensation, e._enabledInHierarchy = !1;
  }
  clone() {
    const e = new this.constructor();
    return this._cloneInternal(e), e;
  }
  copy(e) {
    return e._cloneInternal(this), this;
  }
  find(e, t) {
    let s, i = [];
    const n = this._children.length;
    if (e instanceof Function) {
      const a = e;
      s = a(this), s && i.push(this);
      for (let o = 0; o < n; o++) {
        const h = this._children[o].find(a);
        h.length && (i = i.concat(h));
      }
    } else {
      let a;
      this[e] && (this[e] instanceof Function ? a = this[e]() : a = this[e], a === t && i.push(this));
      for (let o = 0; o < n; ++o) {
        const h = this._children[o].find(e, t);
        h.length && (i = i.concat(h));
      }
    }
    return i;
  }
  findOne(e, t) {
    const s = this._children.length;
    let i = null;
    if (e instanceof Function) {
      const n = e;
      if (i = n(this), i)
        return this;
      for (let a = 0; a < s; a++)
        if (i = this._children[a].findOne(n), i)
          return i;
    } else {
      let n;
      if (this[e] && (this[e] instanceof Function ? n = this[e]() : n = this[e], n === t))
        return this;
      for (let a = 0; a < s; a++)
        if (i = this._children[a].findOne(e, t), i !== null)
          return i;
    }
    return null;
  }
  findByTag() {
    const e = arguments, t = [], s = (i, n) => {
      n && i.tags.has(...e) && t.push(i);
      for (let a = 0; a < i._children.length; a++)
        s(i._children[a], !0);
    };
    return s(this, !1), t;
  }
  findByName(e) {
    if (this.name === e)
      return this;
    for (let t = 0; t < this._children.length; t++) {
      const s = this._children[t].findByName(e);
      if (s !== null)
        return s;
    }
    return null;
  }
  findByPath(e) {
    const t = Array.isArray(e) ? e : e.split("/");
    let s = this;
    for (let i = 0, n = t.length; i < n; ++i)
      if (s = s.children.find((a) => a.name === t[i]), !s)
        return null;
    return s;
  }
  forEach(e, t) {
    e.call(t, this);
    const s = this._children;
    for (let i = 0; i < s.length; i++)
      s[i].forEach(e, t);
  }
  isDescendantOf(e) {
    let t = this._parent;
    for (; t; ) {
      if (t === e)
        return !0;
      t = t._parent;
    }
    return !1;
  }
  isAncestorOf(e) {
    return e.isDescendantOf(this);
  }
  getEulerAngles() {
    return this.getWorldTransform().getEulerAngles(this.eulerAngles), this.eulerAngles;
  }
  getLocalEulerAngles() {
    return this.localRotation.getEulerAngles(this.localEulerAngles), this.localEulerAngles;
  }
  getLocalPosition() {
    return this.localPosition;
  }
  getLocalRotation() {
    return this.localRotation;
  }
  getLocalScale() {
    return this.localScale;
  }
  getLocalTransform() {
    return this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale), this._dirtyLocal = !1), this.localTransform;
  }
  getPosition() {
    return this.getWorldTransform().getTranslation(this.position), this.position;
  }
  getRotation() {
    return this.rotation.setFromMat4(this.getWorldTransform()), this.rotation;
  }
  getScale() {
    return this._scale || (this._scale = new v()), this.getWorldTransform().getScale(this._scale);
  }
  getWorldTransform() {
    return !this._dirtyLocal && !this._dirtyWorld ? this.worldTransform : (this._parent && this._parent.getWorldTransform(), this._sync(), this.worldTransform);
  }
  reparent(e, t) {
    const s = this._parent;
    s && s.removeChild(this), e && (t >= 0 ? e.insertChild(this, t) : e.addChild(this));
  }
  setLocalEulerAngles(e, t, s) {
    this.localRotation.setFromEulerAngles(e, t, s), this._dirtyLocal || this._dirtifyLocal();
  }
  setLocalPosition(e, t, s) {
    e instanceof v ? this.localPosition.copy(e) : this.localPosition.set(e, t, s), this._dirtyLocal || this._dirtifyLocal();
  }
  setLocalRotation(e, t, s, i) {
    e instanceof ee ? this.localRotation.copy(e) : this.localRotation.set(e, t, s, i), this._dirtyLocal || this._dirtifyLocal();
  }
  setLocalScale(e, t, s) {
    e instanceof v ? this.localScale.copy(e) : this.localScale.set(e, t, s), this._dirtyLocal || this._dirtifyLocal();
  }
  _dirtifyLocal() {
    this._dirtyLocal || (this._dirtyLocal = !0, this._dirtyWorld || this._dirtifyWorld());
  }
  _unfreezeParentToRoot() {
    let e = this._parent;
    for (; e; )
      e._frozen = !1, e = e._parent;
  }
  _dirtifyWorld() {
    this._dirtyWorld || this._unfreezeParentToRoot(), this._dirtifyWorldInternal();
  }
  _dirtifyWorldInternal() {
    if (!this._dirtyWorld) {
      this._frozen = !1, this._dirtyWorld = !0;
      for (let e = 0; e < this._children.length; e++)
        this._children[e]._dirtyWorld || this._children[e]._dirtifyWorldInternal();
    }
    this._dirtyNormal = !0, this._aabbVer++;
  }
  setPosition(e, t, s) {
    e instanceof v ? qt.copy(e) : qt.set(e, t, s), this._parent === null ? this.localPosition.copy(qt) : (Jf.copy(this._parent.getWorldTransform()).invert(), Jf.transformPoint(qt, this.localPosition)), this._dirtyLocal || this._dirtifyLocal();
  }
  setRotation(e, t, s, i) {
    if (e instanceof ee ? Xt.copy(e) : Xt.set(e, t, s, i), this._parent === null)
      this.localRotation.copy(Xt);
    else {
      const n = this._parent.getRotation();
      jn.copy(n).invert(), this.localRotation.copy(jn).mul(Xt);
    }
    this._dirtyLocal || this._dirtifyLocal();
  }
  setEulerAngles(e, t, s) {
    if (this.localRotation.setFromEulerAngles(e, t, s), this._parent !== null) {
      const i = this._parent.getRotation();
      jn.copy(i).invert(), this.localRotation.mul2(jn, this.localRotation);
    }
    this._dirtyLocal || this._dirtifyLocal();
  }
  addChild(e) {
    this._prepareInsertChild(e), this._children.push(e), this._onInsertChild(e);
  }
  addChildAndSaveTransform(e) {
    const t = e.getPosition(), s = e.getRotation();
    this._prepareInsertChild(e), e.setPosition(wT.copy(this.worldTransform).invert().transformPoint(t)), e.setRotation(TT.copy(this.getRotation()).invert().mul(s)), this._children.push(e), this._onInsertChild(e);
  }
  insertChild(e, t) {
    this._prepareInsertChild(e), this._children.splice(t, 0, e), this._onInsertChild(e);
  }
  _prepareInsertChild(e) {
    e._parent && e._parent.removeChild(e);
  }
  _fireOnHierarchy(e, t, s) {
    this.fire(e, s);
    for (let i = 0; i < this._children.length; i++)
      this._children[i]._fireOnHierarchy(t, t, s);
  }
  _onInsertChild(e) {
    e._parent = this;
    const t = e._enabled && this.enabled;
    e._enabledInHierarchy !== t && (e._enabledInHierarchy = t, e._notifyHierarchyStateChanged(e, t)), e._updateGraphDepth(), e._dirtifyWorld(), this._frozen && e._unfreezeParentToRoot(), e._fireOnHierarchy("insert", "inserthierarchy", this), this.fire && this.fire("childinsert", e);
  }
  _updateGraphDepth() {
    this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
    for (let e = 0, t = this._children.length; e < t; e++)
      this._children[e]._updateGraphDepth();
  }
  removeChild(e) {
    const t = this._children.indexOf(e);
    t !== -1 && (this._children.splice(t, 1), e._parent = null, e._fireOnHierarchy("remove", "removehierarchy", this), this.fire("childremove", e));
  }
  _sync() {
    if (this._dirtyLocal && (this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale), this._dirtyLocal = !1), this._dirtyWorld) {
      if (this._parent === null)
        this.worldTransform.copy(this.localTransform);
      else if (this.scaleCompensation) {
        let e;
        const t = this._parent;
        let s = this.localScale, i = t;
        if (i) {
          for (; i && i.scaleCompensation; )
            i = i._parent;
          i && (i = i._parent, i && (e = i.worldTransform.getScale(), Kf.mul2(e, this.localScale), s = Kf));
        }
        lc.setFromMat4(t.worldTransform), Yf.mul2(lc, this.localRotation);
        let n = t.worldTransform;
        t.scaleCompensation && (Zf.mul2(e, t.getLocalScale()), $f.setTRS(t.worldTransform.getTranslation(hc), lc, Zf), n = $f), n.transformPoint(this.localPosition, hc), this.worldTransform.setTRS(hc, Yf, s);
      } else
        this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
      this._dirtyWorld = !1;
    }
  }
  syncHierarchy() {
    if (!this._enabled || this._frozen)
      return;
    this._frozen = !0, (this._dirtyLocal || this._dirtyWorld) && this._sync();
    const e = this._children;
    for (let t = 0, s = e.length; t < s; t++)
      e[t].syncHierarchy();
  }
  lookAt(e, t, s, i = 0, n = 1, a = 0) {
    if (e instanceof v)
      cc.copy(e), t instanceof v ? wo.copy(t) : wo.copy(v.UP);
    else {
      if (s === void 0)
        return;
      cc.set(e, t, s), wo.set(i, n, a);
    }
    Qf.setLookAt(this.getPosition(), cc, wo), Xt.setFromMat4(Qf), this.setRotation(Xt);
  }
  translate(e, t, s) {
    e instanceof v ? qt.copy(e) : qt.set(e, t, s), qt.add(this.getPosition()), this.setPosition(qt);
  }
  translateLocal(e, t, s) {
    e instanceof v ? qt.copy(e) : qt.set(e, t, s), this.localRotation.transformVector(qt, qt), this.localPosition.add(qt), this._dirtyLocal || this._dirtifyLocal();
  }
  rotate(e, t, s) {
    if (Xt.setFromEulerAngles(e, t, s), this._parent === null)
      this.localRotation.mul2(Xt, this.localRotation);
    else {
      const i = this.getRotation(), n = this._parent.getRotation();
      jn.copy(n).invert(), Xt.mul2(jn, Xt), this.localRotation.mul2(Xt, i);
    }
    this._dirtyLocal || this._dirtifyLocal();
  }
  rotateLocal(e, t, s) {
    Xt.setFromEulerAngles(e, t, s), this.localRotation.mul(Xt), this._dirtyLocal || this._dirtifyLocal();
  }
}
class CT {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.cache.forEach((e, t) => {
      t.destroy();
    }), this.cache.clear();
  }
  incRef(e) {
    const t = (this.cache.get(e) || 0) + 1;
    this.cache.set(e, t);
  }
  decRef(e) {
    if (e) {
      let t = this.cache.get(e);
      t && (t--, t === 0 ? (this.cache.delete(e), e.destroy()) : this.cache.set(e, t));
    }
  }
}
class ai {
  static incRef(e) {
    this.cache.incRef(e);
  }
  static decRef(e) {
    this.cache.decRef(e);
  }
  static destroy() {
    this.cache.destroy();
  }
}
ai.cache = new CT();
const AT = new Pe(), To = new Pe(), dc = new pl(), uc = /* @__PURE__ */ new Set();
class MT {
  constructor(e) {
    this.vertexBuffer = null, this.count = e;
  }
}
class we {
  constructor(e, t, s = null) {
    if (this._material = void 0, this._shader = [], this._bindGroups = [], e instanceof bt) {
      const i = e;
      e = t, t = s, s = i;
    }
    this._key = [0, 0], this.isStatic = !1, this._staticLightList = null, this._staticSource = null, this.node = s, this._mesh = e, e.incRefCount(), this.material = t, this._shaderDefs = Gs << 16, this._shaderDefs |= e.vertexBuffer.format.hasUv0 ? K_ : 0, this._shaderDefs |= e.vertexBuffer.format.hasUv1 ? Z_ : 0, this._shaderDefs |= e.vertexBuffer.format.hasColor ? J_ : 0, this._shaderDefs |= e.vertexBuffer.format.hasTangents ? eg : 0, this._lightHash = 0, this.visible = !0, this.layer = j_, this._renderStyle = Ba, this.castShadow = !1, this._receiveShadow = !0, this._screenSpace = !1, this._noDepthDrawGl1 = !1, this.cull = !0, this.pick = !0, this._updateAabb = !0, this._updateAabbFunc = null, this._calculateSortDistance = null, this.updateKey(), this._skinInstance = null, this._morphInstance = null, this.instancingData = null, this._customAabb = null, this.aabb = new Pe(), this._aabbVer = -1, this.drawOrder = 0, this.visibleThisFrame = !1, this.isVisibleFunc = null, this.parameters = {}, this.stencilFront = null, this.stencilBack = null, this.flipFaces = !1;
  }
  set renderStyle(e) {
    this._renderStyle = e, this.mesh.prepareRenderState(e);
  }
  get renderStyle() {
    return this._renderStyle;
  }
  set mesh(e) {
    e !== this._mesh && (this._mesh && this._mesh.decRefCount(), this._mesh = e, e && e.incRefCount());
  }
  get mesh() {
    return this._mesh;
  }
  set aabb(e) {
    this._aabb = e;
  }
  get aabb() {
    if (!this._updateAabb)
      return this._aabb;
    if (this._updateAabbFunc)
      return this._updateAabbFunc(this._aabb);
    let e = this._customAabb, t = !!e;
    if (!e)
      if (e = AT, this.skinInstance) {
        if (!this.mesh.boneAabb) {
          const n = this._morphInstance ? this._morphInstance.morph._targets : null;
          this.mesh._initBoneAabbs(n);
        }
        const s = this.mesh.boneUsed;
        let i = !0;
        for (let n = 0; n < this.mesh.boneAabb.length; n++)
          s[n] && (To.setFromTransformedAabb(this.mesh.boneAabb[n], this.skinInstance.matrices[n]), i ? (i = !1, e.center.copy(To.center), e.halfExtents.copy(To.halfExtents)) : e.add(To));
        t = !0;
      } else
        this.node._aabbVer !== this._aabbVer && (this.mesh ? (e.center.copy(this.mesh.aabb.center), e.halfExtents.copy(this.mesh.aabb.halfExtents)) : (e.center.set(0, 0, 0), e.halfExtents.set(0, 0, 0)), this.mesh && this.mesh.morph && e._expand(this.mesh.morph.aabb.getMin(), this.mesh.morph.aabb.getMax()), t = !0, this._aabbVer = this.node._aabbVer);
    return t && this._aabb.setFromTransformedAabb(e, this.node.getWorldTransform()), this._aabb;
  }
  clearShaders() {
    const e = this._shader;
    for (let t = 0; t < e.length; t++)
      e[t] = null;
    this.destroyBindGroups();
  }
  destroyBindGroups() {
    const e = this._bindGroups;
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      if (s) {
        const i = s.defaultUniformBuffer;
        i && i.destroy(), s.destroy();
      }
    }
    e.length = 0;
  }
  getBindGroup(e, t) {
    let s = this._bindGroups[t];
    if (!s) {
      const i = this._shader[t], n = i.meshUniformBufferFormat, a = new Gu(e, n), o = i.meshBindGroupFormat;
      s = new Vu(e, o, a), this._bindGroups[t] = s;
    }
    return s;
  }
  set material(e) {
    this.clearShaders();
    const t = this._material;
    if (t && t.removeMeshInstanceRef(this), this._material = e, e) {
      e.addMeshInstanceRef(this), this.updateKey();
      const s = t && t.transparent;
      if (e.transparent !== s) {
        const i = this._material._scene || (t == null ? void 0 : t._scene);
        i ? i.layers._dirtyBlend = !0 : e._dirtyBlend = !0;
      }
    }
  }
  get material() {
    return this._material;
  }
  set layer(e) {
    this._layer = e, this.updateKey();
  }
  get layer() {
    return this._layer;
  }
  set calculateSortDistance(e) {
    this._calculateSortDistance = e;
  }
  get calculateSortDistance() {
    return this._calculateSortDistance;
  }
  set receiveShadow(e) {
    this._receiveShadow = e, this._shaderDefs = e ? this._shaderDefs & ~Md : this._shaderDefs | Md, this._shader[Er] = null, this._shader[fi] = null;
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set skinInstance(e) {
    this._skinInstance = e;
    let t = this._shaderDefs;
    t = e ? t | Hh : t & ~Hh, t !== this._shaderDefs && (this._shaderDefs = t, this.clearShaders()), this._setupSkinUpdate();
  }
  get skinInstance() {
    return this._skinInstance;
  }
  set morphInstance(e) {
    var t;
    (t = this._morphInstance) == null || t.destroy(), this._morphInstance = e;
    let s = this._shaderDefs;
    s = e && e.morph.useTextureMorph ? s | $h : s & ~$h, s = e && e.morph.morphPositions ? s | Xh : s & ~Xh, s = e && e.morph.morphNormals ? s | jh : s & ~jh, s !== this._shaderDefs && (this._shaderDefs = s, this.clearShaders());
  }
  get morphInstance() {
    return this._morphInstance;
  }
  set screenSpace(e) {
    this._screenSpace = e, this._shaderDefs = e ? this._shaderDefs | qh : this._shaderDefs & ~qh, this._shader[Er] = null;
  }
  get screenSpace() {
    return this._screenSpace;
  }
  set key(e) {
    this._key[ci] = e;
  }
  get key() {
    return this._key[ci];
  }
  set mask(e) {
    const t = this._shaderDefs & 65535;
    this._shaderDefs = t | e << 16, this._shader[Er] = null, this._shader[fi] = null;
  }
  get mask() {
    return this._shaderDefs >> 16;
  }
  set instancingCount(e) {
    this.instancingData && (this.instancingData.count = e);
  }
  get instancingCount() {
    return this.instancingData ? this.instancingData.count : 0;
  }
  destroy() {
    var e, t;
    const s = this.mesh;
    s && (this.mesh = null, s.refCount < 1 && s.destroy()), this.setRealtimeLightmap(we.lightmapParamNames[0], null), this.setRealtimeLightmap(we.lightmapParamNames[1], null), (e = this._skinInstance) == null || e.destroy(), this._skinInstance = null, (t = this.morphInstance) == null || t.destroy(), this.morphInstance = null, this.clearShaders(), this.material = null;
  }
  static _prepareRenderStyleForArray(e, t) {
    if (e) {
      for (let s = 0; s < e.length; s++) {
        e[s]._renderStyle = t;
        const i = e[s].mesh;
        uc.has(i) || (uc.add(i), i.prepareRenderState(t));
      }
      uc.clear();
    }
  }
  _isVisible(e) {
    return this.visible ? this.isVisibleFunc ? this.isVisibleFunc(e) : (dc.center = this.aabb.center, dc.radius = this._aabb.halfExtents.length(), e.frustum.containsSphere(dc)) : !1;
  }
  updateKey() {
    const e = this.material;
    this._key[ci] = ET(this.layer, e.alphaToCoverage || e.alphaTest ? Vt : e.blendType, !1, e.id);
  }
  setInstancing(e) {
    e ? (this.instancingData = new MT(e.numVertices), this.instancingData.vertexBuffer = e, e.format.instancing = !0, this.cull = !1) : (this.instancingData = null, this.cull = !0);
  }
  updatePassShader(e, t, s, i, n, a) {
    this._shader[t] = this.material.getShaderVariant(this.mesh.device, e, this._shaderDefs, s, t, i, n, a);
  }
  ensureMaterial(e) {
    this.material || (this.material = io(e));
  }
  clearParameters() {
    this.parameters = {};
  }
  getParameters() {
    return this.parameters;
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t, s = -262141) {
    if (t === void 0 && typeof e == "object") {
      const n = e;
      if (n.length) {
        for (let a = 0; a < n.length; a++)
          this.setParameter(n[a]);
        return;
      }
      e = n.name, t = n.value;
    }
    const i = this.parameters[e];
    i ? (i.data = t, i.passFlags = s) : this.parameters[e] = {
      scopeId: null,
      data: t,
      passFlags: s
    };
  }
  setRealtimeLightmap(e, t) {
    const s = this.getParameter(e);
    s !== t && (s && ai.decRef(s.data), t ? (ai.incRef(t), this.setParameter(e, t)) : this.deleteParameter(e));
  }
  deleteParameter(e) {
    this.parameters[e] && delete this.parameters[e];
  }
  setParameters(e, t) {
    const s = this.parameters;
    for (const i in s) {
      const n = s[i];
      n.passFlags & t && (n.scopeId || (n.scopeId = e.scope.resolve(i)), n.scopeId.setValue(n.data));
    }
  }
  setLightmapped(e) {
    e ? this.mask = (this.mask | di) & ~(Gs | ui) : (this.setRealtimeLightmap(we.lightmapParamNames[0], null), this.setRealtimeLightmap(we.lightmapParamNames[1], null), this._shaderDefs &= ~(Wh | Bu | Fu), this.mask = (this.mask | Gs) & ~(di | ui));
  }
  setCustomAabb(e) {
    e ? this._customAabb ? this._customAabb.copy(e) : this._customAabb = e.clone() : (this._customAabb = null, this._aabbVer = -1), this._setupSkinUpdate();
  }
  _setupSkinUpdate() {
    this._skinInstance && (this._skinInstance._updateBeforeCull = !this._customAabb);
  }
}
we.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];
function ET(r, e, t, s) {
  return (r & 15) << 27 | (e === ss ? 1 : 0) << 26 | (t ? 1 : 0) << 25 | (s & 33554431) << 0;
}
function em(r, e) {
  if (r && !e || !r && e)
    return !1;
  if (r = r.data, e = e.data, r === e)
    return !0;
  if (r instanceof Float32Array && e instanceof Float32Array) {
    if (r.length !== e.length)
      return !1;
    for (let t = 0; t < r.length; t++)
      if (r[t] !== e[t])
        return !1;
    return !0;
  }
  return !1;
}
function RT(r, e) {
  for (const t in r)
    if (r.hasOwnProperty(t) && !em(r[t], e[t]))
      return !1;
  for (const t in e)
    if (e.hasOwnProperty(t) && !em(e[t], r[t]))
      return !1;
  return !0;
}
function LT(r, e) {
  for (let t = 0; t < r.length; t++)
    if (e.indexOf(r[t]) < 0)
      return !1;
  for (let t = 0; t < e.length; t++)
    if (r.indexOf(e[t]) < 0)
      return !1;
  return !0;
}
const fc = new is(), Co = new v(), tm = new v(), sm = new v();
function mc(r) {
  const e = r.node.worldTransform;
  return e.getX(Co), e.getY(tm), e.getZ(sm), Co.cross(Co, tm), Co.dot(sm) >= 0 ? 1 : -1;
}
class PT {
  constructor(e, t, s) {
    this.device = e, this.rootNode = t, this.scene = s, this._init = !1, this._batchGroups = {}, this._batchGroupCounter = 0, this._batchList = [], this._dirtyGroups = [];
  }
  destroy() {
    this.device = null, this.rootNode = null, this.scene = null, this._batchGroups = {}, this._batchList = [], this._dirtyGroups = [];
  }
  addGroup(e, t, s, i, n) {
    if (i === void 0 && (i = this._batchGroupCounter, this._batchGroupCounter++), this._batchGroups[i])
      return;
    const a = new nt(i, e, t, s, n);
    return this._batchGroups[i] = a, a;
  }
  removeGroup(e) {
    if (!this._batchGroups[e])
      return;
    const t = [];
    for (let s = 0; s < this._batchList.length; s++)
      this._batchList[s].batchGroupId === e ? this.destroyBatch(this._batchList[s]) : t.push(this._batchList[s]);
    this._batchList = t, this._removeModelsFromBatchGroup(this.rootNode, e), delete this._batchGroups[e];
  }
  markGroupDirty(e) {
    this._dirtyGroups.indexOf(e) < 0 && this._dirtyGroups.push(e);
  }
  getGroupByName(e) {
    const t = this._batchGroups;
    for (const s in t)
      if (t.hasOwnProperty(s) && t[s].name === e)
        return t[s];
    return null;
  }
  getBatches(e) {
    const t = [], s = this._batchList.length;
    for (let i = 0; i < s; i++) {
      const n = this._batchList[i];
      n.batchGroupId === e && t.push(n);
    }
    return t;
  }
  _removeModelsFromBatchGroup(e, t) {
    if (e.enabled) {
      e.model && e.model.batchGroupId === t && (e.model.batchGroupId = -1), e.render && e.render.batchGroupId === t && (e.render.batchGroupId = -1), e.element && e.element.batchGroupId === t && (e.element.batchGroupId = -1), e.sprite && e.sprite.batchGroupId === t && (e.sprite.batchGroupId = -1);
      for (let s = 0; s < e._children.length; s++)
        this._removeModelsFromBatchGroup(e._children[s], t);
    }
  }
  insert(e, t, s) {
    const i = this._batchGroups[t];
    i && i._obj[e].indexOf(s) < 0 && (i._obj[e].push(s), this.markGroupDirty(t));
  }
  remove(e, t, s) {
    const i = this._batchGroups[t];
    if (i) {
      const n = i._obj[e].indexOf(s);
      n >= 0 && (i._obj[e].splice(n, 1), this.markGroupDirty(t));
    }
  }
  _extractRender(e, t, s, i) {
    if (e.render) {
      if (e.render.isStatic) {
        const n = this.scene.drawCalls, a = e.render.meshInstances;
        for (let o = 0; o < n.length; o++)
          n[o]._staticSource && (a.indexOf(n[o]._staticSource) < 0 || t.push(n[o]));
        for (let o = 0; o < a.length; o++)
          n.indexOf(a[o]) >= 0 && t.push(a[o]);
      } else
        t = i[e.render.batchGroupId] = t.concat(e.render.meshInstances);
      e.render.removeFromLayers();
    }
    return t;
  }
  _extractModel(e, t, s, i) {
    if (e.model && e.model.model) {
      if (e.model.isStatic) {
        const n = this.scene.drawCalls, a = e.model.meshInstances;
        for (let o = 0; o < n.length; o++)
          n[o]._staticSource && (a.indexOf(n[o]._staticSource) < 0 || t.push(n[o]));
        for (let o = 0; o < a.length; o++)
          n.indexOf(a[o]) >= 0 && t.push(a[o]);
      } else
        t = i[e.model.batchGroupId] = t.concat(e.model.meshInstances);
      e.model.removeModelFromLayers();
    }
    return t;
  }
  _extractElement(e, t, s) {
    if (!e.element)
      return;
    let i = !1;
    e.element._text && e.element._text._model.meshInstances.length > 0 ? (t.push(e.element._text._model.meshInstances[0]), e.element.removeModelFromLayers(e.element._text._model), i = !0) : e.element._image && (t.push(e.element._image._renderable.meshInstance), e.element.removeModelFromLayers(e.element._image._renderable.model), e.element._image._renderable.unmaskMeshInstance && (t.push(e.element._image._renderable.unmaskMeshInstance), (!e.element._image._renderable.unmaskMeshInstance.stencilFront || !e.element._image._renderable.unmaskMeshInstance.stencilBack) && (e.element._dirtifyMask(), e.element._onPrerender())), i = !0), i && (s._ui = !0);
  }
  _collectAndRemoveMeshInstances(e, t) {
    for (let s = 0; s < t.length; s++) {
      const i = t[s], n = this._batchGroups[i];
      if (!n)
        continue;
      let a = e[i];
      a || (a = e[i] = []);
      for (let o = 0; o < n._obj.model.length; o++)
        a = this._extractModel(n._obj.model[o], a, n, e);
      for (let o = 0; o < n._obj.render.length; o++)
        a = this._extractRender(n._obj.render[o], a, n, e);
      for (let o = 0; o < n._obj.element.length; o++)
        this._extractElement(n._obj.element[o], a, n);
      for (let o = 0; o < n._obj.sprite.length; o++) {
        const h = n._obj.sprite[o];
        h.sprite && h.sprite._meshInstance && (n.dynamic || h.sprite.sprite._renderMode === Ni) && (a.push(h.sprite._meshInstance), h.sprite.removeModelFromLayers(), n._sprite = !0, h.sprite._batchGroup = n);
      }
    }
  }
  generate(e) {
    const t = {};
    e || (e = Object.keys(this._batchGroups));
    const s = [];
    for (let h = 0; h < this._batchList.length; h++) {
      if (e.indexOf(this._batchList[h].batchGroupId) < 0) {
        s.push(this._batchList[h]);
        continue;
      }
      this.destroyBatch(this._batchList[h]);
    }
    if (this._batchList = s, this._collectAndRemoveMeshInstances(t, e), e === this._dirtyGroups)
      this._dirtyGroups.length = 0;
    else {
      const h = [];
      for (let l = 0; l < this._dirtyGroups.length; l++)
        e.indexOf(this._dirtyGroups[l]) < 0 && h.push(this._dirtyGroups[l]);
      this._dirtyGroups = h;
    }
    let i, n, a, o;
    for (const h in t)
      if (t.hasOwnProperty(h) && (i = t[h], a = this._batchGroups[h], !!a)) {
        n = this.prepare(i, a.dynamic, a.maxAabbSize, a._ui || a._sprite);
        for (let l = 0; l < n.length; l++)
          o = this.create(n[l], a.dynamic, parseInt(h, 10)), o && o.addToLayers(this.scene, a.layers);
      }
  }
  prepare(e, t, s = Number.POSITIVE_INFINITY, i) {
    if (e.length === 0)
      return [];
    const n = s * 0.5, a = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit, o = this.device.extUintElement ? 4294967295 : 65535, h = new Pe(), l = new Pe();
    let c = null, d;
    const u = [];
    let f = 0;
    i && e.sort(function(g, b) {
      return g.drawOrder - b.drawOrder;
    });
    let m = e, _;
    const p = i ? function(g) {
      c ? c.add(g.aabb) : c = g.aabb.clone(), _.push(g);
    } : function(g) {
      _.push(g);
    };
    for (; m.length > 0; ) {
      u[f] = [m[0]], _ = [];
      const g = m[0].material, b = m[0].layer, x = m[0]._shaderDefs, y = m[0].parameters, S = m[0].stencilFront, C = m[0]._staticLightList;
      let w = m[0].mesh.vertexBuffer.getNumVertices();
      const M = m[0].drawOrder;
      h.copy(m[0].aabb);
      const T = mc(m[0]), A = m[0].mesh.vertexBuffer.format.batchingHash, L = m[0].mesh.primitive[0].indexed;
      c = null;
      for (let O = 1; O < m.length; O++) {
        const I = m[O];
        if (t && u[f].length >= a) {
          _ = _.concat(m.slice(O));
          break;
        }
        if (g !== I.material || b !== I.layer || A !== I.mesh.vertexBuffer.format.batchingHash || L !== I.mesh.primitive[0].indexed || x !== I._shaderDefs || w + I.mesh.vertexBuffer.getNumVertices() > o) {
          p(I);
          continue;
        }
        if (l.copy(h), l.add(I.aabb), l.halfExtents.x > n || l.halfExtents.y > n || l.halfExtents.z > n) {
          p(I);
          continue;
        }
        if (S && (!(d = I.stencilFront) || S.func !== d.func || S.zpass !== d.zpass)) {
          p(I);
          continue;
        }
        if (T !== mc(I)) {
          p(I);
          continue;
        }
        if (!RT(y, I.parameters)) {
          p(I);
          continue;
        }
        const D = I._staticLightList;
        if (C && D) {
          if (!LT(C, D)) {
            p(I);
            continue;
          }
        } else if (C || D) {
          p(I);
          continue;
        }
        if (i && c && c.intersects(I.aabb) && I.drawOrder !== M) {
          p(I);
          continue;
        }
        h.add(I.aabb), w += I.mesh.vertexBuffer.getNumVertices(), u[f].push(I);
      }
      f++, m = _;
    }
    return u;
  }
  collectBatchedMeshData(e, t) {
    let s = null, i = 0, n = 0, a = null;
    for (let o = 0; o < e.length; o++)
      if (e[o].visible) {
        const h = e[o].mesh, l = h.vertexBuffer.numVertices;
        if (i += l, n += h.primitive[0].indexed ? h.primitive[0].count : h.primitive[0].type === Dn && h.primitive[0].count === 4 ? 6 : 0, !s) {
          a = e[o].material, s = {};
          const c = h.vertexBuffer.format.elements;
          for (let d = 0; d < c.length; d++) {
            const u = c[d].name;
            s[u] = {
              numComponents: c[d].numComponents,
              dataType: c[d].dataType,
              normalize: c[d].normalize,
              count: 0
            };
          }
          t && (s[ts] = {
            numComponents: 1,
            dataType: Ie,
            normalize: !1,
            count: 0
          });
        }
      }
    return {
      streams: s,
      batchNumVerts: i,
      batchNumIndices: n,
      material: a
    };
  }
  create(e, t, s) {
    if (!this._init) {
      const c = "#define BONE_LIMIT " + this.device.getBoneLimit() + `
`;
      this.transformVS = c + `#define DYNAMICBATCH
` + N.transformVS, this.skinTexVS = N.skinBatchTexVS, this.skinConstVS = N.skinBatchConstVS, this.vertexFormats = {}, this._init = !0;
    }
    let i = null, n, a, o, h = null;
    const l = this.collectBatchedMeshData(e, t);
    if (l.streams) {
      const c = l.streams;
      let d = l.material;
      const u = l.batchNumVerts, f = l.batchNumIndices;
      h = new qf(e, t, s), this._batchList.push(h);
      let m, _, p, g = 0, b = 0, x;
      const y = new v(), S = u <= 65535 ? Uint16Array : Uint32Array, C = new S(f);
      for (n in c)
        i = c[n], i.typeArrayType = Ar[i.dataType], i.elementByteSize = Bh[i.dataType], i.buffer = new i.typeArrayType(u * i.numComponents);
      for (let T = 0; T < e.length; T++)
        if (e[T].visible) {
          a = e[T].mesh, o = a.vertexBuffer.numVertices, t || (x = e[T].node.getWorldTransform());
          for (n in c)
            if (n !== ts) {
              i = c[n];
              const A = new i.typeArrayType(i.buffer.buffer, i.elementByteSize * i.count), L = a.getVertexStream(n, A) * i.numComponents;
              if (i.count += L, !t && i.numComponents >= 3) {
                if (n === et)
                  for (let O = 0; O < L; O += i.numComponents)
                    y.set(A[O], A[O + 1], A[O + 2]), x.transformPoint(y, y), A[O] = y.x, A[O + 1] = y.y, A[O + 2] = y.z;
                else if (n === Gt || n === qs) {
                  x.invertTo3x3(fc), fc.transpose();
                  for (let O = 0; O < L; O += i.numComponents)
                    y.set(A[O], A[O + 1], A[O + 2]), fc.transformVector(y, y), A[O] = y.x, A[O + 1] = y.y, A[O + 2] = y.z;
                }
              }
            }
          if (t) {
            i = c[ts];
            for (let A = 0; A < o; A++)
              i.buffer[i.count++] = T;
          }
          if (a.primitive[0].indexed) {
            m = a.primitive[0].base, _ = a.primitive[0].count;
            const A = a.indexBuffer[0].getFormat();
            p = new gd[A](a.indexBuffer[0].storage);
          } else if (a.primitive[0].type === Dn && a.primitive[0].count === 4)
            m = 0, _ = 6, p = [0, 1, 3, 2, 3, 1];
          else {
            _ = 0;
            continue;
          }
          for (let A = 0; A < _; A++)
            C[A + b] = p[m + A] + g;
          b += _, g += o;
        }
      a = new _s(this.device);
      for (n in c)
        i = c[n], a.setVertexStream(n, i.buffer, i.numComponents, void 0, i.dataType, i.normalize);
      C.length > 0 && a.setIndices(C), a.update(Es, !1), t && (d = d.clone(), d.chunks.transformVS = this.transformVS, d.chunks.skinTexVS = this.skinTexVS, d.chunks.skinConstVS = this.skinConstVS, d.update());
      const w = new we(a, d, this.rootNode);
      w.castShadow = h.origMeshInstances[0].castShadow, w.parameters = h.origMeshInstances[0].parameters, w.isStatic = h.origMeshInstances[0].isStatic, w.layer = h.origMeshInstances[0].layer, w._staticLightList = h.origMeshInstances[0]._staticLightList, w._shaderDefs = h.origMeshInstances[0]._shaderDefs, w.cull = h.origMeshInstances[0].cull;
      const M = this._batchGroups[s];
      if (M && M._ui && (w.cull = !1), t) {
        const T = [];
        for (let A = 0; A < h.origMeshInstances.length; A++)
          T.push(h.origMeshInstances[A].node);
        w.skinInstance = new jf(this.device, T, this.rootNode);
      }
      w._updateAabb = !1, w.drawOrder = h.origMeshInstances[0].drawOrder, w.stencilFront = h.origMeshInstances[0].stencilFront, w.stencilBack = h.origMeshInstances[0].stencilBack, w.flipFaces = mc(h.origMeshInstances[0]) < 0, w.castShadow = h.origMeshInstances[0].castShadow, h.meshInstance = w, h.updateBoundingBox();
    }
    return h;
  }
  updateAll() {
    this._dirtyGroups.length > 0 && this.generate(this._dirtyGroups);
    for (let e = 0; e < this._batchList.length; e++)
      this._batchList[e].dynamic && this._batchList[e].updateBoundingBox();
  }
  clone(e, t) {
    const s = new qf(t, e.dynamic, e.batchGroupId);
    this._batchList.push(s);
    const i = [];
    for (let n = 0; n < t.length; n++)
      i.push(t[n].node);
    return s.meshInstance = new we(e.meshInstance.mesh, e.meshInstance.material, e.meshInstance.node), s.meshInstance._updateAabb = !1, s.meshInstance.parameters = t[0].parameters, s.meshInstance.isStatic = t[0].isStatic, s.meshInstance.cull = t[0].cull, s.meshInstance.layer = t[0].layer, s.meshInstance._staticLightList = t[0]._staticLightList, e.dynamic && (s.meshInstance.skinInstance = new jf(this.device, i, this.rootNode)), s.meshInstance.castShadow = e.meshInstance.castShadow, s.meshInstance._shader = e.meshInstance._shader.slice(), s.meshInstance.castShadow = e.meshInstance.castShadow, s;
  }
  destroyBatch(e) {
    e.destroy(this.scene, this._batchGroups[e.batchGroupId].layers);
  }
}
const $n = new v(), ta = new v(), im = new v(), nm = new j(), IT = [new v(), new v(), new v(), new v(), new v(), new v(), new v(), new v()];
class ro {
  constructor() {
    this._aspectRatio = 16 / 9, this._aspectRatioMode = ku, this._calculateProjection = null, this._calculateTransform = null, this._clearColor = new z(0.75, 0.75, 0.75, 1), this._clearColorBuffer = !0, this._clearDepth = 1, this._clearDepthBuffer = !0, this._clearStencil = 0, this._clearStencilBuffer = !0, this._cullingMask = 4294967295, this._cullFaces = !0, this._farClip = 1e3, this._flipFaces = !1, this._fov = 45, this._frustumCulling = !0, this._horizontalFov = !1, this._layers = [wi, kt, Pu, Xa, zh], this._layersSet = new Set(this._layers), this._nearClip = 0.1, this._node = null, this._orthoHeight = 10, this._projection = Bs, this._rect = new Z(0, 0, 1, 1), this._renderTarget = null, this._scissorRect = new Z(0, 0, 1, 1), this._scissorRectClear = !1, this._aperture = 16, this._shutter = 1 / 1e3, this._sensitivity = 1e3, this._projMat = new j(), this._projMatDirty = !0, this._projMatSkybox = new j(), this._viewMat = new j(), this._viewMatDirty = !0, this._viewProjMat = new j(), this._viewProjMatDirty = !0, this.frustum = new b0(), this._xr = null, this._xrProperties = {
      horizontalFov: this._horizontalFov,
      fov: this._fov,
      aspectRatio: this._aspectRatio,
      farClip: this._farClip,
      nearClip: this._nearClip
    };
  }
  get fullSizeClearRect() {
    const e = this._scissorRectClear ? this.scissorRect : this._rect;
    return e.x === 0 && e.y === 0 && e.z === 1 && e.w === 1;
  }
  set aspectRatio(e) {
    this._aspectRatio !== e && (this._aspectRatio = e, this._projMatDirty = !0);
  }
  get aspectRatio() {
    var e;
    return (e = this.xr) != null && e.active ? this._xrProperties.aspectRatio : this._aspectRatio;
  }
  set aspectRatioMode(e) {
    this._aspectRatioMode !== e && (this._aspectRatioMode = e, this._projMatDirty = !0);
  }
  get aspectRatioMode() {
    return this._aspectRatioMode;
  }
  set calculateProjection(e) {
    this._calculateProjection = e, this._projMatDirty = !0;
  }
  get calculateProjection() {
    return this._calculateProjection;
  }
  set calculateTransform(e) {
    this._calculateTransform = e;
  }
  get calculateTransform() {
    return this._calculateTransform;
  }
  set clearColor(e) {
    this._clearColor.copy(e);
  }
  get clearColor() {
    return this._clearColor;
  }
  set clearColorBuffer(e) {
    this._clearColorBuffer = e;
  }
  get clearColorBuffer() {
    return this._clearColorBuffer;
  }
  set clearDepth(e) {
    this._clearDepth = e;
  }
  get clearDepth() {
    return this._clearDepth;
  }
  set clearDepthBuffer(e) {
    this._clearDepthBuffer = e;
  }
  get clearDepthBuffer() {
    return this._clearDepthBuffer;
  }
  set clearStencil(e) {
    this._clearStencil = e;
  }
  get clearStencil() {
    return this._clearStencil;
  }
  set clearStencilBuffer(e) {
    this._clearStencilBuffer = e;
  }
  get clearStencilBuffer() {
    return this._clearStencilBuffer;
  }
  set cullingMask(e) {
    this._cullingMask = e;
  }
  get cullingMask() {
    return this._cullingMask;
  }
  set cullFaces(e) {
    this._cullFaces = e;
  }
  get cullFaces() {
    return this._cullFaces;
  }
  set farClip(e) {
    this._farClip !== e && (this._farClip = e, this._projMatDirty = !0);
  }
  get farClip() {
    var e;
    return (e = this.xr) != null && e.active ? this._xrProperties.farClip : this._farClip;
  }
  set flipFaces(e) {
    this._flipFaces = e;
  }
  get flipFaces() {
    return this._flipFaces;
  }
  set fov(e) {
    this._fov !== e && (this._fov = e, this._projMatDirty = !0);
  }
  get fov() {
    var e;
    return (e = this.xr) != null && e.active ? this._xrProperties.fov : this._fov;
  }
  set frustumCulling(e) {
    this._frustumCulling = e;
  }
  get frustumCulling() {
    return this._frustumCulling;
  }
  set horizontalFov(e) {
    this._horizontalFov !== e && (this._horizontalFov = e, this._projMatDirty = !0);
  }
  get horizontalFov() {
    var e;
    return (e = this.xr) != null && e.active ? this._xrProperties.horizontalFov : this._horizontalFov;
  }
  set layers(e) {
    this._layers = e.slice(0), this._layersSet = new Set(this._layers);
  }
  get layers() {
    return this._layers;
  }
  get layersSet() {
    return this._layersSet;
  }
  set nearClip(e) {
    this._nearClip !== e && (this._nearClip = e, this._projMatDirty = !0);
  }
  get nearClip() {
    var e;
    return (e = this.xr) != null && e.active ? this._xrProperties.nearClip : this._nearClip;
  }
  set node(e) {
    this._node = e;
  }
  get node() {
    return this._node;
  }
  set orthoHeight(e) {
    this._orthoHeight !== e && (this._orthoHeight = e, this._projMatDirty = !0);
  }
  get orthoHeight() {
    return this._orthoHeight;
  }
  set projection(e) {
    this._projection !== e && (this._projection = e, this._projMatDirty = !0);
  }
  get projection() {
    return this._projection;
  }
  get projectionMatrix() {
    return this._evaluateProjectionMatrix(), this._projMat;
  }
  set rect(e) {
    this._rect.copy(e);
  }
  get rect() {
    return this._rect;
  }
  set renderTarget(e) {
    this._renderTarget = e;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  set scissorRect(e) {
    this._scissorRect.copy(e);
  }
  get scissorRect() {
    return this._scissorRect;
  }
  get viewMatrix() {
    if (this._viewMatDirty) {
      const e = this._node.getWorldTransform();
      this._viewMat.copy(e).invert(), this._viewMatDirty = !1;
    }
    return this._viewMat;
  }
  set aperture(e) {
    this._aperture = e;
  }
  get aperture() {
    return this._aperture;
  }
  set sensitivity(e) {
    this._sensitivity = e;
  }
  get sensitivity() {
    return this._sensitivity;
  }
  set shutter(e) {
    this._shutter = e;
  }
  get shutter() {
    return this._shutter;
  }
  set xr(e) {
    this._xr !== e && (this._xr = e, this._projMatDirty = !0);
  }
  get xr() {
    return this._xr;
  }
  clone() {
    return new ro().copy(this);
  }
  copy(e) {
    return this._aspectRatio = e._aspectRatio, this._farClip = e._farClip, this._fov = e._fov, this._horizontalFov = e._horizontalFov, this._nearClip = e._nearClip, this._xrProperties.aspectRatio = e._xrProperties.aspectRatio, this._xrProperties.farClip = e._xrProperties.farClip, this._xrProperties.fov = e._xrProperties.fov, this._xrProperties.horizontalFov = e._xrProperties.horizontalFov, this._xrProperties.nearClip = e._xrProperties.nearClip, this.aspectRatioMode = e.aspectRatioMode, this.calculateProjection = e.calculateProjection, this.calculateTransform = e.calculateTransform, this.clearColor = e.clearColor, this.clearColorBuffer = e.clearColorBuffer, this.clearDepth = e.clearDepth, this.clearDepthBuffer = e.clearDepthBuffer, this.clearStencil = e.clearStencil, this.clearStencilBuffer = e.clearStencilBuffer, this.cullFaces = e.cullFaces, this.cullingMask = e.cullingMask, this.flipFaces = e.flipFaces, this.frustumCulling = e.frustumCulling, this.layers = e.layers, this.orthoHeight = e.orthoHeight, this.projection = e.projection, this.rect = e.rect, this.renderTarget = e.renderTarget, this.scissorRect = e.scissorRect, this.aperture = e.aperture, this.shutter = e.shutter, this.sensitivity = e.sensitivity, this._projMatDirty = !0, this;
  }
  _updateViewProjMat() {
    (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) && (this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix), this._viewProjMatDirty = !1);
  }
  worldToScreen(e, t, s, i = new v()) {
    this._updateViewProjMat(), this._viewProjMat.transformPoint(e, i);
    const n = this._viewProjMat.data, a = e.x * n[3] + e.y * n[7] + e.z * n[11] + 1 * n[15];
    return i.x = (i.x / a + 1) * 0.5 * t, i.y = (1 - i.y / a) * 0.5 * s, i;
  }
  screenToWorld(e, t, s, i, n, a = new v()) {
    const o = this.farClip - this.nearClip;
    if ($n.set(e / i, (n - t) / n, s / o), $n.mulScalar(2), $n.sub(v.ONE), this._projection === Bs) {
      j._getPerspectiveHalfSize(ta, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov), ta.x *= $n.x, ta.y *= $n.y;
      const h = this._node.getWorldTransform();
      ta.z = -this.nearClip, h.transformPoint(ta, im);
      const l = this._node.getPosition();
      a.sub2(im, l), a.normalize(), a.mulScalar(s), a.add(l);
    } else
      this._updateViewProjMat(), nm.copy(this._viewProjMat).invert(), nm.transformPoint($n, a);
    return a;
  }
  _evaluateProjectionMatrix() {
    if (this._projMatDirty) {
      if (this._projection === Bs)
        this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov), this._projMatSkybox.copy(this._projMat);
      else {
        const e = this._orthoHeight, t = e * this.aspectRatio;
        this._projMat.setOrtho(-t, t, -e, e, this.nearClip, this.farClip), this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
      }
      this._projMatDirty = !1;
    }
  }
  getProjectionMatrixSkybox() {
    return this._evaluateProjectionMatrix(), this._projMatSkybox;
  }
  getExposure() {
    const e = Math.log2(this._aperture * this._aperture / this._shutter * 100 / this._sensitivity);
    return 1 / (Math.pow(2, e) * 1.2);
  }
  getScreenSize(e) {
    if (this._projection === Bs) {
      const t = this._node.getPosition().distance(e.center);
      if (t < e.radius)
        return 1;
      const s = Math.asin(e.radius / t), i = Math.tan(s), n = Math.tan(this.fov / 2 * U.DEG_TO_RAD);
      return Math.min(i / n, 1);
    }
    return U.clamp(e.radius / this._orthoHeight, 0, 1);
  }
  getFrustumCorners(e = this.nearClip, t = this.farClip) {
    const s = this.fov * Math.PI / 180;
    let i = this._projection === Bs ? Math.tan(s / 2) * e : this._orthoHeight, n = i * this.aspectRatio;
    const a = IT;
    return a[0].x = n, a[0].y = -i, a[0].z = -e, a[1].x = n, a[1].y = i, a[1].z = -e, a[2].x = -n, a[2].y = i, a[2].z = -e, a[3].x = -n, a[3].y = -i, a[3].z = -e, this._projection === Bs && (i = Math.tan(s / 2) * t, n = i * this.aspectRatio), a[4].x = n, a[4].y = -i, a[4].z = -t, a[5].x = n, a[5].y = i, a[5].z = -t, a[6].x = -n, a[6].y = i, a[6].z = -t, a[7].x = -n, a[7].y = -i, a[7].z = -t, a;
  }
  setXrProperties(e) {
    Object.assign(e, this._xrProperties), this._projMatDirty = !0;
  }
}
const pc = 1 / 255, cg = new Float32Array(1), DT = new Int32Array(cg.buffer);
class qe {
  static float2Half(e) {
    cg[0] = e;
    const t = DT[0];
    let s = t >> 16 & 32768, i = t >> 12 & 2047;
    const n = t >> 23 & 255;
    return n < 103 ? s : n > 142 ? (s |= 31744, s |= (n === 255 ? 0 : 1) && t & 8388607, s) : n < 113 ? (i |= 2048, s |= (i >> 114 - n) + (i >> 113 - n & 1), s) : (s |= n - 112 << 10 | i >> 1, s += i & 1, s);
  }
  static float2Bytes(e, t, s, i) {
    const n = 255 * e % 1;
    if (t[s + 0] = Math.round((e % 1 - pc * n) * 255), i > 1) {
      const a = 65025 * e % 1;
      if (t[s + 1] = Math.round((n - pc * a) * 255), i > 2) {
        const o = 16581375 * e % 1;
        t[s + 2] = Math.round((a - pc * o) * 255), i > 3 && (t[s + 3] = Math.round(o * 255));
      }
    }
  }
  static float2BytesRange(e, t, s, i, n, a) {
    e = U.clamp((e - i) / (n - i), 0, 1), qe.float2Bytes(e, t, s, a);
  }
  static float2MantissaExponent(e, t, s, i) {
    const n = Math.floor(Math.log2(Math.abs(e))) + 1;
    e /= Math.pow(2, n), qe.float2BytesRange(e, t, s, -1, 1, i - 1), t[s + i - 1] = Math.round(n + 127);
  }
}
const rm = new j(), am = new j(), om = new j();
class Ms {
  static create(e, t, s) {
    const i = new ro();
    switch (i.node = new bt(e), i.aspectRatio = 1, i.aspectRatioMode = Ld, i._scissorRectClear = !0, t) {
      case Se:
        i.node.setRotation(Ms.pointLightRotations[s]), i.fov = 90, i.projection = Bs;
        break;
      case Ee:
        i.projection = Bs;
        break;
      case de:
        i.projection = Mr;
        break;
    }
    return i;
  }
  static evalSpotCookieMatrix(e) {
    let t = Ms._spotCookieCamera;
    t || (t = Ms.create("SpotCookieCamera", Ee), Ms._spotCookieCamera = t), t.fov = e._outerConeAngle * 2;
    const s = t._node;
    s.setPosition(e._node.getPosition()), s.setRotation(e._node.getRotation()), s.rotateLocal(-90, 0, 0), rm.setTRS(s.getPosition(), s.getRotation(), v.ONE).invert(), am.mul2(t.projectionMatrix, rm);
    const i = e.cookieMatrix, n = e.atlasViewport;
    return om.setViewport(n.x, n.y, n.z, n.w), i.mul2(om, am), i;
  }
}
Ms.pointLightRotations = [new ee().setFromEulerAngles(0, 90, 180), new ee().setFromEulerAngles(0, -90, 180), new ee().setFromEulerAngles(90, 0, 0), new ee().setFromEulerAngles(-90, 0, 0), new ee().setFromEulerAngles(0, 180, 180), new ee().setFromEulerAngles(0, 0, 180)];
Ms._spotCookieCamera = null;
const sa = 1e-6, Tt = new v(), tn = new Float32Array(6), BT = new v(-0.5, 0, 0), FT = new v(0, 0, 0.5), jt = {
  FLAGS: 0,
  COLOR_A: 1,
  COLOR_B: 2,
  SPOT_ANGLES: 3,
  SHADOW_BIAS: 4,
  COOKIE_A: 5,
  COOKIE_B: 6,
  COUNT_ALWAYS: 7,
  POSITION_X: 7,
  POSITION_Y: 8,
  POSITION_Z: 9,
  RANGE: 10,
  SPOT_DIRECTION_X: 11,
  SPOT_DIRECTION_Y: 12,
  SPOT_DIRECTION_Z: 13,
  PROJ_MAT_00: 14,
  ATLAS_VIEWPORT_A: 14,
  PROJ_MAT_01: 15,
  ATLAS_VIEWPORT_B: 15,
  PROJ_MAT_02: 16,
  PROJ_MAT_03: 17,
  PROJ_MAT_10: 18,
  PROJ_MAT_11: 19,
  PROJ_MAT_12: 20,
  PROJ_MAT_13: 21,
  PROJ_MAT_20: 22,
  PROJ_MAT_21: 23,
  PROJ_MAT_22: 24,
  PROJ_MAT_23: 25,
  PROJ_MAT_30: 26,
  PROJ_MAT_31: 27,
  PROJ_MAT_32: 28,
  PROJ_MAT_33: 29,
  AREA_DATA_WIDTH_X: 30,
  AREA_DATA_WIDTH_Y: 31,
  AREA_DATA_WIDTH_Z: 32,
  AREA_DATA_HEIGHT_X: 33,
  AREA_DATA_HEIGHT_Y: 34,
  AREA_DATA_HEIGHT_Z: 35,
  COUNT: 36
}, ct = {
  POSITION_RANGE: 0,
  SPOT_DIRECTION: 1,
  PROJ_MAT_0: 2,
  ATLAS_VIEWPORT: 2,
  PROJ_MAT_1: 3,
  PROJ_MAT_2: 4,
  PROJ_MAT_3: 5,
  AREA_DATA_WIDTH: 6,
  AREA_DATA_HEIGHT: 7,
  COUNT: 8
};
class ke {
  static initShaderDefines() {
    const e = ke.lightTextureFormat === ke.FORMAT_FLOAT ? "FLOAT" : "8BIT";
    ke.shaderDefines = `
						
#define CLUSTER_TEXTURE_${e}
						${ke.buildShaderDefines(jt, "CLUSTER_TEXTURE_8_")}
						${ke.buildShaderDefines(ct, "CLUSTER_TEXTURE_F_")}
				`;
  }
  static buildShaderDefines(e, t) {
    let s = "";
    const i = ke.useTexelFetch ? "" : ".5";
    return Object.keys(e).forEach((n) => {
      s += `
#define ${t}${n} ${e[n]}${i}`;
    }), s;
  }
  static init(e) {
    ke.lightTextureFormat = e.extTextureFloat && e.maxTextures > 8 ? ke.FORMAT_FLOAT : ke.FORMAT_8BIT, ke.useTexelFetch = e.supportsTextureFetch, ke.initShaderDefines();
  }
  static createTexture(e, t, s, i, n) {
    return new ue(e, {
      name: n,
      width: t,
      height: s,
      mipmaps: !1,
      format: i,
      addressU: he,
      addressV: he,
      type: Rs,
      magFilter: Be,
      minFilter: Be,
      anisotropy: 1
    });
  }
  constructor(e) {
    this.device = e, this.cookiesEnabled = !1, this.shadowsEnabled = !1, this.areaLightsEnabled = !1, this.maxLights = 255;
    let t = jt.COUNT_ALWAYS, s = 0;
    ke.lightTextureFormat === ke.FORMAT_FLOAT ? s = ct.COUNT : t = jt.COUNT, this.lights8 = new Uint8ClampedArray(4 * t * this.maxLights), this.lightsTexture8 = ke.createTexture(this.device, t, this.maxLights, ye, "LightsTexture8"), this._lightsTexture8Id = this.device.scope.resolve("lightsTexture8"), s ? (this.lightsFloat = new Float32Array(4 * s * this.maxLights), this.lightsTextureFloat = ke.createTexture(this.device, s, this.maxLights, vt, "LightsTextureFloat"), this._lightsTextureFloatId = this.device.scope.resolve("lightsTextureFloat")) : (this.lightsFloat = null, this.lightsTextureFloat = null, this._lightsTextureFloatId = void 0), this._lightsTextureInvSizeId = this.device.scope.resolve("lightsTextureInvSize"), this._lightsTextureInvSizeData = new Float32Array(4), this._lightsTextureInvSizeData[0] = s ? 1 / this.lightsTextureFloat.width : 0, this._lightsTextureInvSizeData[1] = s ? 1 / this.lightsTextureFloat.height : 0, this._lightsTextureInvSizeData[2] = 1 / this.lightsTexture8.width, this._lightsTextureInvSizeData[3] = 1 / this.lightsTexture8.height, this.invMaxColorValue = 0, this.invMaxAttenuation = 0, this.boundsMin = new v(), this.boundsDelta = new v();
  }
  destroy() {
    this.lightsTexture8 && (this.lightsTexture8.destroy(), this.lightsTexture8 = null), this.lightsTextureFloat && (this.lightsTextureFloat.destroy(), this.lightsTextureFloat = null);
  }
  setCompressionRanges(e, t) {
    this.invMaxColorValue = 1 / t, this.invMaxAttenuation = 1 / e;
  }
  setBounds(e, t) {
    this.boundsMin.copy(e), this.boundsDelta.copy(t);
  }
  uploadTextures() {
    this.lightsTextureFloat && (this.lightsTextureFloat.lock().set(this.lightsFloat), this.lightsTextureFloat.unlock()), this.lightsTexture8.lock().set(this.lights8), this.lightsTexture8.unlock();
  }
  updateUniforms() {
    this._lightsTexture8Id.setValue(this.lightsTexture8), ke.lightTextureFormat === ke.FORMAT_FLOAT && this._lightsTextureFloatId.setValue(this.lightsTextureFloat), this._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);
  }
  getSpotDirection(e, t) {
    t._node.getWorldTransform().getY(e).mulScalar(-1), e.normalize();
  }
  getLightAreaSizes(e) {
    const t = e._node.getWorldTransform();
    return t.transformVector(BT, Tt), tn[0] = Tt.x, tn[1] = Tt.y, tn[2] = Tt.z, t.transformVector(FT, Tt), tn[3] = Tt.x, tn[4] = Tt.y, tn[5] = Tt.z, tn;
  }
  addLightDataFlags(e, t, s, i, n, a) {
    e[t + 0] = i ? 255 : 0, e[t + 1] = s._shape * 64, e[t + 2] = s._falloffMode * 255, e[t + 3] = n ? a * 255 : 0;
  }
  addLightDataColor(e, t, s, i, n) {
    const a = this.invMaxColorValue, o = i ? s._linearFinalColor : s._finalColor;
    qe.float2Bytes(o[0] * a, e, t + 0, 2), qe.float2Bytes(o[1] * a, e, t + 2, 2), qe.float2Bytes(o[2] * a, e, t + 4, 2), e[t + 6] = n ? 255 : 0;
    const h = !!(s.mask & Gs), l = !!(s.mask & di);
    e[t + 7] = h && l ? 127 : l ? 255 : 0;
  }
  addLightDataSpotAngles(e, t, s) {
    qe.float2Bytes(s._innerConeAngleCos * (0.5 - sa) + 0.5, e, t + 0, 2), qe.float2Bytes(s._outerConeAngleCos * (0.5 - sa) + 0.5, e, t + 2, 2);
  }
  addLightDataShadowBias(e, t, s) {
    const i = s.getRenderData(null, 0), n = s._getUniformBiasValues(i);
    qe.float2BytesRange(n.bias, e, t, -1, 20, 2), qe.float2Bytes(n.normalBias, e, t + 2, 2);
  }
  addLightDataPositionRange(e, t, s, i) {
    const n = Tt.sub2(i, this.boundsMin).div(this.boundsDelta);
    qe.float2Bytes(n.x, e, t + 0, 4), qe.float2Bytes(n.y, e, t + 4, 4), qe.float2Bytes(n.z, e, t + 8, 4), qe.float2Bytes(s.attenuationEnd * this.invMaxAttenuation, e, t + 12, 4);
  }
  addLightDataSpotDirection(e, t, s) {
    this.getSpotDirection(Tt, s), qe.float2Bytes(Tt.x * (0.5 - sa) + 0.5, e, t + 0, 4), qe.float2Bytes(Tt.y * (0.5 - sa) + 0.5, e, t + 4, 4), qe.float2Bytes(Tt.z * (0.5 - sa) + 0.5, e, t + 8, 4);
  }
  addLightDataLightProjMatrix(e, t, s) {
    const i = s.data;
    for (let n = 0; n < 12; n++)
      qe.float2BytesRange(i[n], e, t + 4 * n, -2, 2, 4);
    for (let n = 12; n < 16; n++)
      qe.float2MantissaExponent(i[n], e, t + 4 * n, 4);
  }
  addLightDataCookies(e, t, s) {
    const i = s._cookieChannel === "rgb";
    if (e[t + 0] = Math.floor(s.cookieIntensity * 255), e[t + 1] = i ? 255 : 0, !i) {
      const n = s._cookieChannel;
      e[t + 4] = n === "rrr" ? 255 : 0, e[t + 5] = n === "ggg" ? 255 : 0, e[t + 6] = n === "bbb" ? 255 : 0, e[t + 7] = n === "aaa" ? 255 : 0;
    }
  }
  addLightAtlasViewport(e, t, s) {
    qe.float2Bytes(s.x, e, t + 0, 2), qe.float2Bytes(s.y, e, t + 2, 2), qe.float2Bytes(s.z / 3, e, t + 4, 2);
  }
  addLightAreaSizes(e, t, s) {
    const i = this.getLightAreaSizes(s);
    for (let n = 0; n < 6; n++)
      qe.float2MantissaExponent(i[n], e, t + 4 * n, 4);
  }
  addLightData(e, t, s) {
    const i = e._type === Ee, n = e.atlasViewportAllocated, a = this.cookiesEnabled && !!e._cookie && n, o = this.areaLightsEnabled && e.shape !== Mt, h = this.shadowsEnabled && e.castShadows && n, l = e._node.getPosition();
    let c = null, d = null;
    i ? h ? c = e.getRenderData(null, 0).shadowMatrix : a && (c = Ms.evalSpotCookieMatrix(e)) : (h || a) && (d = e.atlasViewport);
    const u = this.lights8, f = t * this.lightsTexture8.width * 4;
    if (this.addLightDataFlags(u, f + 4 * jt.FLAGS, e, i, h, e.shadowIntensity), this.addLightDataColor(u, f + 4 * jt.COLOR_A, e, s, a), i && this.addLightDataSpotAngles(u, f + 4 * jt.SPOT_ANGLES, e), e.castShadows && this.addLightDataShadowBias(u, f + 4 * jt.SHADOW_BIAS, e), a && this.addLightDataCookies(u, f + 4 * jt.COOKIE_A, e), ke.lightTextureFormat === ke.FORMAT_FLOAT) {
      const m = this.lightsFloat, _ = t * this.lightsTextureFloat.width * 4;
      if (m[_ + 4 * ct.POSITION_RANGE + 0] = l.x, m[_ + 4 * ct.POSITION_RANGE + 1] = l.y, m[_ + 4 * ct.POSITION_RANGE + 2] = l.z, m[_ + 4 * ct.POSITION_RANGE + 3] = e.attenuationEnd, i && (this.getSpotDirection(Tt, e), m[_ + 4 * ct.SPOT_DIRECTION + 0] = Tt.x, m[_ + 4 * ct.SPOT_DIRECTION + 1] = Tt.y, m[_ + 4 * ct.SPOT_DIRECTION + 2] = Tt.z), c) {
        const p = c.data;
        for (let g = 0; g < 16; g++)
          m[_ + 4 * ct.PROJ_MAT_0 + g] = p[g];
      }
      if (d && (m[_ + 4 * ct.ATLAS_VIEWPORT + 0] = d.x, m[_ + 4 * ct.ATLAS_VIEWPORT + 1] = d.y, m[_ + 4 * ct.ATLAS_VIEWPORT + 2] = d.z / 3), o) {
        const p = this.getLightAreaSizes(e);
        m[_ + 4 * ct.AREA_DATA_WIDTH + 0] = p[0], m[_ + 4 * ct.AREA_DATA_WIDTH + 1] = p[1], m[_ + 4 * ct.AREA_DATA_WIDTH + 2] = p[2], m[_ + 4 * ct.AREA_DATA_HEIGHT + 0] = p[3], m[_ + 4 * ct.AREA_DATA_HEIGHT + 1] = p[4], m[_ + 4 * ct.AREA_DATA_HEIGHT + 2] = p[5];
      }
    } else
      this.addLightDataPositionRange(u, f + 4 * jt.POSITION_X, e, l), i && this.addLightDataSpotDirection(u, f + 4 * jt.SPOT_DIRECTION_X, e), c && this.addLightDataLightProjMatrix(u, f + 4 * jt.PROJ_MAT_00, c), d && this.addLightAtlasViewport(u, f + 4 * jt.ATLAS_VIEWPORT_A, d), o && this.addLightAreaSizes(u, f + 4 * jt.AREA_DATA_WIDTH_X, e);
  }
}
ke.FORMAT_FLOAT = 0;
ke.FORMAT_8BIT = 1;
ke.lightTextureFormat = ke.FORMAT_8BIT;
ke.useTexelFetch = !1;
ke.shaderDefines = "";
const Ao = new v(), Mo = new v(), Eo = new v(), _c = new Pe(), hm = 1e-6;
class lm {
  constructor() {
    this.light = null, this.min = new v(), this.max = new v();
  }
}
class Pd {
  constructor(e) {
    this.clusterTexture = void 0, this.device = e, this.name = "Untitled", this.reportCount = 0, this.boundsMin = new v(), this.boundsMax = new v(), this.boundsDelta = new v(), this._cells = new v(1, 1, 1), this._cellsLimit = new v(), this.cells = this._cells, this.maxCellLightCount = 4, this._maxAttenuation = 0, this._maxColorValue = 0, this._usedLights = [], this._usedLights.push(new lm()), this.lightsBuffer = new ke(e), this.registerUniforms(e);
  }
  set maxCellLightCount(e) {
    e !== this._maxCellLightCount && (this._maxCellLightCount = e, this._cellsDirty = !0);
  }
  get maxCellLightCount() {
    return this._maxCellLightCount;
  }
  set cells(e) {
    Ao.copy(e).floor(), this._cells.equals(Ao) || (this._cells.copy(Ao), this._cellsLimit.copy(Ao).sub(v.ONE), this._cellsDirty = !0);
  }
  get cells() {
    return this._cells;
  }
  destroy() {
    this.lightsBuffer.destroy(), this.releaseClusterTexture();
  }
  releaseClusterTexture() {
    this.clusterTexture && (this.clusterTexture.destroy(), this.clusterTexture = null);
  }
  registerUniforms(e) {
    this._clusterMaxCellsId = e.scope.resolve("clusterMaxCells"), this._clusterWorldTextureId = e.scope.resolve("clusterWorldTexture"), this._clusterTextureSizeId = e.scope.resolve("clusterTextureSize"), this._clusterTextureSizeData = new Float32Array(3), this._clusterBoundsMinId = e.scope.resolve("clusterBoundsMin"), this._clusterBoundsMinData = new Float32Array(3), this._clusterBoundsDeltaId = e.scope.resolve("clusterBoundsDelta"), this._clusterBoundsDeltaData = new Float32Array(3), this._clusterCellsCountByBoundsSizeId = e.scope.resolve("clusterCellsCountByBoundsSize"), this._clusterCellsCountByBoundsSizeData = new Float32Array(3), this._clusterCellsDotId = e.scope.resolve("clusterCellsDot"), this._clusterCellsDotData = new Float32Array(3), this._clusterCellsMaxId = e.scope.resolve("clusterCellsMax"), this._clusterCellsMaxData = new Float32Array(3), this._clusterCompressionLimit0Id = e.scope.resolve("clusterCompressionLimit0"), this._clusterCompressionLimit0Data = new Float32Array(2);
  }
  updateParams(e) {
    e && (this.cells = e.cells, this.maxCellLightCount = e.maxLightsPerCell, this.lightsBuffer.cookiesEnabled = e.cookiesEnabled, this.lightsBuffer.shadowsEnabled = e.shadowsEnabled, this.lightsBuffer.areaLightsEnabled = e.areaLightsEnabled);
  }
  updateCells() {
    if (this._cellsDirty) {
      this._cellsDirty = !1;
      const e = this._cells.x, t = this._cells.y, s = this._cells.z, i = e * t * s, n = this.maxCellLightCount * i;
      let a = Math.ceil(Math.sqrt(n));
      a = U.roundUp(a, this.maxCellLightCount);
      const o = Math.ceil(n / a);
      this._clusterCellsMaxData[0] = e, this._clusterCellsMaxData[1] = t, this._clusterCellsMaxData[2] = s, this._clusterCellsDotData[0] = this.maxCellLightCount, this._clusterCellsDotData[1] = e * s * this.maxCellLightCount, this._clusterCellsDotData[2] = e * this.maxCellLightCount, this.clusters = new Uint8ClampedArray(n), this.counts = new Int32Array(i), this._clusterTextureSizeData[0] = a, this._clusterTextureSizeData[1] = 1 / a, this._clusterTextureSizeData[2] = 1 / o, this.releaseClusterTexture(), this.clusterTexture = ke.createTexture(this.device, a, o, bl, "ClusterTexture");
    }
  }
  uploadTextures() {
    this.clusterTexture.lock().set(this.clusters), this.clusterTexture.unlock(), this.lightsBuffer.uploadTextures();
  }
  updateUniforms() {
    this.lightsBuffer.updateUniforms(), this._clusterWorldTextureId.setValue(this.clusterTexture), this._clusterMaxCellsId.setValue(this.maxCellLightCount);
    const e = this.boundsDelta;
    this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / e.x, this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / e.y, this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / e.z, this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData), this._clusterBoundsMinData[0] = this.boundsMin.x, this._clusterBoundsMinData[1] = this.boundsMin.y, this._clusterBoundsMinData[2] = this.boundsMin.z, this._clusterBoundsDeltaData[0] = e.x, this._clusterBoundsDeltaData[1] = e.y, this._clusterBoundsDeltaData[2] = e.z, this._clusterCompressionLimit0Data[0] = this._maxAttenuation, this._clusterCompressionLimit0Data[1] = this._maxColorValue, this._clusterTextureSizeId.setValue(this._clusterTextureSizeData), this._clusterBoundsMinId.setValue(this._clusterBoundsMinData), this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData), this._clusterCellsDotId.setValue(this._clusterCellsDotData), this._clusterCellsMaxId.setValue(this._clusterCellsMaxData), this._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);
  }
  evalLightCellMinMax(e, t, s) {
    t.copy(e.min), t.sub(this.boundsMin), t.div(this.boundsDelta), t.mul2(t, this.cells), t.floor(), s.copy(e.max), s.sub(this.boundsMin), s.div(this.boundsDelta), s.mul2(s, this.cells), s.ceil(), t.max(v.ZERO), s.min(this._cellsLimit);
  }
  collectLights(e) {
    const t = this.lightsBuffer.maxLights, s = this._usedLights;
    let i = 1;
    e.forEach((n) => {
      const a = !!(n.mask & (Gs | di)), o = n.type === Ee && n._outerConeAngle === 0;
      if (n.enabled && n.type !== de && n.visibleThisFrame && n.intensity > 0 && a && !o && i < t) {
        let h;
        i < s.length ? h = s[i] : (h = new lm(), s.push(h)), h.light = n, n.getBoundingBox(_c), h.min.copy(_c.getMin()), h.max.copy(_c.getMax()), i++;
      }
    }), s.length = i;
  }
  evaluateBounds() {
    const e = this._usedLights, t = this.boundsMin, s = this.boundsMax;
    if (e.length > 1) {
      t.copy(e[1].min), s.copy(e[1].max);
      for (let i = 2; i < e.length; i++)
        t.min(e[i].min), s.max(e[i].max);
    } else
      t.set(0, 0, 0), s.set(1, 1, 1);
    this.boundsDelta.sub2(s, t), this.lightsBuffer.setBounds(t, this.boundsDelta);
  }
  evaluateCompressionLimits(e) {
    let t = 0, s = 0;
    const i = this._usedLights;
    for (let n = 1; n < i.length; n++) {
      const a = i[n].light;
      t = Math.max(a.attenuationEnd, t);
      const o = e ? a._linearFinalColor : a._finalColor;
      s = Math.max(o[0], s), s = Math.max(o[1], s), s = Math.max(o[2], s);
    }
    this._maxAttenuation = t + hm, this._maxColorValue = s + hm, this.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);
  }
  updateClusters(e) {
    this.counts.fill(0), this.clusters.fill(0);
    const t = this._cells.x, s = this._cells.z, i = this.counts, n = this._maxCellLightCount, a = this.clusters, o = this.maxCellLightCount, h = this._usedLights;
    for (let l = 1; l < h.length; l++) {
      const c = h[l], d = c.light;
      this.lightsBuffer.addLightData(d, l, e), this.evalLightCellMinMax(c, Mo, Eo);
      const u = Mo.x, f = Eo.x, m = Mo.y, _ = Eo.y, p = Mo.z, g = Eo.z;
      for (let b = u; b <= f; b++)
        for (let x = p; x <= g; x++)
          for (let y = m; y <= _; y++) {
            const S = b + t * (x + y * s), C = i[S];
            C < n && (a[o * S + C] = l, i[S] = C + 1);
          }
    }
  }
  update(e, t, s) {
    this.updateParams(s), this.updateCells(), this.collectLights(e), this.evaluateBounds(), this.evaluateCompressionLimits(t), this.updateClusters(t), this.uploadTextures();
  }
  activate() {
    this.updateUniforms();
  }
}
const OT = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}`, kT = `
		varying vec2 uv0;
		uniform sampler2D blitTexture;
		void main(void) {
				gl_FragColor = texture2D(blitTexture, uv0);
		}`, NT = `
		varying vec2 uv0;
		uniform samplerCube blitTexture;
		uniform mat4 invViewProj;
		void main(void) {
				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
				vec4 worldPos = invViewProj * projPos;
				gl_FragColor = textureCube(blitTexture, worldPos.xyz);
		}`, Li = new Z();
class Gi {
  constructor(e, t) {
    this.device = e, this.lightTextureAtlas = t, this.blitShader2d = null, this.blitShaderCube = null, this.blitTextureId = null, this.invViewProjId = null;
  }
  destroy() {
  }
  getShader(e, t) {
    return this[e] || (this[e] = ps(this.device, OT, t, `cookie_renderer_${e}`)), this.blitTextureId || (this.blitTextureId = this.device.scope.resolve("blitTexture")), this.invViewProjId || (this.invViewProjId = this.device.scope.resolve("invViewProj")), this[e];
  }
  get shader2d() {
    return this.getShader("blitShader2d", kT);
  }
  get shaderCube() {
    return this.getShader("blitShaderCube", NT);
  }
  static createTexture(e, t) {
    return new ue(e, {
      name: "CookieAtlas",
      width: t,
      height: t,
      format: ye,
      cubemap: !1,
      mipmaps: !1,
      minFilter: Be,
      magFilter: Be,
      addressU: he,
      addressV: he
    });
  }
  initInvViewProjMatrices() {
    if (!Gi._invViewProjMatrices) {
      Gi._invViewProjMatrices = [];
      for (let e = 0; e < 6; e++) {
        const t = Ms.create(null, Se, e), s = t.projectionMatrix, i = t.node.getLocalTransform().clone().invert();
        Gi._invViewProjMatrices[e] = new j().mul2(s, i).invert();
      }
    }
  }
  render(e, t) {
    if (e.enabled && e.cookie && e.visibleThisFrame) {
      const s = e.numShadowFaces, i = s > 1 ? this.shaderCube : this.shader2d, n = this.device;
      s > 1 && this.initInvViewProjMatrices(), this.blitTextureId.setValue(e.cookie);
      for (let a = 0; a < s; a++) {
        if (Li.copy(e.atlasViewport), s > 1) {
          const o = Li.z / 3, h = this.lightTextureAtlas.cubeSlotsOffsets[a];
          Li.x += o * h.x, Li.y += o * h.y, Li.z = o, Li.w = o, this.invViewProjId.setValue(Gi._invViewProjMatrices[a].data);
        }
        Li.mulScalar(t.colorBuffer.width), Yi(n, t, i, Li);
      }
    }
  }
}
Gi._invViewProjMatrices = null;
class Fn {
  constructor(e, t) {
    this.texture = e, this.cached = !1, this.renderTargets = t;
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null);
    const e = this.renderTargets;
    for (let t = 0; t < e.length; t++)
      e[t].destroy();
    this.renderTargets.length = 0;
  }
  static getShadowFormat(e, t) {
    return t === zs ? vt : t === li ? Pt : t === Us || t === gt && e.supportsDepthShadow ? Va : ye;
  }
  static getShadowFiltering(e, t) {
    return t === gt && !e.supportsDepthShadow ? Be : t === zs ? e.extTextureFloatLinear ? rt : Be : t === li ? e.extTextureHalfFloatLinear ? rt : Be : rt;
  }
  static create(e, t) {
    let s = null;
    return t._type === Se ? s = this.createCubemap(e, t._shadowResolution) : s = this.create2dMap(e, t._shadowResolution, t._shadowType), s;
  }
  static createAtlas(e, t, s) {
    const i = this.create2dMap(e, t, s), n = i.renderTargets, a = n[0];
    for (let o = 0; o < 5; o++)
      n.push(a);
    return i;
  }
  static create2dMap(e, t, s) {
    const i = this.getShadowFormat(e, s), n = this.getShadowFiltering(e, s), a = new ue(e, {
      format: i,
      width: t,
      height: t,
      mipmaps: !1,
      minFilter: n,
      magFilter: n,
      addressU: he,
      addressV: he,
      name: "ShadowMap2D"
    });
    let o = null;
    return s === Us || s === gt && e.supportsDepthShadow ? (a.compareOnRead = !0, a.compareFunc = gu, o = new Dt({
      depthBuffer: a
    })) : o = new Dt({
      colorBuffer: a,
      depth: !0
    }), e.deviceType === Et && (o.flipY = !0), new Fn(a, [o]);
  }
  static createCubemap(e, t) {
    const s = new ue(e, {
      format: ye,
      width: t,
      height: t,
      cubemap: !0,
      mipmaps: !1,
      minFilter: Be,
      magFilter: Be,
      addressU: he,
      addressV: he,
      name: "ShadowMapCube"
    }), i = [];
    for (let n = 0; n < 6; n++) {
      const a = new Dt({
        colorBuffer: s,
        face: n,
        depth: !0
      });
      i.push(a);
    }
    return new Fn(s, i);
  }
}
const zT = [], UT = [], $s = new Z(), gc = new Z();
class yc {
  constructor(e) {
    this.size = Math.floor(e.w * 1024), this.used = !1, this.lightId = -1, this.rect = e;
  }
}
class VT {
  constructor(e) {
    this.device = e, this.version = 1, this.shadowAtlasResolution = 2048, this.shadowAtlas = null, this.shadowEdgePixels = 3, this.cookieAtlasResolution = 2048, this.cookieAtlas = null, this.cookieRenderTarget = null, this.slots = [], this.atlasSplit = [], this.cubeSlotsOffsets = [new q(0, 0), new q(0, 1), new q(1, 0), new q(1, 1), new q(2, 0), new q(2, 1)], this.scissorVec = new Z(), this.allocateShadowAtlas(1), this.allocateCookieAtlas(1), this.allocateUniforms();
  }
  destroy() {
    this.destroyShadowAtlas(), this.destroyCookieAtlas();
  }
  destroyShadowAtlas() {
    this.shadowAtlas && (this.shadowAtlas.destroy(), this.shadowAtlas = null);
  }
  destroyCookieAtlas() {
    this.cookieAtlas && (this.cookieAtlas.destroy(), this.cookieAtlas = null), this.cookieRenderTarget && (this.cookieRenderTarget.destroy(), this.cookieRenderTarget = null);
  }
  allocateShadowAtlas(e) {
    if (!this.shadowAtlas || this.shadowAtlas.texture.width !== e) {
      this.version++, this.destroyShadowAtlas(), this.shadowAtlas = Fn.createAtlas(this.device, e, gt), this.shadowAtlas.cached = !0;
      const t = 4 / this.shadowAtlasResolution;
      this.scissorVec.set(t, t, -2 * t, -2 * t);
    }
  }
  allocateCookieAtlas(e) {
    (!this.cookieAtlas || this.cookieAtlas.width !== e) && (this.version++, this.destroyCookieAtlas(), this.cookieAtlas = Gi.createTexture(this.device, e), this.cookieRenderTarget = new Dt({
      colorBuffer: this.cookieAtlas,
      depth: !1,
      flipY: !0
    }));
  }
  allocateUniforms() {
    this._shadowAtlasTextureId = this.device.scope.resolve("shadowAtlasTexture"), this._shadowAtlasParamsId = this.device.scope.resolve("shadowAtlasParams"), this._shadowAtlasParams = new Float32Array(2), this._cookieAtlasTextureId = this.device.scope.resolve("cookieAtlasTexture");
  }
  updateUniforms() {
    const t = this.shadowAtlas.renderTargets[0], s = this.device.webgl2 ? t.depthBuffer : t.colorBuffer;
    this._shadowAtlasTextureId.setValue(s), this._shadowAtlasParams[0] = this.shadowAtlasResolution, this._shadowAtlasParams[1] = this.shadowEdgePixels, this._shadowAtlasParamsId.setValue(this._shadowAtlasParams), this._cookieAtlasTextureId.setValue(this.cookieAtlas);
  }
  subdivide(e, t) {
    let s = t.atlasSplit;
    if (!s) {
      const n = Math.ceil(Math.sqrt(e));
      s = UT, s[0] = n, s.length = 1;
    }
    if (!((n, a) => n.length === a.length && n.every((o, h) => o === a[h]))(s, this.atlasSplit)) {
      this.version++, this.slots.length = 0, this.atlasSplit.length = 0, this.atlasSplit.push(...s);
      const n = this.atlasSplit[0];
      if (n > 1) {
        const a = 1 / n;
        for (let o = 0; o < n; o++)
          for (let h = 0; h < n; h++) {
            const l = new Z(o * a, h * a, a, a), c = this.atlasSplit[1 + o * n + h];
            if (c > 1)
              for (let d = 0; d < c; d++)
                for (let u = 0; u < c; u++) {
                  const f = a / c, m = new Z(l.x + d * f, l.y + u * f, f, f);
                  this.slots.push(new yc(m));
                }
            else
              this.slots.push(new yc(l));
          }
      } else
        this.slots.push(new yc(new Z(0, 0, 1, 1)));
      this.slots.sort((a, o) => o.size - a.size);
    }
  }
  collectLights(e, t, s) {
    const i = s.cookiesEnabled, n = s.shadowsEnabled;
    let a = !1, o = !1;
    const h = zT;
    h.length = 0;
    const l = (c) => {
      for (let d = 0; d < c.length; d++) {
        const u = c[d];
        if (u.visibleThisFrame) {
          const f = n && u.castShadows, m = i && !!u.cookie;
          a || (a = f), o || (o = m), (f || m) && h.push(u);
        }
      }
    };
    return (i || n) && (l(e), l(t)), h.sort((c, d) => d.maxScreenSize - c.maxScreenSize), a && this.allocateShadowAtlas(this.shadowAtlasResolution), o && this.allocateCookieAtlas(this.cookieAtlasResolution), (a || o) && this.subdivide(h.length, s), h;
  }
  setupSlot(e, t) {
    e.atlasViewport.copy(t);
    const s = e.numShadowFaces;
    for (let i = 0; i < s; i++)
      if (e.castShadows || e._cookie) {
        if ($s.copy(t), gc.copy(t), e._type === Ee && $s.add(this.scissorVec), e._type === Se) {
          const n = $s.z / 3, a = this.cubeSlotsOffsets[i];
          $s.x += n * a.x, $s.y += n * a.y, $s.z = n, $s.w = n, gc.copy($s);
        }
        if (e.castShadows) {
          const n = e.getRenderData(null, i);
          n.shadowViewport.copy($s), n.shadowScissor.copy(gc);
        }
      }
  }
  assignSlot(e, t, s) {
    e.atlasViewportAllocated = !0;
    const i = this.slots[t];
    i.lightId = e.id, i.used = !0, s && (e.atlasSlotUpdated = !0, e.atlasVersion = this.version, e.atlasSlotIndex = t);
  }
  update(e, t, s) {
    this.shadowAtlasResolution = s.shadowAtlasResolution, this.cookieAtlasResolution = s.cookieAtlasResolution;
    const i = this.collectLights(e, t, s);
    if (i.length > 0) {
      const n = this.slots;
      for (let h = 0; h < n.length; h++)
        n[h].used = !1;
      const a = Math.min(i.length, n.length);
      for (let h = 0; h < a; h++) {
        const l = i[h];
        l.castShadows && (l._shadowMap = this.shadowAtlas);
        const c = n[l.atlasSlotIndex];
        if (l.atlasVersion === this.version && l.id === (c == null ? void 0 : c.lightId)) {
          const d = n[l.atlasSlotIndex];
          d.size === n[h].size && !d.used && this.assignSlot(l, l.atlasSlotIndex, !1);
        }
      }
      let o = 0;
      for (let h = 0; h < a; h++) {
        for (; o < n.length && n[o].used; )
          o++;
        const l = i[h];
        l.atlasViewportAllocated || this.assignSlot(l, o, !0);
        const c = n[l.atlasSlotIndex];
        this.setupSlot(l, c.rect);
      }
    }
    this.updateUniforms();
  }
}
class GT {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.clear(), this.cache = null;
  }
  clear() {
    this.cache.forEach((e) => {
      e.forEach((t) => {
        t.destroy();
      });
    }), this.cache.clear();
  }
  getKey(e) {
    const t = e._type === Se, s = e._shadowType, i = e._shadowResolution;
    return `${t}-${s}-${i}`;
  }
  get(e, t) {
    const s = this.getKey(t), i = this.cache.get(s);
    if (i && i.length)
      return i.pop();
    const n = Fn.create(e, t);
    return n.cached = !0, n;
  }
  add(e, t) {
    const s = this.getKey(e), i = this.cache.get(s);
    i ? i.push(t) : this.cache.set(s, [t]);
  }
}
class HT {
  constructor(e, t) {
    this.renderer = e, this.shadowRenderer = t, this.device = e.device;
  }
  cull(e, t) {
    const s = this.renderer.scene.clusteredLightingEnabled;
    e.visibleThisFrame = !0, s || e._shadowMap || (e._shadowMap = Fn.create(this.device, e));
    const i = e._type, n = i === Ee ? 1 : 6;
    for (let a = 0; a < n; a++) {
      const o = e.getRenderData(null, a), h = o.shadowCamera;
      h.nearClip = e.attenuationEnd / 1e3, h.farClip = e.attenuationEnd;
      const l = h._node, c = e._node;
      if (l.setPosition(c.getPosition()), i === Ee)
        h.fov = e._outerConeAngle * 2, l.setRotation(c.getRotation()), l.rotateLocal(-90, 0, 0);
      else if (i === Se)
        if (s) {
          const f = 2 / (this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * e.atlasViewport.z / 3) * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
          h.fov = Math.atan(1 + f) * U.RAD_TO_DEG * 2;
        } else
          h.fov = 90;
      this.renderer.updateCameraFrustum(h), this.shadowRenderer.cullShadowCasters(t, o.visibleCasters, h);
    }
  }
}
const Ro = new Pe(), Ys = new v(), cm = new j(), Ue = [new v(), new v(), new v(), new v(), new v(), new v(), new v(), new v()], xc = {
  min: 0,
  max: 0
};
function WT(r, e, t) {
  Ue[0].x = Ue[1].x = Ue[2].x = Ue[3].x = e.x, Ue[1].y = Ue[3].y = Ue[7].y = Ue[5].y = e.y, Ue[2].z = Ue[3].z = Ue[6].z = Ue[7].z = e.z, Ue[4].x = Ue[5].x = Ue[6].x = Ue[7].x = t.x, Ue[0].y = Ue[2].y = Ue[4].y = Ue[6].y = t.y, Ue[0].z = Ue[1].z = Ue[4].z = Ue[5].z = t.z;
  let s = 9999999999, i = -9999999999;
  for (let n = 0; n < 8; ++n) {
    r.transformPoint(Ue[n], Ue[n]);
    const a = Ue[n].z;
    a < s && (s = a), a > i && (i = a);
  }
  return xc.min = s, xc.max = i, xc;
}
class qT {
  constructor(e, t) {
    this.renderer = e, this.shadowRenderer = t, this.device = e.device;
  }
  cull(e, t, s) {
    e.visibleThisFrame = !0, e._shadowMap || (e._shadowMap = Fn.create(this.device, e));
    const i = s._nearClip;
    this.generateSplitDistances(e, i, e.shadowDistance);
    const n = e.shadowUpdateOverrides;
    for (let a = 0; a < e.numCascades && (n == null ? void 0 : n[a]) !== Vs; a++) {
      const o = e.getRenderData(s, a), h = o.shadowCamera;
      h.renderTarget = e._shadowMap.renderTargets[0], o.shadowViewport.copy(e.cascades[a]), o.shadowScissor.copy(e.cascades[a]);
      const l = h._node, c = e._node;
      l.setPosition(c.getPosition()), l.setRotation(c.getRotation()), l.rotateLocal(-90, 0, 0);
      const d = a === 0 ? i : e._shadowCascadeDistances[a - 1], u = e._shadowCascadeDistances[a], f = s.getFrustumCorners(d, u);
      Ys.set(0, 0, 0);
      const m = s.node.getWorldTransform();
      for (let I = 0; I < 8; I++)
        m.transformPoint(f[I], f[I]), Ys.add(f[I]);
      Ys.mulScalar(1 / 8);
      let _ = 0;
      for (let I = 0; I < 8; I++) {
        const D = f[I].sub(Ys).length();
        D > _ && (_ = D);
      }
      const p = l.right, g = l.up, b = l.forward, x = 0.25 * e._shadowResolution / _, y = Math.ceil(Ys.dot(g) * x) / x, S = Math.ceil(Ys.dot(p) * x) / x, C = g.mulScalar(y), w = p.mulScalar(S), M = Ys.dot(b), T = b.mulScalar(M);
      Ys.add2(C, w).add(T), l.setPosition(Ys), l.translateLocal(0, 0, 1e6), h.nearClip = 0.01, h.farClip = 2e6, h.orthoHeight = _, this.renderer.updateCameraFrustum(h), this.shadowRenderer.cullShadowCasters(t, o.visibleCasters, h);
      let A = !0;
      const L = o.visibleCasters;
      for (let I = 0; I < L.length; I++) {
        const D = L[I];
        A ? (A = !1, Ro.copy(D.aabb)) : Ro.add(D.aabb);
      }
      cm.copy(l.getWorldTransform()).invert();
      const O = WT(cm, Ro.getMin(), Ro.getMax());
      l.translateLocal(0, 0, O.max + 0.1), h.farClip = O.max - O.min + 0.2;
    }
  }
  generateSplitDistances(e, t, s) {
    e._shadowCascadeDistances.fill(s);
    for (let i = 1; i < e.numCascades; i++) {
      const n = i / e.numCascades, a = t + (s - t) * n, o = t * (s / t) ** n, h = U.lerp(a, o, e.cascadeDistribution);
      e._shadowCascadeDistances[i - 1] = h;
    }
  }
  addLightRenderPasses(e, t, s) {
    const i = t.numShadowFaces, n = t.shadowUpdateOverrides;
    let a = !0, o;
    for (let l = 0; l < i; l++)
      (n == null ? void 0 : n[l]) === Vs && (a = !1), o = this.shadowRenderer.prepareFace(t, s, l);
    const h = new vr(this.device, () => {
      for (let l = 0; l < i; l++)
        (n == null ? void 0 : n[l]) !== Vs && this.shadowRenderer.renderFace(t, s, l, !a), (n == null ? void 0 : n[l]) === Gr && (n[l] = Vs);
    });
    h.after = () => {
      this.shadowRenderer.renderVms(t, s);
    }, this.shadowRenderer.setupRenderPass(h, o, a), e.addRenderPass(h);
  }
  buildFrameGraph(e, t, s) {
    const i = t.directionalLights;
    for (let n = 0; n < i.length; n++) {
      const a = i[n];
      this.shadowRenderer.needsShadowRendering(a) && this.addLightRenderPasses(e, a, s.camera);
    }
  }
}
const ia = new pl();
class br {
  static lightCompare(e, t) {
    return e.key - t.key;
  }
  static prepare(e, t, s, i) {
    const n = s, a = n.length, o = [], h = new v(), l = new v(), c = new Pe(), d = new j(), u = [], f = [], m = [], _ = [];
    for (let p = 0; p < a; p++) {
      const g = n[p];
      if (!g.isStatic)
        o.push(g);
      else {
        const b = g.aabb;
        _.length = 0;
        for (let D = Se; D <= Ee; D++)
          for (let G = 0; G < i.length; G++) {
            const X = i[G];
            if (X._type === D && X.enabled && X.mask & g.mask && X.isStatic) {
              if (f[G] || (f[G] = new Pe(), X._node.getWorldTransform(), X.getBoundingSphere(ia), f[G].center.copy(ia.center), f[G].halfExtents.set(ia.radius, ia.radius, ia.radius)), !f[G].intersects(b))
                continue;
              _.push(G);
            }
          }
        if (_.length === 0) {
          o.push(g);
          continue;
        }
        const x = g.mesh, y = x.vertexBuffer, S = x.indexBuffer[g.renderStyle], C = S.bytesPerIndex === 2 ? new Uint16Array(S.lock()) : new Uint32Array(S.lock()), w = x.primitive[g.renderStyle].count / 3, M = x.primitive[g.renderStyle].base, T = y.format.elements, A = y.format.size / 4, L = new Float32Array(y.storage);
        let O;
        for (let D = 0; D < T.length; D++)
          T[D].name === et && (O = T[D].offset / 4);
        u.length = w;
        for (let D = 0; D < w; D++)
          u[D] = 0;
        let I = !1;
        m.length = w * 6;
        for (let D = 0; D < w; D++) {
          let G = Number.MAX_VALUE, X = Number.MAX_VALUE, E = Number.MAX_VALUE, P = -Number.MAX_VALUE, B = -Number.MAX_VALUE, k = -Number.MAX_VALUE;
          for (let V = 0; V < 3; V++) {
            let K = C[D * 3 + V + M];
            K = K * A + O;
            const Q = L[K], se = L[K + 1], J = L[K + 2];
            Q < G && (G = Q), se < X && (X = se), J < E && (E = J), Q > P && (P = Q), se > B && (B = se), J > k && (k = J);
          }
          const H = D * 6;
          m[H] = G, m[H + 1] = X, m[H + 2] = E, m[H + 3] = P, m[H + 4] = B, m[H + 5] = k;
        }
        for (let D = 0; D < _.length; D++) {
          const G = _[D];
          d.copy(g.node.worldTransform).invert(), c.setFromTransformedAabb(f[G], d);
          const X = c.getMin(), E = c.getMax(), P = 1 << D;
          for (let B = 0; B < w; B++) {
            const k = B * 6;
            m[k] <= E.x && m[k + 3] >= X.x && m[k + 1] <= E.y && m[k + 4] >= X.y && m[k + 2] <= E.z && m[k + 5] >= X.z && (u[B] |= P, I = !0);
          }
        }
        if (I) {
          const D = {};
          for (let G = 0; G < w; G++) {
            const X = G * 3 + M, E = u[G];
            D[E] || (D[E] = []);
            const P = D[E];
            P.push(C[X]), P.push(C[X + 1]), P.push(C[X + 2]);
          }
          for (const G in D) {
            const X = D[G], E = new ji(e, S.format, X.length, S.usage);
            (E.bytesPerIndex === 2 ? new Uint16Array(E.lock()) : new Uint32Array(E.lock())).set(X), E.unlock();
            let B = Number.MAX_VALUE, k = Number.MAX_VALUE, H = Number.MAX_VALUE, V = -Number.MAX_VALUE, K = -Number.MAX_VALUE, Q = -Number.MAX_VALUE;
            for (let Re = 0; Re < X.length; Re++) {
              const Je = X[Re], Ke = L[Je * A + O], at = L[Je * A + O + 1], gs = L[Je * A + O + 2];
              Ke < B && (B = Ke), at < k && (k = at), gs < H && (H = gs), Ke > V && (V = Ke), at > K && (K = at), gs > Q && (Q = gs);
            }
            h.set(B, k, H), l.set(V, K, Q);
            const se = new Pe();
            se.setMinMax(h, l);
            const J = new _s(e);
            J.vertexBuffer = y, J.indexBuffer[0] = E, J.primitive[0].type = Es, J.primitive[0].base = 0, J.primitive[0].count = X.length, J.primitive[0].indexed = !0, J.aabb = se;
            const $ = new we(J, g.material, g.node);
            $.isStatic = g.isStatic, $.visible = g.visible, $.layer = g.layer, $.castShadow = g.castShadow, $._receiveShadow = g._receiveShadow, $.cull = g.cull, $.pick = g.pick, $.mask = g.mask, $.parameters = g.parameters, $._shaderDefs = g._shaderDefs, $._staticSource = g, g._staticLightList ? $._staticLightList = g._staticLightList : $._staticLightList = [];
            for (let Re = 0; Re < _.length; Re++) {
              const Je = 1 << Re;
              if (G & Je) {
                const Ke = i[_[Re]];
                $._staticLightList.indexOf(Ke) < 0 && $._staticLightList.push(Ke);
              }
            }
            $._staticLightList.sort(br.lightCompare), o.push($);
          }
        } else
          o.push(g);
      }
    }
    s.length = o.length;
    for (let p = 0; p < o.length; p++)
      s[p] = o[p];
  }
  static revert(e) {
    const t = e, s = t.length, i = [];
    let n;
    for (let a = 0; a < s; a++) {
      const o = t[a];
      o._staticSource ? o._staticSource !== n && (i.push(o._staticSource), n = o._staticSource) : i.push(o);
    }
    e.length = i.length;
    for (let a = 0; a < i.length; a++)
      e[a] = i[a];
  }
}
function XT(r, e) {
  return Math.exp(-(r * r) / (2 * e * e));
}
const dm = 25;
function jT(r) {
  r > dm && (r = dm);
  const e = (r - 1) / (2 * 3), t = (r - 1) * 0.5, s = new Array(r);
  let i = 0;
  for (let n = 0; n < r; ++n)
    s[n] = XT(n - t, e), i += s[n];
  for (let n = 0; n < r; ++n)
    s[n] /= i;
  return s;
}
const um = new j(), fm = new j(), sn = new Float32Array(2), na = new Z(1, 1, 0, 0), $T = {
  r: 1,
  g: 2,
  b: 3,
  a: 4
}, mm = new j();
function YT(r) {
  const e = r.material, t = r.skinInstance ? 10 : 0;
  let s = 0;
  if (e.opacityMap) {
    const i = e.opacityMapChannel;
    i && (s = $T[i]);
  }
  return t + s;
}
class ql {
  constructor(e, t) {
    this.device = e.device, this.renderer = e, this.lightTextureAtlas = t;
    const s = this.device.scope;
    this.polygonOffsetId = s.resolve("polygonOffset"), this.polygonOffset = new Float32Array(2), this.sourceId = s.resolve("source"), this.pixelOffsetId = s.resolve("pixelOffset"), this.weightId = s.resolve("weight[0]"), this.blurVsmShaderCode = [N.blurVSMPS, `#define GAUSS
` + N.blurVSMPS];
    const i = `#define PACKED
`;
    this.blurPackedVsmShaderCode = [i + this.blurVsmShaderCode[0], i + this.blurVsmShaderCode[1]], this.blurVsmShader = [{}, {}], this.blurPackedVsmShader = [{}, {}], this.blurVsmWeights = {}, this.shadowMapLightRadiusId = s.resolve("light_radius"), this.viewUniformFormat = null, this.viewBindGroupFormat = null;
  }
  static createShadowCamera(e, t, s, i) {
    const n = Ms.create("ShadowCamera", s, i);
    return t >= Os && t <= zs ? n.clearColor = new z(0, 0, 0, 0) : n.clearColor = new z(1, 1, 1, 1), n.clearDepthBuffer = !0, n.clearStencilBuffer = !1, n;
  }
  static setShadowCameraSettings(e, t, s, i, n) {
    let a = s === Us || s === gt && t.supportsDepthShadow;
    i === Se && !n && (a = !1), e.clearColorBuffer = !a;
  }
  cullShadowCasters(e, t, s) {
    let i = 0;
    const n = e.length;
    for (let a = 0; a < n; a++) {
      const o = e[a];
      (!o.cull || o._isVisible(s)) && (o.visibleThisFrame = !0, t[i] = o, i++);
    }
    t.length = i, t.sort(this.renderer.sortCompareDepth);
  }
  setupRenderState(e, t) {
    const s = this.renderer.scene.clusteredLightingEnabled;
    e.webgl2 || e.deviceType === Et ? t._type === Se && !s ? e.setDepthBias(!1) : (e.setDepthBias(!0), e.setDepthBiasValues(t.shadowBias * -1e3, t.shadowBias * -1e3)) : e.extStandardDerivatives && (t._type === Se ? (this.polygonOffset[0] = 0, this.polygonOffset[1] = 0, this.polygonOffsetId.setValue(this.polygonOffset)) : (this.polygonOffset[0] = t.shadowBias * -1e3, this.polygonOffset[1] = t.shadowBias * -1e3, this.polygonOffsetId.setValue(this.polygonOffset))), e.setBlending(!1), e.setDepthWrite(!0), e.setDepthTest(!0), e.setDepthFunc(Sl), (s ? t._isPcf && e.webgl2 : t._isPcf && e.webgl2 && t._type !== Se) ? e.setColorWrite(!1, !1, !1, !1) : e.setColorWrite(!0, !0, !0, !0);
  }
  restoreRenderState(e) {
    e.webgl2 ? e.setDepthBias(!1) : e.extStandardDerivatives && (this.polygonOffset[0] = 0, this.polygonOffset[1] = 0, this.polygonOffsetId.setValue(this.polygonOffset));
  }
  dispatchUniforms(e, t, s, i) {
    const n = t._node;
    e._type !== de && (this.renderer.dispatchViewPos(n.getPosition()), this.shadowMapLightRadiusId.setValue(e.attenuationEnd)), um.setTRS(n.getPosition(), n.getRotation(), v.ONE).invert(), fm.mul2(t.projectionMatrix, um);
    const a = s.shadowViewport;
    t.rect = a, t.scissorRect = s.shadowScissor, mm.setViewport(a.x, a.y, a.z, a.w), s.shadowMatrix.mul2(mm, fm), e._type === de && e._shadowMatrixPalette.set(s.shadowMatrix.data, i * 16);
  }
  submitCasters(e, t) {
    const s = this.device, i = this.renderer, n = i.scene, a = 1 << vn, o = Ut.getShadow(t._type, t._shadowType), h = e.length;
    for (let l = 0; l < h; l++) {
      const c = e[l], d = c.mesh;
      c.ensureMaterial(s);
      const u = c.material;
      i.setBaseConstants(s, u), i.setSkinning(s, c), u.dirty && (u.updateUniforms(s, n), u.dirty = !1), u.chunks && (i.setCullMode(!0, !1, c), u.setParameters(s), c.setParameters(s, a));
      let f = c._shader[o];
      f || (c.updatePassShader(n, o, null, null, this.viewUniformFormat, this.viewBindGroupFormat), f = c._shader[o], c._key[Ed] = YT(c)), !f.failed && s.setShader(f), i.setVertexBuffers(s, d), i.setMorphing(s, c.morphInstance), this.renderer.setupMeshUniformBuffers(c, o);
      const m = c.renderStyle;
      s.setIndexBuffer(d.indexBuffer[m]), i.drawInstance(s, c, d, m), i._shadowDrawCalls++;
    }
  }
  needsShadowRendering(e) {
    const t = e.enabled && e.castShadows && e.shadowUpdateMode !== Vs && e.visibleThisFrame;
    return e.shadowUpdateMode === Gr && (e.shadowUpdateMode = Vs), t && (this.renderer._shadowMapUpdates += e.numShadowFaces), t;
  }
  getLightRenderData(e, t, s) {
    return e.getRenderData(e._type === de ? t : null, s);
  }
  setupRenderPass(e, t, s) {
    const i = t.renderTarget;
    if (e.init(i), s) {
      const n = t.clearColorBuffer;
      e.colorOps.clear = n, n && e.colorOps.clearValue.copy(t.clearColor), e.depthStencilOps.storeDepth = !n, e.setClearDepth(1);
    }
    e.requiresCubemaps = !1;
  }
  prepareFace(e, t, s) {
    const i = e._type, n = e._shadowType, a = this.renderer.scene.clusteredLightingEnabled, h = this.getLightRenderData(e, t, s).shadowCamera;
    ql.setShadowCameraSettings(h, this.device, n, i, a);
    const l = i === de ? 0 : s;
    return h.renderTarget = e._shadowMap.renderTargets[l], h;
  }
  renderFace(e, t, s, i) {
    const n = this.device;
    this.setupRenderState(n, e);
    const a = this.getLightRenderData(e, t, s), o = a.shadowCamera;
    this.dispatchUniforms(e, o, a, s);
    const h = o.renderTarget;
    this.renderer.setCameraUniforms(o, h), n.supportsUniformBuffers && this.renderer.setupViewUniformBuffers(a.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1), i ? this.renderer.clearView(o, h, !0, !1) : this.renderer.setupViewport(o, h), this.submitCasters(a.visibleCasters, e), this.restoreRenderState(n);
  }
  render(e, t) {
    if (this.needsShadowRendering(e)) {
      const s = e.numShadowFaces;
      for (let i = 0; i < s; i++)
        this.prepareFace(e, t, i), this.renderFace(e, t, i, !0);
      this.renderVms(e, t);
    }
  }
  renderVms(e, t) {
    e._isVsm && e._vsmBlurSize > 1 && (!this.renderer.scene.clusteredLightingEnabled || e._type === de) && this.applyVsmBlur(e, t);
  }
  getVsmBlurShader(e, t, s) {
    let i = (e ? this.blurPackedVsmShader : this.blurVsmShader)[t][s];
    if (!i) {
      this.blurVsmWeights[s] = jT(s);
      const n = N.fullscreenQuadVS;
      let a = "#define SAMPLES " + s + `
`;
      e ? a += this.blurPackedVsmShaderCode[t] : a += this.blurVsmShaderCode[t];
      const o = "blurVsm" + t + s + e;
      i = ps(this.device, n, a, o), e ? this.blurPackedVsmShader[t][s] = i : this.blurVsmShader[t][s] = i;
    }
    return i;
  }
  applyVsmBlur(e, t) {
    const s = this.device, a = e.getRenderData(e._type === de ? t : null, 0).shadowCamera.renderTarget, o = this.renderer.shadowMapCache.get(s, e), h = o.renderTargets[0], l = e._shadowType === Os, c = e.vsmBlurMode, d = e._vsmBlurSize, u = this.getVsmBlurShader(l, c, d);
    na.z = e._shadowResolution - 2, na.w = na.z, this.sourceId.setValue(a.colorBuffer), sn[0] = 1 / e._shadowResolution, sn[1] = 0, this.pixelOffsetId.setValue(sn), c === Du && this.weightId.setValue(this.blurVsmWeights[d]), Yi(s, h, u, null, na), this.sourceId.setValue(h.colorBuffer), sn[1] = sn[0], sn[0] = 0, this.pixelOffsetId.setValue(sn), Yi(s, a, u, null, na), this.renderer.shadowMapCache.add(e, o);
  }
  initViewBindGroupFormat() {
    this.device.supportsUniformBuffers && !this.viewUniformFormat && (this.viewUniformFormat = new k_(this.device, [new O_("matrix_viewProjection", Ur)]), this.viewBindGroupFormat = new z_(this.device, [new N_(Eu, D_ | pd)], []));
  }
  frameUpdate() {
    this.initViewBindGroupFormat();
  }
}
let vc = 0;
const ra = [0, 0, 0, 0], nn = new j(), Pi = new j(), Yn = new j(), Ii = new v(), Lo = new v(), Po = new v(), pm = new is(), Sc = new pl(), _m = new j().setScale(1, -1, 1), gm = new j().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]), KT = new j(), ZT = new j(), JT = new j(), QT = new j(), Kn = /* @__PURE__ */ new Set();
let eC = class {
  constructor(e) {
    this.clustersDebugRendered = !1, this.device = e, this.scene = null, this.lightTextureAtlas = new VT(e), this.shadowMapCache = new GT(), this.shadowRenderer = new ql(this, this.lightTextureAtlas), this._shadowRendererLocal = new HT(this, this.shadowRenderer), this._shadowRendererDirectional = new qT(this, this.shadowRenderer), this._cookieRenderer = new Gi(e, this.lightTextureAtlas), this.viewUniformFormat = null, this.viewBindGroupFormat = null, this._skinTime = 0, this._morphTime = 0, this._cullTime = 0, this._shadowMapTime = 0, this._lightClustersTime = 0, this._layerCompositionUpdateTime = 0, this._shadowDrawCalls = 0, this._skinDrawCalls = 0, this._instancedDrawCalls = 0, this._shadowMapUpdates = 0, this._numDrawCallsCulled = 0, this._camerasRendered = 0, this._lightClusters = 0;
    const t = e.scope;
    this.boneTextureId = t.resolve("texture_poseMap"), this.boneTextureSizeId = t.resolve("texture_poseMapSize"), this.poseMatrixId = t.resolve("matrix_pose[0]"), this.modelMatrixId = t.resolve("matrix_model"), this.normalMatrixId = t.resolve("matrix_normal"), this.viewInvId = t.resolve("matrix_viewInverse"), this.viewPos = new Float32Array(3), this.viewPosId = t.resolve("view_position"), this.projId = t.resolve("matrix_projection"), this.projSkyboxId = t.resolve("matrix_projectionSkybox"), this.viewId = t.resolve("matrix_view"), this.viewId3 = t.resolve("matrix_view3"), this.viewProjId = t.resolve("matrix_viewProjection"), this.flipYId = t.resolve("projectionFlipY"), this.tbnBasis = t.resolve("tbnBasis"), this.nearClipId = t.resolve("camera_near"), this.farClipId = t.resolve("camera_far"), this.cameraParams = new Float32Array(4), this.cameraParamsId = t.resolve("camera_params"), this.alphaTestId = t.resolve("alpha_ref"), this.opacityMapId = t.resolve("texture_opacityMap"), this.exposureId = t.resolve("exposure"), this.twoSidedLightingNegScaleFactorId = t.resolve("twoSidedLightingNegScaleFactor"), this.morphWeightsA = t.resolve("morph_weights_a"), this.morphWeightsB = t.resolve("morph_weights_b"), this.morphPositionTex = t.resolve("morphPositionTex"), this.morphNormalTex = t.resolve("morphNormalTex"), this.morphTexParams = t.resolve("morph_tex_params");
  }
  destroy() {
    this.shadowRenderer = null, this._shadowRendererLocal = null, this._shadowRendererDirectional = null, this.shadowMapCache.destroy(), this.shadowMapCache = null, this._cookieRenderer.destroy(), this._cookieRenderer = null, this.lightTextureAtlas.destroy(), this.lightTextureAtlas = null;
  }
  sortCompare(e, t) {
    if (e.layer === t.layer) {
      if (e.drawOrder && t.drawOrder)
        return e.drawOrder - t.drawOrder;
      if (e.zdist && t.zdist)
        return t.zdist - e.zdist;
      if (e.zdist2 && t.zdist2)
        return e.zdist2 - t.zdist2;
    }
    return t._key[ci] - e._key[ci];
  }
  sortCompareMesh(e, t) {
    if (e.layer === t.layer) {
      if (e.drawOrder && t.drawOrder)
        return e.drawOrder - t.drawOrder;
      if (e.zdist && t.zdist)
        return t.zdist - e.zdist;
    }
    const s = e._key[ci], i = t._key[ci];
    return s === i && e.mesh && t.mesh ? t.mesh.id - e.mesh.id : i - s;
  }
  sortCompareDepth(e, t) {
    const s = e._key[Ed], i = t._key[Ed];
    return s === i && e.mesh && t.mesh ? t.mesh.id - e.mesh.id : i - s;
  }
  setupViewport(e, t) {
    const s = this.device, i = t ? t.width : s.width, n = t ? t.height : s.height, a = e.rect;
    let o = Math.floor(a.x * i), h = Math.floor(a.y * n), l = Math.floor(a.z * i), c = Math.floor(a.w * n);
    if (s.setViewport(o, h, l, c), e._scissorRectClear) {
      const d = e.scissorRect;
      o = Math.floor(d.x * i), h = Math.floor(d.y * n), l = Math.floor(d.z * i), c = Math.floor(d.w * n);
    }
    s.setScissor(o, h, l, c);
  }
  clear(e, t) {
    const s = (e.clearColor ? Ca : 0) | (e.clearDepth ? Aa : 0) | (e.clearStencil ? Ah : 0);
    s && this.device.clear({
      color: [t._clearColor.r, t._clearColor.g, t._clearColor.b, t._clearColor.a],
      depth: t._clearDepth,
      stencil: t._clearStencil,
      flags: s
    });
  }
  setCameraUniforms(e, t) {
    const s = t == null ? void 0 : t.flipY;
    let i = 1;
    if (e.xr && e.xr.session) {
      let o;
      const h = e._node.parent;
      h && (o = h.getWorldTransform());
      const l = e.xr.views;
      i = l.length;
      for (let c = 0; c < i; c++) {
        const d = l[c];
        h ? (d.viewInvOffMat.mul2(o, d.viewInvMat), d.viewOffMat.copy(d.viewInvOffMat).invert()) : (d.viewInvOffMat.copy(d.viewInvMat), d.viewOffMat.copy(d.viewMat)), d.viewMat3.setFromMat4(d.viewOffMat), d.projViewOffMat.mul2(d.projMat, d.viewOffMat), d.position[0] = d.viewInvOffMat.data[12], d.position[1] = d.viewInvOffMat.data[13], d.position[2] = d.viewInvOffMat.data[14], e.frustum.setFromMat4(d.projViewOffMat);
      }
    } else {
      let o = e.projectionMatrix;
      e.calculateProjection && e.calculateProjection(o, bo);
      let h = e.getProjectionMatrixSkybox();
      if (s && (o = KT.mul2(_m, o), h = ZT.mul2(_m, h)), this.device.deviceType === Et && (o = JT.mul2(gm, o), h = QT.mul2(gm, h)), this.projId.setValue(o.data), this.projSkyboxId.setValue(h.data), e.calculateTransform)
        e.calculateTransform(Pi, bo);
      else {
        const l = e._node.getPosition(), c = e._node.getRotation();
        Pi.setTRS(l, c, v.ONE);
      }
      this.viewInvId.setValue(Pi.data), Yn.copy(Pi).invert(), this.viewId.setValue(Yn.data), pm.setFromMat4(Yn), this.viewId3.setValue(pm.data), nn.mul2(o, Yn), this.viewProjId.setValue(nn.data), this.flipYId.setValue(s ? -1 : 1), this.dispatchViewPos(e._node.getPosition()), e.frustum.setFromMat4(nn);
    }
    this.tbnBasis.setValue(s ? -1 : 1);
    const n = e._nearClip, a = e._farClip;
    return this.nearClipId.setValue(n), this.farClipId.setValue(a), this.cameraParams[0] = 1 / a, this.cameraParams[1] = a, this.cameraParams[2] = n, this.cameraParams[3] = e.projection === Mr ? 1 : 0, this.cameraParamsId.setValue(this.cameraParams), this.exposureId.setValue(this.scene.physicalUnits ? e.getExposure() : this.scene.exposure), i;
  }
  setCamera(e, t, s, i = null) {
    this.setCameraUniforms(e, t), this.clearView(e, t, s, !1);
  }
  clearView(e, t, s, i) {
    const n = this.device;
    if (n.setRenderTarget(t), n.updateBegin(), i && (n.setColorWrite(!0, !0, !0, !0), n.setDepthWrite(!0)), this.setupViewport(e, t), s) {
      const a = e._clearOptions;
      n.clear(a || {
        color: [e._clearColor.r, e._clearColor.g, e._clearColor.b, e._clearColor.a],
        depth: e._clearDepth,
        flags: (e._clearColorBuffer ? Ca : 0) | (e._clearDepthBuffer ? Aa : 0) | (e._clearStencilBuffer ? Ah : 0),
        stencil: e._clearStencil
      });
    }
  }
  setCullMode(e, t, s) {
    const i = s.material;
    let n = Ft;
    if (e) {
      let a = 1;
      if (i.cull > Ft && i.cull < x_) {
        s.flipFaces && (a *= -1), t && (a *= -1);
        const o = s.node.worldTransform;
        o.getX(Ii), o.getY(Lo), o.getZ(Po), Ii.cross(Ii, Lo), Ii.dot(Po) < 0 && (a *= -1);
      }
      a < 0 ? n = i.cull === Mh ? Br : Mh : n = i.cull;
    }
    if (this.device.setCullMode(n), n === Ft && i.cull === Ft) {
      const a = s.node.worldTransform;
      a.getX(Ii), a.getY(Lo), a.getZ(Po), Ii.cross(Ii, Lo), this.twoSidedLightingNegScaleFactorId.setValue(Ii.dot(Po) < 0 ? -1 : 1);
    }
  }
  updateCameraFrustum(e) {
    if (e.xr && e.xr.views.length) {
      const s = e.xr.views[0];
      nn.mul2(s.projMat, s.viewOffMat), e.frustum.setFromMat4(nn);
      return;
    }
    const t = e.projectionMatrix;
    if (e.calculateProjection && e.calculateProjection(t, bo), e.calculateTransform)
      e.calculateTransform(Pi, bo);
    else {
      const s = e._node.getPosition(), i = e._node.getRotation();
      Pi.setTRS(s, i, v.ONE), this.viewInvId.setValue(Pi.data);
    }
    Yn.copy(Pi).invert(), nn.mul2(t, Yn), e.frustum.setFromMat4(nn);
  }
  setBaseConstants(e, t) {
    e.setCullMode(t.cull), t.opacityMap && (this.opacityMapId.setValue(t.opacityMap), this.alphaTestId.setValue(t.alphaTest));
  }
  updateCpuSkinMatrices(e) {
    vc++;
    const t = e.length;
    if (t !== 0)
      for (let s = 0; s < t; s++) {
        const i = e[s].skinInstance;
        i && (i.updateMatrices(e[s].node, vc), i._dirty = !0);
      }
  }
  updateGpuSkinMatrices(e) {
    const t = e.length;
    for (let s = 0; s < t; s++) {
      const i = e[s];
      if (i.visibleThisFrame) {
        const n = i.skinInstance;
        n && n._dirty && (n.updateMatrixPalette(i.node, vc), n._dirty = !1);
      }
    }
  }
  updateMorphing(e) {
    const t = e.length;
    for (let s = 0; s < t; s++) {
      const i = e[s], n = i.morphInstance;
      n && n._dirty && i.visibleThisFrame && n.update();
    }
  }
  gpuUpdate(e) {
    this.updateGpuSkinMatrices(e), this.updateMorphing(e);
  }
  setVertexBuffers(e, t) {
    e.setVertexBuffer(t.vertexBuffer);
  }
  setMorphing(e, t) {
    if (t)
      if (t.morph.useTextureMorph)
        e.setVertexBuffer(t.morph.vertexBufferIds), this.morphPositionTex.setValue(t.texturePositions), this.morphNormalTex.setValue(t.textureNormals), this.morphTexParams.setValue(t._textureParams);
      else {
        for (let s = 0; s < t._activeVertexBuffers.length; s++) {
          const i = t._activeVertexBuffers[s];
          if (i) {
            const n = I0 + (s + 8);
            i.format.elements[0].name = n, i.format.elements[0].scopeId = e.scope.resolve(n), i.format.update(), e.setVertexBuffer(i);
          }
        }
        this.morphWeightsA.setValue(t._shaderMorphWeightsA), this.morphWeightsB.setValue(t._shaderMorphWeightsB);
      }
  }
  setSkinning(e, t) {
    if (t.skinInstance)
      if (this._skinDrawCalls++, e.supportsBoneTextures) {
        const s = t.skinInstance.boneTexture;
        this.boneTextureId.setValue(s), ra[0] = s.width, ra[1] = s.height, ra[2] = 1 / s.width, ra[3] = 1 / s.height, this.boneTextureSizeId.setValue(ra);
      } else
        this.poseMatrixId.setValue(t.skinInstance.matrixPalette);
  }
  dispatchViewPos(e) {
    const t = this.viewPos;
    t[0] = e.x, t[1] = e.y, t[2] = e.z, this.viewPosId.setValue(t);
  }
  initViewBindGroupFormat() {
    this.device.supportsUniformBuffers && !this.viewUniformFormat && (this.viewUniformFormat = new k_(this.device, [new O_("matrix_viewProjection", Ur)]), this.viewBindGroupFormat = new z_(this.device, [new N_(Eu, D_ | pd)], [new dx("lightsTextureFloat", pd, Au, W0)]));
  }
  setupViewUniformBuffers(e, t, s, i) {
    const n = this.device;
    for (; e.length < i; ) {
      const o = new Gu(n, t), h = new Vu(n, s, o);
      e.push(h);
    }
    const a = e[0];
    a.defaultUniformBuffer.update(), a.update(), n.setBindGroup(_d, a);
  }
  setupMeshUniformBuffers(e, t) {
    const s = this.device;
    if (s.supportsUniformBuffers) {
      this.modelMatrixId.setValue(e.node.worldTransform.data), this.normalMatrixId.setValue(e.node.normalMatrix.data);
      const i = e.getBindGroup(s, t);
      i.defaultUniformBuffer.update(), i.update(), s.setBindGroup(B_, i);
    }
  }
  drawInstance(e, t, s, i, n) {
    const a = t.instancingData;
    if (a)
      a.count > 0 && (this._instancedDrawCalls++, e.setVertexBuffer(a.vertexBuffer), e.draw(s.primitive[i], a.count));
    else {
      const o = t.node.worldTransform;
      this.modelMatrixId.setValue(o.data), n && this.normalMatrixId.setValue(t.node.normalMatrix.data), e.draw(s.primitive[i]);
    }
  }
  drawInstance2(e, t, s, i) {
    const n = t.instancingData;
    n ? n.count > 0 && (this._instancedDrawCalls++, e.draw(s.primitive[i], n.count, !0)) : e.draw(s.primitive[i], void 0, !0);
  }
  cull(e, t, s) {
    let i = 0;
    const n = t.length, a = e.cullingMask || 4294967295;
    if (!e.frustumCulling) {
      for (let o = 0; o < n; o++) {
        const h = t[o];
        !h.visible && !h.command || h.mask && !(h.mask & a) || (s[i] = h, i++, h.visibleThisFrame = !0);
      }
      return i;
    }
    for (let o = 0; o < n; o++) {
      const h = t[o];
      if (h.command)
        s[i] = h, i++, h.visibleThisFrame = !0;
      else {
        if (!h.visible)
          continue;
        let l = !0;
        if (h.mask && !(h.mask & a))
          continue;
        h.cull && (l = h._isVisible(e)), l && (s[i] = h, i++, h.visibleThisFrame = !0);
      }
    }
    return i;
  }
  cullLights(e, t) {
    const s = this.scene.clusteredLightingEnabled, i = this.scene.physicalUnits;
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      if (a.enabled)
        if (a._type !== de)
          if (a.getBoundingSphere(Sc), e.frustum.containsSphere(Sc)) {
            a.visibleThisFrame = !0, a.usePhysicalUnits = i;
            const o = e.getScreenSize(Sc);
            a.maxScreenSize = Math.max(a.maxScreenSize, o);
          } else
            s || a.castShadows && !a.shadowMap && (a.visibleThisFrame = !0);
        else
          a.usePhysicalUnits = this.scene.physicalUnits;
    }
  }
  cullShadowmaps(e) {
    const t = this.scene.clusteredLightingEnabled;
    for (let i = 0; i < e._lights.length; i++) {
      const n = e._lights[i];
      if (n._type !== de && (t && n.atlasSlotUpdated && n.shadowUpdateMode === Vs && (n.shadowUpdateMode = Gr), n.visibleThisFrame && n.castShadows && n.shadowUpdateMode !== Vs)) {
        const a = e._lightCompositionData[i].shadowCastersList;
        this._shadowRendererLocal.cull(n, a);
      }
    }
    const s = e._renderActions;
    for (let i = 0; i < s.length; i++) {
      const n = s[i], a = n.directionalLightsIndices.length;
      for (let o = 0; o < a; o++) {
        const h = n.directionalLightsIndices[o], l = e._lights[h], c = e._lightCompositionData[h].shadowCastersList;
        this._shadowRendererDirectional.cull(l, c, n.camera.camera);
      }
    }
  }
  cullComposition(e) {
    const t = e._renderActions;
    for (let s = 0; s < t.length; s++) {
      const i = t[s], n = i.layerIndex, a = e.layerList[n];
      if (!a.enabled || !e.subLayerEnabled[n])
        continue;
      const o = e.subLayerList[n], h = i.cameraIndex, l = a.cameras[h];
      if (l) {
        l.frameUpdate(i.renderTarget), i.firstCameraUse && (this.updateCameraFrustum(l.camera), this._camerasRendered++), this.cullLights(l.camera, a._lights);
        const c = a.instances, d = o ? c.visibleTransparent[h] : c.visibleOpaque[h];
        if (!d.done) {
          a.onPreCull && a.onPreCull(h);
          const u = o ? a.transparentMeshInstances : a.opaqueMeshInstances;
          d.length = this.cull(l.camera, u, d.list), d.done = !0, a.onPostCull && a.onPostCull(h);
        }
      }
    }
    this.scene.clusteredLightingEnabled && this.updateLightTextureAtlas(e), this.cullShadowmaps(e);
  }
  updateShaders(e, t) {
    const s = e.length;
    for (let i = 0; i < s; i++) {
      const n = e[i].material;
      if (n && !Kn.has(n) && (Kn.add(n), n.getShaderVariant !== Ki.prototype.getShaderVariant)) {
        if (t && (!n.useLighting || n.emitter && !n.emitter.lighting))
          continue;
        n.clearVariants();
      }
    }
    Kn.clear();
  }
  renderCookies(e) {
    const t = this.lightTextureAtlas.cookieRenderTarget;
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      i.atlasViewportAllocated && i.atlasSlotUpdated && this._cookieRenderer.render(i, t);
    }
  }
  beginFrame(e, t) {
    const s = e._meshInstances, i = this.scene;
    if (i.updateShaders || t) {
      const h = !i.updateShaders && t;
      this.updateShaders(s, h), i.updateShaders = !1, i._shaderVersion++;
    }
    this.updateCpuSkinMatrices(s);
    const n = s.length;
    for (let h = 0; h < n; h++)
      s[h].visibleThisFrame = !1;
    const a = e._lights, o = a.length;
    for (let h = 0; h < o; h++)
      a[h].beginFrame();
  }
  updateLightTextureAtlas(e) {
    this.lightTextureAtlas.update(e._splitLights[Ee], e._splitLights[Se], this.scene.lighting);
  }
  updateClusters(e) {
    const t = e.getEmptyWorldClusters(this.device), s = e._renderActions;
    for (let i = 0; i < s.length; i++) {
      const n = s[i], a = n.lightClusters;
      if (a && a !== t && !Kn.has(a)) {
        Kn.add(a);
        const o = e.layerList[n.layerIndex];
        a.update(o.clusteredLightsSet, this.scene.gammaCorrection, this.scene.lighting);
      }
    }
    Kn.clear();
  }
  updateLayerComposition(e, t) {
    const s = e.layerList.length;
    for (let o = 0; o < s; o++)
      e.layerList[o]._postRenderCounter = 0;
    const i = this.scene, n = i._shaderVersion;
    for (let o = 0; o < s; o++) {
      const h = e.layerList[o];
      h._shaderVersion = n, h._preRenderCalledForCameras = 0, h._postRenderCalledForCameras = 0, e.subLayerList[o] ? h._postRenderCounter |= 2 : h._postRenderCounter |= 1, h._postRenderCounterMax = h._postRenderCounter;
      for (let c = 0; c < h.cameras.length; c++)
        h.instances.prepare(c);
      h._needsStaticPrepare && h._staticLightHash && !this.scene.clusteredLightingEnabled && (h._staticPrepareDone && (br.revert(h.opaqueMeshInstances), br.revert(h.transparentMeshInstances)), br.prepare(this.device, i, h.opaqueMeshInstances, h._lights), br.prepare(this.device, i, h.transparentMeshInstances, h._lights), e._dirty = !0, i.updateShaders = !0, h._needsStaticPrepare = !1, h._staticPrepareDone = !0);
    }
    return e._update(this.device, t);
  }
  frameUpdate() {
    this.clustersDebugRendered = !1, this.initViewBindGroupFormat();
  }
};
const ym = 2.399963229728653, ao = {
  circlePoint: function(r) {
    const e = Math.sqrt(Math.random()), t = Math.random() * 2 * Math.PI;
    r.x = e * Math.cos(t), r.y = e * Math.sin(t);
  },
  circlePointDeterministic: function(r, e, t) {
    const s = e * ym, i = Math.sqrt(e) / Math.sqrt(t);
    r.x = i * Math.cos(s), r.y = i * Math.sin(s);
  },
  spherePointDeterministic: function(r, e, t, s = 0, i = 1) {
    s = 1 - 2 * s, i = 1 - 2 * i;
    const n = U.lerp(s, i, e / t), a = Math.sqrt(1 - n * n), o = ym * e;
    r.x = Math.cos(o) * a, r.y = n, r.z = Math.sin(o) * a;
  },
  radicalInverse: function(r) {
    let e = (r << 16 | r >>> 16) >>> 0;
    return e = ((e & 1431655765) << 1 | (e & 2863311530) >>> 1) >>> 0, e = ((e & 858993459) << 2 | (e & 3435973836) >>> 2) >>> 0, e = ((e & 252645135) << 4 | (e & 4042322160) >>> 4) >>> 0, e = ((e & 16711935) << 8 | (e & 4278255360) >>> 8) >>> 0, e * 23283064365386963e-26;
  }
}, tC = {
  linear: "decodeLinear",
  srgb: "decodeGamma",
  rgbm: "decodeRGBM",
  rgbe: "decodeRGBE",
  rgbp: "decodeRGBP"
}, sC = {
  linear: "encodeLinear",
  srgb: "encodeGamma",
  rgbm: "encodeRGBM",
  rgbe: "encodeRGBE",
  rgbp: "encodeRGBP"
};
class ks {
  static decodeFunc(e) {
    return tC[e] || "decodeGamma";
  }
  static encodeFunc(e) {
    return sC[e] || "encodeGamma";
  }
}
const xm = (r) => {
  switch (r) {
    case dd:
      return "Cubemap";
    case X0:
      return "Octahedral";
    default:
      return "Equirect";
  }
}, Io = (r, e, t) => {
  if (r <= 0)
    e[t + 0] = 0, e[t + 1] = 0, e[t + 2] = 0, e[t + 3] = 0;
  else if (r >= 1)
    e[t + 0] = 255, e[t + 1] = 0, e[t + 2] = 0, e[t + 3] = 0;
  else {
    let s = 1 * r % 1, i = 255 * r % 1, n = 65025 * r % 1;
    const a = 16581375 * r % 1;
    s -= i / 255, i -= n / 255, n -= a / 255, e[t + 0] = Math.min(255, Math.floor(s * 256)), e[t + 1] = Math.min(255, Math.floor(i * 256)), e[t + 2] = Math.min(255, Math.floor(n * 256)), e[t + 3] = Math.min(255, Math.floor(a * 256));
  }
}, iC = (r) => {
  const e = r.length, t = Math.min(e, 512), s = Math.ceil(e / t), i = new Uint8Array(t * s * 4);
  let n = 0;
  for (let a = 0; a < e; a += 4)
    Io(r[a + 0] * 0.5 + 0.5, i, n + 0), Io(r[a + 1] * 0.5 + 0.5, i, n + 4), Io(r[a + 2] * 0.5 + 0.5, i, n + 8), Io(r[a + 3] / 8, i, n + 12), n += 16;
  return {
    width: t,
    height: s,
    data: i
  };
}, nC = (r, e, t, s) => {
  const i = t * 2 * Math.PI, n = Math.pow(1 - e, 1 / (s + 1)), a = Math.sqrt(1 - n * n);
  r.set(Math.cos(i) * a, Math.sin(i) * a, n).normalize();
}, rC = (r, e, t) => {
  const s = t * 2 * Math.PI, i = Math.sqrt(1 - e), n = Math.sqrt(e);
  r.set(Math.cos(s) * n, Math.sin(s) * n, i).normalize();
}, aC = (r, e, t, s) => {
  const i = t * 2 * Math.PI, n = Math.sqrt((1 - e) / (1 + (s * s - 1) * e)), a = Math.sqrt(1 - n * n);
  r.set(Math.cos(i) * a, Math.sin(i) * a, n).normalize();
}, oC = (r, e) => {
  const t = r * e, s = e / (1 - r * r + t * t);
  return s * s * (1 / Math.PI);
}, hC = (r, e) => {
  const t = new v(), s = [];
  for (let i = 0; i < r; ++i)
    nC(t, i / r, ao.radicalInverse(i), e), s.push(t.x, t.y, t.z, 0);
  return s;
}, lC = (r, e) => {
  const t = e / r, s = new v(), i = [];
  for (let n = 0; n < r; ++n) {
    rC(s, n / r, ao.radicalInverse(n));
    const a = s.z / Math.PI, o = 0.5 * Math.log2(t / a);
    i.push(s.x, s.y, s.z, o);
  }
  return i;
}, cC = {
  16: {
    2: 26,
    8: 20,
    32: 17,
    128: 16,
    512: 16
  },
  32: {
    2: 53,
    8: 40,
    32: 34,
    128: 32,
    512: 32
  },
  128: {
    2: 214,
    8: 163,
    32: 139,
    128: 130,
    512: 128
  },
  1024: {
    2: 1722,
    8: 1310,
    32: 1114,
    128: 1041,
    512: 1025
  }
}, dC = (r, e) => {
  const t = cC[r];
  return t && t[e] || r;
}, uC = (r, e, t) => {
  const s = t / r, i = 1 - Math.log2(e) / 11, n = i * i, a = new v(), o = new v(), h = new v(0, 0, 1), l = [], c = dC(r, e);
  for (let d = 0; d < c; ++d) {
    aC(a, d / c, ao.radicalInverse(d), n);
    const u = a.z;
    if (o.set(a.x, a.y, a.z).mulScalar(2 * u).sub(h), o.z > 0) {
      const f = oC(Math.min(1, u), n) / 4 + 1e-3, m = 0.5 * Math.log2(s / f);
      l.push(o.x, o.y, o.z, m);
    }
  }
  for (; l.length < r * 4; )
    l.push(0, 0, 0, 0);
  return l;
}, fC = (r, e, t) => {
  const s = iC(t);
  return new ue(r, {
    name: e,
    width: s.width,
    height: s.height,
    mipmaps: !1,
    minFilter: Be,
    magFilter: Be,
    levels: [s.data]
  });
};
class dg {
  constructor(e = !0) {
    this.map = /* @__PURE__ */ new Map(), this.destroyContent = e;
  }
  destroy() {
    this.destroyContent && this.map.forEach((e, t) => {
      e.destroy();
    });
  }
  get(e, t) {
    if (!this.map.has(e)) {
      const s = t();
      return this.map.set(e, s), s;
    }
    return this.map.get(e);
  }
}
const mC = new dg(!1), pC = new Ji(), Hu = (r, e, t) => pC.get(r, () => new dg()).get(e, () => fC(r, e, mC.get(e, t))), _C = (r, e, t) => {
  const s = `lambert-samples-${e}-${t}`;
  return Hu(r, s, () => lC(e, t));
}, gC = (r, e, t) => {
  const s = `phong-samples-${e}-${t}`;
  return Hu(r, s, () => hC(e, t));
}, yC = (r, e, t, s) => {
  const i = `ggx-samples-${e}-${t}-${s}`;
  return Hu(r, i, () => uC(e, t, s));
}, xC = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;
function Ks(r, e, t = {}) {
  var s;
  r instanceof Ru && (r = arguments[1], e = arguments[2], t = {}, arguments[3] !== void 0 && (t.specularPower = arguments[3]), arguments[4] !== void 0 && (t.numSamples = arguments[4]));
  const i = {
    none: "reproject",
    lambert: "prefilterSamplesUnweighted",
    phong: "prefilterSamplesUnweighted",
    ggx: "prefilterSamples"
  }, n = t.hasOwnProperty("specularPower") ? t.specularPower : 1, a = t.hasOwnProperty("face") ? t.face : null, o = t.hasOwnProperty("distribution") ? t.distribution : n === 1 ? "none" : "phong", h = i[o] || "reproject", l = h.startsWith("prefilterSamples"), c = ks.decodeFunc(r.encoding), d = ks.encodeFunc(e.encoding), u = `sample${xm(r.projection)}`, f = `getDirection${xm(e.projection)}`, m = t.hasOwnProperty("numSamples") ? t.numSamples : 1024, _ = `${h}_${c}_${d}_${u}_${f}_${m}`, p = r.device;
  let g = Vn(p).getCachedShader(_);
  if (!g) {
    const T = `#define PROCESS_FUNC ${h}
` + (l ? `#define USE_SAMPLES_TEX
` : "") + (r.cubemap ? `#define CUBEMAP_SOURCE
` : "") + `#define DECODE_FUNC ${c}
#define ENCODE_FUNC ${d}
#define SOURCE_FUNC ${u}
#define TARGET_FUNC ${f}
#define NUM_SAMPLES ${m}
#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(m)).toFixed(1)}
`;
    g = ps(p, xC, `${T}
${N.reprojectPS}`, _);
  }
  p.scope.resolve(r.cubemap ? "sourceCube" : "sourceTex").setValue(r);
  const x = p.scope.resolve("params"), y = p.scope.resolve("params2"), S = p.scope.resolve("uvMod");
  if ((s = t) != null && s.seamPixels) {
    const T = t.seamPixels, A = t.rect ? t.rect.z : e.width, L = t.rect ? t.rect.w : e.height, O = A - T * 2, I = L - T * 2;
    S.setValue([(O + T * 2) / O, (I + T * 2) / I, -T / O, -T / I]);
  } else
    S.setValue([1, 1, 0, 0]);
  const C = [0, n, r.fixCubemapSeams ? 1 / r.width : 0, e.fixCubemapSeams ? 1 / e.width : 0], w = [e.width * e.height * (e.cubemap ? 6 : 1), r.width * r.height * (r.cubemap ? 6 : 1)];
  if (l) {
    const T = r.width * r.height * (r.cubemap ? 6 : 1), A = o === "ggx" ? yC(p, m, n, T) : o === "lambert" ? _C(p, m, T) : gC(p, m, n);
    p.scope.resolve("samplesTex").setValue(A), p.scope.resolve("samplesTexInverseSize").setValue([1 / A.width, 1 / A.height]);
  }
  for (let T = 0; T < (e.cubemap ? 6 : 1); T++)
    if (a === null || T === a) {
      var M;
      const A = new Dt({
        colorBuffer: e,
        face: T,
        depth: !1
      });
      C[0] = T, x.setValue(C), y.setValue(w), Yi(p, A, g, (M = t) == null ? void 0 : M.rect), A.destroy();
    }
}
const vC = !0, Id = _i, bc = (r, e = 0) => 1 + Math.floor(Math.log2(Math.max(r, e))), SC = (r) => r.extTextureHalfFloat && r.textureHalfFloatRenderable, bC = (r) => r.extTextureFloat && r.textureFloatRenderable, wC = (r) => SC(r) ? Pt : bC(r) ? vt : ye, TC = (r) => ye, CC = (r, e, t, s) => new ue(r, {
  name: `lighting-${e}`,
  cubemap: !0,
  width: e,
  height: e,
  format: t,
  type: t === ye ? Id : Rs,
  addressU: he,
  addressV: he,
  fixCubemapSeams: vC,
  mipmaps: !!s
});
class ug {
  static generateSkyboxCubemap(e, t) {
    const s = e.device, i = CC(s, t || (e.cubemap ? e.width : e.width / 4), ye, !1);
    return Ks(e, i, {
      numSamples: 1024
    }), i;
  }
  static generateLightingSource(e, t) {
    const s = e.device, i = wC(s), n = (t == null ? void 0 : t.target) || new ue(s, {
      name: "lighting-source",
      cubemap: !0,
      width: (t == null ? void 0 : t.size) || 128,
      height: (t == null ? void 0 : t.size) || 128,
      format: i,
      type: i === ye ? Id : Rs,
      addressU: he,
      addressV: he,
      fixCubemapSeams: !1,
      mipmaps: !0
    });
    return Ks(e, n, {
      numSamples: e.mipmaps ? 1 : 1024
    }), n;
  }
  static generateAtlas(e, t) {
    const s = e.device, i = TC(), n = (t == null ? void 0 : t.target) || new ue(s, {
      name: "envAtlas",
      width: (t == null ? void 0 : t.size) || 512,
      height: (t == null ? void 0 : t.size) || 512,
      format: i,
      type: Id,
      projection: Rf,
      addressU: he,
      addressV: he,
      mipmaps: !1
    }), a = n.width / 512, o = new Z(0, 0, 512 * a, 256 * a), h = bc(256) - bc(4);
    for (let l = 0; l < h; ++l)
      Ks(e, n, {
        numSamples: 1,
        rect: o,
        seamPixels: a
      }), o.x += o.w, o.y += o.w, o.z = Math.max(1, Math.floor(o.z * 0.5)), o.w = Math.max(1, Math.floor(o.w * 0.5));
    o.set(0, 256 * a, 256 * a, 128 * a);
    for (let l = 1; l < 7; ++l)
      Ks(e, n, {
        numSamples: (t == null ? void 0 : t.numReflectionSamples) || 1024,
        distribution: (t == null ? void 0 : t.distribution) || "ggx",
        specularPower: Math.max(1, 2048 >> l * 2),
        rect: o,
        seamPixels: a
      }), o.y += o.w, o.z = Math.max(1, Math.floor(o.z * 0.5)), o.w = Math.max(1, Math.floor(o.w * 0.5));
    return o.set(128 * a, (256 + 128) * a, 64 * a, 32 * a), Ks(e, n, {
      numSamples: (t == null ? void 0 : t.numAmbientSamples) || 2048,
      distribution: "lambert",
      rect: o,
      seamPixels: a
    }), n;
  }
  static generatePrefilteredAtlas(e, t) {
    const s = e[0].device, i = e[0].format, n = e[0].type, a = (t == null ? void 0 : t.target) || new ue(s, {
      name: "envPrefilteredAtlas",
      width: (t == null ? void 0 : t.size) || 512,
      height: (t == null ? void 0 : t.size) || 512,
      format: i,
      type: n,
      projection: Rf,
      addressU: he,
      addressV: he,
      mipmaps: !1
    }), o = a.width / 512, h = new Z(0, 0, 512 * o, 256 * o), l = bc(512);
    for (let c = 0; c < l; ++c)
      Ks(e[0], a, {
        numSamples: 1,
        rect: h,
        seamPixels: o
      }), h.x += h.w, h.y += h.w, h.z = Math.max(1, Math.floor(h.z * 0.5)), h.w = Math.max(1, Math.floor(h.w * 0.5));
    h.set(0, 256 * o, 256 * o, 128 * o);
    for (let c = 1; c < e.length; ++c)
      Ks(e[c], a, {
        numSamples: 1,
        rect: h,
        seamPixels: o
      }), h.y += h.w, h.z = Math.max(1, Math.floor(h.z * 0.5)), h.w = Math.max(1, Math.floor(h.w * 0.5));
    return h.set(128 * o, (256 + 128) * o, 64 * o, 32 * o), t != null && t.legacyAmbient ? Ks(e[5], a, {
      numSamples: 1,
      rect: h,
      seamPixels: o
    }) : Ks(e[0], a, {
      numSamples: (t == null ? void 0 : t.numSamples) || 2048,
      distribution: "lambert",
      rect: h,
      seamPixels: o
    }), a;
  }
}
const wc = {
  vertex_normal: Gt,
  vertex_tangent: qs,
  vertex_texCoord0: rs,
  vertex_texCoord1: Zi,
  vertex_color: It,
  vertex_boneWeights: Xs,
  vertex_boneIndices: ts
}, vm = {
  vVertexColor: "vec4",
  vPositionW: "vec3",
  vNormalV: "vec3",
  vNormalW: "vec3",
  vTangentW: "vec3",
  vBinormalW: "vec3",
  vObjectSpaceUpW: "vec3",
  vUv0: "vec2",
  vUv1: "vec2"
};
class AC {
  constructor(e, t) {
    if (this.device = e, this.options = t, this.attributes = {
      vertex_position: et
    }, t.chunks) {
      this.chunks = {};
      const s = t.chunks;
      for (const i in N)
        if (s.hasOwnProperty(i)) {
          const n = s[i];
          for (const a in wc)
            wc.hasOwnProperty(a) && n.indexOf(a) >= 0 && (this.attributes[a] = wc[a]);
          this.chunks[i] = n;
        } else
          this.chunks[i] = N[i];
    } else
      this.chunks = N;
    this.lighting = t.lights.length > 0 || t.dirLightMapEnabled || t.clusteredLightingEnabled, this.reflections = !!t.reflectionSource, this.shadowPass = Ut.isShadow(t.pass), this.needsNormal = this.lighting || this.reflections || t.useSpecular || t.ambientSH || t.heightMapEnabled || t.enableGGXSpecular || t.clusteredLightingEnabled && !this.shadowPass || t.clearCoatNormalMapEnabled, this.needsNormal = this.needsNormal && !this.shadowPass, this.needsSceneColor = t.useDynamicRefraction, this.needsScreenSize = t.useDynamicRefraction, this.needsTransforms = t.useDynamicRefraction, this.varyings = "", this.vshader = null, this.frontendDecl = null, this.frontendCode = null, this.frontendFunc = null, this.lightingUv = null, this.defines = [], this.fshader = null;
  }
  _vsAddBaseCode(e, t, s) {
    return e += t.baseVS, (s.nineSlicedMode === ht || s.nineSlicedMode === it) && (e += t.baseNineSlicedVS), e;
  }
  _vsAddTransformCode(e, t, s, i) {
    return e += this.chunks.transformVS, e;
  }
  _setMapTransform(e, t, s, i) {
    const n = s + i * 100;
    if (!e[3][n]) {
      const a = `texture_${t}MapTransform`;
      e[0] += `uniform vec3 ${a}0;
`, e[0] += `uniform vec3 ${a}1;
`, e[1] += `varying vec2 vUV${i}_${s};
`, e[2] += `   vUV${i}_${s} = vec2(dot(vec3(uv${i}, 1), ${a}0), dot(vec3(uv${i}, 1), ${a}1));
`, e[3][n] = !0;
    }
    return e;
  }
  _fsGetBaseCode() {
    const e = this.options, t = this.chunks;
    let s = this.chunks.basePS;
    return e.nineSlicedMode === ht ? s += t.baseNineSlicedPS : e.nineSlicedMode === it && (s += t.baseNineSlicedTiledPS), s;
  }
  _fsGetStartCode(e, t, s, i) {
    let n = s.startPS;
    return i.nineSlicedMode === ht ? n += s.startNineSlicedPS : i.nineSlicedMode === it && (n += s.startNineSlicedTiledPS), n;
  }
  _directionalShadowMapProjection(e, t, s, i, n) {
    let a = "";
    return e.numCascades > 1 && (a += `getShadowCascadeMatrix(light${i}_shadowMatrixPalette, light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount);
`, t = `(cascadeShadowMat, ${s});
`), a += n + t, a += `fadeShadow(light${i}_shadowCascadeDistances);
`, a;
  }
  _nonPointShadowMapProjection(e, t, s, i, n) {
    const a = `(${s}, ${i});
`;
    return !t._normalOffsetBias || t._isVsm ? t._type === Ee ? t._isPcf && (e.webgl2 || e.extStandardDerivatives || e.deviceType === Et) ? "       getShadowCoordPerspZbuffer" + a : "       getShadowCoordPersp" + a : this._directionalShadowMapProjection(t, a, i, n, "getShadowCoordOrtho") : t._type === Ee ? t._isPcf && (e.webgl2 || e.extStandardDerivatives || e.deviceType === Et) ? "       getShadowCoordPerspZbufferNormalOffset" + a : "       getShadowCoordPerspNormalOffset" + a : this._directionalShadowMapProjection(t, a, i, n, "getShadowCoordOrthoNormalOffset");
  }
  _getLightSourceShapeString(e) {
    switch (e) {
      case lv:
        return "Rect";
      case cv:
        return "Disk";
      case dv:
        return "Sphere";
      default:
        return "";
    }
  }
  generateVertexShader(e, t, s) {
    const i = this.device, n = this.options, a = this.chunks;
    let o = "", h = "";
    o = this._vsAddBaseCode(o, a, n), h += `   vPositionW    = getWorldPosition();
`, this.options.pass === As && (o += `varying float vDepth;
`, o += `#ifndef VIEWMATRIX
`, o += `#define VIEWMATRIX
`, o += `uniform mat4 matrix_view;
`, o += `#endif
`, o += `#ifndef CAMERAPLANES
`, o += `#define CAMERAPLANES
`, o += `uniform vec4 camera_params;

`, o += `#endif
`, h += `    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;
`), this.options.useInstancing && (this.attributes.instance_line1 = Ma, this.attributes.instance_line2 = Ea, this.attributes.instance_line3 = Ra, this.attributes.instance_line4 = bn, o += a.instancingVS), this.needsNormal && (this.attributes.vertex_normal = Gt, h += `   vNormalW = getNormal();
`, n.reflectionSource === "sphereMap" && i.fragmentUniformsCount <= 16 && (o += a.viewNormalVS, h += `   vNormalV    = getViewNormal();
`), n.hasTangents && (n.heightMapEnabled || n.normalMapEnabled || n.enableGGXSpecular) ? (this.attributes.vertex_tangent = qs, o += a.tangentBinormalVS, h += `   vTangentW   = getTangent();
`, h += `   vBinormalW  = getBinormal();
`) : (n.enableGGXSpecular || !i.extStandardDerivatives) && (o += a.tangentBinormalVS, h += `   vObjectSpaceUpW  = getObjectSpaceUp();
`));
    const l = 2;
    for (let u = 0; u < l; u++)
      e[u] && (this.attributes["vertex_texCoord" + u] = "TEXCOORD" + u, o += a["uv" + u + "VS"], h += "   vec2 uv" + u + " = getUv" + u + `();
`), t[u] && (h += "   vUv" + u + " = uv" + u + `;
`);
    const c = [o, this.varyings, h, []];
    s.forEach((u) => {
      this._setMapTransform(c, u.name, u.id, u.uv);
    }), o = c[0], this.varyings = c[1], h = c[2], n.vertexColors && (this.attributes.vertex_color = It, h += `   vVertexColor = vertex_color;
`), n.useMsdf && n.msdfTextAttribute && (this.attributes.vertex_outlineParameters = En, this.attributes.vertex_shadowParameters = Rn, h += `    unpackMsdfParams();
`, o += a.msdfVS), (n.useMorphPosition || n.useMorphNormal) && (n.useMorphTextureBased ? (o += `#define MORPHING_TEXTURE_BASED
`, n.useMorphPosition && (o += `#define MORPHING_TEXTURE_BASED_POSITION
`), n.useMorphNormal && (o += `#define MORPHING_TEXTURE_BASED_NORMAL
`), this.attributes.morph_vertex_id = bn, o += `attribute float morph_vertex_id;
`) : (o += `#define MORPHING
`, n.useMorphPosition ? (this.attributes.morph_pos0 = En, this.attributes.morph_pos1 = Rn, this.attributes.morph_pos2 = ld, this.attributes.morph_pos3 = cd, o += `#define MORPHING_POS03
`, o += `attribute vec3 morph_pos0;
`, o += `attribute vec3 morph_pos1;
`, o += `attribute vec3 morph_pos2;
`, o += `attribute vec3 morph_pos3;
`) : n.useMorphNormal && (this.attributes.morph_nrm0 = En, this.attributes.morph_nrm1 = Rn, this.attributes.morph_nrm2 = ld, this.attributes.morph_nrm3 = cd, o += `#define MORPHING_NRM03
`, o += `attribute vec3 morph_nrm0;
`, o += `attribute vec3 morph_nrm1;
`, o += `attribute vec3 morph_nrm2;
`, o += `attribute vec3 morph_nrm3;
`), n.useMorphNormal ? (this.attributes.morph_nrm4 = Ma, this.attributes.morph_nrm5 = Ea, this.attributes.morph_nrm6 = Ra, this.attributes.morph_nrm7 = bn, o += `#define MORPHING_NRM47
`, o += `attribute vec3 morph_nrm4;
`, o += `attribute vec3 morph_nrm5;
`, o += `attribute vec3 morph_nrm6;
`, o += `attribute vec3 morph_nrm7;
`) : (this.attributes.morph_pos4 = Ma, this.attributes.morph_pos5 = Ea, this.attributes.morph_pos6 = Ra, this.attributes.morph_pos7 = bn, o += `#define MORPHING_POS47
`, o += `attribute vec3 morph_pos4;
`, o += `attribute vec3 morph_pos5;
`, o += `attribute vec3 morph_pos6;
`, o += `attribute vec3 morph_pos7;
`))), n.skin ? (this.attributes.vertex_boneWeights = Xs, this.attributes.vertex_boneIndices = ts, o += hg(i, a), o += `#define SKIN
`) : n.useInstancing && (o += `#define INSTANCING
`), n.screenSpace && (o += `#define SCREENSPACE
`), n.pixelSnap && (o += `#define PIXELSNAP
`), o = this._vsAddTransformCode(o, i, a, n), this.needsNormal && (o += a.normalVS), o += `
`, o += a.startVS, o += h, o += a.endVS, o += "}", Object.keys(vm).forEach((u) => {
      o.indexOf(u) >= 0 && (this.varyings += `varying ${vm[u]} ${u};
`);
    });
    const d = Ut.getPassShaderDefine(this.options.pass);
    this.vshader = d + this.varyings + o;
  }
  _fsGetBeginCode() {
    let e = Ut.getPassShaderDefine(this.options.pass);
    for (let t = 0; t < this.defines.length; t++)
      e += `#define ${this.defines[t]}
`;
    return e;
  }
  _fsGetPickPassCode() {
    let e = this._fsGetBeginCode();
    return e += `uniform vec4 uColor;
`, e += this.varyings, e += this.frontendDecl, e += this.frontendCode, e += Fa(), e += this.frontendFunc, e += `    gl_FragColor = uColor;
`, e += Sr(), e;
  }
  _fsGetDepthPassCode() {
    const e = this.chunks;
    let t = this._fsGetBeginCode();
    return t += `varying float vDepth;
`, t += this.varyings, t += e.packDepthPS, t += this.frontendDecl, t += this.frontendCode, t += Fa(), t += this.frontendFunc, t += `    gl_FragColor = packFloat(vDepth);
`, t += Sr(), t;
  }
  _fsGetShadowPassCode() {
    const e = this.device, t = this.options, s = this.chunks, i = this.varyings, n = Ut.toLightType(t.pass), a = Ut.toShadowType(t.pass);
    let o = this._fsGetBeginCode();
    e.extStandardDerivatives && !e.webgl2 && e.deviceType !== Et && (o += `uniform vec2 polygonOffset;
`), a === zs ? e.textureFloatHighPrecision ? o += `#define VSM_EXPONENT 15.0

` : o += `#define VSM_EXPONENT 5.54

` : a === li && (o += `#define VSM_EXPONENT 5.54

`), n !== de && (o += `uniform vec3 view_position;
`, o += `uniform float light_radius;
`), o += i, o += this.frontendDecl, o += this.frontendCode, a === gt && (!e.webgl2 || e.deviceType !== Et || n === Se) ? o += s.packDepthPS : a === Os && (o += `vec2 encodeFloatRG( float v ) {
`, o += `    vec2 enc = vec2(1.0, 255.0) * v;
`, o += `    enc = fract(enc);
`, o += `    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
`, o += `    return enc;
`, o += `}

`), o += Fa(), o += this.frontendFunc;
    const h = a === Os || a === li || a === zs, l = !e.webgl2 && e.extStandardDerivatives && e.deviceType !== Et;
    return n === Se || h && n !== de ? o += `    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
` : o += `    float depth = gl_FragCoord.z;
`, l && (o += `    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);
`, o += `    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;
`), a === gt && (!e.webgl2 || n === Se && !t.clusteredLightingEnabled) ? o += `    gl_FragColor = packFloat(depth);
` : a === gt || a === Us ? (o += `    gl_FragColor = vec4(1.0);
`, t.clusteredLightingEnabled && n === Se && e.webgl2 && (o += `    gl_FragDepth = depth;
`)) : a === Os ? o += `    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));
` : o += s.storeEVSMPS, o += Sr(), o;
  }
  _fsGetLitPassCode() {
    const e = this.device, t = this.options, s = this.chunks;
    let i = "";
    t.opacityFadesSpecular === !1 && (i += `uniform float material_alphaFade;
`), t.useSpecular && (this.defines.push("LIT_SPECULAR"), this.reflections && this.defines.push("LIT_REFLECTIONS"), t.useClearCoat && this.defines.push("LIT_CLEARCOAT"), t.fresnelModel > 0 && this.defines.push("LIT_SPECULAR_FRESNEL"), t.conserveEnergy && this.defines.push("LIT_CONSERVE_ENERGY"), t.useSheen && this.defines.push("LIT_SHEEN"), t.useIridescence && this.defines.push("LIT_IRIDESCENCE"));
    const n = [];
    let a = 0, o = !1, h = !1, l = !1, c = t.lights.some(function(T) {
      return T._shape && T._shape !== Mt;
    });
    t.clusteredLightingEnabled && t.clusteredLightingAreaLightsEnabled && (c = !0);
    let d = "highp";
    e.areaLightLutFormat === ye && (i += `#define AREA_R8_G8_B8_A8_LUTS
`, d = "lowp"), (c || t.clusteredLightingEnabled) && (i += `#define AREA_LIGHTS
`, i += `uniform ${d} sampler2D areaLightsLutTex1;
`, i += `uniform ${d} sampler2D areaLightsLutTex2;
`);
    for (let T = 0; T < t.lights.length; T++) {
      const A = t.lights[T], L = A._type;
      if (t.clusteredLightingEnabled && L !== de)
        continue;
      const O = c && A._shape ? A._shape : Mt;
      i += "uniform vec3 light" + T + `_color;
`, L === de ? i += "uniform vec3 light" + T + `_direction;
` : (i += "uniform vec3 light" + T + `_position;
`, i += "uniform float light" + T + `_radius;
`, L === Ee && (i += "uniform vec3 light" + T + `_direction;
`, i += "uniform float light" + T + `_innerConeAngle;
`, i += "uniform float light" + T + `_outerConeAngle;
`)), O !== Mt && (L === de && (i += "uniform vec3 light" + T + `_position;
`), i += "uniform vec3 light" + T + `_halfWidth;
`, i += "uniform vec3 light" + T + `_halfHeight;
`), A.castShadows && !t.noShadow && (i += "uniform mat4 light" + T + `_shadowMatrix;
`, i += "uniform float light" + T + `_shadowIntensity;
`, L === de && (i += "uniform mat4 light" + T + `_shadowMatrixPalette[4];
`, i += "uniform float light" + T + `_shadowCascadeDistances[4];
`, i += "uniform float light" + T + `_shadowCascadeCount;
`), L !== de ? i += "uniform vec4 light" + T + `_shadowParams;
` : (o = !0, i += "uniform vec3 light" + T + `_shadowParams;
`), L === Se ? i += "uniform samplerCube light" + T + `_shadowMap;
` : A._isPcf && e.supportsDepthShadow ? i += "uniform sampler2DShadow light" + T + `_shadowMap;
` : i += "uniform sampler2D light" + T + `_shadowMap;
`, a++, n[A._shadowType] = !0, A._isVsm && (h = !0), A._isPcf && (e.supportsDepthShadow || e.extStandardDerivatives) && L === Ee && (l = !0)), A._cookie && (A._cookie._cubemap ? L === Se && (i += "uniform samplerCube light" + T + `_cookie;
`, i += "uniform float light" + T + `_cookieIntensity;
`, (!A.castShadows || t.noShadow) && (i += "uniform mat4 light" + T + `_shadowMatrix;
`)) : L === Ee && (i += "uniform sampler2D light" + T + `_cookie;
`, i += "uniform float light" + T + `_cookieIntensity;
`, (!A.castShadows || t.noShadow) && (i += "uniform mat4 light" + T + `_shadowMatrix;
`), A._cookieTransform && (i += "uniform vec4 light" + T + `_cookieMatrix;
`, i += "uniform vec2 light" + T + `_cookieOffset;
`)));
    }
    i += `
`;
    const u = this.needsNormal && (t.normalMapEnabled || t.clearCoatNormalMapEnabled || t.enableGGXSpecular && !t.heightMapEnabled);
    u && (t.hasTangents ? i += t.fastTbn ? s.TBNfastPS : s.TBNPS : e.extStandardDerivatives && (t.normalMapEnabled || t.clearCoatNormalMapEnabled) ? i += s.TBNderivativePS.replace(/\$UV/g, this.lightingUv) : i += s.TBNObjectSpacePS), i += s.sphericalPS, i += s.decodePS, i += Yh(t.gamma, s), i += Kh(t.toneMap, s), i += og(t.fog, s), i += this.frontendCode, t.useCubeMapRotation && (i += `#define CUBEMAP_ROTATION
`), this.needsNormal && (i += s.cubeMapRotatePS, i += t.cubeMapProjection > 0 ? s.cubeMapProjectBoxPS : s.cubeMapProjectNonePS, i += t.skyboxIntensity ? s.envMultiplyPS : s.envConstPS), (this.lighting && t.useSpecular || this.reflections) && (t.useMetalness && (i += s.metalnessModulatePS), t.fresnelModel === Lu && (i += s.fresnelSchlickPS), t.useIridescence && (i += s.iridescenceDiffractionPS));
    const f = t.aoMapEnabled || t.useAoVertexColors;
    if (f)
      switch (i += s.aoDiffuseOccPS, t.occludeSpecular) {
        case ja:
          i += t.occludeSpecularFloat ? s.aoSpecOccSimplePS : s.aoSpecOccConstSimplePS;
          break;
        case Ad:
          i += t.occludeSpecularFloat ? s.aoSpecOccPS : s.aoSpecOccConstPS;
          break;
      }
    if (t.reflectionSource === "envAtlasHQ")
      i += t.fixSeams ? s.fixCubemapSeamsStretchPS : s.fixCubemapSeamsNonePS, i += s.envAtlasPS, i += s.reflectionEnvHQPS.replace(/\$DECODE/g, ks.decodeFunc(t.reflectionEncoding));
    else if (t.reflectionSource === "envAtlas")
      i += s.envAtlasPS, i += s.reflectionEnvPS.replace(/\$DECODE/g, ks.decodeFunc(t.reflectionEncoding));
    else if (t.reflectionSource === "cubeMap")
      i += t.fixSeams ? s.fixCubemapSeamsStretchPS : s.fixCubemapSeamsNonePS, i += s.reflectionCubePS.replace(/\$DECODE/g, ks.decodeFunc(t.reflectionEncoding));
    else if (t.reflectionSource === "sphereMap") {
      const T = e.fragmentUniformsCount > 16 ? s.reflectionSpherePS : s.reflectionSphereLowPS;
      i += T.replace(/\$DECODE/g, ks.decodeFunc(t.reflectionEncoding));
    }
    this.reflections && (t.useClearCoat && (i += s.reflectionCCPS), t.useSheen && (i += s.reflectionSheenPS)), t.useRefraction && (t.useDynamicRefraction ? i += s.refractionDynamicPS : this.reflections && (i += s.refractionCubePS)), t.useSheen && (i += s.lightSheenPS), t.clusteredLightingEnabled && (i += s.clusteredLightUtilsPS, t.clusteredLightingCookiesEnabled && (i += s.clusteredLightCookiesPS), t.clusteredLightingShadowsEnabled && !t.noShadow && (n[gt] = !0, n[Us] = !0), l = !0), (a > 0 || t.clusteredLightingEnabled) && (o && (i += s.shadowCascadesPS), n[gt] && (i += s.shadowStandardPS), n[Us] && (e.webgl2 || e.deviceType === Et) && (i += s.shadowStandardGL2PS), h && (i += s.shadowVSM_commonPS, n[Os] && (i += s.shadowVSM8PS), n[li] && (i += e.extTextureHalfFloatLinear ? s.shadowEVSMPS.replace(/\$/g, "16") : s.shadowEVSMnPS.replace(/\$/g, "16")), n[zs] && (i += e.extTextureFloatLinear ? s.shadowEVSMPS.replace(/\$/g, "32") : s.shadowEVSMnPS.replace(/\$/g, "32"))), e.webgl2 || e.extStandardDerivatives || e.deviceType === Et || (i += s.biasConstPS), i += s.shadowCoordPS + s.shadowCommonPS, l && (i += s.shadowCoordPerspZbufferPS)), t.enableGGXSpecular && (i += `uniform float material_anisotropy;
`), this.lighting && (i += s.lightDiffuseLambertPS, (c || t.clusteredLightingAreaLightsEnabled) && (i += s.ltcPS)), i += `
`;
    let m = !1;
    t.useSpecular && (this.lighting && (i += t.shadingModel === Hs ? s.lightSpecularPhongPS : t.enableGGXSpecular ? s.lightSpecularAnisoGGXPS : s.lightSpecularBlinnPS), !t.fresnelModel && !this.reflections && !t.diffuseMapEnabled && (i += `    uniform vec3 material_ambient;
`, i += "#define LIT_OLD_AMBIENT", m = !0)), i += s.combinePS, (t.lightMapEnabled || t.useLightMapVertexColors) && (i += t.useSpecular && t.dirLightMapEnabled ? s.lightmapDirAddPS : s.lightmapAddPS);
    const _ = !t.lightMapEnabled && !t.useLightMapVertexColors || t.lightMapWithoutAmbient;
    _ && (t.ambientSource === "ambientSH" ? i += s.ambientSHPS : t.ambientSource === "envAtlas" ? (t.reflectionSource !== "envAtlas" && t.reflectionSource !== "envAtlasHQ" && (i += s.envAtlasPS), i += s.ambientEnvPS.replace(/\$DECODE/g, ks.decodeFunc(t.ambientEncoding))) : i += s.ambientConstantPS), t.useAmbientTint && !m && (i += `uniform vec3 material_ambient;
`), t.useMsdf && (t.msdfTextAttribute || (i += `
#define UNIFORM_TEXT_PARAMETERS`), i += s.msdfPS), this.needsNormal && (i += s.viewDirPS, t.useSpecular && (i += t.enableGGXSpecular ? s.reflDirAnisoPS : s.reflDirPS));
    let p = !1, g = !1, b = !1, x = !1, y = !1, S;
    if (t.clusteredLightingEnabled && this.lighting && (x = !0, p = !0, g = !0, y = !0, i += s.floatUnpackingPS, t.lightMaskDynamic && (i += `
#define CLUSTER_MESH_DYNAMIC_LIGHTS`), t.clusteredLightingCookiesEnabled && (i += `
#define CLUSTER_COOKIES`), t.clusteredLightingShadowsEnabled && !t.noShadow && (i += `
#define CLUSTER_SHADOWS`, i += `
#define CLUSTER_SHADOW_TYPE_` + zn[t.clusteredLightingShadowType]), t.clusteredLightingAreaLightsEnabled && (i += `
#define CLUSTER_AREALIGHTS`), i += ke.shaderDefines, t.clusteredLightingShadowsEnabled && !t.noShadow && (i += s.clusteredLightShadowsPS), i += s.clusteredLightPS), t.twoSidedLighting && (i += `uniform float twoSidedLightingNegScaleFactor;
`), i += this._fsGetStartCode(i, e, s, t), this.needsNormal && (t.twoSidedLighting ? i += `    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);
` : i += `    dVertexNormalW = normalize(vNormalW);
`, (t.heightMapEnabled || t.normalMapEnabled) && t.hasTangents && (t.twoSidedLighting ? (i += `    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;
`, i += `    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;
`) : (i += `    dTangentW = vTangentW;
`, i += `    dBinormalW = vBinormalW;
`)), i += `    getViewDir();
`, u && (i += `    getTBN();
`)), i += this.frontendFunc, this.needsNormal && (t.useSpecular && (i += `    getReflDir();
`), t.useClearCoat && (i += `    ccReflDirW = normalize(-reflect(dViewDirW, ccNormalW));
`)), (this.lighting && t.useSpecular || this.reflections) && (t.useMetalness && (i += `    getMetalnessModulate();
`), t.useIridescence && (i += `    getIridescence(saturate(dot(dViewDirW, dNormalW)));
`)), _ && (i += `    addAmbient();
`, t.conserveEnergy && t.useSpecular && (i += "   dDiffuseLight = dDiffuseLight * (1.0 - dSpecularity);"), t.separateAmbient && (i += `
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`)), t.useAmbientTint && !m && (i += `    dDiffuseLight *= material_ambient;
`), f && !t.occludeDirect && (i += `    occludeDiffuse();
`), (t.lightMapEnabled || t.useLightMapVertexColors) && (i += `    addLightMap();
`), this.lighting || this.reflections) {
      this.reflections && (t.useClearCoat && (i += `    addReflectionCC();
`, t.fresnelModel > 0 ? (i += `    ccFresnel = getFresnelCC(dot(dViewDirW, ccNormalW));
`, i += `    ccReflection.rgb *= ccFresnel;
`) : i += `    ccFresnel = 0.0;
`), t.useSpecularityFactor && (i += `    ccReflection.rgb *= dSpecularityFactor;
`), t.useSheen && (i += `    addReflectionSheen();
`), i += `    addReflection();
`, t.fresnelModel > 0 ? i += `    dReflection.rgb *= getFresnel(dot(dViewDirW, dNormalW), dSpecularity);
` : i += `    dReflection.rgb *= dSpecularity;
`, t.useSpecularityFactor && (i += `    dReflection.rgb *= dSpecularityFactor;
`)), c && (i += `    dSpecularLight *= dSpecularity;
`, t.useSpecular && (i += `    calcLTCLightValues();
`));
      for (let T = 0; T < t.lights.length; T++) {
        const A = t.lights[T], L = A._type;
        if (t.clusteredLightingEnabled && L !== de)
          continue;
        S = !1;
        const O = c && A._shape ? A.shape : Mt, I = c && A._shape ? this._getLightSourceShapeString(O) : "";
        if (O !== Mt && (i += "    calc" + I + "LightValues(light" + T + "_position, light" + T + "_halfWidth, light" + T + `_halfHeight);
`), L === de ? (i += "    dLightDirNormW = light" + T + `_direction;
`, i += `    dAtten = 1.0;
`) : (A._cookie && (L === Ee && !A._cookie._cubemap || L === Se && A._cookie._cubemap) && (y = !0, S = !0), i += "    getLightDirPoint(light" + T + `_position);
`, p = !0, S && (L === Ee ? i += "    dAtten3 = getCookie2D" + (A._cookieFalloff ? "" : "Clip") + (A._cookieTransform ? "Xform" : "") + "(light" + T + "_cookie, light" + T + "_shadowMatrix, light" + T + "_cookieIntensity" + (A._cookieTransform ? ", light" + T + "_cookieMatrix, light" + T + "_cookieOffset" : "") + ")." + A._cookieChannel + `;
` : i += "    dAtten3 = getCookieCube(light" + T + "_cookie, light" + T + "_shadowMatrix, light" + T + "_cookieIntensity)." + A._cookieChannel + `;
`), O === Mt ? A._falloffMode === Iu ? (i += "    dAtten = getFalloffLinear(light" + T + `_radius);
`, g = !0) : (i += "    dAtten = getFalloffInvSquared(light" + T + `_radius);
`, b = !0) : (i += "    dAtten = getFalloffWindow(light" + T + `_radius);
`, b = !0), i += `    if (dAtten > 0.00001) {
`, L === Ee && (S && !A._cookieFalloff || (i += "    dAtten *= getSpotEffect(light" + T + "_direction, light" + T + "_innerConeAngle, light" + T + `_outerConeAngle);
`, x = !0))), O !== Mt ? L === de ? i += `    dAttenD = getLightDiffuse();
` : i += "    dAttenD = get" + I + `LightDiffuse() * 16.0;
` : i += `    dAtten *= getLightDiffuse();
`, A.castShadows && !t.noShadow) {
          let D = null, G;
          if (A._shadowType === Os ? (D = "VSM8", G = "0.0") : A._shadowType === li ? (D = "VSM16", G = "5.54") : A._shadowType === zs ? (D = "VSM32", e.textureFloatHighPrecision ? G = "15.0" : G = "5.54") : A._shadowType === Us ? D = "PCF5x5" : D = "PCF3x3", D !== null)
            if (L === Se) {
              const X = "(light" + T + "_shadowMap, light" + T + `_shadowParams);
`;
              A._normalOffsetBias && (i += "    normalOffsetPointShadow(light" + T + `_shadowParams);
`), i += `    float shadow${T} = getShadowPoint${D}${X}`, i += `    dAtten *= mix(1.0, shadow${T}, light${T}_shadowIntensity);
`;
            } else {
              const X = `light${T}_shadowMatrix`, E = `light${T}_shadowParams`;
              i += this._nonPointShadowMapProjection(e, t.lights[T], X, E, T), L === Ee && (D = "Spot" + D), i += `    float shadow${T} = getShadow${D}(SHADOWMAP_PASS(light${T}_shadowMap), light${T}_shadowParams${A._isVsm ? ", " + G : ""});
`, i += `    dAtten *= mix(1.0, shadow${T}, light${T}_shadowIntensity);
`;
            }
        }
        if (O !== Mt ? t.conserveEnergy && t.useSpecular ? i += "    dDiffuseLight += ((dAttenD * dAtten) * light" + T + "_color" + (S ? " * dAtten3" : "") + `) * (1.0 - dLTCSpecFres);
` : i += "    dDiffuseLight += (dAttenD * dAtten) * light" + T + "_color" + (S ? " * dAtten3" : "") + `;
` : c && t.conserveEnergy && t.useSpecular ? i += "    dDiffuseLight += (dAtten * light" + T + "_color" + (S ? " * dAtten3" : "") + `) * (1.0 - dSpecularity);
` : i += "    dDiffuseLight += dAtten * light" + T + "_color" + (S ? " * dAtten3" : "") + `;
`, t.useSpecular && (i += `    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);
`), O !== Mt)
          t.useClearCoat && (i += "    ccSpecularLight += ccLTCSpecFres * get" + I + "LightSpecularCC() * dAtten * light" + T + "_color" + (S ? " * dAtten3" : "") + `;
`), t.useSpecular && (i += "    dSpecularLight += dLTCSpecFres * get" + I + "LightSpecular() * dAtten * light" + T + "_color" + (S ? " * dAtten3" : "") + `;
`);
        else {
          var C = !1;
          L === de && t.fresnelModel > 0 && (C = !0), t.useClearCoat && (i += "    ccSpecularLight += getLightSpecularCC(dHalfDirW) * dAtten * light" + T + "_color", i += S ? " * dAtten3" : "", i += C ? " * getFresnelCC(dot(dViewDirW, dHalfDirW))" : "", i += `;
`), t.useSheen && (i += "    sSpecularLight += getLightSpecularSheen(dHalfDirW) * dAtten * light" + T + "_color", i += S ? " * dAtten3" : "", i += `;
`), t.useSpecular && (i += "    dSpecularLight += getLightSpecular(dHalfDirW) * dAtten * light" + T + "_color", i += S ? " * dAtten3" : "", i += C ? " * getFresnel(dot(dViewDirW, dHalfDirW), dSpecularity)" : "* dSpecularity", i += `;
`);
        }
        L !== de && (i += `    }
`), i += `
`;
      }
      t.clusteredLightingEnabled && this.lighting && (g = !0, b = !0, p = !0, i += `    addClusteredLights();
`), c && (t.useClearCoat && (i += `    ccSpecularity = 1.0;
`), t.useSpecular && (i += `    dSpecularity = vec3(1);
`)), t.useRefraction && (i += `    addRefraction();
`);
    }
    i += `
`, f && (t.occludeDirect && (i += `    occludeDiffuse();
`), (t.occludeSpecular === ja || t.occludeSpecular === Ad) && (i += `    occludeSpecular();
`)), t.useSpecularityFactor && (i += `    dSpecularLight *= dSpecularityFactor;
`), t.opacityFadesSpecular === !1 && ((t.blendType === Vt || t.blendType === $i) && (i += `float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));
`, i += `#ifdef LIT_CLEARCOAT
 specLum += dot(ccSpecularLight * ccSpecularity + ccReflection.rgb * ccSpecularity, vec3( 0.2126, 0.7152, 0.0722 ));
#endif
`, i += `dAlpha = clamp(dAlpha + gammaCorrectInput(specLum), 0.0, 1.0);
`), i += `dAlpha *= material_alphaFade;
`), i += s.endPS, t.blendType === Vt || t.blendType === Nh || t.alphaToCoverage ? i += s.outputAlphaPS : t.blendType === $i ? i += s.outputAlphaPremulPS : i += s.outputAlphaOpaquePS, t.useMsdf && (i += `    gl_FragColor = applyMsdf(gl_FragColor);
`), i += `
`, i += Sr(), p && (i = s.lightDirPointPS + i), g && (i = s.falloffLinearPS + i), b && (i = s.falloffInvSquaredPS + i), x && (i = s.spotPS + i), y && !t.clusteredLightingEnabled && (i = s.cookiePS + i);
    let w = "";
    return i.includes("dReflection") && (w += `vec4 dReflection;
`), i.includes("dTBN") && (w += `mat3 dTBN;
`), i.includes("dVertexNormalW") && (w += `vec3 dVertexNormalW;
`), i.includes("dTangentW") && (w += `vec3 dTangentW;
`), i.includes("dBinormalW") && (w += `vec3 dBinormalW;
`), i.includes("dViewDirW") && (w += `vec3 dViewDirW;
`), i.includes("dReflDirW") && (w += `vec3 dReflDirW;
`), i.includes("dHalfDirW") && (w += `vec3 dHalfDirW;
`), i.includes("dDiffuseLight") && (w += `vec3 dDiffuseLight;
`), i.includes("dSpecularLight") && (w += `vec3 dSpecularLight;
`), i.includes("dLightDirNormW") && (w += `vec3 dLightDirNormW;
`), i.includes("dLightDirW") && (w += `vec3 dLightDirW;
`), i.includes("dLightPosW") && (w += `vec3 dLightPosW;
`), i.includes("dShadowCoord") && (w += `vec3 dShadowCoord;
`), i.includes("dAtten") && (w += `float dAtten;
`), i.includes("dAttenD") && (w += `float dAttenD;
`), i.includes("dAtten3") && (w += `vec3 dAtten3;
`), i.includes("dMsdf") && (w += `vec4 dMsdf;
`), i.includes("ccFresnel") && (w += `float ccFresnel;
`), i.includes("ccReflection") && (w += `vec3 ccReflection;
`), i.includes("ccReflDirW") && (w += `vec3 ccReflDirW;
`), i.includes("ccSpecularLight") && (w += `vec3 ccSpecularLight;
`), i.includes("ccSpecularityNoFres") && (w += `float ccSpecularityNoFres;
`), i.includes("sSpecularLight") && (w += `vec3 sSpecularLight;
`), i.includes("sReflection") && (w += `vec3 sReflection;
`), this._fsGetBeginCode() + this.varyings + this._fsGetBaseCode() + (t.detailModes ? s.detailModesPS : "") + w + this.frontendDecl + i;
  }
  generateFragmentShader(e, t, s, i) {
    const n = this.options;
    this.frontendDecl = e, this.frontendCode = t, this.frontendFunc = s, this.lightingUv = i, n.pass === Hr ? this.fshader = this._fsGetPickPassCode() : n.pass === As ? this.fshader = this._fsGetDepthPassCode() : this.shadowPass ? this.fshader = this._fsGetShadowPassCode() : n.customFragmentShader ? this.fshader = this._fsGetBeginCode() + n.customFragmentShader : this.fshader = this._fsGetLitPassCode();
  }
  getDefinition() {
    const e = pt.createDefinition(this.device, {
      name: "LitShader",
      attributes: this.attributes,
      vertexCode: this.vshader,
      fragmentCode: this.fshader
    });
    return Ut.isForward(this.options.pass) && (e.tag = O0), e;
  }
}
class Tc {
  constructor() {
    this.code = "";
  }
  append(...e) {
    e.forEach((t) => {
      t.endsWith(`
`) ? this.code += t : this.code += t + `
`;
    });
  }
  prepend(...e) {
    e.forEach((t) => {
      t.endsWith(`
`) ? this.code = t + this.code : this.code = t + `
` + this.code;
    });
  }
}
class MC {
  constructor() {
    this.hasTangents = !1, this.chunks = [], this._pass = 0, this.alphaTest = !1, this.forceFragmentPrecision = !1, this.blendType = ss, this.separateAmbient = !1, this.screenSpace = !1, this.skin = !1, this.useInstancing = !1, this.useMorphPosition = !1, this.useMorphNormal = !1, this.useMorphTextureBased = !1, this.nineSlicedMode = !1, this.clusteredLightingEnabled = !0, this.clusteredLightingCookiesEnabled = !1, this.clusteredLightingShadowsEnabled = !1, this.clusteredLightingShadowType = 0, this.clusteredLightingAreaLightsEnabled = !1, this.vertexColors = !1, this.lightMapEnabled = !1, this.useLightMapVertexColors = !1, this.dirLightMapEnabled = !1, this.heightMapEnabled = !1, this.normalMapEnabled = !1, this.clearCoatNormalMapEnabled = !1, this.aoMapEnabled = !1, this.useAoVertexColors = !1, this.diffuseMapEnabled = !1, this.useAmbientTint = !1, this.customFragmentShader = null, this.pixelSnap = !1, this.useClearCoatNormalMap = !1, this.useDiffuseMap = !1, this.useAoMap = !1, this.detailModes = 0, this.shadingModel = 0, this.ambientSH = !1, this.fastTbn = !1, this.twoSidedLighting = !1, this.occludeSpecular = !1, this.occludeSpecularFloat = !1, this.useMsdf = !1, this.msdfTextAttribute = 0, this.alphaToCoverage = !1, this.opacityFadesSpecular = !1, this.cubeMapProjection = !1, this.occludeDirect = !1, this.conserveEnergy = !1, this.useSpecular = !1, this.useSpecularityFactor = !1, this.useSpecularColor = !1, this.enableGGXSpecular = !1, this.fresnelModel = 0, this.useRefraction = !1, this.useClearCoat = !1, this.useSheen = !1, this.useIridescence = !1, this.useMetalness = !1, this.useDynamicRefraction = !1, this.fog = Hl, this.gamma = Uh, this.toneMap = -1, this.fixSeams = !1, this.reflectionSource = null, this.reflectionEncoding = null, this.ambientSource = "constant", this.ambientEncoding = null, this.skyboxIntensity = 1, this.useCubeMapRotation = !1, this.lightMapWithoutAmbient = !1, this.lights = [], this.noShadow = !1, this.lightMaskDynamic = 0;
  }
  set pass(e) {
  }
  get pass() {
    return this._pass;
  }
}
class Zh {
  constructor() {
    this.chunks = [], this._pass = 0, this.forceUv1 = !1, this.ambientTint = !1, this.diffuseTint = !1, this.specularTint = !1, this.metalnessTint = !1, this.glossTint = !1, this.emissiveTint = !1, this.opacityTint = !1, this.emissiveEncoding = "linear", this.lightMapEncoding = "linear", this.packedNormal = !1, this.glossInvert = !1, this.sheenGlossInvert = !1, this.clearCoatGlossInvert = !1, this.litOptions = new MC();
  }
  set pass(e) {
    this._pass = e, this.litOptions._pass = e;
  }
  get pass() {
    return this._pass;
  }
}
const Rr = [], Cc = {
  optionsContext: new Zh(),
  optionsContextMin: new Zh(),
  generateKey: function(r) {
    const e = function(n) {
      const a = [];
      for (const o in n)
        n.hasOwnProperty(o) && o !== "chunks" && o !== "lights" && a.push(o);
      return a.sort();
    };
    let t;
    r === this.optionsContextMin ? (this.propsMin || (this.propsMin = e(r)), t = this.propsMin) : r === this.optionsContext ? (this.props || (this.props = e(r)), t = this.props) : t = e(r);
    let s = "standard";
    for (let i = 0; i < t.length; i++)
      r[t[i]] && (s += t[i] + r[t[i]]);
    if (r.chunks) {
      const i = [];
      for (const n in r.chunks)
        r.chunks.hasOwnProperty(n) && i.push(n + r.chunks[n]);
      i.sort(), s += i;
    }
    if (r.litOptions)
      for (const i in r.litOptions)
        if (i === "lights") {
          const n = r.litOptions.clusteredLightingEnabled;
          for (let a = 0; a < r.litOptions.lights.length; a++) {
            const o = r.litOptions.lights[a];
            (!n || o._type === de) && (s += o.key);
          }
        } else
          s += i + r.litOptions[i];
    return Wa(s);
  },
  _getUvSourceExpression: function(r, e, t) {
    const s = t[r], i = t[e], n = Ut.isForward(t.pass);
    let a;
    return n && t.litOptions.nineSlicedMode === ht || n && t.litOptions.nineSlicedMode === it ? a = "nineSlicedUv" : (s === 0 ? a = "vUv" + i : a = "vUV" + i + "_" + s, t.heightMap && r !== "heightMapTransform" && (a += " + dUvOffset")), a;
  },
  _addMapDef: function(r, e) {
    return e ? `#define ${r}
` : `#undef ${r}
`;
  },
  _addMapDefs: function(r, e, t, s, i) {
    return this._addMapDef("MAPFLOAT", r) + this._addMapDef("MAPCOLOR", e) + this._addMapDef("MAPVERTEX", t) + this._addMapDef("MAPTEXTURE", s) + this._addMapDef("MAPINVERT", i);
  },
  _addMap: function(r, e, t, s, i, n = null) {
    const a = r + "Map", o = a + "Uv", h = a + "Identifier", l = a + "Transform", c = a + "Channel", d = r + "VertexColorChannel", u = r + "Tint", f = r + "VertexColor", m = r + "Mode", _ = r + "Invert", p = t[u], g = t[f], b = t[a], x = t[h], y = t[m];
    let S = s[e];
    if (b) {
      const T = this._getUvSourceExpression(l, o, t);
      if (S = S.replace(/\$UV/g, T).replace(/\$CH/g, t[c]), i && S.search(/\$SAMPLER/g) !== -1) {
        let A = "texture_" + a;
        const L = i[x];
        L ? A = L : i[x] = A, S = S.replace(/\$SAMPLER/g, A);
      }
      if (n && (t[c] === "aaa" ? S = S.replace(/\$DECODE/g, "passThrough") : S = S.replace(/\$DECODE/g, ks.decodeFunc(!t.litOptions.gamma && n === "srgb" ? "linear" : n)), S.indexOf("$texture2DSAMPLE"))) {
        const A = {
          linear: "texture2D",
          srgb: "texture2DSRGB",
          rgbm: "texture2DRGBM",
          rgbe: "texture2DRGBE"
        };
        S = S.replace(/\$texture2DSAMPLE/g, A[n] || "texture2D");
      }
    }
    g && (S = S.replace(/\$VC/g, t[d])), y && (S = S.replace(/\$DETAILMODE/g, y));
    const C = !!(p & 1), w = !!(p & 2), M = !!t[_];
    return S = this._addMapDefs(C, w, g, b, M) + S, S.replace(/\$/g, "");
  },
  _correctChannel: function(r, e, t) {
    if (t[r] > 0) {
      if (t[r] < e.length)
        return e.substring(0, t[r]);
      if (t[r] > e.length) {
        let s = e;
        const i = s.charAt(s.length - 1), n = t[r] - s.length;
        for (let a = 0; a < n; a++)
          s += i;
        return s;
      }
      return e;
    }
  },
  createShaderDefinition: function(r, e) {
    const t = new AC(r, e.litOptions), s = [], i = [], n = [], a = 2, o = {};
    for (const u in Rr) {
      const f = u + "Map";
      if (e[u + "VertexColor"]) {
        const m = u + "VertexColorChannel";
        e[m] = this._correctChannel(u, e[m], Rr);
      }
      if (e[f]) {
        const m = f + "Channel", _ = f + "Transform", p = f + "Uv";
        e[p] = Math.min(e[p], a - 1), e[m] = this._correctChannel(u, e[m], Rr);
        const g = e[p];
        s[g] = !0, i[g] = i[g] || e[f] && !e[_], e[_] && n.push({
          name: u,
          id: e[_],
          uv: e[p]
        });
      }
    }
    e.forceUv1 && (s[1] = !0, i[1] = i[1] !== void 0 ? i[1] : !0), t.generateVertexShader(s, i, n), e.litOptions.shadingModel === Hs ? (e.litOptions.fresnelModel = 0, e.litOptions.ambientSH = !1) : e.litOptions.fresnelModel = e.litOptions.fresnelModel === 0 ? Lu : e.litOptions.fresnelModel;
    const h = new Tc(), l = new Tc(), c = new Tc();
    let d = "";
    if (e.litOptions.nineSlicedMode === it ? h.append("const float textureBias = -1000.0;") : h.append("uniform float textureBias;"), Ut.isForward(e.pass)) {
      if (e.heightMap && (h.append("vec2 dUvOffset;"), l.append(this._addMap("height", "parallaxPS", e, t.chunks, o)), c.append("getParallax();")), e.litOptions.blendType !== ss || e.litOptions.alphaTest || e.litOptions.alphaToCoverage ? (h.append("float dAlpha;"), l.append(this._addMap("opacity", "opacityPS", e, t.chunks, o)), c.append("getOpacity();"), e.litOptions.alphaTest && (l.append(t.chunks.alphaTestPS), c.append("alphaTest(dAlpha);"))) : h.append("float dAlpha = 1.0;"), t.needsNormal) {
        if ((e.normalMap || e.clearCoatNormalMap) && (l.append(e.packedNormal ? t.chunks.normalXYPS : t.chunks.normalXYZPS), !e.litOptions.hasTangents)) {
          const u = e.normalMap ? "normalMap" : "clearCoatNormalMap";
          d = this._getUvSourceExpression(`${u}Transform`, `${u}Uv`, e);
        }
        h.append("vec3 dNormalW;"), l.append(this._addMap("normalDetail", "normalDetailMapPS", e, t.chunks, o)), l.append(this._addMap("normal", "normalMapPS", e, t.chunks, o)), c.append("getNormal();");
      }
      if (t.needsSceneColor && h.append("uniform sampler2D uSceneColorMap;"), t.needsScreenSize && h.append("uniform vec4 uScreenSize;"), t.needsTransforms && (h.append("uniform mat4 matrix_viewProjection;"), h.append("uniform mat4 matrix_model;")), h.append("vec3 dAlbedo;"), e.diffuseDetail && l.append(this._addMap("diffuseDetail", "diffuseDetailMapPS", e, t.chunks, o, e.diffuseDetailEncoding)), l.append(this._addMap("diffuse", "diffusePS", e, t.chunks, o, e.diffuseEncoding)), c.append("getAlbedo();"), e.litOptions.useRefraction && (h.append("float dTransmission;"), l.append(this._addMap("refraction", "transmissionPS", e, t.chunks, o)), c.append("getRefraction();"), h.append("float dThickness;"), l.append(this._addMap("thickness", "thicknessPS", e, t.chunks, o)), c.append("getThickness();")), e.litOptions.useIridescence && (h.append("vec3 dIridescenceFresnel;"), h.append("float dIridescence;"), l.append(this._addMap("iridescence", "iridescencePS", e, t.chunks, o)), c.append("getIridescence();"), h.append("float dIridescenceThickness;"), l.append(this._addMap("iridescenceThickness", "iridescenceThicknessPS", e, t.chunks, o)), c.append("getIridescenceThickness();")), t.lighting && e.litOptions.useSpecular || t.reflections ? (h.append("vec3 dSpecularity;"), h.append("float dGlossiness;"), e.litOptions.useSheen && (h.append("vec3 sSpecularity;"), l.append(this._addMap("sheen", "sheenPS", e, t.chunks, o, e.sheenEncoding)), c.append("getSheen();"), h.append("float sGlossiness;"), l.append(this._addMap("sheenGloss", "sheenGlossPS", e, t.chunks, o)), c.append("getSheenGlossiness();")), e.litOptions.useMetalness && (h.append("float dMetalness;"), l.append(this._addMap("metalness", "metalnessPS", e, t.chunks, o)), c.append("getMetalness();")), e.litOptions.useSpecularityFactor && (h.append("float dSpecularityFactor;"), l.append(this._addMap("specularityFactor", "specularityFactorPS", e, t.chunks, o)), c.append("getSpecularityFactor();")), e.litOptions.useSpecularColor ? l.append(this._addMap("specular", "specularPS", e, t.chunks, o, e.specularEncoding)) : l.append("void getSpecularity() { dSpecularity = vec3(1); }"), l.append(this._addMap("gloss", "glossPS", e, t.chunks, o)), c.append("getGlossiness();"), c.append("getSpecularity();")) : (h.append("vec3 dSpecularity = vec3(0.0);"), h.append("float dGlossiness = 0.0;")), (e.aoMap || e.aoVertexColor) && (h.append("float dAo;"), l.append(this._addMap("ao", "aoPS", e, t.chunks, o)), c.append("getAO();")), h.append("vec3 dEmission;"), l.append(this._addMap("emissive", "emissivePS", e, t.chunks, o, e.emissiveEncoding)), c.append("getEmission();"), e.litOptions.useClearCoat && (h.append("float ccSpecularity;"), h.append("float ccGlossiness;"), h.append("vec3 ccNormalW;"), l.append(this._addMap("clearCoat", "clearCoatPS", e, t.chunks, o)), l.append(this._addMap("clearCoatGloss", "clearCoatGlossPS", e, t.chunks, o)), l.append(this._addMap("clearCoatNormal", "clearCoatNormalPS", e, t.chunks, o)), c.append("getClearCoat();"), c.append("getClearCoatGlossiness();"), c.append("getClearCoatNormal();")), e.litOptions.lightMapEnabled || e.lightMapVertexColors) {
        const u = e.litOptions.dirLightMapEnabled && e.litOptions.useSpecular, f = u ? "lightmapDirPS" : "lightmapSinglePS";
        h.append("vec3 dLightmap;"), u && h.append("vec3 dLightmapDir;"), l.append(this._addMap("light", f, e, t.chunks, o, e.lightMapEncoding)), c.append("getLightMap();");
      }
      (l.code.indexOf("texture2DSRGB") !== -1 || l.code.indexOf("texture2DRGBM") !== -1 || l.code.indexOf("texture2DRGBE") !== -1) && l.prepend(t.chunks.textureSamplePS);
    } else
      e.litOptions.alphaTest && (h.append("float dAlpha;"), l.append(this._addMap("opacity", "opacityPS", e, t.chunks, o)), l.append(t.chunks.alphaTestPS), c.append("getOpacity();"), c.append("alphaTest(dAlpha);"));
    for (const u in o)
      h.append(`uniform sampler2D ${o[u]};`);
    return c.code = `
${c.code.split(`
`).map((u) => `    ${u}`).join(`
`)}

`, t.generateFragmentShader(h.code, l.code, c.code, d), t.getDefinition();
  }
}, Sm = (r, e) => {
  if (r.length !== e.length)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}, Do = (r) => r.r !== 1 || r.g !== 1 || r.b !== 1, EC = (r) => r.r !== 0 || r.g !== 0 || r.b !== 0;
class RC {
  constructor() {
    this._mapXForms = null;
  }
  updateMinRef(e, t, s, i, n, a, o) {
    this._updateSharedOptions(e, t, s, i, a), this._updateMinOptions(e, s), this._updateUVOptions(e, s, i, !0), e.litOptions.chunks = e.chunks;
  }
  updateRef(e, t, s, i, n, a, o) {
    this._updateSharedOptions(e, t, s, i, a), this._updateEnvOptions(e, s, t), this._updateMaterialOptions(e, s), a === fi && (e.litOptions.gamma && (e.litOptions.gamma = Vh), e.litOptions.toneMap = Gh), e.litOptions.hasTangents = i && (i & eg) !== 0, this._updateLightOptions(e, t, s, i, o, n), this._updateUVOptions(e, s, i, !1), e.litOptions.chunks = e.chunks;
  }
  _updateSharedOptions(e, t, s, i, n) {
    e.forceUv1 = s.forceUv1, e.chunks = s.chunks || "", e.pass = n, e.litOptions.alphaTest = s.alphaTest > 0, e.litOptions.forceFragmentPrecision = s.forceFragmentPrecision || "", e.litOptions.blendType = s.blendType, e.litOptions.separateAmbient = !1, e.litOptions.screenSpace = i && (i & qh) !== 0, e.litOptions.skin = i && (i & Hh) !== 0, e.litOptions.useInstancing = i && (i & Q_) !== 0, e.litOptions.useMorphPosition = i && (i & Xh) !== 0, e.litOptions.useMorphNormal = i && (i & jh) !== 0, e.litOptions.useMorphTextureBased = i && (i & $h) !== 0, e.litOptions.nineSlicedMode = s.nineSlicedMode || 0, t.clusteredLightingEnabled && s.useLighting ? (e.litOptions.clusteredLightingEnabled = !0, e.litOptions.clusteredLightingCookiesEnabled = t.lighting.cookiesEnabled, e.litOptions.clusteredLightingShadowsEnabled = t.lighting.shadowsEnabled, e.litOptions.clusteredLightingShadowType = t.lighting.shadowType, e.litOptions.clusteredLightingAreaLightsEnabled = t.lighting.areaLightsEnabled) : (e.litOptions.clusteredLightingEnabled = !1, e.litOptions.clusteredLightingCookiesEnabled = !1, e.litOptions.clusteredLightingShadowsEnabled = !1, e.litOptions.clusteredLightingAreaLightsEnabled = !1);
  }
  _updateUVOptions(e, t, s, i) {
    let n = !1, a = !1, o = !1;
    s && (n = (s & K_) !== 0, a = (s & Z_) !== 0, o = (s & J_) !== 0), e.litOptions.vertexColors = !1, this._mapXForms = [];
    const h = {};
    for (const l in Rr)
      this._updateTexOptions(e, t, l, n, a, o, i, h);
    this._mapXForms = null, e.litOptions.lightMapEnabled = e.lightMap, e.litOptions.useLightMapVertexColors = e.lightVertexColor, e.litOptions.dirLightMapEnabled = e.dirLightMap, e.litOptions.heightMapEnabled = e.heightMap, e.litOptions.normalMapEnabled = e.normalMap, e.litOptions.clearCoatNormalMapEnabled = e.clearCoatNormalMap, e.litOptions.aoMapEnabled = e.aoMap, e.litOptions.useAoVertexColors = e.aoVertexColor, e.litOptions.diffuseMapEnabled = e.diffuseMap;
  }
  _updateTexOptions(e, t, s, i, n, a, o, h) {
    const l = s + "Map", c = s + "VertexColor", d = s + "VertexColorChannel", u = l + "Channel", f = l + "Transform", m = l + "Uv", _ = l + "Identifier";
    s !== "light" && (e[l] = !1, e[_] = void 0, e[u] = "", e[f] = 0, e[m] = 0), e[c] = !1, e[d] = "";
    const p = s === "opacity";
    if (!(p && t.blendType === ss && t.alphaTest === 0 && !t.alphaToCoverage) && (!o || p) && (s !== "height" && t[c] && a && (e[c] = t[c], e[d] = t[d], e.litOptions.vertexColors = !0), t[l])) {
      let g = !0;
      if (t[m] === 0 && !i && (g = !1), t[m] === 1 && !n && (g = !1), g) {
        const b = t[l].id;
        let x = h[b];
        x === void 0 && (h[b] = s, x = s), e[l] = !!t[l], e[_] = x, e[f] = this._getMapTransformID(t.getUniform(f), t[m]), e[u] = t[u], e[m] = t[m];
      }
    }
  }
  _updateMinOptions(e, t) {
    e.opacityTint = t.opacity !== 1 && t.blendType !== ss, e.litOptions.lights = [];
  }
  _updateMaterialOptions(e, t) {
    var s, i, n, a;
    const o = (t.diffuseTint || !t.diffuseMap && !t.diffuseVertexColor) && Do(t.diffuse), h = !!(t.useMetalness || t.specularMap || t.sphereMap || t.cubeMap || EC(t.specular) || t.specularityFactor > 0 && t.useMetalness || t.enableGGXSpecular || t.clearCoat > 0), l = !t.useMetalness || t.useMetalnessSpecularColor, c = h && (t.specularTint || !t.specularMap && !t.specularVertexColor) && Do(t.specular), d = h && t.useMetalnessSpecularColor && (t.specularityFactorTint || t.specularityFactor < 1 && !t.specularityFactorMap), u = !t.emissiveMap || Do(t.emissive) && t.emissiveTint, f = t.emissiveIntensity !== 1, m = t.normalMap ? t.normalMap.format === In || t.normalMap.type === kl : !1;
    e.opacityTint = t.opacity !== 1 && t.blendType !== ss ? 1 : 0, e.ambientTint = t.ambientTint, e.diffuseTint = o ? 2 : 0, e.specularTint = c ? 2 : 0, e.specularityFactorTint = d ? 1 : 0, e.metalnessTint = t.useMetalness && t.metalness < 1 ? 1 : 0, e.glossTint = 1, e.emissiveTint = (u ? 2 : 0) + (f ? 1 : 0), e.diffuseEncoding = (s = t.diffuseMap) == null ? void 0 : s.encoding, e.diffuseDetailEncoding = (i = t.diffuseDetailMap) == null ? void 0 : i.encoding, e.emissiveEncoding = (n = t.emissiveMap) == null ? void 0 : n.encoding, e.lightMapEncoding = (a = t.lightMap) == null ? void 0 : a.encoding, e.packedNormal = m, e.refractionTint = t.refraction !== 1 ? 1 : 0, e.refractionIndexTint = t.refractionIndex !== 1 / 1.5 ? 1 : 0, e.thicknessTint = t.useDynamicRefraction && t.thickness !== 1 ? 1 : 0, e.specularEncoding = t.specularEncoding || "linear", e.sheenEncoding = t.sheenEncoding || "linear", e.aoMapUv = t.aoUvSet, e.diffuseDetail = !!t.diffuseMap, e.normalDetail = !!t.normalMap, e.diffuseDetailMode = t.diffuseDetailMode, e.clearCoatTint = t.clearCoat !== 1 ? 1 : 0, e.clearCoatGloss = !!t.clearCoatGloss, e.clearCoatGlossTint = t.clearCoatGloss !== 1 ? 1 : 0, e.iridescenceTint = t.iridescence !== 1 ? 1 : 0, e.sheenTint = t.useSheen && Do(t.sheen) ? 2 : 0, e.sheenGlossTint = 1, e.glossInvert = t.glossInvert, e.sheenGlossInvert = t.sheenGlossInvert, e.clearCoatGlossInvert = t.clearCoatGlossInvert, e.litOptions.useAmbientTint = e.ambientTint, e.litOptions.customFragmentShader = t.customFragmentShader, e.litOptions.pixelSnap = t.pixelSnap, e.litOptions.useClearCoatNormalMap = !!t.clearCoatNormalMap, e.litOptions.useDiffuseMap = !!t.diffuseMap, e.litOptions.useAoMap = !!t.aoMap, e.litOptions.detailModes = !!e.diffuseDetail, e.litOptions.shadingModel = t.shadingModel, e.litOptions.ambientSH = !!t.ambientSH, e.litOptions.fastTbn = t.fastTbn, e.litOptions.twoSidedLighting = t.twoSidedLighting, e.litOptions.occludeSpecular = t.occludeSpecular, e.litOptions.occludeSpecularFloat = t.occludeSpecularIntensity !== 1, e.litOptions.useMsdf = !!t.msdfMap, e.litOptions.msdfTextAttribute = !!t.msdfTextAttribute, e.litOptions.alphaToCoverage = t.alphaToCoverage, e.litOptions.opacityFadesSpecular = t.opacityFadesSpecular, e.litOptions.cubeMapProjection = t.cubeMapProjection, e.litOptions.occludeDirect = t.occludeDirect, e.litOptions.conserveEnergy = t.conserveEnergy && t.shadingModel !== Hs, e.litOptions.useSpecular = h, e.litOptions.useSpecularityFactor = (d || !!t.specularityFactorMap) && t.useMetalnessSpecularColor, e.litOptions.useSpecularColor = l, e.litOptions.enableGGXSpecular = t.enableGGXSpecular, e.litOptions.fresnelModel = t.fresnelModel, e.litOptions.useRefraction = (t.refraction || !!t.refractionMap) && (t.useDynamicRefraction || !!e.litOptions.reflectionSource), e.litOptions.useClearCoat = !!t.clearCoat, e.litOptions.useSheen = t.useSheen, e.litOptions.useIridescence = t.useIridescence && t.iridescence !== 0, e.litOptions.useMetalness = t.useMetalness, e.litOptions.useDynamicRefraction = t.useDynamicRefraction;
  }
  _updateEnvOptions(e, t, s) {
    e.litOptions.fog = t.useFog ? s.fog : "none", e.litOptions.gamma = t.useGammaTonemap ? s.gammaCorrection : Uh, e.litOptions.toneMap = t.useGammaTonemap ? s.toneMapping : -1, e.litOptions.fixSeams = t.cubeMap ? t.cubeMap.fixCubemapSeams : !1;
    const i = t.shadingModel === Hs;
    let n = !1;
    if (t.envAtlas && t.cubeMap && !i ? (e.litOptions.reflectionSource = "envAtlasHQ", e.litOptions.reflectionEncoding = t.envAtlas.encoding) : t.envAtlas && !i ? (e.litOptions.reflectionSource = "envAtlas", e.litOptions.reflectionEncoding = t.envAtlas.encoding) : t.cubeMap ? (e.litOptions.reflectionSource = "cubeMap", e.litOptions.reflectionEncoding = t.cubeMap.encoding) : t.sphereMap ? (e.litOptions.reflectionSource = "sphereMap", e.litOptions.reflectionEncoding = t.sphereMap.encoding) : t.useSkybox && s.envAtlas && s.skybox && !i ? (e.litOptions.reflectionSource = "envAtlasHQ", e.litOptions.reflectionEncoding = s.envAtlas.encoding, n = !0) : t.useSkybox && s.envAtlas && !i ? (e.litOptions.reflectionSource = "envAtlas", e.litOptions.reflectionEncoding = s.envAtlas.encoding, n = !0) : t.useSkybox && s.skybox ? (e.litOptions.reflectionSource = "cubeMap", e.litOptions.reflectionEncoding = s.skybox.encoding, n = !0) : (e.litOptions.reflectionSource = null, e.litOptions.reflectionEncoding = null), t.ambientSH && !i)
      e.litOptions.ambientSource = "ambientSH", e.litOptions.ambientEncoding = null;
    else {
      const a = t.envAtlas || (t.useSkybox && s.envAtlas ? s.envAtlas : null);
      a && !i ? (e.litOptions.ambientSource = "envAtlas", e.litOptions.ambientEncoding = a.encoding) : (e.litOptions.ambientSource = "constant", e.litOptions.ambientEncoding = null);
    }
    e.litOptions.skyboxIntensity = n && (s.skyboxIntensity !== 1 || s.physicalUnits), e.litOptions.useCubeMapRotation = n && s.skyboxRotation && !s.skyboxRotation.equals(ee.IDENTITY);
  }
  _updateLightOptions(e, t, s, i, n, a) {
    if (e.lightMap = !1, e.lightMapChannel = "", e.lightMapUv = 0, e.lightMapTransform = 0, e.litOptions.lightMapWithoutAmbient = !1, e.dirLightMap = !1, i && (e.litOptions.noShadow = (i & Md) !== 0, i & Wh && (e.lightMapEncoding = t.lightmapPixelFormat === ye ? "rgbm" : "linear", e.lightMap = !0, e.lightMapChannel = "rgb", e.lightMapUv = 1, e.lightMapTransform = 0, e.litOptions.lightMapWithoutAmbient = !s.lightMap, i & Bu && (e.dirLightMap = !0), i & Fu && (e.litOptions.lightMapWithoutAmbient = !1))), s.useLighting) {
      const o = [], h = i ? i >> 16 : Gs;
      e.litOptions.lightMaskDynamic = !!(h & Gs), n && (this._collectLights(de, n[de], o, h), this._collectLights(Se, n[Se], o, h, a), this._collectLights(Ee, n[Ee], o, h, a)), e.litOptions.lights = o;
    } else
      e.litOptions.lights = [];
    e.litOptions.lights.length === 0 && (e.litOptions.noShadow = !0);
  }
  _collectLights(e, t, s, i, n) {
    for (let a = 0; a < t.length; a++) {
      const o = t[a];
      if (o.enabled && o.mask & i) {
        if (e !== de && o.isStatic)
          continue;
        s.push(o);
      }
    }
    if (n)
      for (let a = 0; a < n.length; a++) {
        const o = n[a];
        o._type === e && s.push(o);
      }
  }
  _getMapTransformID(e, t) {
    if (!e)
      return 0;
    let s = this._mapXForms[t];
    s || (s = [], this._mapXForms[t] = s);
    for (let i = 0; i < s.length; i++)
      if (Sm(s[i][0].value, e[0].value) && Sm(s[i][1].value, e[1].value))
        return i + 1;
    return s.push(e);
  }
}
function On() {
  return On = Object.assign ? Object.assign.bind() : function(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s]);
    }
    return r;
  }, On.apply(this, arguments);
}
function Qe(r, e = !0, t = !0) {
  const s = {};
  return s[`${r}Map`] = "texture", s[`${r}MapTiling`] = "vec2", s[`${r}MapOffset`] = "vec2", s[`${r}MapRotation`] = "number", s[`${r}MapUv`] = "number", e && (s[`${r}MapChannel`] = "string", t && (s[`${r}VertexColor`] = "boolean", s[`${r}VertexColorChannel`] = "string")), s;
}
const Wr = On({
  name: "string",
  chunks: "chunks",
  mappingFormat: "string",
  _engine: "boolean",
  ambient: "rgb",
  ambientTint: "boolean"
}, Qe("ao"), {
  diffuse: "rgb",
  diffuseTint: "boolean"
}, Qe("diffuse"), Qe("diffuseDetail", !0, !1), {
  diffuseDetailMode: "string",
  specular: "rgb",
  specularTint: "boolean"
}, Qe("specular"), {
  occludeSpecular: "enum:occludeSpecular",
  specularityFactor: "number",
  specularityFactorTint: "boolean"
}, Qe("specularityFactor"), {
  useMetalness: "boolean",
  metalness: "number",
  enableGGXSpecular: "boolean",
  anisotropy: "number",
  metalnessTint: "boolean"
}, Qe("metalness"), {
  useMetalnessSpecularColor: "boolean",
  conserveEnergy: "boolean",
  shininess: "number",
  gloss: "number",
  glossInvert: "boolean"
}, Qe("gloss"), {
  clearCoat: "number"
}, Qe("clearCoat"), {
  clearCoatGloss: "number",
  clearCoatGlossInvert: "boolean"
}, Qe("clearCoatGloss"), {
  clearCoatBumpiness: "number"
}, Qe("clearCoatNormal", !1), {
  useSheen: "boolean",
  sheen: "rgb",
  sheenTint: "boolean"
}, Qe("sheen"), {
  sheenGloss: "number",
  sheenGlossTint: "boolean",
  sheenGlossInvert: "boolean"
}, Qe("sheenGloss"), {
  fresnelModel: "number",
  emissive: "rgb",
  emissiveTint: "boolean"
}, Qe("emissive"), {
  emissiveIntensity: "number"
}, Qe("normal", !1), {
  bumpiness: "number"
}, Qe("normalDetail", !1), {
  normalDetailMapBumpiness: "number"
}, Qe("height", !0, !1), {
  heightMapFactor: "number",
  alphaToCoverage: "boolean",
  alphaTest: "number",
  alphaFade: "number",
  opacity: "number"
}, Qe("opacity"), {
  opacityFadesSpecular: "boolean",
  reflectivity: "number",
  refraction: "number",
  refractionTint: "boolean"
}, Qe("refraction"), {
  refractionIndex: "number",
  thickness: "number",
  thicknessTint: "boolean"
}, Qe("thickness"), {
  attenuation: "rgb",
  attenuationDistance: "number",
  useDynamicRefraction: "boolean",
  sphereMap: "texture",
  cubeMap: "cubemap",
  cubeMapProjection: "number",
  cubeMapProjectionBox: "boundingbox",
  useIridescence: "boolean",
  iridescence: "number",
  iridescenceTint: "boolean"
}, Qe("iridescence"), {
  iridescenceThicknessTint: "boolean",
  iridescenceThicknessMin: "number",
  iridescenceThicknessMax: "number",
  iridescenceRefractionIndex: "number"
}, Qe("iridescenceThickness"), Qe("light"), {
  depthTest: "boolean",
  depthFunc: "enum:depthFunc",
  depthWrite: "boolean",
  depthBias: "number",
  slopeDepthBias: "number",
  cull: "enum:cull",
  blendType: "enum:blendType",
  shadingModel: "enum:shadingModel",
  useFog: "boolean",
  useLighting: "boolean",
  useSkybox: "boolean",
  useGammaTonemap: "boolean",
  envAtlas: "texture",
  twoSidedLighting: "boolean"
}), Xl = [];
for (const r in Wr)
  Wr[r] === "texture" && Xl.push(r);
const Wu = [];
for (const r in Wr)
  Wr[r] === "cubemap" && Wu.push(r);
const LC = {
  aoMapVertexColor: "boolean",
  diffuseMapTint: "boolean",
  diffuseMapVertexColor: "boolean",
  emissiveMapTint: "boolean",
  emissiveMapVertexColor: "boolean",
  glossMapVertexColor: "boolean",
  metalnessMapVertexColor: "boolean",
  opacityMapVertexColor: "boolean",
  specularAntialias: "boolean",
  specularMapTint: "boolean",
  specularMapVertexColor: "boolean"
}, ph = {}, fg = {};
let aa = /* @__PURE__ */ new Set();
class Ht extends Ki {
  constructor() {
    super(), this._dirtyShader = !0, this._assetReferences = {}, this._activeParams = /* @__PURE__ */ new Set(), this._activeLightingParams = /* @__PURE__ */ new Set(), this.shaderOptBuilder = new RC(), this.reset();
  }
  reset() {
    Object.keys(ph).forEach((e) => {
      this[`_${e}`] = ph[e].value();
    }), this._chunks = {}, this._uniformCache = {};
  }
  set shader(e) {
  }
  get shader() {
    return null;
  }
  set chunks(e) {
    this._dirtyShader = !0, this._chunks = e;
  }
  get chunks() {
    return this._dirtyShader = !0, this._chunks;
  }
  copy(e) {
    super.copy(e), Object.keys(ph).forEach((t) => {
      this[t] = e[t];
    });
    for (const t in e._chunks)
      e._chunks.hasOwnProperty(t) && (this._chunks[t] = e._chunks[t]);
    return this;
  }
  _setParameter(e, t) {
    aa.add(e), this.setParameter(e, t);
  }
  _setParameters(e) {
    e.forEach((t) => {
      this._setParameter(t.name, t.value);
    });
  }
  _processParameters(e) {
    const t = this[e];
    t.forEach((s) => {
      aa.has(s) || delete this.parameters[s];
    }), this[e] = aa, aa = t, aa.clear();
  }
  _updateMap(e) {
    const t = e + "Map", s = this[t];
    if (s) {
      this._setParameter("texture_" + t, s);
      const i = t + "Transform", n = this.getUniform(i);
      n && this._setParameters(n);
    }
  }
  _allocUniform(e, t) {
    let s = this._uniformCache[e];
    return s || (s = t(), this._uniformCache[e] = s), s;
  }
  getUniform(e, t, s) {
    return fg[e](this, t, s);
  }
  updateUniforms(e, t) {
    const s = (n) => this.getUniform(n, e, t);
    if (this._setParameter("material_ambient", s("ambient")), (!this.diffuseMap || this.diffuseTint) && this._setParameter("material_diffuse", s("diffuse")), !this.useMetalness)
      (!this.specularMap || this.specularTint) && this._setParameter("material_specular", s("specular"));
    else if ((!this.metalnessMap || this.metalness < 1) && this._setParameter("material_metalness", this.metalness), (!this.specularMap || this.specularTint) && this._setParameter("material_specular", s("specular")), (!this.specularityFactorMap || this.specularityFactorTint) && this._setParameter("material_specularityFactor", this.specularityFactor), (!this.sheenMap || this.sheenTint) && this._setParameter("material_sheen", s("sheen")), (!this.sheenGlossMap || this.sheenGlossTint) && this._setParameter("material_sheenGloss", this.sheenGloss), this.refractionIndex !== 1 / 1.5) {
      const n = 1 / this.refractionIndex, a = (n - 1) / (n + 1);
      this._setParameter("material_f0", a * a);
    } else
      this._setParameter("material_f0", 0.04);
    this.enableGGXSpecular && this._setParameter("material_anisotropy", this.anisotropy), this.clearCoat > 0 && (this._setParameter("material_clearCoat", this.clearCoat), this._setParameter("material_clearCoatGloss", this.clearCoatGloss), this._setParameter("material_clearCoatBumpiness", this.clearCoatBumpiness)), this._setParameter("material_gloss", s("gloss")), (!this.emissiveMap || this.emissiveTint) && this._setParameter("material_emissive", s("emissive")), this.emissiveIntensity !== 1 && this._setParameter("material_emissiveIntensity", this.emissiveIntensity), this.refraction > 0 && (this._setParameter("material_refraction", this.refraction), this._setParameter("material_refractionIndex", this.refractionIndex)), this.useDynamicRefraction && (this._setParameter("material_thickness", this.thickness), this._setParameter("material_attenuation", s("attenuation")), this._setParameter("material_invAttenuationDistance", this.attenuationDistance === 0 ? 0 : 1 / this.attenuationDistance)), this.useIridescence && (this._setParameter("material_iridescence", this.iridescence), this._setParameter("material_iridescenceRefractionIndex", this.iridescenceRefractionIndex), this._setParameter("material_iridescenceThicknessMin", this.iridescenceThicknessMin), this._setParameter("material_iridescenceThicknessMax", this.iridescenceThicknessMax)), this._setParameter("material_opacity", this.opacity), this.opacityFadesSpecular === !1 && this._setParameter("material_alphaFade", this.alphaFade), this.occludeSpecular && this._setParameter("material_occludeSpecularIntensity", this.occludeSpecularIntensity), this.cubeMapProjection === gv && this._setParameter(s("cubeMapProjectionBox"));
    for (const n in Rr)
      this._updateMap(n);
    this.ambientSH && this._setParameter("ambientSH[0]", this.ambientSH), this.normalMap && this._setParameter("material_bumpiness", this.bumpiness), this.normalMap && this.normalDetailMap && this._setParameter("material_normalDetailMapBumpiness", this.normalDetailMapBumpiness), this.heightMap && this._setParameter("material_heightMapFactor", s("heightMapFactor"));
    const i = this.shadingModel === Hs;
    this.envAtlas && this.cubeMap && !i ? (this._setParameter("texture_envAtlas", this.envAtlas), this._setParameter("texture_cubeMap", this.cubeMap)) : this.envAtlas && !i ? this._setParameter("texture_envAtlas", this.envAtlas) : this.cubeMap ? this._setParameter("texture_cubeMap", this.cubeMap) : this.sphereMap && this._setParameter("texture_sphereMap", this.sphereMap), this._setParameter("material_reflectivity", this.reflectivity), this._processParameters("_activeParams"), this._dirtyShader && this.clearVariants();
  }
  updateEnvUniforms(e, t) {
    const s = this.shadingModel === Hs;
    !(this.envAtlas && !s || this.cubeMap || this.sphereMap) && this.useSkybox && (t.envAtlas && t.skybox && !s ? (this._setParameter("texture_envAtlas", t.envAtlas), this._setParameter("texture_cubeMap", t.skybox)) : t.envAtlas && !s ? this._setParameter("texture_envAtlas", t.envAtlas) : t.skybox && this._setParameter("texture_cubeMap", t.skybox)), this._processParameters("_activeLightingParams");
  }
  getShaderVariant(e, t, s, i, n, a, o, h) {
    this.updateEnvUniforms(e, t);
    const l = n === As || n === Hr || Ut.isShadow(n);
    let c = l ? Cc.optionsContextMin : Cc.optionsContext;
    l ? this.shaderOptBuilder.updateMinRef(c, t, this, s, i, n, a) : this.shaderOptBuilder.updateRef(c, t, this, s, i, n, a), this.onUpdateShader && (c = this.onUpdateShader(c));
    const d = new $r(o, h), u = Vn(e);
    u.register("standard", Cc);
    const f = u.getProgram("standard", c, d);
    return this._dirtyShader = !1, f;
  }
  destroy() {
    for (const e in this._assetReferences)
      this._assetReferences[e]._unbind();
    this._assetReferences = null, super.destroy();
  }
}
Ht.TEXTURE_PARAMETERS = Xl;
Ht.CUBEMAP_PARAMETERS = Wu;
const jl = (r, e) => {
  fg[r] = e;
}, qu = (r, e, t, s) => {
  Object.defineProperty(Ht.prototype, r, {
    get: s || function() {
      return this[`_${r}`];
    },
    set: t
  }), ph[r] = {
    value: e
  };
}, PC = (r) => {
  const e = `_${r.name}`, t = r.dirtyShaderFunc || (() => !0), s = function(n) {
    const a = this[e];
    a !== n && (this._dirtyShader = this._dirtyShader || t(a, n), this[e] = n);
  };
  qu(r.name, () => r.defaultValue, s, r.getterFunc);
}, IC = (r) => {
  const e = `_${r.name}`, t = r.dirtyShaderFunc || (() => !0), s = function(n) {
    const a = this[e];
    a.equals(n) || (this._dirtyShader = this._dirtyShader || t(a, n), this[e] = a.copy(n));
  };
  qu(r.name, () => r.defaultValue.clone(), s, r.getterFunc);
}, cs = (r) => r.defaultValue && r.defaultValue.clone ? IC(r) : PC(r);
function Ze(r, e = "rgb", t = !0, s = 0) {
  Rr[r] = e.length || -1, cs({
    name: `${r}Map`,
    defaultValue: null,
    dirtyShaderFunc: (h, l) => !!h != !!l || h && (h.type !== l.type || h.fixCubemapSeams !== l.fixCubemapSeams || h.format !== l.format)
  }), cs({
    name: `${r}MapTiling`,
    defaultValue: new q(1, 1)
  }), cs({
    name: `${r}MapOffset`,
    defaultValue: new q(0, 0)
  }), cs({
    name: `${r}MapRotation`,
    defaultValue: 0
  }), cs({
    name: `${r}MapUv`,
    defaultValue: s
  }), e && (cs({
    name: `${r}MapChannel`,
    defaultValue: e
  }), t && (cs({
    name: `${r}VertexColor`,
    defaultValue: !1
  }), cs({
    name: `${r}VertexColorChannel`,
    defaultValue: e
  })));
  const i = `${r}MapTiling`, n = `${r}MapOffset`, a = `${r}MapRotation`, o = `${r}MapTransform`;
  jl(o, (h, l, c) => {
    const d = h[i], u = h[n], f = h[a];
    if (d.x === 1 && d.y === 1 && u.x === 0 && u.y === 0 && f === 0)
      return null;
    const m = h._allocUniform(o, () => [{
      name: `texture_${o}0`,
      value: new Float32Array(3)
    }, {
      name: `texture_${o}1`,
      value: new Float32Array(3)
    }]), _ = Math.cos(f * U.DEG_TO_RAD), p = Math.sin(f * U.DEG_TO_RAD), g = m[0].value;
    g[0] = _ * d.x, g[1] = -p * d.y, g[2] = u.x;
    const b = m[1].value;
    return b[0] = p * d.x, b[1] = _ * d.y, b[2] = 1 - d.y - u.y, m;
  });
}
function Zn(r, e) {
  cs({
    name: r,
    defaultValue: e,
    getterFunc: function() {
      return this._dirtyShader = !0, this[`_${r}`];
    }
  }), jl(r, (t, s, i) => {
    const n = t._allocUniform(r, () => new Float32Array(3)), a = t[r];
    return t.useGammaTonemap && i.gammaCorrection ? (n[0] = Math.pow(a.r, 2.2), n[1] = Math.pow(a.g, 2.2), n[2] = Math.pow(a.b, 2.2)) : (n[0] = a.r, n[1] = a.g, n[2] = a.b), n;
  });
}
function Ge(r, e, t) {
  cs({
    name: r,
    defaultValue: e,
    dirtyShaderFunc: (s, i) => (s === 0 || s === 1) != (i === 0 || i === 1)
  }), jl(r, t);
}
function oa(r, e) {
  cs({
    name: r,
    defaultValue: null,
    dirtyShaderFunc: (t, s) => !!t == !!s
  }), jl(r, e);
}
function Me(r, e) {
  cs({
    name: r,
    defaultValue: e
  });
}
function DC() {
  Zn("ambient", new z(0.7, 0.7, 0.7)), Zn("diffuse", new z(1, 1, 1)), Zn("specular", new z(0, 0, 0)), Zn("emissive", new z(0, 0, 0)), Zn("sheen", new z(1, 1, 1)), Zn("attenuation", new z(1, 1, 1)), Ge("emissiveIntensity", 1), Ge("specularityFactor", 1), Ge("sheenGloss", 0), Ge("gloss", 0.25, (s, i, n) => s.shadingModel === Hs ? Math.pow(2, s.gloss * 11) : s.gloss), Object.defineProperty(Ht.prototype, "shininess", {
    get: function() {
      return this.gloss * 100;
    },
    set: function(s) {
      this.gloss = s * 0.01;
    }
  }), Ge("heightMapFactor", 1, (s, i, n) => s.heightMapFactor * 0.025), Ge("opacity", 1), Ge("alphaFade", 1), Ge("alphaTest", 0), Ge("bumpiness", 1), Ge("normalDetailMapBumpiness", 1), Ge("reflectivity", 1), Ge("occludeSpecularIntensity", 1), Ge("refraction", 0), Ge("refractionIndex", 1 / 1.5), Ge("thickness", 0), Ge("attenuationDistance", 0), Ge("metalness", 1), Ge("anisotropy", 0), Ge("clearCoat", 0), Ge("clearCoatGloss", 1), Ge("clearCoatBumpiness", 1), Ge("aoUvSet", 0, null), Ge("iridescence", 0), Ge("iridescenceRefractionIndex", 1 / 1.5), Ge("iridescenceThicknessMin", 0), Ge("iridescenceThicknessMax", 0), oa("ambientSH"), oa("cubeMapProjectionBox", (s, i, n) => {
    const a = s._allocUniform("cubeMapProjectionBox", () => [{
      name: "envBoxMin",
      value: new Float32Array(3)
    }, {
      name: "envBoxMax",
      value: new Float32Array(3)
    }]), o = s.cubeMapProjectionBox.getMin(), h = a[0].value;
    h[0] = o.x, h[1] = o.y, h[2] = o.z;
    const l = s.cubeMapProjectionBox.getMax(), c = a[1].value;
    return c[0] = l.x, c[1] = l.y, c[2] = l.z, a;
  }), Me("ambientTint", !1), Me("diffuseTint", !1), Me("specularTint", !1), Me("specularityFactorTint", !1), Me("emissiveTint", !1), Me("fastTbn", !1), Me("useMetalness", !1), Me("useMetalnessSpecularColor", !1), Me("useSheen", !1), Me("enableGGXSpecular", !1), Me("occludeDirect", !1), Me("normalizeNormalMap", !0), Me("conserveEnergy", !0), Me("opacityFadesSpecular", !0), Me("occludeSpecular", ja), Me("shadingModel", Wl), Me("fresnelModel", Lu), Me("useDynamicRefraction", !1), Me("cubeMapProjection", _v), Me("customFragmentShader", null), Me("forceFragmentPrecision", null), Me("useFog", !0), Me("useLighting", !0), Me("useGammaTonemap", !0), Me("useSkybox", !0), Me("forceUv1", !1), Me("pixelSnap", !1), Me("twoSidedLighting", !1), Me("nineSlicedMode", void 0), Me("msdfTextAttribute", !1), Me("useIridescence", !1), Me("glossInvert", !1), Me("sheenGlossInvert", !1), Me("clearCoatGlossInvert", !1), Ze("diffuse"), Ze("specular"), Ze("emissive"), Ze("thickness", "g"), Ze("specularityFactor", "g"), Ze("normal", ""), Ze("metalness", "g"), Ze("gloss", "g"), Ze("opacity", "a"), Ze("refraction", "g"), Ze("height", "g", !1), Ze("ao", "g"), Ze("light", "rgb", !0, 1), Ze("msdf", ""), Ze("diffuseDetail", "rgb", !1), Ze("normalDetail", ""), Ze("clearCoat", "g"), Ze("clearCoatGloss", "g"), Ze("clearCoatNormal", ""), Ze("sheen", "rgb"), Ze("sheenGloss", "g"), Ze("iridescence", "g"), Ze("iridescenceThickness", "g"), Me("diffuseDetailMode", yv), oa("cubeMap"), oa("sphereMap"), oa("envAtlas");
  const r = function() {
    return this._prefilteredCubemaps;
  }, e = function(i) {
    const n = this._prefilteredCubemaps;
    i = i || [];
    let a = !1, o = !0;
    for (let h = 0; h < 6; ++h) {
      const l = i[h] || null;
      n[h] !== l && (n[h] = l, a = !0), o = o && !!n[h];
    }
    a && (o ? this.envAtlas = ug.generatePrefilteredAtlas(n, {
      target: this.envAtlas
    }) : this.envAtlas && (this.envAtlas.destroy(), this.envAtlas = null), this._dirtyShader = !0);
  }, t = [null, null, null, null, null, null];
  qu("prefilteredCubemaps", () => t.slice(), e, r);
}
DC();
let Ac, Mc, Bo, Fo;
function BC(r, e) {
  return r.drawOrder - e.drawOrder;
}
function FC(r, e) {
  return Ac = r._key[ci], Mc = e._key[ci], Ac === Mc && r.mesh && e.mesh ? e.mesh.id - r.mesh.id : Mc - Ac;
}
function OC(r, e) {
  return e.zdist - r.zdist;
}
function kC(r, e) {
  return r.zdist - e.zdist;
}
const NC = [null, BC, FC, OC, kC];
function zC(r, e) {
  return e.key - r.key;
}
let Ec = 0;
class bm {
  constructor() {
    this.list = [], this.length = 0, this.done = !1;
  }
}
class UC {
  constructor() {
    this.opaqueMeshInstances = [], this.transparentMeshInstances = [], this.shadowCasters = [], this.visibleOpaque = [], this.visibleTransparent = [];
  }
  prepare(e) {
    this.visibleOpaque[e] || (this.visibleOpaque[e] = new bm()), this.visibleTransparent[e] || (this.visibleTransparent[e] = new bm()), this.visibleOpaque[e].done = !1, this.visibleTransparent[e].done = !1;
  }
  delete(e) {
    e < this.visibleOpaque.length && this.visibleOpaque.splice(e, 1), e < this.visibleTransparent.length && this.visibleTransparent.splice(e, 1);
  }
}
class Sn {
  constructor(e = {}) {
    e.id !== void 0 ? (this.id = e.id, Ec = Math.max(this.id + 1, Ec)) : this.id = Ec++, this.name = e.name, this._enabled = e.enabled === void 0 ? !0 : e.enabled, this._refCounter = this._enabled ? 1 : 0, this.opaqueSortMode = e.opaqueSortMode === void 0 ? Ev : e.opaqueSortMode, this.transparentSortMode = e.transparentSortMode === void 0 ? Gf : e.transparentSortMode, e.renderTarget && (this.renderTarget = e.renderTarget), this.shaderPass = e.shaderPass === void 0 ? Er : e.shaderPass, this.passThrough = e.passThrough === void 0 ? !1 : e.passThrough, this._clearColorBuffer = !!e.clearColorBuffer, this._clearDepthBuffer = !!e.clearDepthBuffer, this._clearStencilBuffer = !!e.clearStencilBuffer, this.onPreCull = e.onPreCull, this.onPreRender = e.onPreRender, this.onPreRenderOpaque = e.onPreRenderOpaque, this.onPreRenderTransparent = e.onPreRenderTransparent, this.onPostCull = e.onPostCull, this.onPostRender = e.onPostRender, this.onPostRenderOpaque = e.onPostRenderOpaque, this.onPostRenderTransparent = e.onPostRenderTransparent, this.onDrawCall = e.onDrawCall, this.onEnable = e.onEnable, this.onDisable = e.onDisable, this._enabled && this.onEnable && this.onEnable(), this.layerReference = e.layerReference, this.instances = e.layerReference ? e.layerReference.instances : new UC(), this.cullingMask = e.cullingMask ? e.cullingMask : 4294967295, this.opaqueMeshInstances = this.instances.opaqueMeshInstances, this.transparentMeshInstances = this.instances.transparentMeshInstances, this.shadowCasters = this.instances.shadowCasters, this.customSortCallback = null, this.customCalculateSortValues = null, this._lights = [], this._lightsSet = /* @__PURE__ */ new Set(), this._clusteredLightsSet = /* @__PURE__ */ new Set(), this._splitLights = [[], [], []], this.cameras = [], this._dirty = !1, this._dirtyLights = !1, this._dirtyCameras = !1, this._lightHash = 0, this._staticLightHash = 0, this._needsStaticPrepare = !0, this._staticPrepareDone = !1, this._shaderVersion = -1, this._lightCube = null;
  }
  get hasClusteredLights() {
    return this._clusteredLightsSet.size > 0;
  }
  set enabled(e) {
    e !== this._enabled && (this._enabled = e, e ? (this.incrementCounter(), this.onEnable && this.onEnable()) : (this.decrementCounter(), this.onDisable && this.onDisable()));
  }
  get enabled() {
    return this._enabled;
  }
  set clearColorBuffer(e) {
    this._clearColorBuffer = e, this._dirtyCameras = !0;
  }
  get clearColorBuffer() {
    return this._clearColorBuffer;
  }
  set clearDepthBuffer(e) {
    this._clearDepthBuffer = e, this._dirtyCameras = !0;
  }
  get clearDepthBuffer() {
    return this._clearDepthBuffer;
  }
  set clearStencilBuffer(e) {
    this._clearStencilBuffer = e, this._dirtyCameras = !0;
  }
  get clearStencilBuffer() {
    return this._clearStencilBuffer;
  }
  get clusteredLightsSet() {
    return this._clusteredLightsSet;
  }
  incrementCounter() {
    this._refCounter === 0 && (this._enabled = !0, this.onEnable && this.onEnable()), this._refCounter++;
  }
  decrementCounter() {
    if (this._refCounter === 1)
      this._enabled = !1, this.onDisable && this.onDisable();
    else if (this._refCounter === 0)
      return;
    this._refCounter--;
  }
  addMeshInstances(e, t) {
    const s = this._shaderVersion, i = this.shadowCasters;
    for (let n = 0; n < e.length; n++) {
      const a = e[n], o = a.material, h = o.blendType === ss ? this.opaqueMeshInstances : this.transparentMeshInstances;
      this.opaqueMeshInstances.indexOf(a) < 0 && this.transparentMeshInstances.indexOf(a) < 0 && h.push(a), !t && a.castShadow && i.indexOf(a) < 0 && i.push(a), !this.passThrough && s >= 0 && o._shaderVersion !== s && (o.getShaderVariant !== Ki.prototype.getShaderVariant && o.clearVariants(), o._shaderVersion = s);
    }
    this.passThrough || (this._dirty = !0);
  }
  removeMeshInstanceFromArray(e, t) {
    let s = -1, i = 0;
    const n = t.length;
    for (let a = 0; a < n; a++) {
      const o = t[a];
      if (o === e) {
        s = a, i = 1;
        break;
      }
      if (o._staticSource === e)
        s < 0 && (s = a), i++;
      else if (s >= 0)
        break;
    }
    s >= 0 && t.splice(s, i);
  }
  removeMeshInstances(e, t) {
    const s = this.opaqueMeshInstances, i = this.transparentMeshInstances, n = this.shadowCasters;
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      if (this.removeMeshInstanceFromArray(o, s), this.removeMeshInstanceFromArray(o, i), !t) {
        const h = n.indexOf(o);
        h >= 0 && n.splice(h, 1);
      }
    }
    this._dirty = !0;
  }
  clearMeshInstances(e) {
    this.opaqueMeshInstances.length === 0 && this.transparentMeshInstances.length === 0 && (e || this.shadowCasters.length === 0) || (this.opaqueMeshInstances.length = 0, this.transparentMeshInstances.length = 0, e || (this.shadowCasters.length = 0), this.passThrough || (this._dirty = !0));
  }
  addLight(e) {
    const t = e.light;
    this._lightsSet.has(t) || (this._lightsSet.add(t), this._lights.push(t), this._dirtyLights = !0, this._generateLightHash()), t.type !== de && this._clusteredLightsSet.add(t);
  }
  removeLight(e) {
    const t = e.light;
    this._lightsSet.has(t) && (this._lightsSet.delete(t), this._lights.splice(this._lights.indexOf(t), 1), this._dirtyLights = !0, this._generateLightHash()), t.type !== de && this._clusteredLightsSet.delete(t);
  }
  clearLights() {
    this._lightsSet.clear(), this._clusteredLightsSet.clear(), this._lights.length = 0, this._dirtyLights = !0;
  }
  addShadowCasters(e) {
    const t = this.shadowCasters;
    for (let s = 0; s < e.length; s++) {
      const i = e[s];
      i.castShadow && t.indexOf(i) < 0 && t.push(i);
    }
    this._dirtyLights = !0;
  }
  removeShadowCasters(e) {
    const t = this.shadowCasters;
    for (let s = 0; s < e.length; s++) {
      const i = t.indexOf(e[s]);
      i >= 0 && t.splice(i, 1);
    }
    this._dirtyLights = !0;
  }
  _generateLightHash() {
    if (this._lights.length > 0) {
      this._lights.sort(zC);
      let e = "", t = "";
      for (let s = 0; s < this._lights.length; s++)
        this._lights[s].isStatic ? t += this._lights[s].key : e += this._lights[s].key;
      e.length === 0 ? this._lightHash = 0 : this._lightHash = Wa(e), t.length === 0 ? this._staticLightHash = 0 : this._staticLightHash = Wa(t);
    } else
      this._lightHash = 0, this._staticLightHash = 0;
  }
  addCamera(e) {
    this.cameras.indexOf(e) >= 0 || (this.cameras.push(e), this._dirtyCameras = !0);
  }
  removeCamera(e) {
    const t = this.cameras.indexOf(e);
    t >= 0 && (this.cameras.splice(t, 1), this._dirtyCameras = !0, this.instances.delete(t));
  }
  clearCameras() {
    this.cameras.length = 0, this._dirtyCameras = !0;
  }
  _calculateSortDistances(e, t, s, i) {
    for (let n = 0; n < t; n++) {
      const a = e[n];
      if (a.command || a.layer <= ov)
        continue;
      if (a.calculateSortDistance) {
        a.zdist = a.calculateSortDistance(a, s, i);
        continue;
      }
      const o = a.aabb.center, h = o.x - s.x, l = o.y - s.y, c = o.z - s.z;
      a.zdist = h * i.x + l * i.y + c * i.z;
    }
  }
  _sortVisible(e, t, s) {
    const i = this.instances, n = e ? this.transparentSortMode : this.opaqueSortMode;
    if (n === Rd)
      return;
    const a = e ? i.visibleTransparent[s] : i.visibleOpaque[s];
    n === Lv ? (Bo = t.getPosition(), Fo = t.forward, this.customCalculateSortValues && this.customCalculateSortValues(a.list, a.length, Bo, Fo), a.list.length !== a.length && (a.list.length = a.length), this.customSortCallback && a.list.sort(this.customSortCallback)) : ((n === Gf || n === Rv) && (Bo = t.getPosition(), Fo = t.forward, this._calculateSortDistances(a.list, a.length, Bo, Fo)), a.list.length !== a.length && (a.list.length = a.length), a.list.sort(NC[n]));
  }
}
const wm = ["uSceneDepthMap", "uDepthMap"], Tm = ["uSceneColorMap", "texture_grabPass"];
class mg {
  constructor(e, t) {
    this.scene = t, this.device = e, this.layer = null, this.device.webgl2 || this.device.deviceType === Et ? this.initMainPath() : this.initFallbackPath();
  }
  static requiresRenderPass(e, t) {
    return e.webgl2 || e.deviceType === Et ? !1 : t.renderSceneDepthMap;
  }
  setupUniform(e, t, s) {
    (t ? wm : Tm).forEach((n) => e.scope.resolve(n).setValue(s));
  }
  allocateTexture(e, t, s, i, n, a) {
    return new ue(e, {
      name: s,
      format: i,
      width: t ? t.colorBuffer.width : e.width,
      height: t ? t.colorBuffer.height : e.height,
      mipmaps: a,
      minFilter: n ? Be : a ? Ln : rt,
      magFilter: n ? Be : rt,
      addressU: he,
      addressV: he
    });
  }
  getSourceColorFormat(e) {
    var t;
    return (t = e == null ? void 0 : e.format) != null ? t : this.device.framebufferFormat;
  }
  shouldReallocate(e, t, s) {
    if (s) {
      const a = e == null ? void 0 : e.colorBuffer.format, o = this.getSourceColorFormat(t);
      if (a !== o)
        return !0;
    }
    const i = (t == null ? void 0 : t.width) || this.device.width, n = (t == null ? void 0 : t.height) || this.device.height;
    return !e || i !== e.width || n !== e.height;
  }
  allocateRenderTarget(e, t, s, i, n, a, o) {
    const h = o ? wm : Tm, l = this.allocateTexture(s, t, h[0], i, n, a);
    return e ? (e.destroyFrameBuffers(), n ? e._depthBuffer = l : e._colorBuffer = l) : e = new Dt({
      name: "renderTargetSceneGrab",
      colorBuffer: n ? null : l,
      depthBuffer: n ? l : null,
      depth: !n,
      stencil: s.supportsStencil,
      autoResolve: !1
    }), e;
  }
  releaseRenderTarget(e) {
    e && (e.destroyTextureBuffers(), e.destroy());
  }
  initMainPath() {
    const e = this.device, t = this;
    this.layer = new Sn({
      enabled: !1,
      name: "Depth",
      id: kt,
      onDisable: function() {
        t.releaseRenderTarget(this.depthRenderTarget), this.depthRenderTarget = null, t.releaseRenderTarget(this.colorRenderTarget), this.colorRenderTarget = null;
      },
      onPreRenderOpaque: function(s) {
        const i = this.cameras[s];
        if (i.renderSceneColorMap) {
          var n;
          if (t.shouldReallocate(this.colorRenderTarget, (n = i.renderTarget) == null ? void 0 : n.colorBuffer, !0)) {
            var a;
            t.releaseRenderTarget(this.colorRenderTarget);
            const l = t.getSourceColorFormat((a = i.renderTarget) == null ? void 0 : a.colorBuffer);
            this.colorRenderTarget = t.allocateRenderTarget(this.colorRenderTarget, i.renderTarget, e, l, !1, !0, !1);
          }
          const h = this.colorRenderTarget.colorBuffer;
          e.deviceType === Et ? e.copyRenderTarget(i.renderTarget, this.colorRenderTarget, !0, !1) : (e.copyRenderTarget(e.renderTarget, this.colorRenderTarget, !0, !1), e.activeTexture(e.maxCombinedTextures - 1), e.bindTexture(h), e.gl.generateMipmap(h.impl._glTarget)), t.setupUniform(e, !1, h);
        }
        if (i.renderSceneDepthMap) {
          var o;
          t.shouldReallocate(this.depthRenderTarget, (o = i.renderTarget) == null ? void 0 : o.depthBuffer) && (t.releaseRenderTarget(this.depthRenderTarget), this.depthRenderTarget = t.allocateRenderTarget(this.depthRenderTarget, i.renderTarget, e, Al, !0, !1, !0)), e.copyRenderTarget(e.renderTarget, this.depthRenderTarget, !1, !0), t.setupUniform(e, !0, this.depthRenderTarget.depthBuffer);
        }
      },
      onPostRenderOpaque: function(s) {
      }
    });
  }
  initFallbackPath() {
    const e = this, t = this.device, s = this.scene;
    this.layer = new Sn({
      enabled: !1,
      name: "Depth",
      id: kt,
      shaderPass: As,
      onEnable: function() {
        this.depthRenderTarget = new Dt({
          name: "depthRenderTarget-webgl1",
          depth: !0,
          stencil: t.supportsStencil,
          autoResolve: !1,
          graphicsDevice: t
        }), this.renderTarget = this.depthRenderTarget;
      },
      onDisable: function() {
        this.depthRenderTarget.destroyTextureBuffers(), this.renderTarget = null, e.releaseRenderTarget(this.colorRenderTarget), this.colorRenderTarget = null;
      },
      onPostCull: function(i) {
        const n = this.cameras[i];
        if (n.renderSceneDepthMap) {
          var a;
          (!this.depthRenderTarget.depthBuffer || e.shouldReallocate(this.depthRenderTarget, (a = n.renderTarget) == null ? void 0 : a.depthBuffer)) && (this.depthRenderTarget.destroyTextureBuffers(), this.depthRenderTarget = e.allocateRenderTarget(this.depthRenderTarget, n.renderTarget, t, ye, !1, !1, !0));
          const o = this.instances.visibleOpaque[i], h = o.list, l = s.layers, c = l.subLayerEnabled, d = l.subLayerList, u = l.getLayerById(wi).renderTarget;
          let f = 0;
          const m = l.layerList;
          for (let _ = 0; _ < m.length; _++) {
            const p = m[_];
            if (p === this)
              break;
            if (p.renderTarget !== u || !p.enabled || !c[_])
              continue;
            const g = p.cameras.indexOf(n);
            if (g < 0)
              continue;
            let x = d[_] ? p.instances.visibleTransparent[g] : p.instances.visibleOpaque[g];
            const y = x.length;
            x = x.list;
            for (let S = 0; S < y; S++) {
              const C = x[S];
              C.material && C.material.depthWrite && !C._noDepthDrawGl1 && (h[f] = C, f++);
            }
          }
          o.length = f;
        }
      },
      onPreRenderOpaque: function(i) {
        const n = this.cameras[i];
        if (n.renderSceneColorMap) {
          var a;
          if (e.shouldReallocate(this.colorRenderTarget, (a = n.renderTarget) == null ? void 0 : a.colorBuffer)) {
            var o;
            e.releaseRenderTarget(this.colorRenderTarget);
            const c = e.getSourceColorFormat((o = n.renderTarget) == null ? void 0 : o.colorBuffer);
            this.colorRenderTarget = e.allocateRenderTarget(this.colorRenderTarget, n.renderTarget, t, c, !1, !1, !1);
          }
          const h = this.colorRenderTarget._colorBuffer;
          h.impl._glTexture || h.impl.initialize(t, h), t.bindTexture(h);
          const l = t.gl;
          l.copyTexImage2D(l.TEXTURE_2D, 0, h.impl._glFormat, 0, 0, h.width, h.height, 0), h._needsUpload = !1, h._needsMipmapsUpload = !1, e.setupUniform(t, !1, h);
        }
        n.renderSceneDepthMap && e.setupUniform(t, !0, this.depthRenderTarget.colorBuffer);
      },
      onDrawCall: function() {
        t.setColorWrite(!0, !0, !0, !0);
      },
      onPostRenderOpaque: function(i) {
        if (this.cameras[i].renderSceneDepthMap) {
          const a = this.instances.visibleOpaque[i];
          a.length = 0;
        }
      }
    });
  }
  patch(e) {
    e.onEnable = this.layer.onEnable, e.onDisable = this.layer.onDisable, e.onPreRenderOpaque = this.layer.onPreRenderOpaque, e.onPostRenderOpaque = this.layer.onPostRenderOpaque, e.shaderPass = this.layer.shaderPass, e.onPostCull = this.layer.onPostCull, e.onDrawCall = this.layer.onDrawCall;
  }
}
const VC = new z(254 / 255, 254 / 255, 254 / 255, 254 / 255), Di = {
  drawCalls: [],
  isNewMaterial: [],
  lightMaskChanged: []
};
class GC extends eC {
  constructor(e) {
    super(e);
    const t = this.device;
    this._forwardDrawCalls = 0, this._materialSwitches = 0, this._depthMapTime = 0, this._forwardTime = 0, this._sortTime = 0;
    const s = t.scope;
    this.fogColorId = s.resolve("fog_color"), this.fogStartId = s.resolve("fog_start"), this.fogEndId = s.resolve("fog_end"), this.fogDensityId = s.resolve("fog_density"), this.ambientId = s.resolve("light_globalAmbient"), this.skyboxIntensityId = s.resolve("skyboxIntensity"), this.cubeMapRotationMatrixId = s.resolve("cubeMapRotationMatrix"), this.lightColorId = [], this.lightDir = [], this.lightDirId = [], this.lightShadowMapId = [], this.lightShadowMatrixId = [], this.lightShadowParamsId = [], this.lightShadowIntensity = [], this.lightRadiusId = [], this.lightPos = [], this.lightPosId = [], this.lightWidth = [], this.lightWidthId = [], this.lightHeight = [], this.lightHeightId = [], this.lightInAngleId = [], this.lightOutAngleId = [], this.lightCookieId = [], this.lightCookieIntId = [], this.lightCookieMatrixId = [], this.lightCookieOffsetId = [], this.shadowMatrixPaletteId = [], this.shadowCascadeDistancesId = [], this.shadowCascadeCountId = [], this.screenSizeId = s.resolve("uScreenSize"), this._screenSize = new Float32Array(4), this.fogColor = new Float32Array(3), this.ambientColor = new Float32Array(3);
  }
  destroy() {
    super.destroy();
  }
  dispatchGlobalLights(e) {
    if (this.ambientColor[0] = e.ambientLight.r, this.ambientColor[1] = e.ambientLight.g, this.ambientColor[2] = e.ambientLight.b, e.gammaCorrection)
      for (let t = 0; t < 3; t++)
        this.ambientColor[t] = Math.pow(this.ambientColor[t], 2.2);
    if (e.physicalUnits)
      for (let t = 0; t < 3; t++)
        this.ambientColor[t] *= e.ambientLuminance;
    this.ambientId.setValue(this.ambientColor), this.skyboxIntensityId.setValue(e.physicalUnits ? e.skyboxLuminance : e.skyboxIntensity), this.cubeMapRotationMatrixId.setValue(e._skyboxRotationMat3.data);
  }
  _resolveLight(e, t) {
    const s = "light" + t;
    this.lightColorId[t] = e.resolve(s + "_color"), this.lightDir[t] = new Float32Array(3), this.lightDirId[t] = e.resolve(s + "_direction"), this.lightShadowMapId[t] = e.resolve(s + "_shadowMap"), this.lightShadowMatrixId[t] = e.resolve(s + "_shadowMatrix"), this.lightShadowParamsId[t] = e.resolve(s + "_shadowParams"), this.lightShadowIntensity[t] = e.resolve(s + "_shadowIntensity"), this.lightRadiusId[t] = e.resolve(s + "_radius"), this.lightPos[t] = new Float32Array(3), this.lightPosId[t] = e.resolve(s + "_position"), this.lightWidth[t] = new Float32Array(3), this.lightWidthId[t] = e.resolve(s + "_halfWidth"), this.lightHeight[t] = new Float32Array(3), this.lightHeightId[t] = e.resolve(s + "_halfHeight"), this.lightInAngleId[t] = e.resolve(s + "_innerConeAngle"), this.lightOutAngleId[t] = e.resolve(s + "_outerConeAngle"), this.lightCookieId[t] = e.resolve(s + "_cookie"), this.lightCookieIntId[t] = e.resolve(s + "_cookieIntensity"), this.lightCookieMatrixId[t] = e.resolve(s + "_cookieMatrix"), this.lightCookieOffsetId[t] = e.resolve(s + "_cookieOffset"), this.shadowMatrixPaletteId[t] = e.resolve(s + "_shadowMatrixPalette[0]"), this.shadowCascadeDistancesId[t] = e.resolve(s + "_shadowCascadeDistances[0]"), this.shadowCascadeCountId[t] = e.resolve(s + "_shadowCascadeCount");
  }
  setLTCDirectionalLight(e, t, s, i, n) {
    this.lightPos[t][0] = i.x - s.x * n, this.lightPos[t][1] = i.y - s.y * n, this.lightPos[t][2] = i.z - s.z * n, this.lightPosId[t].setValue(this.lightPos[t]);
    const a = e.transformVector(new v(-0.5, 0, 0));
    this.lightWidth[t][0] = a.x * n, this.lightWidth[t][1] = a.y * n, this.lightWidth[t][2] = a.z * n, this.lightWidthId[t].setValue(this.lightWidth[t]);
    const o = e.transformVector(new v(0, 0, 0.5));
    this.lightHeight[t][0] = o.x * n, this.lightHeight[t][1] = o.y * n, this.lightHeight[t][2] = o.z * n, this.lightHeightId[t].setValue(this.lightHeight[t]);
  }
  dispatchDirectLights(e, t, s, i) {
    let n = 0;
    const a = this.device.scope;
    for (let o = 0; o < e.length; o++) {
      if (!(e[o].mask & s))
        continue;
      const h = e[o], l = h._node.getWorldTransform();
      if (this.lightColorId[n] || this._resolveLight(a, n), this.lightColorId[n].setValue(t.gammaCorrection ? h._linearFinalColor : h._finalColor), l.getY(h._direction).mulScalar(-1), h._direction.normalize(), this.lightDir[n][0] = h._direction.x, this.lightDir[n][1] = h._direction.y, this.lightDir[n][2] = h._direction.z, this.lightDirId[n].setValue(this.lightDir[n]), h.shape !== Mt && this.setLTCDirectionalLight(l, n, h._direction, i._node.getPosition(), i.farClip), h.castShadows) {
        const c = h.getRenderData(i, 0), d = h._getUniformBiasValues(c);
        this.lightShadowMapId[n].setValue(c.shadowBuffer), this.lightShadowMatrixId[n].setValue(c.shadowMatrix.data), this.shadowMatrixPaletteId[n].setValue(h._shadowMatrixPalette), this.shadowCascadeDistancesId[n].setValue(h._shadowCascadeDistances), this.shadowCascadeCountId[n].setValue(h.numCascades), this.lightShadowIntensity[n].setValue(h.shadowIntensity);
        const u = h._shadowRenderParams;
        u.length = 3, u[0] = h._shadowResolution, u[1] = d.normalBias, u[2] = d.bias, this.lightShadowParamsId[n].setValue(u);
      }
      n++;
    }
    return n;
  }
  setLTCPositionalLight(e, t) {
    const s = e.transformVector(new v(-0.5, 0, 0));
    this.lightWidth[t][0] = s.x, this.lightWidth[t][1] = s.y, this.lightWidth[t][2] = s.z, this.lightWidthId[t].setValue(this.lightWidth[t]);
    const i = e.transformVector(new v(0, 0, 0.5));
    this.lightHeight[t][0] = i.x, this.lightHeight[t][1] = i.y, this.lightHeight[t][2] = i.z, this.lightHeightId[t].setValue(this.lightHeight[t]);
  }
  dispatchOmniLight(e, t, s, i) {
    const n = s._node.getWorldTransform();
    if (this.lightColorId[i] || this._resolveLight(t, i), this.lightRadiusId[i].setValue(s.attenuationEnd), this.lightColorId[i].setValue(e.gammaCorrection ? s._linearFinalColor : s._finalColor), n.getTranslation(s._position), this.lightPos[i][0] = s._position.x, this.lightPos[i][1] = s._position.y, this.lightPos[i][2] = s._position.z, this.lightPosId[i].setValue(this.lightPos[i]), s.shape !== Mt && this.setLTCPositionalLight(n, i), s.castShadows) {
      const a = s.getRenderData(null, 0);
      this.lightShadowMapId[i].setValue(a.shadowBuffer);
      const o = s._getUniformBiasValues(a), h = s._shadowRenderParams;
      h.length = 4, h[0] = s._shadowResolution, h[1] = o.normalBias, h[2] = o.bias, h[3] = 1 / s.attenuationEnd, this.lightShadowParamsId[i].setValue(h), this.lightShadowIntensity[i].setValue(s.shadowIntensity);
    }
    s._cookie && (this.lightCookieId[i].setValue(s._cookie), this.lightShadowMatrixId[i].setValue(n.data), this.lightCookieIntId[i].setValue(s.cookieIntensity));
  }
  dispatchSpotLight(e, t, s, i) {
    const n = s._node.getWorldTransform();
    if (this.lightColorId[i] || this._resolveLight(t, i), this.lightInAngleId[i].setValue(s._innerConeAngleCos), this.lightOutAngleId[i].setValue(s._outerConeAngleCos), this.lightRadiusId[i].setValue(s.attenuationEnd), this.lightColorId[i].setValue(e.gammaCorrection ? s._linearFinalColor : s._finalColor), n.getTranslation(s._position), this.lightPos[i][0] = s._position.x, this.lightPos[i][1] = s._position.y, this.lightPos[i][2] = s._position.z, this.lightPosId[i].setValue(this.lightPos[i]), s.shape !== Mt && this.setLTCPositionalLight(n, i), n.getY(s._direction).mulScalar(-1), s._direction.normalize(), this.lightDir[i][0] = s._direction.x, this.lightDir[i][1] = s._direction.y, this.lightDir[i][2] = s._direction.z, this.lightDirId[i].setValue(this.lightDir[i]), s.castShadows) {
      const a = s.getRenderData(null, 0);
      this.lightShadowMapId[i].setValue(a.shadowBuffer), this.lightShadowMatrixId[i].setValue(a.shadowMatrix.data);
      const o = s._getUniformBiasValues(a), h = s._shadowRenderParams;
      h.length = 4, h[0] = s._shadowResolution, h[1] = o.normalBias, h[2] = o.bias, h[3] = 1 / s.attenuationEnd, this.lightShadowParamsId[i].setValue(h), this.lightShadowIntensity[i].setValue(s.shadowIntensity);
    }
    if (s._cookie) {
      if (!s.castShadows) {
        const a = Ms.evalSpotCookieMatrix(s);
        this.lightShadowMatrixId[i].setValue(a.data);
      }
      this.lightCookieId[i].setValue(s._cookie), this.lightCookieIntId[i].setValue(s.cookieIntensity), s._cookieTransform && (s._cookieTransformUniform[0] = s._cookieTransform.x, s._cookieTransformUniform[1] = s._cookieTransform.y, s._cookieTransformUniform[2] = s._cookieTransform.z, s._cookieTransformUniform[3] = s._cookieTransform.w, this.lightCookieMatrixId[i].setValue(s._cookieTransformUniform), s._cookieOffsetUniform[0] = s._cookieOffset.x, s._cookieOffsetUniform[1] = s._cookieOffset.y, this.lightCookieOffsetId[i].setValue(s._cookieOffsetUniform));
    }
  }
  dispatchLocalLights(e, t, s, i, n) {
    let a = i;
    const o = this.device.scope, h = e[Se], l = h.length;
    for (let f = 0; f < l; f++) {
      const m = h[f];
      m.mask & s && (m.isStatic || (this.dispatchOmniLight(t, o, m, a), a++));
    }
    let c = 0;
    if (n) {
      let f = n[c];
      for (; f && f._type === Se; )
        this.dispatchOmniLight(t, o, f, a), a++, c++, f = n[c];
    }
    const d = e[Ee], u = d.length;
    for (let f = 0; f < u; f++) {
      const m = d[f];
      m.mask & s && (m.isStatic || (this.dispatchSpotLight(t, o, m, a), a++));
    }
    if (n) {
      let f = n[c];
      for (; f && f._type === Ee; )
        this.dispatchSpotLight(t, o, f, a), a++, c++, f = n[c];
    }
  }
  renderShadowsLocal(e, t) {
    const s = this.scene.clusteredLightingEnabled;
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      s && !n.atlasViewportAllocated || this.shadowRenderer.render(n, t);
    }
  }
  renderForwardPrepareMaterials(e, t, s, i, n, a, o) {
    const h = (p, g, b) => {
      Di.drawCalls.push(p), Di.isNewMaterial.push(g), Di.lightMaskChanged.push(b);
    };
    Di.drawCalls.length = 0, Di.isNewMaterial.length = 0, Di.lightMaskChanged.length = 0;
    const l = this.device, c = this.scene, d = a ? a._lightHash : 0;
    let u = null, f, m, _;
    for (let p = 0; p < s; p++) {
      const g = t[p];
      if (!(n && g.mask && !(n & g.mask)))
        if (g.command)
          h(g, !1, !1);
        else {
          g.ensureMaterial(l);
          const b = g.material, x = g._shaderDefs, y = g.mask;
          if (b && b === u && x !== f && (u = null), (g.isStatic || m) && (u = null), b !== u && (this._materialSwitches++, b._scene = c, b.dirty && (b.updateUniforms(l, c), b.dirty = !1), b._dirtyBlend && (c.layers._dirtyBlend = !0)), !g._shader[o] || g._shaderDefs !== x || g._lightHash !== d) {
            if (g.isStatic)
              g.updatePassShader(c, o, g._staticLightList, i, this.viewUniformFormat, this.viewBindGroupFormat);
            else {
              const S = o + "_" + x + "_" + d;
              g._shader[o] = b.variants[S], g._shader[o] || (g.updatePassShader(c, o, null, i, this.viewUniformFormat, this.viewBindGroupFormat), b.variants[S] = g._shader[o]);
            }
            g._lightHash = d;
          }
          h(g, b !== u, !u || y !== _), u = b, f = x, _ = y, m = g.isStatic;
        }
    }
    return l.endShaderBatch == null || l.endShaderBatch(), Di;
  }
  renderForwardInternal(e, t, s, i, n, a) {
    const o = this.device, h = this.scene, l = 1 << i;
    let c = !1;
    const d = t.drawCalls.length;
    for (let u = 0; u < d; u++) {
      const f = t.drawCalls[u];
      if (f.command)
        f.command();
      else {
        const m = t.isNewMaterial[u], _ = t.lightMaskChanged[u], p = f.material;
        f._shaderDefs;
        const g = f.mask;
        if (m) {
          const C = f._shader[i];
          if (!C.failed && o.setShader(C), c = C.failed, c)
            break;
          if (p.setParameters(o), _) {
            const w = this.dispatchDirectLights(s[de], h, g, e);
            this.dispatchLocalLights(s, h, g, w, f._staticLightList);
          }
          this.alphaTestId.setValue(p.alphaTest), o.setBlending(p.blend), p.blend && (p.separateAlphaBlend ? (o.setBlendFunctionSeparate(p.blendSrc, p.blendDst, p.blendSrcAlpha, p.blendDstAlpha), o.setBlendEquationSeparate(p.blendEquation, p.blendAlphaEquation)) : (o.setBlendFunction(p.blendSrc, p.blendDst), o.setBlendEquation(p.blendEquation))), o.setColorWrite(p.redWrite, p.greenWrite, p.blueWrite, p.alphaWrite), o.setDepthWrite(p.depthWrite), p.depthWrite && !p.depthTest ? (o.setDepthFunc(Mn), o.setDepthTest(!0)) : (o.setDepthFunc(p.depthFunc), o.setDepthTest(p.depthTest)), o.setAlphaToCoverage(p.alphaToCoverage), p.depthBias || p.slopeDepthBias ? (o.setDepthBias(!0), o.setDepthBiasValues(p.depthBias, p.slopeDepthBias)) : o.setDepthBias(!1);
        }
        this.setCullMode(e._cullFaces, a, f);
        const b = f.stencilFront || p.stencilFront, x = f.stencilBack || p.stencilBack;
        b || x ? (o.setStencilTest(!0), b === x ? (o.setStencilFunc(b.func, b.ref, b.readMask), o.setStencilOperation(b.fail, b.zfail, b.zpass, b.writeMask)) : (b ? (o.setStencilFuncFront(b.func, b.ref, b.readMask), o.setStencilOperationFront(b.fail, b.zfail, b.zpass, b.writeMask)) : (o.setStencilFuncFront(Mn, 0, 255), o.setStencilOperationFront(us, us, us, 255)), x ? (o.setStencilFuncBack(x.func, x.ref, x.readMask), o.setStencilOperationBack(x.fail, x.zfail, x.zpass, x.writeMask)) : (o.setStencilFuncBack(Mn, 0, 255), o.setStencilOperationBack(us, us, us, 255)))) : o.setStencilTest(!1);
        const y = f.mesh;
        f.setParameters(o, l), this.setVertexBuffers(o, y), this.setMorphing(o, f.morphInstance), this.setSkinning(o, f), this.setupMeshUniformBuffers(f, i);
        const S = f.renderStyle;
        if (o.setIndexBuffer(y.indexBuffer[S]), n && n(f, u), e.xr && e.xr.session && e.xr.views.length) {
          const C = e.xr.views;
          for (let w = 0; w < C.length; w++) {
            const M = C[w];
            o.setViewport(M.viewport.x, M.viewport.y, M.viewport.z, M.viewport.w), this.projId.setValue(M.projMat.data), this.projSkyboxId.setValue(M.projMat.data), this.viewId.setValue(M.viewOffMat.data), this.viewInvId.setValue(M.viewInvOffMat.data), this.viewId3.setValue(M.viewMat3.data), this.viewProjId.setValue(M.projViewOffMat.data), this.viewPosId.setValue(M.position), w === 0 ? this.drawInstance(o, f, y, S, !0) : this.drawInstance2(o, f, y, S), this._forwardDrawCalls++;
          }
        } else
          this.drawInstance(o, f, y, S, !0), this._forwardDrawCalls++;
        u < d - 1 && !t.isNewMaterial[u + 1] && p.setParameters(o, f.parameters);
      }
    }
  }
  renderForward(e, t, s, i, n, a, o, h, l) {
    const c = this.renderForwardPrepareMaterials(e, t, s, i, a, h, n);
    this.renderForwardInternal(e, c, i, n, o, l), Di.length = 0;
  }
  setSceneConstants() {
    const e = this.scene;
    if (this.dispatchGlobalLights(e), e.fog !== Hl) {
      if (this.fogColor[0] = e.fogColor.r, this.fogColor[1] = e.fogColor.g, this.fogColor[2] = e.fogColor.b, e.gammaCorrection)
        for (let s = 0; s < 3; s++)
          this.fogColor[s] = Math.pow(this.fogColor[s], 2.2);
      this.fogColorId.setValue(this.fogColor), e.fog === rv ? (this.fogStartId.setValue(e.fogStart), this.fogEndId.setValue(e.fogEnd)) : this.fogDensityId.setValue(e.fogDensity);
    }
    const t = this.device;
    this._screenSize[0] = t.width, this._screenSize[1] = t.height, this._screenSize[2] = 1 / t.width, this._screenSize[3] = 1 / t.height, this.screenSizeId.setValue(this._screenSize);
  }
  updateLightStats(e, t) {
  }
  buildFrameGraph(e, t) {
    e.reset(), this.update(t);
    const s = this.scene.clusteredLightingEnabled;
    if (s) {
      const l = new vr(this.device, () => {
        this.scene.lighting.cookiesEnabled && (this.renderCookies(t._splitLights[Ee]), this.renderCookies(t._splitLights[Se]));
      });
      l.requiresCubemaps = !1, e.addRenderPass(l);
    }
    const i = new vr(this.device, () => {
      (!s || s && this.scene.lighting.shadowsEnabled) && (this.renderShadowsLocal(t._splitLights[Ee]), this.renderShadowsLocal(t._splitLights[Se])), s && this.updateClusters(t);
    });
    i.requiresCubemaps = !1, e.addRenderPass(i);
    let n = 0, a = !0, o = null;
    const h = t._renderActions;
    for (let l = n; l < h.length; l++) {
      const c = h[l], d = t.layerList[c.layerIndex], u = d.cameras[c.cameraIndex];
      if (!c.isLayerEnabled(t))
        continue;
      const m = d.id === kt && (u.renderSceneColorMap || u.renderSceneDepthMap);
      c.hasDirectionalShadowLights && u && this._shadowRendererDirectional.buildFrameGraph(e, c, u), a && (a = !1, n = l, o = c.renderTarget);
      let _ = l + 1;
      for (; h[_] && !h[_].isLayerEnabled(t); )
        _++;
      const p = h[_], b = (p ? t.layerList[p.layerIndex].id === kt : !1) && (u.renderSceneColorMap || u.renderSceneDepthMap);
      if (!p || p.renderTarget !== o || p.hasDirectionalShadowLights || b || m) {
        if (this.addMainRenderPass(e, t, o, n, l, m), c.triggerPostprocess && u != null && u.onPostprocessing) {
          const x = new vr(this.device, () => {
            this.renderPassPostprocessing(c, t);
          });
          x.requiresCubemaps = !1, e.addRenderPass(x);
        }
        a = !0;
      }
    }
  }
  addMainRenderPass(e, t, s, i, n, a) {
    const o = {
      start: i,
      end: n
    }, h = new vr(this.device, () => {
      this.renderPassRenderActions(t, o);
    }), l = t._renderActions, c = l[i], d = l[n], f = t.layerList[c.layerIndex].cameras[c.cameraIndex];
    f && (c.firstCameraUse && f.onPreRender && (h.before = () => {
      f.onPreRender();
    }), d.lastCameraUse && f.onPostRender && (h.after = () => {
      f.onPostRender();
    }));
    const m = a && mg.requiresRenderPass(this.device, f);
    (!a || m) && (h.init(s), h.fullSizeClearRect = f.camera.fullSizeClearRect, m ? (h.setClearColor(VC), h.setClearDepth(1)) : h.fullSizeClearRect && (c.clearColor && h.setClearColor(f.camera.clearColor), c.clearDepth && h.setClearDepth(f.camera.clearDepth), c.clearStencil && h.setClearStencil(f.camera.clearStencil))), e.addRenderPass(h);
  }
  update(e) {
    this.frameUpdate(), this.shadowRenderer.frameUpdate();
    const t = this.scene.clusteredLightingEnabled;
    this.scene._updateSky(this.device);
    const s = this.updateLayerComposition(e, t), i = (s & mr) !== 0;
    this.updateLightStats(e, s), this.beginFrame(e, i), this.setSceneConstants(), this.cullComposition(e), this.gpuUpdate(e._meshInstances);
  }
  renderPassPostprocessing(e, t) {
    t.layerList[e.layerIndex].cameras[e.cameraIndex].onPostprocessing();
  }
  renderPassRenderActions(e, t) {
    const s = e._renderActions;
    for (let i = t.start; i <= t.end; i++)
      this.renderRenderAction(e, s[i], i === t.start);
  }
  renderRenderAction(e, t, s) {
    const i = this.scene.clusteredLightingEnabled, n = this.device, a = t.layerIndex, o = e.layerList[a], h = e.subLayerList[a], l = t.cameraIndex, c = o.cameras[l];
    if (t.isLayerEnabled(e)) {
      if (!h && o.onPreRenderOpaque ? o.onPreRenderOpaque(l) : h && o.onPreRenderTransparent && o.onPreRenderTransparent(l), o._preRenderCalledForCameras & 1 << l || (o.onPreRender && o.onPreRender(l), o._preRenderCalledForCameras |= 1 << l), c) {
        var d;
        this.setupViewport(c.camera, t.renderTarget), (!s || !c.camera.fullSizeClearRect) && this.clear(t, c.camera), o._sortVisible(h, c.camera.node, l);
        const u = o.instances, f = h ? u.visibleTransparent[l] : u.visibleOpaque[l];
        this.scene.immediate.onPreRenderLayer(o, f, h), i && t.lightClusters && (t.lightClusters.activate(this.lightTextureAtlas), !this.clustersDebugRendered && this.scene.lighting.debugLayer === o.id && (this.clustersDebugRendered = !0)), this.scene._activeCamera = c.camera;
        const m = this.setCameraUniforms(c.camera, t.renderTarget);
        n.supportsUniformBuffers && this.setupViewUniformBuffers(t.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, m);
        const _ = !!(c.camera._flipFaces ^ (t == null || (d = t.renderTarget) == null ? void 0 : d.flipY)), p = this._forwardDrawCalls;
        this.renderForward(c.camera, f.list, f.length, o._splitLights, o.shaderPass, o.cullingMask, o.onDrawCall, o, _), o._forwardDrawCalls += this._forwardDrawCalls - p, n.setColorWrite(!0, !0, !0, !0), n.setStencilTest(!1), n.setAlphaToCoverage(!1), n.setDepthBias(!1);
      }
      !h && o.onPostRenderOpaque ? o.onPostRenderOpaque(l) : h && o.onPostRenderTransparent && o.onPostRenderTransparent(l), o.onPostRender && !(o._postRenderCalledForCameras & 1 << l) && (o._postRenderCounter &= ~(h ? 2 : 1), o._postRenderCounter === 0 && (o.onPostRender(l), o._postRenderCalledForCameras |= 1 << l, o._postRenderCounter = o._postRenderCounterMax));
    }
  }
}
const HC = {
  equals: function(r, e) {
    if (r.size !== e.size)
      return !1;
    for (const t of r)
      if (!e.has(t))
        return !1;
    return !0;
  }
}, WC = (r, e) => r.priority - e.priority, $a = (r) => r.sort(WC);
class qC {
  constructor() {
    this.layerIndex = 0, this.cameraIndex = 0, this.camera = null, this.renderTarget = null, this.lightClusters = null, this.clearColor = !1, this.clearDepth = !1, this.clearStencil = !1, this.triggerPostprocess = !1, this.firstCameraUse = !1, this.lastCameraUse = !1, this.directionalLightsSet = /* @__PURE__ */ new Set(), this.directionalLights = [], this.directionalLightsIndices = [], this.viewBindGroups = [];
  }
  destroy() {
    this.viewBindGroups.forEach((e) => {
      e.defaultUniformBuffer.destroy(), e.destroy();
    }), this.viewBindGroups.length = 0;
  }
  get hasDirectionalShadowLights() {
    return this.directionalLights.length > 0;
  }
  reset() {
    this.lightClusters = null, this.directionalLightsSet.clear(), this.directionalLights.length = 0, this.directionalLightsIndices.length = 0;
  }
  isLayerEnabled(e) {
    return e.layerList[this.layerIndex].enabled && e.subLayerEnabled[this.layerIndex];
  }
  collectDirectionalLights(e, t, s) {
    this.directionalLightsSet.clear(), this.directionalLights.length = 0, this.directionalLightsIndices.length = 0;
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      if (n.castShadows) {
        for (let a = 0; a < e.length; a++)
          if (e[a]._splitLights[de].indexOf(n) >= 0 && !this.directionalLightsSet.has(n)) {
            this.directionalLightsSet.add(n), this.directionalLights.push(n);
            const o = s.indexOf(n);
            this.directionalLightsIndices.push(o);
          }
      }
    }
  }
}
class XC {
  constructor() {
    this.shadowCastersSet = /* @__PURE__ */ new Set(), this.shadowCastersList = [];
  }
  clearShadowCasters() {
    this.shadowCastersSet.clear(), this.shadowCastersList.length = 0;
  }
  addShadowCasters(e) {
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      this.shadowCastersSet.has(s) || (this.shadowCastersSet.add(s), this.shadowCastersList.push(s));
    }
  }
}
const Jn = /* @__PURE__ */ new Set(), ha = [];
class Cm extends _e {
  constructor(e = "Untitled") {
    super(), this.name = e, this.layerList = [], this.subLayerList = [], this.subLayerEnabled = [], this._opaqueOrder = {}, this._transparentOrder = {}, this._dirty = !1, this._dirtyBlend = !1, this._dirtyLights = !1, this._dirtyCameras = !1, this._meshInstances = [], this._meshInstancesSet = /* @__PURE__ */ new Set(), this._lights = [], this._lightsMap = /* @__PURE__ */ new Map(), this._lightCompositionData = [], this._splitLights = [[], [], []], this.cameras = [], this._renderActions = [], this._worldClusters = [], this._emptyWorldClusters = null;
  }
  destroy() {
    this._emptyWorldClusters && (this._emptyWorldClusters.destroy(), this._emptyWorldClusters = null), this._worldClusters.forEach((e) => {
      e.destroy();
    }), this._worldClusters = null, this._renderActions.forEach((e) => e.destroy()), this._renderActions = null;
  }
  getEmptyWorldClusters(e) {
    return this._emptyWorldClusters || (this._emptyWorldClusters = new Pd(e), this._emptyWorldClusters.name = "ClusterEmpty", this._emptyWorldClusters.update([], !1, null)), this._emptyWorldClusters;
  }
  _splitLightsArray(e) {
    const t = e._lights;
    e._splitLights[de].length = 0, e._splitLights[Se].length = 0, e._splitLights[Ee].length = 0;
    for (let s = 0; s < t.length; s++) {
      const i = t[s];
      i.enabled && e._splitLights[i._type].push(i);
    }
  }
  _update(e, t = !1) {
    const s = this.layerList.length;
    let i = 0;
    if (!this._dirty || !this._dirtyLights || !this._dirtyCameras)
      for (let o = 0; o < s; o++) {
        const h = this.layerList[o];
        h._dirty && (this._dirty = !0), h._dirtyLights && (this._dirtyLights = !0), h._dirtyCameras && (this._dirtyCameras = !0);
      }
    function n(o, h, l) {
      let c = !1;
      const d = l.length;
      for (let u = 0; u < d; u++) {
        const f = l[u];
        if (!h.has(f)) {
          h.add(f), o.push(f);
          const m = f.material;
          m && m._dirtyBlend && (c = !0, m._dirtyBlend = !1);
        }
      }
      return c;
    }
    if (this._dirty) {
      i |= Hf, this._meshInstances.length = 0, this._meshInstancesSet.clear();
      for (let o = 0; o < s; o++) {
        const h = this.layerList[o];
        h.passThrough || (this._dirtyBlend = n(this._meshInstances, this._meshInstancesSet, h.opaqueMeshInstances) || this._dirtyBlend, this._dirtyBlend = n(this._meshInstances, this._meshInstancesSet, h.transparentMeshInstances) || this._dirtyBlend), h._dirty = !1;
      }
      this._dirty = !1;
    }
    function a(o, h, l) {
      for (let d = 0; d < h.length; ) {
        var c;
        ((c = h[d].material) == null ? void 0 : c.transparent) === l ? (o.push(h[d]), h[d] = h[h.length - 1], h.length--) : d++;
      }
    }
    if (this._dirtyBlend) {
      i |= Pv;
      for (let o = 0; o < s; o++) {
        const h = this.layerList[o];
        h.passThrough || (a(h.opaqueMeshInstances, h.transparentMeshInstances, !1), a(h.transparentMeshInstances, h.opaqueMeshInstances, !0));
      }
      this._dirtyBlend = !1;
    }
    if (this._dirtyLights && (i |= mr, this._dirtyLights = !1, this.updateLights()), i && this.updateShadowCasters(), this._dirtyCameras || i & mr) {
      this._dirtyCameras = !1, i |= Wf, this.cameras.length = 0;
      for (let l = 0; l < s; l++) {
        const c = this.layerList[l];
        c._dirtyCameras = !1;
        for (let d = 0; d < c.cameras.length; d++) {
          const u = c.cameras[d];
          this.cameras.indexOf(u) < 0 && this.cameras.push(u);
        }
      }
      this.cameras.length > 1 && $a(this.cameras);
      const o = [];
      let h = 0;
      for (let l = 0; l < this.cameras.length; l++) {
        const c = this.cameras[l];
        o.length = 0;
        let d = !0;
        const u = h;
        let f = null, m = !1;
        for (let _ = 0; _ < s; _++) {
          const p = this.layerList[_], g = this.subLayerEnabled[_];
          if (p && g && p.cameras.length > 0 && c.layers.indexOf(p.id) >= 0) {
            o.push(p), !m && p.id === c.disablePostEffectsLayer && (m = !0, f && (f.triggerPostprocess = !0));
            const b = p.cameras.indexOf(c);
            b >= 0 && (f = this.addRenderAction(this._renderActions, h, p, _, b, d, m), h++, d = !1);
          }
        }
        u < h && (this._renderActions[u].collectDirectionalLights(o, this._splitLights[de], this._lights), f.lastCameraUse = !0), !m && f && (f.triggerPostprocess = !0), c.renderTarget && c.postEffectsEnabled && this.propagateRenderTarget(u - 1, c);
      }
      for (let l = h; l < this._renderActions.length; l++)
        this._renderActions[l].destroy();
      this._renderActions.length = h;
    }
    return i & (Wf | mr | Hf) && t && this.allocateLightClusters(e), i & (mr | mr) && this._logRenderActions(), i;
  }
  updateShadowCasters() {
    const e = this._lights.length;
    for (let s = 0; s < e; s++)
      this._lightCompositionData[s].clearShadowCasters();
    const t = this.layerList.length;
    for (let s = 0; s < t; s++) {
      const i = this.layerList[s];
      if (!Jn.has(i)) {
        Jn.add(i);
        const n = i._lights;
        for (let a = 0; a < n.length; a++)
          if (n[a].castShadows) {
            const o = this._lightsMap.get(n[a]);
            this._lightCompositionData[o].addShadowCasters(i.shadowCasters);
          }
      }
    }
    Jn.clear();
  }
  updateLights() {
    this._lights.length = 0, this._lightsMap.clear();
    const e = this.layerList.length;
    for (let s = 0; s < e; s++) {
      const i = this.layerList[s];
      if (!Jn.has(i)) {
        Jn.add(i);
        const n = i._lights;
        for (let a = 0; a < n.length; a++) {
          const o = n[a];
          let h = this._lightsMap.get(o);
          if (h === void 0) {
            h = this._lights.length, this._lightsMap.set(o, h), this._lights.push(o);
            let l = this._lightCompositionData[h];
            l || (l = new XC(), this._lightCompositionData[h] = l);
          }
        }
      }
      this._splitLightsArray(i), i._dirtyLights = !1;
    }
    Jn.clear(), this._splitLightsArray(this);
    const t = this._lights.length;
    this._lightCompositionData.length = t;
  }
  findCompatibleCluster(e, t, s) {
    for (let i = 0; i < t; i++) {
      const n = this._renderActions[i], a = this.layerList[n.layerIndex];
      if (n.lightClusters !== s && (e === a || n.lightClusters && HC.equals(e._clusteredLightsSet, a._clusteredLightsSet)))
        return n.lightClusters;
    }
    return null;
  }
  allocateLightClusters(e) {
    ha.push(...this._worldClusters);
    const t = this.getEmptyWorldClusters(e);
    this._worldClusters.length = 0;
    const s = this._renderActions.length;
    for (let i = 0; i < s; i++) {
      const n = this._renderActions[i], a = this.layerList[n.layerIndex];
      if (n.lightClusters = null, a.hasClusteredLights && (this.subLayerList[n.layerIndex] ? a.transparentMeshInstances : a.opaqueMeshInstances).length) {
        let l = this.findCompatibleCluster(a, i, t);
        l || (ha.length && (l = ha.pop()), l || (l = new Pd(e)), l.name = "Cluster-" + this._worldClusters.length, this._worldClusters.push(l)), n.lightClusters = l;
      }
      n.lightClusters || (n.lightClusters = t);
    }
    ha.forEach((i) => {
      i.destroy();
    }), ha.length = 0;
  }
  addRenderAction(e, t, s, i, n, a, o) {
    let h = e[t];
    h || (h = e[t] = new qC());
    let l = s.renderTarget;
    const c = s.cameras[n];
    c && c.renderTarget && s.id !== kt && (l = c.renderTarget);
    let d = !1;
    for (let p = t - 1; p >= 0; p--)
      if (e[p].camera === c && e[p].renderTarget === l) {
        d = !0;
        break;
      }
    const u = a || !d;
    let f = u ? c.clearColorBuffer : !1, m = u ? c.clearDepthBuffer : !1, _ = u ? c.clearStencilBuffer : !1;
    return f || (f = s.clearColorBuffer), m || (m = s.clearDepthBuffer), _ || (_ = s.clearStencilBuffer), o && c.postEffectsEnabled && (l = null), h.reset(), h.triggerPostprocess = !1, h.layerIndex = i, h.cameraIndex = n, h.camera = c, h.renderTarget = l, h.clearColor = f, h.clearDepth = m, h.clearStencil = _, h.firstCameraUse = a, h.lastCameraUse = !1, h;
  }
  propagateRenderTarget(e, t) {
    for (let s = e; s >= 0; s--) {
      const i = this._renderActions[s], n = this.layerList[i.layerIndex];
      if (i.renderTarget && n.id !== kt)
        break;
      if (n.id === kt)
        continue;
      const a = i == null ? void 0 : i.camera.camera;
      if (a && (!t.camera.rect.equals(a.rect) || !t.camera.scissorRect.equals(a.scissorRect)))
        break;
      i.renderTarget = t.renderTarget;
    }
  }
  _logRenderActions() {
  }
  _isLayerAdded(e) {
    return this.layerList.indexOf(e) >= 0;
  }
  _isSublayerAdded(e, t) {
    for (let s = 0; s < this.layerList.length; s++)
      if (this.layerList[s] === e && this.subLayerList[s] === t)
        return !0;
    return !1;
  }
  push(e) {
    this._isLayerAdded(e) || (this.layerList.push(e), this.layerList.push(e), this._opaqueOrder[e.id] = this.subLayerList.push(!1) - 1, this._transparentOrder[e.id] = this.subLayerList.push(!0) - 1, this.subLayerEnabled.push(!0), this.subLayerEnabled.push(!0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e));
  }
  insert(e, t) {
    if (this._isLayerAdded(e))
      return;
    this.layerList.splice(t, 0, e, e), this.subLayerList.splice(t, 0, !1, !0);
    const s = this.layerList.length;
    this._updateOpaqueOrder(t, s - 1), this._updateTransparentOrder(t, s - 1), this.subLayerEnabled.splice(t, 0, !0, !0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e);
  }
  remove(e) {
    let t = this.layerList.indexOf(e);
    for (delete this._opaqueOrder[t], delete this._transparentOrder[t]; t >= 0; )
      this.layerList.splice(t, 1), this.subLayerList.splice(t, 1), this.subLayerEnabled.splice(t, 1), t = this.layerList.indexOf(e), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("remove", e);
    const s = this.layerList.length;
    this._updateOpaqueOrder(0, s - 1), this._updateTransparentOrder(0, s - 1);
  }
  pushOpaque(e) {
    this._isSublayerAdded(e, !1) || (this.layerList.push(e), this._opaqueOrder[e.id] = this.subLayerList.push(!1) - 1, this.subLayerEnabled.push(!0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e));
  }
  insertOpaque(e, t) {
    if (this._isSublayerAdded(e, !1))
      return;
    this.layerList.splice(t, 0, e), this.subLayerList.splice(t, 0, !1);
    const s = this.subLayerList.length;
    this._updateOpaqueOrder(t, s - 1), this.subLayerEnabled.splice(t, 0, !0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e);
  }
  removeOpaque(e) {
    for (let t = 0, s = this.layerList.length; t < s; t++)
      if (this.layerList[t] === e && !this.subLayerList[t]) {
        this.layerList.splice(t, 1), this.subLayerList.splice(t, 1), s--, this._updateOpaqueOrder(t, s - 1), this.subLayerEnabled.splice(t, 1), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.layerList.indexOf(e) < 0 && this.fire("remove", e);
        return;
      }
  }
  pushTransparent(e) {
    this._isSublayerAdded(e, !0) || (this.layerList.push(e), this._transparentOrder[e.id] = this.subLayerList.push(!0) - 1, this.subLayerEnabled.push(!0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e));
  }
  insertTransparent(e, t) {
    if (this._isSublayerAdded(e, !0))
      return;
    this.layerList.splice(t, 0, e), this.subLayerList.splice(t, 0, !0);
    const s = this.subLayerList.length;
    this._updateTransparentOrder(t, s - 1), this.subLayerEnabled.splice(t, 0, !0), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.fire("add", e);
  }
  removeTransparent(e) {
    for (let t = 0, s = this.layerList.length; t < s; t++)
      if (this.layerList[t] === e && this.subLayerList[t]) {
        this.layerList.splice(t, 1), this.subLayerList.splice(t, 1), s--, this._updateTransparentOrder(t, s - 1), this.subLayerEnabled.splice(t, 1), this._dirty = !0, this._dirtyLights = !0, this._dirtyCameras = !0, this.layerList.indexOf(e) < 0 && this.fire("remove", e);
        return;
      }
  }
  _getSublayerIndex(e, t) {
    let s = this.layerList.indexOf(e);
    return s < 0 || this.subLayerList[s] !== t && (s = this.layerList.indexOf(e, s + 1), s < 0 || this.subLayerList[s] !== t) ? -1 : s;
  }
  getOpaqueIndex(e) {
    return this._getSublayerIndex(e, !1);
  }
  getTransparentIndex(e) {
    return this._getSublayerIndex(e, !0);
  }
  getLayerById(e) {
    for (let t = 0; t < this.layerList.length; t++)
      if (this.layerList[t].id === e)
        return this.layerList[t];
    return null;
  }
  getLayerByName(e) {
    for (let t = 0; t < this.layerList.length; t++)
      if (this.layerList[t].name === e)
        return this.layerList[t];
    return null;
  }
  _updateOpaqueOrder(e, t) {
    for (let s = e; s <= t; s++)
      this.subLayerList[s] === !1 && (this._opaqueOrder[this.layerList[s].id] = s);
  }
  _updateTransparentOrder(e, t) {
    for (let s = e; s <= t; s++)
      this.subLayerList[s] === !0 && (this._transparentOrder[this.layerList[s].id] = s);
  }
  _sortLayersDescending(e, t, s) {
    let i = -1, n = -1;
    for (let a = 0, o = e.length; a < o; a++) {
      const h = e[a];
      s.hasOwnProperty(h) && (i = Math.max(i, s[h]));
    }
    for (let a = 0, o = t.length; a < o; a++) {
      const h = t[a];
      s.hasOwnProperty(h) && (n = Math.max(n, s[h]));
    }
    return i === -1 && n !== -1 ? 1 : n === -1 && i !== -1 ? -1 : n - i;
  }
  sortTransparentLayers(e, t) {
    return this._sortLayersDescending(e, t, this._transparentOrder);
  }
  sortOpaqueLayers(e, t) {
    return this._sortLayersDescending(e, t, this._opaqueOrder);
  }
}
const Oo = new v(), ys = {
  bias: 0,
  normalBias: 0
}, Rc = {
  r: 0,
  g: 1,
  b: 2,
  a: 3
}, Dd = {
  directional: de,
  omni: Se,
  point: Se,
  spot: Ee
}, jC = [[new Z(0, 0, 1, 1)], [new Z(0, 0, 0.5, 0.5), new Z(0, 0.5, 0.5, 0.5)], [new Z(0, 0, 0.5, 0.5), new Z(0, 0.5, 0.5, 0.5), new Z(0.5, 0, 0.5, 0.5)], [new Z(0, 0, 0.5, 0.5), new Z(0, 0.5, 0.5, 0.5), new Z(0.5, 0, 0.5, 0.5), new Z(0.5, 0.5, 0.5, 0.5)]];
let $C = 0;
class YC {
  constructor(e, t, s, i) {
    this.light = i, this.camera = t, this.shadowCamera = ql.createShadowCamera(e, i._shadowType, i._type, s), this.shadowMatrix = new j(), this.shadowViewport = new Z(0, 0, 1, 1), this.shadowScissor = new Z(0, 0, 1, 1), this.face = s, this.visibleCasters = [], this.viewBindGroups = [];
  }
  destroy() {
    this.viewBindGroups.forEach((e) => {
      e.defaultUniformBuffer.destroy(), e.destroy();
    }), this.viewBindGroups.length = 0;
  }
  get shadowBuffer() {
    const e = this.shadowCamera.renderTarget;
    if (e) {
      const t = this.light;
      return t._type === Se ? e.colorBuffer : t._isPcf && t.device.supportsDepthShadow ? e.depthBuffer : e.colorBuffer;
    }
    return null;
  }
}
class Ya {
  constructor(e) {
    this.device = e, this.id = $C++, this._type = de, this._color = new z(0.8, 0.8, 0.8), this._intensity = 1, this._luminance = 0, this._castShadows = !1, this._enabled = !1, this.mask = Gs, this.isStatic = !1, this.key = 0, this.bakeDir = !0, this.bakeNumSamples = 1, this.bakeArea = 0, this.attenuationStart = 10, this.attenuationEnd = 10, this._falloffMode = Iu, this._shadowType = gt, this._vsmBlurSize = 11, this.vsmBlurMode = Du, this.vsmBias = 0.01 * 0.25, this._cookie = null, this.cookieIntensity = 1, this._cookieFalloff = !0, this._cookieChannel = "rgb", this._cookieTransform = null, this._cookieTransformUniform = new Float32Array(4), this._cookieOffset = null, this._cookieOffsetUniform = new Float32Array(2), this._cookieTransformSet = !1, this._cookieOffsetSet = !1, this._innerConeAngle = 40, this._outerConeAngle = 45, this.cascades = null, this._shadowMatrixPalette = null, this._shadowCascadeDistances = null, this.numCascades = 1, this.cascadeDistribution = 0.5, this._shape = Mt, this._finalColor = new Float32Array([0.8, 0.8, 0.8]);
    const t = Math.pow(this._finalColor[0], 2.2);
    this._linearFinalColor = new Float32Array([t, t, t]), this._position = new v(0, 0, 0), this._direction = new v(0, 0, 0), this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180), this._updateOuterAngle(this._outerConeAngle), this._usePhysicalUnits = void 0, this._shadowMap = null, this._shadowRenderParams = [], this.shadowDistance = 40, this._shadowResolution = 1024, this.shadowBias = -5e-4, this.shadowIntensity = 1, this._normalOffsetBias = 0, this.shadowUpdateMode = Ou, this.shadowUpdateOverrides = null, this._isVsm = !1, this._isPcf = !0, this._cookieMatrix = null, this._atlasViewport = null, this.atlasViewportAllocated = !1, this.atlasVersion = 0, this.atlasSlotIndex = 0, this.atlasSlotUpdated = !1, this._scene = null, this._node = null, this._renderData = [], this.visibleThisFrame = !1, this.maxScreenSize = 0;
  }
  destroy() {
    this._destroyShadowMap(), this.releaseRenderData(), this._renderData = null;
  }
  releaseRenderData() {
    if (this._renderData) {
      for (let e = 0; e < this._renderData.length; e++)
        this._renderData[e].destroy();
      this._renderData.length = 0;
    }
  }
  set numCascades(e) {
    (!this.cascades || this.numCascades !== e) && (this.cascades = jC[e - 1], this._shadowMatrixPalette = new Float32Array(4 * 16), this._shadowCascadeDistances = new Float32Array(4), this._destroyShadowMap(), this.updateKey());
  }
  get numCascades() {
    return this.cascades.length;
  }
  set shadowMap(e) {
    this._shadowMap !== e && (this._destroyShadowMap(), this._shadowMap = e);
  }
  get shadowMap() {
    return this._shadowMap;
  }
  get numShadowFaces() {
    const e = this._type;
    return e === de ? this.numCascades : e === Se ? 6 : 1;
  }
  set type(e) {
    if (this._type === e)
      return;
    this._type = e, this._destroyShadowMap(), this.updateKey();
    const t = this._shadowType;
    this._shadowType = null, this.shadowUpdateOverrides = null, this.shadowType = t;
  }
  get type() {
    return this._type;
  }
  set shape(e) {
    if (this._shape === e)
      return;
    this._shape = e, this._destroyShadowMap(), this.updateKey();
    const t = this._shadowType;
    this._shadowType = null, this.shadowType = t;
  }
  get shape() {
    return this._shape;
  }
  set usePhysicalUnits(e) {
    this._usePhysicalUnits !== e && (this._usePhysicalUnits = e, this._updateFinalColor());
  }
  get usePhysicalUnits() {
    return this._usePhysicalUnits;
  }
  set shadowType(e) {
    if (this._shadowType === e)
      return;
    const t = this.device;
    this._type === Se && (e = gt);
    const s = t.supportsDepthShadow;
    e === Us && !s && (e = gt), e === zs && !t.textureFloatRenderable && (e = li), e === li && !t.textureHalfFloatRenderable && (e = Os), this._isVsm = e >= Os && e <= zs, this._isPcf = e === Us || e === gt, this._shadowType = e, this._destroyShadowMap(), this.updateKey();
  }
  get shadowType() {
    return this._shadowType;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e, this.layersDirty());
  }
  get enabled() {
    return this._enabled;
  }
  set castShadows(e) {
    this._castShadows !== e && (this._castShadows = e, this._destroyShadowMap(), this.layersDirty(), this.updateKey());
  }
  get castShadows() {
    return this._castShadows && this.mask !== ui && this.mask !== 0;
  }
  set shadowResolution(e) {
    this._shadowResolution !== e && (this._type === Se ? e = Math.min(e, this.device.maxCubeMapSize) : e = Math.min(e, this.device.maxTextureSize), this._shadowResolution = e, this._destroyShadowMap());
  }
  get shadowResolution() {
    return this._shadowResolution;
  }
  set vsmBlurSize(e) {
    this._vsmBlurSize !== e && (e % 2 === 0 && e++, this._vsmBlurSize = e);
  }
  get vsmBlurSize() {
    return this._vsmBlurSize;
  }
  set normalOffsetBias(e) {
    this._normalOffsetBias !== e && ((!this._normalOffsetBias && e || this._normalOffsetBias && !e) && this.updateKey(), this._normalOffsetBias = e);
  }
  get normalOffsetBias() {
    return this._normalOffsetBias;
  }
  set falloffMode(e) {
    this._falloffMode !== e && (this._falloffMode = e, this.updateKey());
  }
  get falloffMode() {
    return this._falloffMode;
  }
  set innerConeAngle(e) {
    this._innerConeAngle !== e && (this._innerConeAngle = e, this._innerConeAngleCos = Math.cos(e * Math.PI / 180), this._usePhysicalUnits && this._updateFinalColor());
  }
  get innerConeAngle() {
    return this._innerConeAngle;
  }
  set outerConeAngle(e) {
    this._outerConeAngle !== e && (this._outerConeAngle = e, this._updateOuterAngle(e), this._usePhysicalUnits && this._updateFinalColor());
  }
  get outerConeAngle() {
    return this._outerConeAngle;
  }
  _updateOuterAngle(e) {
    const t = e * Math.PI / 180;
    this._outerConeAngleCos = Math.cos(t), this._outerConeAngleSin = Math.sin(t);
  }
  set intensity(e) {
    this._intensity !== e && (this._intensity = e, this._updateFinalColor());
  }
  get intensity() {
    return this._intensity;
  }
  set luminance(e) {
    this._luminance !== e && (this._luminance = e, this._updateFinalColor());
  }
  get luminance() {
    return this._luminance;
  }
  get cookieMatrix() {
    return this._cookieMatrix || (this._cookieMatrix = new j()), this._cookieMatrix;
  }
  get atlasViewport() {
    return this._atlasViewport || (this._atlasViewport = new Z(0, 0, 1, 1)), this._atlasViewport;
  }
  set cookie(e) {
    this._cookie !== e && (this._cookie = e, this.updateKey());
  }
  get cookie() {
    return this._cookie;
  }
  set cookieFalloff(e) {
    this._cookieFalloff !== e && (this._cookieFalloff = e, this.updateKey());
  }
  get cookieFalloff() {
    return this._cookieFalloff;
  }
  set cookieChannel(e) {
    if (this._cookieChannel !== e) {
      if (e.length < 3) {
        const t = e.charAt(e.length - 1), s = 3 - e.length;
        for (let i = 0; i < s; i++)
          e += t;
      }
      this._cookieChannel = e, this.updateKey();
    }
  }
  get cookieChannel() {
    return this._cookieChannel;
  }
  set cookieTransform(e) {
    this._cookieTransform !== e && (this._cookieTransform = e, this._cookieTransformSet = !!e, e && !this._cookieOffset && (this.cookieOffset = new q(), this._cookieOffsetSet = !1), this.updateKey());
  }
  get cookieTransform() {
    return this._cookieTransform;
  }
  set cookieOffset(e) {
    if (this._cookieOffset === e)
      return;
    !!(this._cookieTransformSet || e) && !e && this._cookieOffset ? this._cookieOffset.set(0, 0) : this._cookieOffset = e, this._cookieOffsetSet = !!e, e && !this._cookieTransform && (this.cookieTransform = new Z(1, 1, 0, 0), this._cookieTransformSet = !1), this.updateKey();
  }
  get cookieOffset() {
    return this._cookieOffset;
  }
  beginFrame() {
    this.visibleThisFrame = this._type === de && this._enabled, this.maxScreenSize = 0, this.atlasViewportAllocated = !1, this.atlasSlotUpdated = !1;
  }
  _destroyShadowMap() {
    if (this.releaseRenderData(), this._shadowMap && (this._shadowMap.cached || this._shadowMap.destroy(), this._shadowMap = null), this.shadowUpdateMode === Vs && (this.shadowUpdateMode = Gr), this.shadowUpdateOverrides)
      for (let e = 0; e < this.shadowUpdateOverrides.length; e++)
        this.shadowUpdateOverrides[e] === Vs && (this.shadowUpdateOverrides[e] = Gr);
  }
  getRenderData(e, t) {
    for (let i = 0; i < this._renderData.length; i++) {
      const n = this._renderData[i];
      if (n.camera === e && n.face === t)
        return n;
    }
    const s = new YC(this.device, e, t, this);
    return this._renderData.push(s), s;
  }
  clone() {
    const e = new Ya(this.device);
    return e.type = this._type, e.setColor(this._color), e.intensity = this._intensity, e.luminance = this._luminance, e.castShadows = this.castShadows, e._enabled = this._enabled, e.attenuationStart = this.attenuationStart, e.attenuationEnd = this.attenuationEnd, e.falloffMode = this._falloffMode, e.shadowType = this._shadowType, e.vsmBlurSize = this._vsmBlurSize, e.vsmBlurMode = this.vsmBlurMode, e.vsmBias = this.vsmBias, e.shadowUpdateMode = this.shadowUpdateMode, e.mask = this.mask, this.shadowUpdateOverrides && (e.shadowUpdateOverrides = this.shadowUpdateOverrides.slice()), e.innerConeAngle = this._innerConeAngle, e.outerConeAngle = this._outerConeAngle, e.numCascades = this.numCascades, e.cascadeDistribution = this.cascadeDistribution, e.shape = this._shape, e.shadowBias = this.shadowBias, e.normalOffsetBias = this._normalOffsetBias, e.shadowResolution = this._shadowResolution, e.shadowDistance = this.shadowDistance, e.shadowIntensity = this.shadowIntensity, e;
  }
  static getLightUnitConversion(e, t = Math.PI / 4, s = 0) {
    switch (e) {
      case Ee: {
        const i = Math.cos(t), n = Math.cos(s);
        return 2 * Math.PI * (1 - n + (n - i) / 2);
      }
      case Se:
        return 4 * Math.PI;
      case de:
        return 1;
    }
  }
  _getUniformBiasValues(e) {
    const t = e.shadowCamera._farClip;
    switch (this._type) {
      case Se:
        ys.bias = this.shadowBias, ys.normalBias = this._normalOffsetBias;
        break;
      case Ee:
        this._isVsm ? ys.bias = -1e-5 * 20 : (ys.bias = this.shadowBias * 20, !this.device.webgl2 && this.device.extStandardDerivatives && (ys.bias *= -100)), ys.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7) : this._normalOffsetBias;
        break;
      case de:
        this._isVsm ? ys.bias = -1e-5 * 20 : (ys.bias = this.shadowBias / t * 100, !this.device.webgl2 && this.device.extStandardDerivatives && (ys.bias *= -100)), ys.normalBias = this._isVsm ? this.vsmBias / (t / 7) : this._normalOffsetBias;
        break;
    }
    return ys;
  }
  getColor() {
    return this._color;
  }
  getBoundingSphere(e) {
    if (this._type === Ee) {
      const t = this.attenuationEnd, s = this._outerConeAngle, i = this._outerConeAngleCos, n = this._node;
      Oo.copy(n.up), s > 45 ? (e.radius = t * this._outerConeAngleSin, Oo.mulScalar(-t * i)) : (e.radius = t / (2 * i), Oo.mulScalar(-e.radius)), e.center.add2(n.getPosition(), Oo);
    } else
      this._type === Se && (e.center = this._node.getPosition(), e.radius = this.attenuationEnd);
  }
  getBoundingBox(e) {
    if (this._type === Ee) {
      const t = this.attenuationEnd, s = this._outerConeAngle, i = this._node, n = Math.abs(Math.sin(s * U.DEG_TO_RAD) * t);
      e.center.set(0, -t * 0.5, 0), e.halfExtents.set(n, t * 0.5, n), e.setFromTransformedAabb(e, i.getWorldTransform(), !0);
    } else
      this._type === Se && (e.center.copy(this._node.getPosition()), e.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd));
  }
  _updateFinalColor() {
    const e = this._color, t = e.r, s = e.g, i = e.b;
    let n = this._intensity;
    this._usePhysicalUnits && (n = this._luminance / Ya.getLightUnitConversion(this._type, this._outerConeAngle * U.DEG_TO_RAD, this._innerConeAngle * U.DEG_TO_RAD));
    const a = this._finalColor, o = this._linearFinalColor;
    a[0] = t * n, a[1] = s * n, a[2] = i * n, n >= 1 ? (o[0] = Math.pow(t, 2.2) * n, o[1] = Math.pow(s, 2.2) * n, o[2] = Math.pow(i, 2.2) * n) : (o[0] = Math.pow(a[0], 2.2), o[1] = Math.pow(a[1], 2.2), o[2] = Math.pow(a[2], 2.2));
  }
  setColor() {
    arguments.length === 1 ? this._color.set(arguments[0].r, arguments[0].g, arguments[0].b) : arguments.length === 3 && this._color.set(arguments[0], arguments[1], arguments[2]), this._updateFinalColor();
  }
  layersDirty() {
    var e;
    (e = this._scene) != null && e.layers && (this._scene.layers._dirtyLights = !0);
  }
  updateKey() {
    let e = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | Rc[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8;
    this._cookieChannel.length === 3 && (e |= Rc[this._cookieChannel.charAt(1)] << 16, e |= Rc[this._cookieChannel.charAt(2)] << 14), e !== this.key && this._scene !== null && this.layersDirty(), this.key = e;
  }
}
class pg {
  constructor(e, t, s) {
    this._maxTextureSize = t, this._supportsAreaLights = e, this._dirtyLightsFnc = s, this._areaLightsEnabled = !1, this._cells = new v(10, 3, 10), this._maxLightsPerCell = 255, this._shadowsEnabled = !0, this._shadowType = gt, this._shadowAtlasResolution = 2048, this._cookiesEnabled = !1, this._cookieAtlasResolution = 2048, this.atlasSplit = null, this.debugLayer = void 0;
  }
  applySettings(e) {
    this.shadowsEnabled = e.lightingShadowsEnabled, this.cookiesEnabled = e.lightingCookiesEnabled, this.areaLightsEnabled = e.lightingAreaLightsEnabled, this.shadowAtlasResolution = e.lightingShadowAtlasResolution, this.cookieAtlasResolution = e.lightingCookieAtlasResolution, this.maxLightsPerCell = e.lightingMaxLightsPerCell, this.shadowType = e.lightingShadowType, this.cell = new v(e.lightingCells);
  }
  set cells(e) {
    this._cells.copy(e);
  }
  get cells() {
    return this._cells;
  }
  set maxLightsPerCell(e) {
    this._maxLightsPerCell = U.clamp(e, 1, 255);
  }
  get maxLightsPerCell() {
    return this._maxLightsPerCell;
  }
  set cookieAtlasResolution(e) {
    this._cookieAtlasResolution = U.clamp(e, 32, this._maxTextureSize);
  }
  get cookieAtlasResolution() {
    return this._cookieAtlasResolution;
  }
  set shadowAtlasResolution(e) {
    this._shadowAtlasResolution = U.clamp(e, 32, this._maxTextureSize);
  }
  get shadowAtlasResolution() {
    return this._shadowAtlasResolution;
  }
  set shadowType(e) {
    this._shadowType !== e && (this._shadowType = e, this._dirtyLightsFnc());
  }
  get shadowType() {
    return this._shadowType;
  }
  set cookiesEnabled(e) {
    this._cookiesEnabled !== e && (this._cookiesEnabled = e, this._dirtyLightsFnc());
  }
  get cookiesEnabled() {
    return this._cookiesEnabled;
  }
  set areaLightsEnabled(e) {
    this._supportsAreaLights && this._areaLightsEnabled !== e && (this._areaLightsEnabled = e, this._dirtyLightsFnc());
  }
  get areaLightsEnabled() {
    return this._areaLightsEnabled;
  }
  set shadowsEnabled(e) {
    this._shadowsEnabled !== e && (this._shadowsEnabled = e, this._dirtyLightsFnc());
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
}
const KC = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}
		`;
class kn {
  constructor(e) {
    this.morph = e, e.incRefCount(), this.device = e.device, this._weights = [], this._weightMap = /* @__PURE__ */ new Map();
    for (let t = 0; t < e._targets.length; t++) {
      const s = e._targets[t];
      s.name && this._weightMap.set(s.name, t), this.setWeight(t, s.defaultWeight);
    }
    if (this._activeTargets = [], e.useTextureMorph) {
      this.shaderCache = {}, this.maxSubmitCount = this.device.maxTextures, this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
      const t = (s, i) => (this[i] = e._createTexture(s, e._renderTextureFormat), new Dt({
        colorBuffer: this[i],
        depth: !1
      }));
      e.morphPositions && (this.rtPositions = t("MorphRTPos", "texturePositions")), e.morphNormals && (this.rtNormals = t("MorphRTNrm", "textureNormals")), this._textureParams = new Float32Array([e.morphTextureWidth, e.morphTextureHeight, 1 / e.morphTextureWidth, 1 / e.morphTextureHeight]);
      for (let s = 0; s < this.maxSubmitCount; s++)
        this["morphBlendTex" + s] = this.device.scope.resolve("morphBlendTex" + s);
      this.morphFactor = this.device.scope.resolve("morphFactor[0]"), this.zeroTextures = !1;
    } else
      this.maxSubmitCount = 8, this._shaderMorphWeights = new Float32Array(this.maxSubmitCount), this._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4), this._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4), this._activeVertexBuffers = new Array(this.maxSubmitCount);
  }
  destroy() {
    this.shader = null;
    const e = this.morph;
    e && (this.morph = null, e.decRefCount(), e.refCount < 1 && e.destroy()), this.rtPositions && (this.rtPositions.destroy(), this.rtPositions = null), this.texturePositions && (this.texturePositions.destroy(), this.texturePositions = null), this.rtNormals && (this.rtNormals.destroy(), this.rtNormals = null), this.textureNormals && (this.textureNormals.destroy(), this.textureNormals = null);
  }
  clone() {
    return new kn(this.morph);
  }
  _getWeightIndex(e) {
    return typeof e == "string" ? this._weightMap.get(e) : e;
  }
  getWeight(e) {
    const t = this._getWeightIndex(e);
    return this._weights[t];
  }
  setWeight(e, t) {
    const s = this._getWeightIndex(e);
    this._weights[s] = t, this._dirty = !0;
  }
  _getFragmentShader(e) {
    let t = "";
    e > 0 && (t += `varying vec2 uv0;
uniform highp float morphFactor[` + e + `];
`);
    for (let s = 0; s < e; s++)
      t += "uniform highp sampler2D morphBlendTex" + s + `;
`;
    t += `void main (void) {
    highp vec4 color = vec4(0, 0, 0, 1);
`;
    for (let s = 0; s < e; s++)
      t += "    color.xyz += morphFactor[" + s + "] * texture2D(morphBlendTex" + s + `, uv0).xyz;
`;
    return t += `    gl_FragColor = color;
}
`, t;
  }
  _getShader(e) {
    let t = this.shaderCache[e];
    if (!t) {
      const s = this._getFragmentShader(e);
      t = ps(this.device, KC, s, "textureMorph" + e), this.shaderCache[e] = t;
    }
    return t;
  }
  _updateTextureRenderTarget(e, t) {
    const s = this.device, i = (h, l) => {
      this.morphFactor.setValue(this._shaderMorphWeights), s.setBlending(l), l && (s.setBlendFunction(We, We), s.setBlendEquation(ot));
      const c = this._getShader(h);
      Yi(s, e, c, void 0, void 0, l);
    };
    let n = 0, a = !1;
    const o = this._activeTargets.length;
    for (let h = 0; h < o; h++) {
      const l = this._activeTargets[h], c = l.target[t];
      c && (this["morphBlendTex" + n].setValue(c), this._shaderMorphWeights[n] = l.weight, n++, n >= this.maxSubmitCount && (i(n, a), n = 0, a = !0));
    }
    (n > 0 || o === 0 && !this.zeroTextures) && i(n, a);
  }
  _updateTextureMorph() {
    this.device, (this._activeTargets.length > 0 || !this.zeroTextures) && (this.rtPositions && this._updateTextureRenderTarget(this.rtPositions, "texturePositions"), this.rtNormals && this._updateTextureRenderTarget(this.rtNormals, "textureNormals"), this.zeroTextures = this._activeTargets.length === 0);
  }
  _updateVertexMorph() {
    const e = this.maxSubmitCount;
    for (let i = 0; i < e; i++)
      this._shaderMorphWeights[i] = 0, this._activeVertexBuffers[i] = null;
    let t = 0, s = this.morph.morphPositions ? 4 : 0;
    for (let i = 0; i < this._activeTargets.length; i++) {
      const n = this._activeTargets[i].target;
      n._vertexBufferPositions && (this._activeVertexBuffers[t] = n._vertexBufferPositions, this._shaderMorphWeights[t] = this._activeTargets[i].weight, t++), n._vertexBufferNormals && (this._activeVertexBuffers[s] = n._vertexBufferNormals, this._shaderMorphWeights[s] = this._activeTargets[i].weight, s++);
    }
  }
  update() {
    this._dirty = !1;
    const e = this.morph._targets;
    let t = 0;
    const s = 1e-5;
    for (let n = 0; n < e.length; n++) {
      const a = Math.abs(this.getWeight(n));
      if (a > s) {
        this._activeTargets.length <= t && (this._activeTargets[t] = {});
        const o = this._activeTargets[t++];
        o.absWeight = a, o.weight = this.getWeight(n), o.target = e[n];
      }
    }
    this._activeTargets.length = t;
    const i = this.morph.maxActiveTargets;
    this._activeTargets.length > i && (this._activeTargets.sort(function(n, a) {
      return n.absWeight < a.absWeight ? 1 : a.absWeight < n.absWeight ? -1 : 0;
    }), this._activeTargets.length = i), this.morph.useTextureMorph ? this._updateTextureMorph() : this._updateVertexMorph();
  }
}
class Ti {
  constructor() {
    this.graph = null, this.meshInstances = [], this.skinInstances = [], this.morphInstances = [], this.cameras = [], this.lights = [], this._shadersVersion = 0, this._immutable = !1;
  }
  getGraph() {
    return this.graph;
  }
  setGraph(e) {
    this.graph = e;
  }
  getCameras() {
    return this.cameras;
  }
  setCameras(e) {
    this.cameras = e;
  }
  getLights() {
    return this.lights;
  }
  setLights(e) {
    this.lights = e;
  }
  getMaterials() {
    const e = [];
    for (let t = 0; t < this.meshInstances.length; t++) {
      const s = this.meshInstances[t];
      e.indexOf(s.material) === -1 && e.push(s.material);
    }
    return e;
  }
  clone() {
    const e = [], t = [], i = function l(c) {
      const d = c.clone();
      e.push(c), t.push(d);
      for (let u = 0; u < c._children.length; u++)
        d.addChild(l(c._children[u]));
      return d;
    }(this.graph), n = [], a = [], o = [];
    for (let l = 0; l < this.skinInstances.length; l++) {
      const c = this.skinInstances[l].skin, d = new no(c), u = [];
      for (let f = 0; f < c.boneNames.length; f++) {
        const m = c.boneNames[f], _ = i.findByName(m);
        u.push(_);
      }
      d.bones = u, a.push(d);
    }
    for (let l = 0; l < this.morphInstances.length; l++) {
      const c = this.morphInstances[l].morph, d = new kn(c);
      o.push(d);
    }
    for (let l = 0; l < this.meshInstances.length; l++) {
      const c = this.meshInstances[l], d = e.indexOf(c.node), u = new we(c.mesh, c.material, t[d]);
      if (c.skinInstance) {
        const f = this.skinInstances.indexOf(c.skinInstance);
        u.skinInstance = a[f];
      }
      if (c.morphInstance) {
        const f = this.morphInstances.indexOf(c.morphInstance);
        u.morphInstance = o[f];
      }
      n.push(u);
    }
    const h = new Ti();
    return h.graph = i, h.meshInstances = n, h.skinInstances = a, h.morphInstances = o, h.getGraph().syncHierarchy(), h;
  }
  destroy() {
    const e = this.meshInstances;
    for (let t = 0; t < e.length; t++)
      e[t].destroy();
    this.meshInstances.length = 0;
  }
  generateWireframe() {
    we._prepareRenderStyleForArray(this.meshInstances, Rt);
  }
}
const Am = 0.2;
class _g extends Nu {
  constructor(e, t) {
    super(), this.device = t || xi.get(), e.forEach((s) => {
    }), this._targets = e.slice(), this.device.supportsMorphTargetTexturesCore && (this.device.extTextureHalfFloat && this.device.textureHalfFloatRenderable ? this._renderTextureFormat = Pt : this.device.extTextureFloat && this.device.textureFloatRenderable && (this._renderTextureFormat = vt), this.device.extTextureHalfFloat && this.device.textureHalfFloatUpdatable ? this._textureFormat = Pt : this.device.extTextureFloat && (this._textureFormat = Ua), this._renderTextureFormat !== void 0 && this._textureFormat !== void 0 && (this._useTextureMorph = !0)), this._init(), this._updateMorphFlags(), this._calculateAabb();
  }
  get morphPositions() {
    return this._morphPositions;
  }
  get morphNormals() {
    return this._morphNormals;
  }
  get maxActiveTargets() {
    return this._useTextureMorph ? this._targets.length : this._morphPositions && this._morphNormals ? 4 : 8;
  }
  get useTextureMorph() {
    return this._useTextureMorph;
  }
  _init() {
    if (this._useTextureMorph && (this._useTextureMorph = this._initTextureBased()), !this._useTextureMorph)
      for (let e = 0; e < this._targets.length; e++)
        this._targets[e]._initVertexBuffers(this.device);
    for (let e = 0; e < this._targets.length; e++)
      this._targets[e]._postInit();
  }
  _initTextureBased() {
    const e = [], t = [];
    for (let m = 0; m < this._targets.length; m++) {
      const _ = this._targets[m];
      _.options.deltaPositions && (e.push(_.options.deltaPositions), t.push({
        target: _,
        name: "texturePositions"
      })), _.options.deltaNormals && (e.push(_.options.deltaNormals), t.push({
        target: _,
        name: "textureNormals"
      }));
    }
    const s = [], i = [];
    let n = 1;
    const a = e[0].length;
    for (let m = 0; m < a; m += 3) {
      let _ = !1;
      for (let p = 0; p < e.length; p++) {
        const g = e[p];
        if (g[m] !== 0 || g[m + 1] !== 0 || g[m + 2] !== 0) {
          _ = !0;
          break;
        }
      }
      _ ? (s.push(n + Am), i.push(m / 3), n++) : s.push(0 + Am);
    }
    const o = Math.min(this.device.maxTextureSize, 4096);
    let h = Math.ceil(Math.sqrt(n));
    h = Math.min(h, o);
    const l = Math.ceil(n / h);
    if (l > o)
      return !1;
    this.morphTextureWidth = h, this.morphTextureHeight = l;
    let c = !1, d = 3;
    const u = qe.float2Half;
    this._textureFormat === Pt && (c = !0, d = 4);
    for (let m = 0; m < e.length; m++) {
      const _ = e[m], p = this._createTexture("MorphTarget", this._textureFormat), g = p.lock();
      for (let x = 0; x < i.length; x++) {
        const y = i[x];
        c ? (g[x * d + d] = u(_[y * 3]), g[x * d + d + 1] = u(_[y * 3 + 1]), g[x * d + d + 2] = u(_[y * 3 + 2])) : (g[x * d + d] = _[y * 3], g[x * d + d + 1] = _[y * 3 + 1], g[x * d + d + 2] = _[y * 3 + 2]);
      }
      p.unlock(), t[m].target._setTexture(t[m].name, p);
    }
    const f = [{
      semantic: bn,
      components: 1,
      type: Ie
    }];
    return this.vertexBufferIds = new yi(this.device, new Ot(this.device, f), s.length, ns, new Float32Array(s)), !0;
  }
  destroy() {
    var e;
    (e = this.vertexBufferIds) == null || e.destroy(), this.vertexBufferIds = null;
    for (let t = 0; t < this._targets.length; t++)
      this._targets[t].destroy();
    this._targets.length = 0;
  }
  get targets() {
    return this._targets;
  }
  _updateMorphFlags() {
    this._morphPositions = !1, this._morphNormals = !1;
    for (let e = 0; e < this._targets.length; e++) {
      const t = this._targets[e];
      t.morphPositions && (this._morphPositions = !0), t.morphNormals && (this._morphNormals = !0);
    }
  }
  _calculateAabb() {
    const e = new v(), t = new v();
    for (let s = 0; s < this._targets.length; s++) {
      const i = this._targets[s].aabb;
      e.min(i.getMin()), t.max(i.getMax());
    }
    this.aabb = new Pe(), this.aabb.setMinMax(e, t);
  }
  _createTexture(e, t) {
    return new ue(this.device, {
      width: this.morphTextureWidth,
      height: this.morphTextureHeight,
      format: t,
      cubemap: !1,
      mipmaps: !1,
      minFilter: Be,
      magFilter: Be,
      addressU: he,
      addressV: he,
      name: e
    });
  }
}
class $l {
  constructor(e) {
    this.used = !1, arguments.length === 2 && (e = arguments[1]), this.options = e, this._name = e.name, this._defaultWeight = e.defaultWeight || 0, this.aabb = e.aabb, this.aabb || (this.aabb = new Pe(), e.deltaPositions && this.aabb.compute(e.deltaPositions)), this.deltaPositions = e.deltaPositions;
  }
  destroy() {
    var e, t, s, i;
    (e = this._vertexBufferPositions) == null || e.destroy(), this._vertexBufferPositions = null, (t = this._vertexBufferNormals) == null || t.destroy(), this._vertexBufferNormals = null, (s = this.texturePositions) == null || s.destroy(), this.texturePositions = null, (i = this.textureNormals) == null || i.destroy(), this.textureNormals = null;
  }
  get name() {
    return this._name;
  }
  get defaultWeight() {
    return this._defaultWeight;
  }
  get morphPositions() {
    return !!this._vertexBufferPositions || !!this.texturePositions;
  }
  get morphNormals() {
    return !!this._vertexBufferNormals || !!this.textureNormals;
  }
  clone() {
    return new $l(this.options);
  }
  _postInit() {
    this.options.preserveData || (this.options = null), this.used = !0;
  }
  _initVertexBuffers(e) {
    const t = this.options;
    this._vertexBufferPositions = this._createVertexBuffer(e, t.deltaPositions, t.deltaPositionsType), this._vertexBufferNormals = this._createVertexBuffer(e, t.deltaNormals, t.deltaNormalsType), this._vertexBufferPositions && (this.deltaPositions = this._vertexBufferPositions.lock());
  }
  _createVertexBuffer(e, t, s = Ie) {
    if (t) {
      const i = [{
        semantic: Lh,
        components: 3,
        type: s
      }];
      return new yi(e, new Ot(e, i), t.length / 3, ns, t);
    }
    return null;
  }
  _setTexture(e, t) {
    this[e] = t;
  }
}
const ZC = {
  generateKey: function(r) {
    let e = "particle";
    for (const t in r)
      r.hasOwnProperty(t) && (e += r[t]);
    return e;
  },
  _animTex: function(r) {
    let e = "";
    return e += r.animTexLoop ? N.particleAnimFrameLoopVS : N.particleAnimFrameClampVS, e += N.particleAnimTexVS, e;
  },
  createShaderDefinition: function(r, e) {
    let t = `#define PARTICLE
`, s = `#define VERTEXSHADER
`;
    e.mesh && (s += `#define USE_MESH
`), e.localSpace && (s += `#define LOCAL_SPACE
`), e.screenSpace && (s += `#define SCREEN_SPACE
`), e.animTex && (s += `
uniform vec2 animTexTilesParams;
`), e.animTex && (s += `
uniform vec4 animTexParams;
`), e.animTex && (s += `
uniform vec2 animTexIndexParams;
`), e.normal === 2 && (s += `
varying mat3 ParticleMat;
`), e.normal === 1 && (s += `
varying vec3 Normal;
`), e.soft && (s += `
varying float vDepth;
`);
    const i = e.customFace ? N.particle_customFaceVS : N.particle_billboardVS;
    return e.useCpu ? (e.soft > 0 && (s += N.screenDepthPS), s += N.particle_cpuVS, e.localSpace && (s += N.particle_localShiftVS), e.animTex && (s += this._animTex(e)), e.alignToMotion && (s += N.particle_pointAlongVS), s += e.mesh ? N.particle_meshVS : i, e.normal === 1 && (s += N.particle_normalVS), e.normal === 2 && (s += N.particle_TBNVS), e.stretch > 0 && (s += N.particle_stretchVS), s += N.particle_cpu_endVS, e.soft > 0 && (s += N.particle_softVS)) : (s += N.particle_initVS, s += e.pack8 ? N.particleInputRgba8PS : N.particleInputFloatPS, e.soft > 0 && (s += N.screenDepthPS), s += N.particleVS, e.localSpace && (s += N.particle_localShiftVS), e.animTex && (s += this._animTex(e)), e.wrap && (s += N.particle_wrapVS), e.alignToMotion && (s += N.particle_pointAlongVS), s += e.mesh ? N.particle_meshVS : i, e.normal === 1 && (s += N.particle_normalVS), e.normal === 2 && (s += N.particle_TBNVS), e.stretch > 0 && (s += N.particle_stretchVS), s += N.particle_endVS, e.soft > 0 && (s += N.particle_softVS)), s += `}
`, e.normal > 0 && (e.normal === 1 ? t += `
varying vec3 Normal;
` : e.normal === 2 && (t += `
varying mat3 ParticleMat;
`), t += `
uniform vec3 lightCube[6];
`), e.soft && (t += `
varying float vDepth;
`), e.normal === 0 && e.fog === "none" && (e.srgb = !1), t += N.decodePS, t += Yh(e.gamma), t += Kh(e.toneMap), e.fog === "linear" ? t += N.fogLinearPS : e.fog === "exp" ? t += N.fogExpPS : e.fog === "exp2" ? t += N.fogExp2PS : t += N.fogNonePS, e.normal === 2 && (t += `
uniform sampler2D normalMap;
`), e.soft > 0 && (t += N.screenDepthPS), t += N.particlePS, e.soft > 0 && (t += N.particle_softPS), e.normal === 1 && (t += `
vec3 normal = Normal;
`), e.normal === 2 && (t += N.particle_normalMapPS), e.normal > 0 && (t += e.halflambert ? N.particle_halflambertPS : N.particle_lambertPS), e.normal > 0 && (t += N.particle_lightingPS), e.blend === Vt ? t += N.particle_blendNormalPS : e.blend === Oh ? t += N.particle_blendAddPS : e.blend === kh && (t += N.particle_blendMultiplyPS), t += N.particle_endPS, pt.createDefinition(r, {
      vertexCode: s,
      fragmentCode: t
    });
  }
};
let Zs, Mm = 1;
const ie = 4, Lc = new j(), Pc = new j(), Ls = new v(), He = new v(), xs = new v(), Qn = new v(), $t = new v(), tt = new v(), er = new v(), tr = new v(), la = new v(), Em = new v(), Ct = new v(), ko = new v(), rn = new v();
function wr(r) {
  return r - Math.floor(r);
}
function JC(r) {
  return Math.max(Math.min(r, 1), 0);
}
function Ic(r, e) {
  return r - e * Math.floor(r / e);
}
function QC(r) {
  let e = wr(r), t = wr(255 * r), s = wr(65025 * r), i = wr(160581375 * r);
  return e -= t / 255, t -= s / 255, s -= i / 255, i -= i / 255, [e, t, s, i];
}
function No(r) {
  let e = wr(r), t = wr(255 * r);
  return e -= t / 255, t -= t / 255, [e, t];
}
class eA {
  constructor(e) {
    this._emitter = e;
  }
  calcSpawnPosition(e, t, s, i, n) {
    const a = this._emitter, o = Math.random(), h = Math.random(), l = Math.random(), c = Math.random();
    if (a.useCpu && (e[n * ie + 0 + a.numParticlesPot * 2 * ie] = o, e[n * ie + 1 + a.numParticlesPot * 2 * ie] = h, e[n * ie + 2 + a.numParticlesPot * 2 * ie] = l), He.x = o - 0.5, He.y = h - 0.5, He.z = l - 0.5, a.emitterShape === Ds) {
      const f = Math.max(Math.abs(He.x), Math.max(Math.abs(He.y), Math.abs(He.z))), m = f + (0.5 - f) * s[0], _ = f + (0.5 - f) * s[1], p = f + (0.5 - f) * s[2];
      He.x = m * (f === Math.abs(He.x) ? Math.sign(He.x) : 2 * He.x), He.y = _ * (f === Math.abs(He.y) ? Math.sign(He.y) : 2 * He.y), He.z = p * (f === Math.abs(He.z) ? Math.sign(He.z) : 2 * He.z), a.localSpace ? Ls.copy(t.transformPoint(He)) : Ls.copy(i).add(t.transformPoint(He));
    } else {
      He.normalize();
      const f = a.emitterRadius === 0 ? 0 : a.emitterRadiusInner / a.emitterRadius, m = c * (1 - f) + f;
      a.localSpace ? Ls.copy(He.mulScalar(m * a.emitterRadius)) : Ls.copy(i).add(He.mulScalar(m * a.emitterRadius));
    }
    let u = -U.lerp(a.rate, a.rate2, o) * n;
    if (a.pack8) {
      const f = (Ls.x - a.worldBounds.center.x) / a.worldBoundsSize.x + 0.5, m = (Ls.y - a.worldBounds.center.y) / a.worldBoundsSize.y + 0.5, _ = (Ls.z - a.worldBounds.center.z) / a.worldBoundsSize.z + 0.5;
      let p = U.lerp(a.startAngle * U.DEG_TO_RAD, a.startAngle2 * U.DEG_TO_RAD, o);
      p = p % (Math.PI * 2) / (Math.PI * 2);
      const g = No(f);
      e[n * ie] = g[0], e[n * ie + 1] = g[1];
      const b = No(m);
      e[n * ie + 2] = b[0], e[n * ie + 3] = b[1];
      const x = No(_);
      e[n * ie + 0 + a.numParticlesPot * ie] = x[0], e[n * ie + 1 + a.numParticlesPot * ie] = x[1];
      const y = No(p);
      e[n * ie + 2 + a.numParticlesPot * ie] = y[0], e[n * ie + 3 + a.numParticlesPot * ie] = y[1];
      const S = 1;
      e[n * ie + 3 + a.numParticlesPot * ie * 2] = S;
      const C = Math.max(a.lifetime, (a.numParticles - 1) * Math.max(a.rate, a.rate2)), w = a.lifetime + 1;
      u = (u + C) / (C + w);
      const M = QC(u);
      e[n * ie + 0 + a.numParticlesPot * ie * 3] = M[0], e[n * ie + 1 + a.numParticlesPot * ie * 3] = M[1], e[n * ie + 2 + a.numParticlesPot * ie * 3] = M[2], e[n * ie + 3 + a.numParticlesPot * ie * 3] = M[3];
    } else
      e[n * ie] = Ls.x, e[n * ie + 1] = Ls.y, e[n * ie + 2] = Ls.z, e[n * ie + 3] = U.lerp(a.startAngle * U.DEG_TO_RAD, a.startAngle2 * U.DEG_TO_RAD, o), e[n * ie + 3 + a.numParticlesPot * ie] = u;
  }
  update(e, t, s, i, n, a, o, h) {
    let l, c, d;
    const u = this._emitter;
    if (u.meshInstance.node) {
      const T = u.meshInstance.node.worldTransform;
      for (let A = 0; A < 12; A++)
        Lc.data[A] = T.data[A];
      Pc.copy(Lc), Pc.invert(), Zs = u.meshInstance.node.localScale, Mm = Math.max(Math.max(Zs.x, Zs.y), Zs.z);
    }
    a = u.meshInstance.node === null || u.localSpace ? v.ZERO : u.meshInstance.node.getPosition();
    const f = u.camera ? u.camera._node.getPosition() : v.ZERO, m = u.useMesh ? 17 : 15;
    let _, p, g, b, x, y, S, C, w;
    const M = u.precision - 1;
    for (let T = 0; T < u.numParticles; T++) {
      const A = Math.floor(u.vbCPU[T * u.numParticleVerts * (u.useMesh ? 6 : 4) + 3]), L = s[A * ie + 0 + u.numParticlesPot * 2 * ie];
      xs.x = L, xs.y = s[A * ie + 1 + u.numParticlesPot * 2 * ie], xs.z = s[A * ie + 2 + u.numParticlesPot * 2 * ie];
      const O = u.rate + (u.rate2 - u.rate) * L, I = u.lifetime;
      let D = s[A * ie + 3 + u.numParticlesPot * ie] + o;
      const G = JC(D / I);
      let X = 0, E = 0;
      const P = 0;
      (D - o <= 0 || D >= I) && this.calcSpawnPosition(s, i, n, a, A);
      let k = D > 0 && D < I;
      k && (d = G * M, _ = Math.floor(d), p = Math.ceil(d), d %= 1, l = u.qRotSpeed[_], c = u.qRotSpeed[p], g = l + (c - l) * d, l = u.qRotSpeed2[_], c = u.qRotSpeed2[p], b = l + (c - l) * d, l = u.qScale[_], c = u.qScale[p], X = l + (c - l) * d, l = u.qScale2[_], c = u.qScale2[p], x = l + (c - l) * d, l = u.qAlpha[_], c = u.qAlpha[p], y = l + (c - l) * d, l = u.qAlpha2[_], c = u.qAlpha2[p], S = l + (c - l) * d, l = u.qRadialSpeed[_], c = u.qRadialSpeed[p], C = l + (c - l) * d, l = u.qRadialSpeed2[_], c = u.qRadialSpeed2[p], w = l + (c - l) * d, C += (w - C) * (L * 100 % 1), Qn.x = s[A * ie], Qn.y = s[A * ie + 1], Qn.z = s[A * ie + 2], u.localSpace ? la.copy(Qn) : la.copy(Qn).sub(a), la.normalize().mulScalar(C), _ *= 3, p *= 3, l = u.qLocalVelocity[_], c = u.qLocalVelocity[p], tt.x = l + (c - l) * d, l = u.qLocalVelocity[_ + 1], c = u.qLocalVelocity[p + 1], tt.y = l + (c - l) * d, l = u.qLocalVelocity[_ + 2], c = u.qLocalVelocity[p + 2], tt.z = l + (c - l) * d, l = u.qLocalVelocity2[_], c = u.qLocalVelocity2[p], tr.x = l + (c - l) * d, l = u.qLocalVelocity2[_ + 1], c = u.qLocalVelocity2[p + 1], tr.y = l + (c - l) * d, l = u.qLocalVelocity2[_ + 2], c = u.qLocalVelocity2[p + 2], tr.z = l + (c - l) * d, l = u.qVelocity[_], c = u.qVelocity[p], $t.x = l + (c - l) * d, l = u.qVelocity[_ + 1], c = u.qVelocity[p + 1], $t.y = l + (c - l) * d, l = u.qVelocity[_ + 2], c = u.qVelocity[p + 2], $t.z = l + (c - l) * d, l = u.qVelocity2[_], c = u.qVelocity2[p], er.x = l + (c - l) * d, l = u.qVelocity2[_ + 1], c = u.qVelocity2[p + 1], er.y = l + (c - l) * d, l = u.qVelocity2[_ + 2], c = u.qVelocity2[p + 2], er.z = l + (c - l) * d, tt.x += (tr.x - tt.x) * xs.x, tt.y += (tr.y - tt.y) * xs.y, tt.z += (tr.z - tt.z) * xs.z, u.initialVelocity > 0 && (u.emitterShape === mv ? (He.copy(xs).mulScalar(2).sub(v.ONE).normalize(), tt.add(He.mulScalar(u.initialVelocity))) : tt.add(v.FORWARD.mulScalar(u.initialVelocity))), $t.x += (er.x - $t.x) * xs.x, $t.y += (er.y - $t.y) * xs.y, $t.z += (er.z - $t.z) * xs.z, g += (b - g) * xs.y, X = (X + (x - X) * (L * 1e4 % 1)) * Mm, E = (S - y) * (L * 1e3 % 1), u.meshInstance.node && (u.localSpace ? (tt.x /= Zs.x, tt.y /= Zs.y, tt.z /= Zs.z) : Lc.transformPoint(tt, tt)), u.localSpace ? (Pc.transformPoint($t, $t), tt.add($t).add(la)) : (tt.add($t.mul(Zs)), tt.add(la.mul(Zs))), ko.copy(tt), Em.copy(Qn).add(tt.mulScalar(o)), Ct.copy(Em), s[A * ie] = Ct.x, s[A * ie + 1] = Ct.y, s[A * ie + 2] = Ct.z, s[A * ie + 3] += g * o, u.wrap && u.wrapBounds && (u.localSpace || Ct.sub(a), Ct.x = Ic(Ct.x, u.wrapBounds.x) - u.wrapBounds.x * 0.5, Ct.y = Ic(Ct.y, u.wrapBounds.y) - u.wrapBounds.y * 0.5, Ct.z = Ic(Ct.z, u.wrapBounds.z) - u.wrapBounds.z * 0.5, u.localSpace || Ct.add(a)), u.sort > 0 && (u.sort === 1 ? (rn.copy(Ct).sub(f), u.particleDistance[A] = -(rn.x * rn.x + rn.y * rn.y + rn.z * rn.z)) : u.sort === 2 ? u.particleDistance[A] = D : u.sort === 3 && (u.particleDistance[A] = -D))), h ? D < 0 && (s[A * ie + 3 + u.numParticlesPot * 2 * ie] = -1) : (D >= I && (D -= Math.max(I, (u.numParticles - 1) * O), s[A * ie + 3 + u.numParticlesPot * 2 * ie] = u.loop ? 1 : -1), D < 0 && u.loop && (s[A * ie + 3 + u.numParticlesPot * 2 * ie] = 1)), s[A * ie + 3 + u.numParticlesPot * 2 * ie] < 0 && (k = !1), s[A * ie + 3 + u.numParticlesPot * ie] = D;
      for (let H = 0; H < u.numParticleVerts; H++) {
        const V = (T * u.numParticleVerts + H) * (u.useMesh ? 6 : 4);
        let K = u.vbCPU[V], Q = u.vbCPU[V + 1], se = u.vbCPU[V + 2];
        k || (K = Q = se = 0);
        const J = T * u.numParticleVerts * m + H * m;
        e[J] = Ct.x, e[J + 1] = Ct.y, e[J + 2] = Ct.z, e[J + 3] = G, e[J + 4] = u.alignToMotion ? P : s[A * ie + 3], e[J + 5] = X, e[J + 6] = E, e[J + 7] = ko.x, e[J + 8] = K, e[J + 9] = Q, e[J + 10] = se, e[J + 11] = ko.y, e[J + 12] = A, e[J + 13] = ko.z, e[J + 14] = u.vbCPU[V + 3], u.useMesh && (e[J + 15] = u.vbCPU[V + 4], e[J + 16] = u.vbCPU[V + 5]);
      }
    }
    if (u.sort > Cd && u.camera) {
      const T = u.useMesh ? 6 : 4, A = u.particleDistance;
      for (let L = 0; L < u.numParticles; L++)
        t[L][0] = L, t[L][1] = A[Math.floor(u.vbCPU[L * u.numParticleVerts * T + 3])];
      u.vbOld.set(u.vbCPU), t.sort(function(L, O) {
        return L[1] - O[1];
      });
      for (let L = 0; L < u.numParticles; L++) {
        const O = t[L][0] * u.numParticleVerts * T, I = L * u.numParticleVerts * T;
        for (let D = 0; D < u.numParticleVerts * T; D++)
          u.vbCPU[I + D] = u.vbOld[O + D];
      }
    }
  }
}
const Rm = new is(), Lm = new is(), Pm = new is();
class tA {
  constructor(e, t) {
    this._emitter = e, this.frameRandomUniform = new Float32Array(3), this.emitterPosUniform = new Float32Array(3), this.emitterScaleUniform = new Float32Array([1, 1, 1]), this.worldBoundsMulUniform = new Float32Array(3), this.worldBoundsAddUniform = new Float32Array(3), this.inBoundsSizeUniform = new Float32Array(3), this.inBoundsCenterUniform = new Float32Array(3), this.constantParticleTexIN = t.scope.resolve("particleTexIN"), this.constantParticleTexOUT = t.scope.resolve("particleTexOUT"), this.constantEmitterPos = t.scope.resolve("emitterPos"), this.constantEmitterScale = t.scope.resolve("emitterScale"), this.constantSpawnBounds = t.scope.resolve("spawnBounds"), this.constantSpawnPosInnerRatio = t.scope.resolve("spawnPosInnerRatio"), this.constantSpawnBoundsSphere = t.scope.resolve("spawnBoundsSphere"), this.constantSpawnBoundsSphereInnerRatio = t.scope.resolve("spawnBoundsSphereInnerRatio"), this.constantInitialVelocity = t.scope.resolve("initialVelocity"), this.constantFrameRandom = t.scope.resolve("frameRandom"), this.constantDelta = t.scope.resolve("delta"), this.constantRate = t.scope.resolve("rate"), this.constantRateDiv = t.scope.resolve("rateDiv"), this.constantLifetime = t.scope.resolve("lifetime"), this.constantGraphSampleSize = t.scope.resolve("graphSampleSize"), this.constantGraphNumSamples = t.scope.resolve("graphNumSamples"), this.constantInternalTex0 = t.scope.resolve("internalTex0"), this.constantInternalTex1 = t.scope.resolve("internalTex1"), this.constantInternalTex2 = t.scope.resolve("internalTex2"), this.constantInternalTex3 = t.scope.resolve("internalTex3"), this.constantEmitterMatrix = t.scope.resolve("emitterMatrix"), this.constantEmitterMatrixInv = t.scope.resolve("emitterMatrixInv"), this.constantNumParticles = t.scope.resolve("numParticles"), this.constantNumParticlesPot = t.scope.resolve("numParticlesPot"), this.constantLocalVelocityDivMult = t.scope.resolve("localVelocityDivMult"), this.constantVelocityDivMult = t.scope.resolve("velocityDivMult"), this.constantRotSpeedDivMult = t.scope.resolve("rotSpeedDivMult"), this.constantSeed = t.scope.resolve("seed"), this.constantStartAngle = t.scope.resolve("startAngle"), this.constantStartAngle2 = t.scope.resolve("startAngle2"), this.constantOutBoundsMul = t.scope.resolve("outBoundsMul"), this.constantOutBoundsAdd = t.scope.resolve("outBoundsAdd"), this.constantInBoundsSize = t.scope.resolve("inBoundsSize"), this.constantInBoundsCenter = t.scope.resolve("inBoundsCenter"), this.constantMaxVel = t.scope.resolve("maxVel"), this.constantFaceTangent = t.scope.resolve("faceTangent"), this.constantFaceBinorm = t.scope.resolve("faceBinorm");
  }
  _setInputBounds() {
    this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x, this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y, this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z, this.constantInBoundsSize.setValue(this.inBoundsSizeUniform), this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x, this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y, this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z, this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
  }
  randomize() {
    this.frameRandomUniform[0] = Math.random(), this.frameRandomUniform[1] = Math.random(), this.frameRandomUniform[2] = Math.random();
  }
  update(e, t, s, i, n) {
    const a = this._emitter;
    e.setBlending(!1), e.setColorWrite(!0, !0, !0, !0), e.setCullMode(Ft), e.setDepthTest(!1), e.setDepthWrite(!1), this.randomize(), this.constantGraphSampleSize.setValue(1 / a.precision), this.constantGraphNumSamples.setValue(a.precision), this.constantNumParticles.setValue(a.numParticles), this.constantNumParticlesPot.setValue(a.numParticlesPot), this.constantInternalTex0.setValue(a.internalTex0), this.constantInternalTex1.setValue(a.internalTex1), this.constantInternalTex2.setValue(a.internalTex2), this.constantInternalTex3.setValue(a.internalTex3);
    const o = a.meshInstance.node, h = o === null ? v.ONE : o.localScale;
    if (a.pack8) {
      this.worldBoundsMulUniform[0] = a.worldBoundsMul.x, this.worldBoundsMulUniform[1] = a.worldBoundsMul.y, this.worldBoundsMulUniform[2] = a.worldBoundsMul.z, this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform), this.worldBoundsAddUniform[0] = a.worldBoundsAdd.x, this.worldBoundsAddUniform[1] = a.worldBoundsAdd.y, this.worldBoundsAddUniform[2] = a.worldBoundsAdd.z, this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform), this._setInputBounds();
      let f = a.maxVel * Math.max(Math.max(h.x, h.y), h.z);
      f = Math.max(f, 1), this.constantMaxVel.setValue(f);
    }
    const l = o === null || a.localSpace ? v.ZERO : o.getPosition(), c = o === null ? j.IDENTITY : o.getWorldTransform();
    a.emitterShape === Ds ? (Rm.setFromMat4(t), this.constantSpawnBounds.setValue(Rm.data), this.constantSpawnPosInnerRatio.setValue(s)) : (this.constantSpawnBoundsSphere.setValue(a.emitterRadius), this.constantSpawnBoundsSphereInnerRatio.setValue(a.emitterRadius === 0 ? 0 : a.emitterRadiusInner / a.emitterRadius)), this.constantInitialVelocity.setValue(a.initialVelocity), Lm.setFromMat4(c), c.invertTo3x3(Pm), this.emitterPosUniform[0] = l.x, this.emitterPosUniform[1] = l.y, this.emitterPosUniform[2] = l.z, this.constantEmitterPos.setValue(this.emitterPosUniform), this.constantFrameRandom.setValue(this.frameRandomUniform), this.constantDelta.setValue(i), this.constantRate.setValue(a.rate), this.constantRateDiv.setValue(a.rate2 - a.rate), this.constantStartAngle.setValue(a.startAngle * U.DEG_TO_RAD), this.constantStartAngle2.setValue(a.startAngle2 * U.DEG_TO_RAD), this.constantSeed.setValue(a.seed), this.constantLifetime.setValue(a.lifetime), this.emitterScaleUniform[0] = h.x, this.emitterScaleUniform[1] = h.y, this.emitterScaleUniform[2] = h.z, this.constantEmitterScale.setValue(this.emitterScaleUniform), this.constantEmitterMatrix.setValue(Lm.data), this.constantEmitterMatrixInv.setValue(Pm.data), this.constantLocalVelocityDivMult.setValue(a.localVelocityUMax), this.constantVelocityDivMult.setValue(a.velocityUMax), this.constantRotSpeedDivMult.setValue(a.rotSpeedUMax[0]);
    let d = a.swapTex ? a.particleTexOUT : a.particleTexIN;
    d = a.beenReset ? a.particleTexStart : d;
    const u = a.swapTex ? a.particleTexIN : a.particleTexOUT;
    this.constantParticleTexIN.setValue(d), Yi(e, a.swapTex ? a.rtParticleTexIN : a.rtParticleTexOUT, n ? a.shaderParticleUpdateOnStop : a.loop ? a.shaderParticleUpdateRespawn : a.shaderParticleUpdateNoRespawn), a.material.setParameter("particleTexOUT", d), a.material.setParameter("particleTexIN", u), a.beenReset = !1, a.swapTex = !a.swapTex, e.setDepthTest(!0), e.setDepthWrite(!0), a.prevWorldBoundsSize.copy(a.worldBoundsSize), a.prevWorldBoundsCenter.copy(a.worldBounds.center), a.pack8 && this._setInputBounds();
  }
}
const Im = [[-1, -1], [1, -1], [1, 1], [-1, 1]];
function as(r, e, t, s, i = vt, n, a) {
  let o = Be;
  a && i === ye && (o = rt);
  const h = new ue(r, {
    width: e,
    height: t,
    format: i,
    cubemap: !1,
    mipmaps: !1,
    minFilter: o,
    magFilter: o,
    addressU: he,
    addressV: he,
    name: "ParticleSystemTexture"
  }), l = h.lock();
  if (i === ye) {
    const c = new Uint8Array(s.length);
    for (let d = 0; d < s.length; d++)
      c[d] = s[d] * n * 255;
    s = c;
  }
  return l.set(s), h.unlock(), h;
}
function Dm(r) {
  return Math.max(Math.min(r, 1), 0);
}
const Bm = new ms([0, 0, 1, 0]), Fm = new ms([0, 1, 1, 1]), Om = new Wi([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]), sA = new Wi([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
let Js = 2;
const zo = 4, Qs = new Float32Array(3), an = new j(), km = new v(), Uo = new v(), Vo = new v();
let Bd, _h;
function ne(r, e) {
  _h[r] !== void 0 && _h[r] !== null ? Bd[r] = _h[r] : Bd[r] = e;
}
function gg(r, e, t) {
  return (r * 255 << 16 | e * 255 << 8 | t * 255) / (1 << 24);
}
function Nm(r, e) {
  const t = r.length / 3, s = new Array(t * 4);
  for (let i = 0; i < t; i++)
    s[i * 4] = r[i * 3], s[i * 4 + 1] = r[i * 3 + 1], s[i * 4 + 2] = r[i * 3 + 2], s[i * 4 + 3] = gg(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]);
  return s;
}
function iA(r, e) {
  const t = new Array(e.length * 4);
  for (let s = 0; s < e.length; s++)
    t[s * 4] = r[s * 3], t[s * 4 + 1] = r[s * 3 + 1], t[s * 4 + 2] = r[s * 3 + 2], t[s * 4 + 3] = e[s];
  return t;
}
function nA(r, e, t, s, i) {
  const n = new Array(r.length * 4);
  for (let a = 0; a < r.length; a++)
    n[a * 4] = r[a], n[a * 4 + 1] = e[a], n[a * 4 + 2] = 0, n[a * 4 + 3] = gg(t[a], s[a], i[a]);
  return n;
}
function rA(r, e) {
  const t = new Array(r.length * 4);
  for (let s = 0; s < r.length; s++)
    t[s * 4] = r[s], t[s * 4 + 1] = e[s], t[s * 4 + 2] = 0, t[s * 4 + 3] = 0;
  return t;
}
function aA(r) {
  const e = Math.max(r.rate, r.rate2) * r.numParticles + r.lifetime;
  return Date.now() + e * 1e3;
}
function oA(r, e) {
  const t = new Float32Array(r.length);
  for (let s = 0; s < r.length; s++)
    t[s] = r[s] - e[s];
  return t;
}
function _n(r, e) {
  const t = e.length, s = r.length / t;
  for (let i = 0; i < s; i++)
    for (let n = 0; n < t; n++) {
      const a = Math.abs(r[i * t + n]);
      e[n] = Math.max(e[n], a);
    }
}
function hA(r, e) {
  const t = e.length, s = r.length / t;
  for (let i = 0; i < s; i++)
    for (let n = 0; n < t; n++)
      r[i * t + n] /= e[n] === 0 ? 1 : e[n], r[i * t + n] *= 0.5, r[i * t + n] += 0.5;
}
function on(r, e, t) {
  const s = oA(e, r);
  return _n(s, t), hA(s, t), s;
}
const lA = new Ji();
class cA {
  constructor(e, t) {
    this.graphicsDevice = e;
    const s = e, i = 32;
    this.precision = i, this._addTimeTime = 0, Bd = this, _h = t, ne("numParticles", 1), this.numParticles > e.maxTextureSize && (this.numParticles = e.maxTextureSize), ne("rate", 1), ne("rate2", this.rate), ne("lifetime", 50), ne("emitterExtents", new v(0, 0, 0)), ne("emitterExtentsInner", new v(0, 0, 0)), ne("emitterRadius", 0), ne("emitterRadiusInner", 0), ne("emitterShape", Ds), ne("initialVelocity", 1), ne("wrap", !1), ne("localSpace", !1), ne("screenSpace", !1), ne("wrapBounds", null), ne("colorMap", this.defaultParamTexture), ne("normalMap", null), ne("loop", !0), ne("preWarm", !1), ne("sort", Cd), ne("mode", $_), ne("scene", null), ne("lighting", !1), ne("halfLambert", !1), ne("intensity", 1), ne("stretch", 0), ne("alignToMotion", !1), ne("depthSoftening", 0), ne("mesh", null), ne("particleNormal", new v(0, 1, 0)), ne("orientation", fh), ne("depthWrite", !1), ne("noFog", !1), ne("blendType", Vt), ne("node", null), ne("startAngle", 0), ne("startAngle2", this.startAngle), ne("animTilesX", 1), ne("animTilesY", 1), ne("animStartFrame", 0), ne("animNumFrames", 1), ne("animNumAnimations", 1), ne("animIndex", 0), ne("randomizeAnimIndex", !1), ne("animSpeed", 1), ne("animLoop", !0), this._gpuUpdater = new tA(this, s), this._cpuUpdater = new eA(this), this.constantLightCube = s.scope.resolve("lightCube[0]"), this.emitterPosUniform = new Float32Array(3), this.wrapBoundsUniform = new Float32Array(3), this.emitterScaleUniform = new Float32Array([1, 1, 1]), ne("colorGraph", sA), ne("colorGraph2", this.colorGraph), ne("scaleGraph", Fm), ne("scaleGraph2", this.scaleGraph), ne("alphaGraph", Fm), ne("alphaGraph2", this.alphaGraph), ne("localVelocityGraph", Om), ne("localVelocityGraph2", this.localVelocityGraph), ne("velocityGraph", Om), ne("velocityGraph2", this.velocityGraph), ne("rotationSpeedGraph", Bm), ne("rotationSpeedGraph2", this.rotationSpeedGraph), ne("radialSpeedGraph", Bm), ne("radialSpeedGraph2", this.radialSpeedGraph), this.lightCube = new Float32Array(6 * 3), this.lightCubeDir = new Array(6), this.lightCubeDir[0] = new v(-1, 0, 0), this.lightCubeDir[1] = new v(1, 0, 0), this.lightCubeDir[2] = new v(0, -1, 0), this.lightCubeDir[3] = new v(0, 1, 0), this.lightCubeDir[4] = new v(0, 0, -1), this.lightCubeDir[5] = new v(0, 0, 1), this.animTilesParams = new Float32Array(2), this.animParams = new Float32Array(4), this.animIndexParams = new Float32Array(2), this.internalTex0 = null, this.internalTex1 = null, this.internalTex2 = null, this.colorParam = null, this.vbToSort = null, this.vbOld = null, this.particleDistance = null, this.camera = null, this.swapTex = !1, this.useMesh = !0, this.useCpu = !e.supportsGpuParticles, this.pack8 = !0, this.localBounds = new Pe(), this.worldBoundsNoTrail = new Pe(), this.worldBoundsTrail = [new Pe(), new Pe()], this.worldBounds = new Pe(), this.worldBoundsSize = new v(), this.prevWorldBoundsSize = new v(), this.prevWorldBoundsCenter = new v(), this.prevEmitterExtents = this.emitterExtents, this.prevEmitterRadius = this.emitterRadius, this.worldBoundsMul = new v(), this.worldBoundsAdd = new v(), this.timeToSwitchBounds = 0, this.shaderParticleUpdateRespawn = null, this.shaderParticleUpdateNoRespawn = null, this.shaderParticleUpdateOnStop = null, this.numParticleVerts = 0, this.numParticleIndices = 0, this.material = null, this.meshInstance = null, this.drawOrder = 0, this.seed = Math.random(), this.fixedTimeStep = 1 / 60, this.maxSubSteps = 10, this.simTime = 0, this.simTimeTotal = 0, this.beenReset = !1, this._layer = null, this.rebuild();
  }
  get defaultParamTexture() {
    return lA.get(this.graphicsDevice, () => {
      const s = new Float32Array(1024);
      for (let n = 0; n < 16; n++)
        for (let a = 0; a < 16; a++) {
          const o = a + 1 - 8.5, h = n + 1 - 8.5, l = Dm(1 - Dm(Math.sqrt(o * o + h * h) / 16) - 0.5), c = n * 16 + a;
          s[c * 4] = 1, s[c * 4 + 1] = 1, s[c * 4 + 2] = 1, s[c * 4 + 3] = l;
        }
      const i = as(this.graphicsDevice, 16, 16, s, ye, 1, !0);
      return i.minFilter = rt, i.magFilter = rt, i;
    });
  }
  onChangeCamera() {
    this.regenShader(), this.resetMaterial();
  }
  calculateBoundsMad() {
    this.worldBoundsMul.x = 1 / this.worldBoundsSize.x, this.worldBoundsMul.y = 1 / this.worldBoundsSize.y, this.worldBoundsMul.z = 1 / this.worldBoundsSize.z, this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1), this.worldBoundsAdd.x += 0.5, this.worldBoundsAdd.y += 0.5, this.worldBoundsAdd.z += 0.5;
  }
  calculateWorldBounds() {
    if (!this.node)
      return;
    if (this.prevWorldBoundsSize.copy(this.worldBoundsSize), this.prevWorldBoundsCenter.copy(this.worldBounds.center), !this.useCpu) {
      let s = !1;
      this.emitterShape === Ds ? s = !this.emitterExtents.equals(this.prevEmitterExtents) : s = this.emitterRadius !== this.prevEmitterRadius, s && this.calculateLocalBounds();
    }
    const e = this.node.getWorldTransform();
    this.localSpace ? this.worldBoundsNoTrail.copy(this.localBounds) : this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, e), this.worldBoundsTrail[0].add(this.worldBoundsNoTrail), this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
    const t = this.simTimeTotal;
    t >= this.timeToSwitchBounds && (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]), this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail), this.timeToSwitchBounds = t + this.lifetime), this.worldBounds.copy(this.worldBoundsTrail[0]), this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2), this.localSpace ? (this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, e), this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, e)) : (this.meshInstance.aabb.copy(this.worldBounds), this.meshInstance.mesh.aabb.copy(this.worldBounds)), this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer, this.pack8 && this.calculateBoundsMad();
  }
  resetWorldBounds() {
    this.node && (this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? j.IDENTITY : this.node.getWorldTransform()), this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail), this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail), this.worldBounds.copy(this.worldBoundsTrail[0]), this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2), this.prevWorldBoundsSize.copy(this.worldBoundsSize), this.prevWorldBoundsCenter.copy(this.worldBounds.center), this.simTimeTotal = 0, this.timeToSwitchBounds = 0);
  }
  calculateLocalBounds() {
    let e = Number.MAX_VALUE, t = Number.MAX_VALUE, s = Number.MAX_VALUE, i = -Number.MAX_VALUE, n = -Number.MAX_VALUE, a = -Number.MAX_VALUE, o = 0, h = 0;
    const l = this.lifetime / this.precision, c = [this.qVelocity, this.qVelocity2], d = [this.qLocalVelocity, this.qLocalVelocity2], u = [0, 0], f = [0, 0], m = [0, 0], _ = [0, 0], p = [0, 0];
    let g, b, x;
    for (let S = 0; S < this.precision + 1; S++) {
      const C = Math.min(S, this.precision - 1);
      for (let w = 0; w < 2; w++)
        g = d[w][C * 3 + 0] * l + u[w], b = d[w][C * 3 + 1] * l + f[w], x = d[w][C * 3 + 2] * l + m[w], e = Math.min(g, e), t = Math.min(b, t), s = Math.min(x, s), i = Math.max(g, i), n = Math.max(b, n), a = Math.max(x, a), u[w] = g, f[w] = b, m[w] = x;
      for (let w = 0; w < 2; w++)
        p[w] += l * Math.sqrt(c[w][C * 3 + 0] * c[w][C * 3 + 0] + c[w][C * 3 + 1] * c[w][C * 3 + 1] + c[w][C * 3 + 2] * c[w][C * 3 + 2]);
      _[0] += this.qRadialSpeed[C] * l, _[1] += this.qRadialSpeed2[C] * l, o = Math.max(o, Math.max(Math.abs(_[0]), Math.abs(_[1]))), h = Math.max(h, this.qScale[C]);
    }
    this.emitterShape === Ds ? (g = this.emitterExtents.x * 0.5, b = this.emitterExtents.y * 0.5, x = this.emitterExtents.z * 0.5) : (g = this.emitterRadius, b = this.emitterRadius, x = this.emitterRadius);
    const y = Math.max(p[0], p[1]);
    Uo.x = e - h - g - o - y, Uo.y = t - h - b - o - y, Uo.z = s - h - x - o - y, Vo.x = i + h + g + o + y, Vo.y = n + h + b + o + y, Vo.z = a + h + x + o + y, this.localBounds.setMinMax(Uo, Vo);
  }
  rebuild() {
    const e = this.graphicsDevice;
    this.colorMap === null && (this.colorMap = this.defaultParamTexture), this.spawnBounds = this.emitterShape === Ds ? this.emitterExtents : this.emitterRadius, this.useCpu = this.useCpu || this.sort > Cd || e.maxVertexTextures <= 1 || e.fragmentUniformsCount < 64 || e.forceCpuParticles || !e.extTextureFloat, this._destroyResources(), this.pack8 = (this.pack8 || !e.textureFloatRenderable) && !this.useCpu, Js = this.useCpu || this.pack8 ? 4 : 2, this.useMesh = !1, this.mesh && (this.numParticles * this.mesh.vertexBuffer.numVertices > 65535 || (this.useMesh = !0)), this.numParticlesPot = U.nextPowerOfTwo(this.numParticles), this.rebuildGraphs(), this.calculateLocalBounds(), this.resetWorldBounds(), this.node && (this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? j.IDENTITY : this.node.getWorldTransform()), this.worldBoundsTrail[0].copy(this.worldBounds), this.worldBoundsTrail[1].copy(this.worldBounds), this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2), this.prevWorldBoundsSize.copy(this.worldBoundsSize), this.prevWorldBoundsCenter.copy(this.worldBounds.center), this.pack8 && this.calculateBoundsMad()), this.vbToSort = new Array(this.numParticles);
    for (let c = 0; c < this.numParticles; c++)
      this.vbToSort[c] = [0, 0];
    this.particleDistance = new Float32Array(this.numParticles), this._gpuUpdater.randomize(), this.particleTex = new Float32Array(this.numParticlesPot * Js * zo);
    const t = this.node === null || this.localSpace ? v.ZERO : this.node.getPosition();
    this.emitterShape === Ds && (this.node === null || this.localSpace ? an.setTRS(v.ZERO, ee.IDENTITY, this.spawnBounds) : an.setTRS(v.ZERO, this.node.getRotation(), km.copy(this.spawnBounds).mul(this.node.localScale)), Qs[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0, Qs[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0, Qs[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0);
    for (let c = 0; c < this.numParticles; c++)
      this._cpuUpdater.calcSpawnPosition(this.particleTex, an, Qs, t, c), this.useCpu && (this.particleTex[c * zo + 3 + this.numParticlesPot * 2 * zo] = 1);
    this.particleTexStart = new Float32Array(this.numParticlesPot * Js * zo);
    for (let c = 0; c < this.particleTexStart.length; c++)
      this.particleTexStart[c] = this.particleTex[c];
    this.useCpu || (this.pack8 ? (this.particleTexIN = as(e, this.numParticlesPot, Js, this.particleTex, ye, 1, !1), this.particleTexOUT = as(e, this.numParticlesPot, Js, this.particleTex, ye, 1, !1), this.particleTexStart = as(e, this.numParticlesPot, Js, this.particleTexStart, ye, 1, !1)) : (this.particleTexIN = as(e, this.numParticlesPot, Js, this.particleTex), this.particleTexOUT = as(e, this.numParticlesPot, Js, this.particleTex), this.particleTexStart = as(e, this.numParticlesPot, Js, this.particleTexStart)), this.rtParticleTexIN = new Dt({
      colorBuffer: this.particleTexIN,
      depth: !1
    }), this.rtParticleTexOUT = new Dt({
      colorBuffer: this.particleTexOUT,
      depth: !1
    }), this.swapTex = !1);
    const s = (this.localSpace ? `#define LOCAL_SPACE
` : "") + N.particleUpdaterInitPS + (this.pack8 ? N.particleInputRgba8PS + N.particleOutputRgba8PS : N.particleInputFloatPS + N.particleOutputFloatPS) + (this.emitterShape === Ds ? N.particleUpdaterAABBPS : N.particleUpdaterSpherePS) + N.particleUpdaterStartPS, i = s + N.particleUpdaterRespawnPS + N.particleUpdaterEndPS, n = s + N.particleUpdaterNoRespawnPS + N.particleUpdaterEndPS, a = s + N.particleUpdaterOnStopPS + N.particleUpdaterEndPS, o = this.emitterShape + "" + this.pack8 + this.localSpace;
    this.shaderParticleUpdateRespawn = ps(e, N.fullscreenQuadVS, i, "fsQuad0" + o), this.shaderParticleUpdateNoRespawn = ps(e, N.fullscreenQuadVS, n, "fsQuad1" + o), this.shaderParticleUpdateOnStop = ps(e, N.fullscreenQuadVS, a, "fsQuad2" + o), this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4, this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6, this._allocate(this.numParticles);
    const h = new _s(e);
    h.vertexBuffer = this.vertexBuffer, h.indexBuffer[0] = this.indexBuffer, h.primitive[0].type = Es, h.primitive[0].base = 0, h.primitive[0].count = this.numParticles * this.numParticleIndices, h.primitive[0].indexed = !0, this.material = new Ki(), this.material.name = this.node.name, this.material.cull = Ft, this.material.alphaWrite = !1, this.material.blend = !0, this.material.blendType = this.blendType, this.material.depthWrite = this.depthWrite, this.material.emitter = this, this.regenShader(), this.resetMaterial();
    const l = this.meshInstance ? this.meshInstance.visible : !0;
    this.meshInstance = new we(h, this.material, this.node), this.meshInstance.pick = !1, this.meshInstance.updateKey(), this.meshInstance.cull = !0, this.meshInstance._noDepthDrawGl1 = !0, this.localSpace ? this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform()) : this.meshInstance.aabb.copy(this.worldBounds), this.meshInstance._updateAabb = !1, this.meshInstance.visible = l, this._initializeTextures(), this.resetTime(), this.addTime(0, !1), this.preWarm && this.prewarm(this.lifetime);
  }
  _isAnimated() {
    return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
  }
  rebuildGraphs() {
    const e = this.precision, t = this.graphicsDevice;
    this.qLocalVelocity = this.localVelocityGraph.quantize(e), this.qVelocity = this.velocityGraph.quantize(e), this.qColor = this.colorGraph.quantizeClamped(e, 0, 1), this.qRotSpeed = this.rotationSpeedGraph.quantize(e), this.qScale = this.scaleGraph.quantize(e), this.qAlpha = this.alphaGraph.quantize(e), this.qRadialSpeed = this.radialSpeedGraph.quantize(e), this.qLocalVelocity2 = this.localVelocityGraph2.quantize(e), this.qVelocity2 = this.velocityGraph2.quantize(e), this.qColor2 = this.colorGraph2.quantizeClamped(e, 0, 1), this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(e), this.qScale2 = this.scaleGraph2.quantize(e), this.qAlpha2 = this.alphaGraph2.quantize(e), this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(e);
    for (let s = 0; s < e; s++)
      this.qRotSpeed[s] *= U.DEG_TO_RAD, this.qRotSpeed2[s] *= U.DEG_TO_RAD;
    if (this.localVelocityUMax = new Float32Array(3), this.velocityUMax = new Float32Array(3), this.colorUMax = new Float32Array(3), this.rotSpeedUMax = [0], this.scaleUMax = [0], this.alphaUMax = [0], this.radialSpeedUMax = [0], this.qLocalVelocityDiv = on(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax), this.qVelocityDiv = on(this.qVelocity, this.qVelocity2, this.velocityUMax), this.qColorDiv = on(this.qColor, this.qColor2, this.colorUMax), this.qRotSpeedDiv = on(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax), this.qScaleDiv = on(this.qScale, this.qScale2, this.scaleUMax), this.qAlphaDiv = on(this.qAlpha, this.qAlpha2, this.alphaUMax), this.qRadialSpeedDiv = on(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax), this.pack8) {
      const s = [0, 0, 0];
      _n(this.qVelocity, s);
      const i = [0, 0, 0];
      _n(this.qVelocity2, i);
      const n = [0, 0, 0];
      _n(this.qLocalVelocity, n);
      const a = [0, 0, 0];
      _n(this.qLocalVelocity2, a);
      const o = [0];
      _n(this.qRadialSpeed, o);
      const h = [0];
      _n(this.qRadialSpeed2, h);
      let l = Math.max(s[0], i[0]);
      l = Math.max(l, s[1]), l = Math.max(l, i[1]), l = Math.max(l, s[2]), l = Math.max(l, i[2]);
      let c = Math.max(n[0], a[0]);
      c = Math.max(c, n[1]), c = Math.max(c, a[1]), c = Math.max(c, n[2]), c = Math.max(c, a[2]);
      const d = Math.max(o[0], h[0]);
      this.maxVel = l + c + d;
    }
    this.useCpu || (this.internalTex0 = as(t, e, 1, Nm(this.qLocalVelocity, this.qLocalVelocityDiv)), this.internalTex1 = as(t, e, 1, Nm(this.qVelocity, this.qVelocityDiv)), this.internalTex2 = as(t, e, 1, nA(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv)), this.internalTex3 = as(t, e, 1, rA(this.qRadialSpeed, this.qRadialSpeedDiv))), this.colorParam = as(t, e, 1, iA(this.qColor, this.qAlpha), ye, 1, !0);
  }
  _initializeTextures() {
    this.colorMap && (this.material.setParameter("colorMap", this.colorMap), this.lighting && this.normalMap && this.material.setParameter("normalMap", this.normalMap));
  }
  regenShader() {
    const e = Vn(this.graphicsDevice);
    e.register("particle", ZC);
    const t = this.normalMap !== null;
    this.normalOption = 0, this.lighting && (this.normalOption = t ? 2 : 1), this.material.getShaderVariant = function(s, i, n, a, o, h, l, c) {
      this.emitter.scene && this.emitter.camera !== this.emitter.scene._activeCamera && (this.emitter.camera = this.emitter.scene._activeCamera, this.emitter.onChangeCamera());
      const d = this.emitter.inTools, u = new $r(l, c);
      return e.getProgram("particle", {
        useCpu: this.emitter.useCpu,
        normal: this.emitter.normalOption,
        halflambert: this.emitter.halfLambert,
        stretch: this.emitter.stretch,
        alignToMotion: this.emitter.alignToMotion,
        soft: this.emitter.depthSoftening,
        mesh: this.emitter.useMesh,
        gamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,
        toneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,
        fog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : "none",
        wrap: this.emitter.wrap && this.emitter.wrapBounds,
        localSpace: this.emitter.localSpace,
        screenSpace: d ? !1 : this.emitter.screenSpace,
        blend: this.blendType,
        animTex: this.emitter._isAnimated(),
        animTexLoop: this.emitter.animLoop,
        pack8: this.emitter.pack8,
        customFace: this.emitter.orientation !== fh
      }, u);
    }, this.material.shader = this.material.getShaderVariant();
  }
  resetMaterial() {
    const e = this.material;
    e.setParameter("stretch", this.stretch), this._isAnimated() && (e.setParameter("animTexTilesParams", this.animTilesParams), e.setParameter("animTexParams", this.animParams), e.setParameter("animTexIndexParams", this.animIndexParams)), e.setParameter("colorMult", this.intensity), this.useCpu || (e.setParameter("internalTex0", this.internalTex0), e.setParameter("internalTex1", this.internalTex1), e.setParameter("internalTex2", this.internalTex2), e.setParameter("internalTex3", this.internalTex3)), e.setParameter("colorParam", this.colorParam), e.setParameter("numParticles", this.numParticles), e.setParameter("numParticlesPot", this.numParticlesPot), e.setParameter("lifetime", this.lifetime), e.setParameter("rate", this.rate), e.setParameter("rateDiv", this.rate2 - this.rate), e.setParameter("seed", this.seed), e.setParameter("scaleDivMult", this.scaleUMax[0]), e.setParameter("alphaDivMult", this.alphaUMax[0]), e.setParameter("radialSpeedDivMult", this.radialSpeedUMax[0]), e.setParameter("graphNumSamples", this.precision), e.setParameter("graphSampleSize", 1 / this.precision), e.setParameter("emitterScale", new Float32Array([1, 1, 1])), this.pack8 && (this._gpuUpdater._setInputBounds(), e.setParameter("inBoundsSize", this._gpuUpdater.inBoundsSizeUniform), e.setParameter("inBoundsCenter", this._gpuUpdater.inBoundsCenterUniform), e.setParameter("maxVel", this.maxVel)), this.wrap && this.wrapBounds && (this.wrapBoundsUniform[0] = this.wrapBounds.x, this.wrapBoundsUniform[1] = this.wrapBounds.y, this.wrapBoundsUniform[2] = this.wrapBounds.z, e.setParameter("wrapBounds", this.wrapBoundsUniform)), this.colorMap && e.setParameter("colorMap", this.colorMap), this.lighting && this.normalMap && e.setParameter("normalMap", this.normalMap), this.depthSoftening > 0 && e.setParameter("softening", 1 / (this.depthSoftening * this.depthSoftening * 100)), this.stretch > 0 && (e.cull = Ft), this._compParticleFaceParams();
  }
  _compParticleFaceParams() {
    let e, t;
    if (this.orientation === fh)
      e = new Float32Array([1, 0, 0]), t = new Float32Array([0, 0, 1]);
    else {
      let s;
      this.orientation === pv ? s = this.particleNormal.normalize() : s = (this.node === null ? j.IDENTITY : this.node.getWorldTransform()).transformVector(this.particleNormal).normalize();
      const i = new v(1, 0, 0);
      Math.abs(i.dot(s)) === 1 && i.set(0, 0, 1);
      const n = new v().cross(s, i).normalize();
      i.cross(n, s).normalize(), e = new Float32Array([i.x, i.y, i.z]), t = new Float32Array([n.x, n.y, n.z]);
    }
    this.material.setParameter("faceTangent", e), this.material.setParameter("faceBinorm", t);
  }
  _allocate(e) {
    const t = e * this.numParticleVerts, s = e * this.numParticleIndices;
    if (this.vertexBuffer === void 0 || this.vertexBuffer.getNumVertices() !== t) {
      if (this.useCpu) {
        const c = [{
          semantic: Lh,
          components: 4,
          type: Ie
        }, {
          semantic: hd,
          components: 4,
          type: Ie
        }, {
          semantic: A_,
          components: 4,
          type: Ie
        }, {
          semantic: M_,
          components: 1,
          type: Ie
        }, {
          semantic: E_,
          components: this.useMesh ? 4 : 2,
          type: Ie
        }], d = new Ot(this.graphicsDevice, c);
        this.vertexBuffer = new yi(this.graphicsDevice, d, t, Na), this.indexBuffer = new ji(this.graphicsDevice, pi, s);
      } else {
        const c = [{
          semantic: Lh,
          components: 4,
          type: Ie
        }];
        this.useMesh && c.push({
          semantic: hd,
          components: 2,
          type: Ie
        });
        const d = new Ot(this.graphicsDevice, c);
        this.vertexBuffer = new yi(this.graphicsDevice, d, t, Na), this.indexBuffer = new ji(this.graphicsDevice, pi, s);
      }
      const i = new Float32Array(this.vertexBuffer.lock());
      let n, a, o;
      if (this.useMesh) {
        n = new Float32Array(this.mesh.vertexBuffer.lock()), a = n.length / this.mesh.vertexBuffer.numVertices;
        for (let c = 0; c < this.mesh.vertexBuffer.format.elements.length; c++)
          if (this.mesh.vertexBuffer.format.elements[c].name === rs) {
            o = this.mesh.vertexBuffer.format.elements[c].offset / 4;
            break;
          }
      }
      for (let c = 0; c < t; c++) {
        const d = Math.floor(c / this.numParticleVerts);
        if (this.useMesh) {
          const u = c % this.numParticleVerts;
          i[c * 6] = n[u * a], i[c * 6 + 1] = n[u * a + 1], i[c * 6 + 2] = n[u * a + 2], i[c * 6 + 3] = d, i[c * 6 + 4] = n[u * a + o + 0], i[c * 6 + 5] = 1 - n[u * a + o + 1];
        } else {
          const u = c % 4;
          i[c * 4] = Im[u][0], i[c * 4 + 1] = Im[u][1], i[c * 4 + 2] = 0, i[c * 4 + 3] = d;
        }
      }
      this.useCpu && (this.vbCPU = new Float32Array(i), this.vbOld = new Float32Array(this.vbCPU.length)), this.vertexBuffer.unlock(), this.useMesh && this.mesh.vertexBuffer.unlock();
      let h = 0;
      const l = new Uint16Array(this.indexBuffer.lock());
      this.useMesh && (n = new Uint16Array(this.mesh.indexBuffer[0].lock()));
      for (let c = 0; c < e; c++)
        if (this.useMesh)
          for (let d = 0; d < this.numParticleIndices; d++)
            l[c * this.numParticleIndices + d] = n[d] + c * this.numParticleVerts;
        else {
          const d = c * 4;
          l[h++] = d, l[h++] = d + 1, l[h++] = d + 2, l[h++] = d, l[h++] = d + 2, l[h++] = d + 3;
        }
      this.indexBuffer.unlock(), this.useMesh && this.mesh.indexBuffer[0].unlock();
    }
  }
  reset() {
    if (this.beenReset = !0, this.seed = Math.random(), this.material.setParameter("seed", this.seed), this.useCpu)
      for (let t = 0; t < this.particleTexStart.length; t++)
        this.particleTex[t] = this.particleTexStart[t];
    else
      this._initializeTextures();
    this.resetWorldBounds(), this.resetTime();
    const e = this.loop;
    this.loop = !0, this.addTime(0, !1), this.loop = e, this.preWarm && this.prewarm(this.lifetime);
  }
  prewarm(e) {
    const t = e / this.lifetime, s = Math.min(Math.floor(t * this.precision), this.precision), i = e / s;
    for (let n = 0; n < s; n++)
      this.addTime(i, !1);
  }
  resetTime() {
    this.endTime = aA(this);
  }
  finishFrame() {
    this.useCpu && this.vertexBuffer.unlock();
  }
  addTime(e, t) {
    const s = this.graphicsDevice;
    if (this.simTimeTotal += e, this.calculateWorldBounds(), this._isAnimated()) {
      const a = this.animTilesParams;
      a[0] = 1 / this.animTilesX, a[1] = 1 / this.animTilesY;
      const o = this.animParams;
      o[0] = this.animStartFrame, o[1] = this.animNumFrames * this.animSpeed, o[2] = this.animNumFrames - 1, o[3] = this.animNumAnimations - 1;
      const h = this.animIndexParams;
      h[0] = this.animIndex, h[1] = this.randomizeAnimIndex;
    }
    this.scene && this.camera !== this.scene._activeCamera && (this.camera = this.scene._activeCamera, this.onChangeCamera()), this.emitterShape === Ds && (Qs[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0, Qs[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0, Qs[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0, this.meshInstance.node === null ? an.setTRS(v.ZERO, ee.IDENTITY, this.emitterExtents) : an.setTRS(v.ZERO, this.meshInstance.node.getRotation(), km.copy(this.emitterExtents).mul(this.meshInstance.node.localScale)));
    let i;
    const n = this.meshInstance.node === null ? v.ONE : this.meshInstance.node.localScale;
    if (this.emitterScaleUniform[0] = n.x, this.emitterScaleUniform[1] = n.y, this.emitterScaleUniform[2] = n.z, this.material.setParameter("emitterScale", this.emitterScaleUniform), this.localSpace && this.meshInstance.node && (i = this.meshInstance.node.getPosition(), this.emitterPosUniform[0] = i.x, this.emitterPosUniform[1] = i.y, this.emitterPosUniform[2] = i.z, this.material.setParameter("emitterPos", this.emitterPosUniform)), this._compParticleFaceParams(), !this.useCpu)
      this._gpuUpdater.update(s, an, Qs, e, t);
    else {
      const a = new Float32Array(this.vertexBuffer.lock());
      this._cpuUpdater.update(a, this.vbToSort, this.particleTex, an, Qs, i, e, t);
    }
    this.loop || Date.now() > this.endTime && (this.onFinished && this.onFinished(), this.meshInstance.visible = !1), this.meshInstance && (this.meshInstance.drawOrder = this.drawOrder);
  }
  _destroyResources() {
    this.particleTexIN && (this.particleTexIN.destroy(), this.particleTexIN = null), this.particleTexOUT && (this.particleTexOUT.destroy(), this.particleTexOUT = null), this.particleTexStart && this.particleTexStart.destroy && (this.particleTexStart.destroy(), this.particleTexStart = null), this.rtParticleTexIN && (this.rtParticleTexIN.destroy(), this.rtParticleTexIN = null), this.rtParticleTexOUT && (this.rtParticleTexOUT.destroy(), this.rtParticleTexOUT = null), this.internalTex0 && (this.internalTex0.destroy(), this.internalTex0 = null), this.internalTex1 && (this.internalTex1.destroy(), this.internalTex1 = null), this.internalTex2 && (this.internalTex2.destroy(), this.internalTex2 = null), this.internalTex3 && (this.internalTex3.destroy(), this.internalTex3 = null), this.colorParam && (this.colorParam.destroy(), this.colorParam = null), this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBuffer = void 0), this.indexBuffer && (this.indexBuffer.destroy(), this.indexBuffer = void 0), this.material && (this.material.destroy(), this.material = null);
  }
  destroy() {
    this.camera = null, this._destroyResources();
  }
}
const dA = {
  generateKey: function(r) {
    return r.type === "cubemap" ? `skybox-${r.type}-${r.encoding}-${r.useIntensity}-${r.gamma}-${r.toneMapping}-${r.fixSeams}-${r.mip}` : `skybox-${r.type}-${r.encoding}-${r.useIntensity}-${r.gamma}-${r.toneMapping}`;
  },
  createShaderDefinition: function(r, e) {
    let t = "";
    if (e.type === "cubemap") {
      const s = [128, 64, 16, 8, 4, 2];
      t += e.mip ? N.fixCubemapSeamsStretchPS : N.fixCubemapSeamsNonePS, t += e.useIntensity ? N.envMultiplyPS : N.envConstPS, t += N.decodePS, t += Yh(e.gamma), t += Kh(e.toneMapping), t += N.skyboxHDRPS.replace(/\$DECODE/g, ks.decodeFunc(e.encoding)).replace(/\$FIXCONST/g, 1 - 1 / s[e.mip] + "");
    } else
      t += e.useIntensity ? N.envMultiplyPS : N.envConstPS, t += N.decodePS, t += Yh(e.gamma), t += Kh(e.toneMapping), t += N.sphericalPS, t += N.envAtlasPS, t += N.skyboxEnvPS.replace(/\$DECODE/g, ks.decodeFunc(e.encoding));
    return pt.createDefinition(r, {
      attributes: {
        aPosition: et
      },
      vertexCode: N.skyboxVS,
      fragmentCode: t
    });
  }
};
class uA {
  constructor(e, t, s) {
    this.meshInstance = void 0;
    const i = new Ki();
    i.getShaderVariant = function(a, o, h, l, c, d, u, f) {
      const m = s.cubemap ? {
        type: "cubemap",
        encoding: s.encoding,
        useIntensity: t.skyboxIntensity !== 1 || t.physicalUnits,
        mip: s.fixCubemapSeams ? t.skyboxMip : 0,
        fixSeams: s.fixCubemapSeams,
        gamma: c === fi ? t.gammaCorrection ? Vh : Uh : t.gammaCorrection,
        toneMapping: c === fi ? Gh : t.toneMapping
      } : {
        type: "envAtlas",
        encoding: s.encoding,
        useIntensity: t.skyboxIntensity !== 1 || t.physicalUnits,
        gamma: c === fi ? t.gammaCorrection ? Vh : Uh : t.gammaCorrection,
        toneMapping: c === fi ? Gh : t.toneMapping
      }, _ = new $r(u, f), p = Vn(e);
      return p.register("skybox", dA), p.getProgram("skybox", m, _);
    }, s.cubemap ? i.setParameter("texture_cubeMap", s) : (i.setParameter("texture_envAtlas", s), i.setParameter("mipLevel", t._skyboxMip)), i.cull = Mh, i.depthWrite = !1;
    const n = t.layers.getLayerById(Pu);
    if (n) {
      const a = new bt("Skybox"), o = tg(e), h = new we(o, i, a);
      this.meshInstance = h, h.cull = !1, h._noDepthDrawGl1 = !0, h.pick = !1, n.addMeshInstances([h]), this.skyLayer = n;
    }
  }
  destroy() {
    this.meshInstance && (this.skyLayer && this.skyLayer.removeMeshInstances([this.meshInstance]), this.meshInstance.destroy(), this.meshInstance = null);
  }
}
const Jh = new bt();
Jh.worldTransform = j.IDENTITY;
Jh._dirtyWorld = Jh._dirtyNormal = !1;
class fA {
  constructor(e, t, s) {
    this.material = t, this.layer = s, this.positions = [], this.colors = [], this.mesh = new _s(e), this.meshInstance = null;
  }
  addLines(e, t) {
    const s = this.positions, i = e.length;
    for (let a = 0; a < i; a++) {
      const o = e[a];
      s.push(o.x, o.y, o.z);
    }
    const n = this.colors;
    if (t.length)
      for (let a = 0; a < i; a++) {
        const o = t[a];
        n.push(o.r, o.g, o.b, o.a);
      }
    else
      for (let a = 0; a < i; a++)
        n.push(t.r, t.g, t.b, t.a);
  }
  addLinesArrays(e, t) {
    const s = this.positions;
    for (let n = 0; n < e.length; n += 3)
      s.push(e[n], e[n + 1], e[n + 2]);
    const i = this.colors;
    if (t.length)
      for (let n = 0; n < t.length; n += 4)
        i.push(t[n], t[n + 1], t[n + 2], t[n + 3]);
    else {
      const n = e.length / 3;
      for (let a = 0; a < n; a++)
        i.push(t.r, t.g, t.b, t.a);
    }
  }
  onPreRender(e, t) {
    this.positions.length > 0 && this.material.transparent === t && (this.mesh.setPositions(this.positions), this.mesh.setColors(this.colors), this.mesh.update(Ll, !1), this.meshInstance || (this.meshInstance = new we(this.mesh, this.material, Jh)), this.positions.length = 0, this.colors.length = 0, e.list.push(this.meshInstance), e.length++);
  }
}
class mA {
  constructor(e) {
    this.device = e, this.map = /* @__PURE__ */ new Map();
  }
  getBatch(e, t) {
    let s = this.map.get(e);
    return s || (s = new fA(this.device, e, t), this.map.set(e, s)), s;
  }
  onPreRender(e, t) {
    this.map.forEach((s) => {
      s.onPreRender(e, t);
    });
  }
}
const vs = [];
class Qh {
  constructor(e) {
    this.device = e, this.quadMesh = null, this.textureShader = null, this.depthTextureShader = null, this.cubeLocalPos = null, this.cubeWorldPos = null, this.batchesMap = /* @__PURE__ */ new Map(), this.allBatches = /* @__PURE__ */ new Set(), this.updatedLayers = /* @__PURE__ */ new Set(), this._materialDepth = null, this._materialNoDepth = null, this.layerMeshInstances = /* @__PURE__ */ new Map();
  }
  createMaterial(e) {
    const t = new Tn();
    return t.vertexColors = !0, t.blend = !0, t.blendType = Vt, t.depthTest = e, t.update(), t;
  }
  get materialDepth() {
    return this._materialDepth || (this._materialDepth = this.createMaterial(!0)), this._materialDepth;
  }
  get materialNoDepth() {
    return this._materialNoDepth || (this._materialNoDepth = this.createMaterial(!1)), this._materialNoDepth;
  }
  getBatch(e, t) {
    let s = this.batchesMap.get(e);
    s || (s = new mA(this.device), this.batchesMap.set(e, s)), this.allBatches.add(s);
    const i = t ? this.materialDepth : this.materialNoDepth;
    return s.getBatch(i, e);
  }
  static getTextureVS() {
    return `
						attribute vec2 vertex_position;
						uniform mat4 matrix_model;
						varying vec2 uv0;
						void main(void) {
								gl_Position = matrix_model * vec4(vertex_position, 0, 1);
								uv0 = vertex_position.xy + 0.5;
						}
				`;
  }
  getTextureShader() {
    if (!this.textureShader) {
      const e = `
								varying vec2 uv0;
								uniform sampler2D colorMap;
								void main (void) {
										gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
								}
						`;
      this.textureShader = ps(this.device, Qh.getTextureVS(), e, "DebugTextureShader");
    }
    return this.textureShader;
  }
  getDepthTextureShader() {
    if (!this.depthTextureShader) {
      const e = `
								${N.screenDepthPS}
								varying vec2 uv0;
								void main() {
										float depth = getLinearScreenDepth(uv0) * camera_params.x;
										gl_FragColor = vec4(vec3(depth), 1.0);
								}
						`;
      this.depthTextureShader = ps(this.device, Qh.getTextureVS(), e, "DebugDepthTextureShader");
    }
    return this.depthTextureShader;
  }
  getQuadMesh() {
    return this.quadMesh || (this.quadMesh = new _s(this.device), this.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]), this.quadMesh.update(jr)), this.quadMesh;
  }
  drawMesh(e, t, s, i, n) {
    if (!i) {
      const o = this.getGraphNode(t);
      i = new we(s, e, o);
    }
    let a = this.layerMeshInstances.get(n);
    a || (a = [], this.layerMeshInstances.set(n, a)), a.push(i);
  }
  drawWireAlignedBox(e, t, s, i, n) {
    vs.push(e.x, e.y, e.z, e.x, t.y, e.z, e.x, t.y, e.z, t.x, t.y, e.z, t.x, t.y, e.z, t.x, e.y, e.z, t.x, e.y, e.z, e.x, e.y, e.z, e.x, e.y, t.z, e.x, t.y, t.z, e.x, t.y, t.z, t.x, t.y, t.z, t.x, t.y, t.z, t.x, e.y, t.z, t.x, e.y, t.z, e.x, e.y, t.z, e.x, e.y, e.z, e.x, e.y, t.z, e.x, t.y, e.z, e.x, t.y, t.z, t.x, t.y, e.z, t.x, t.y, t.z, t.x, e.y, e.z, t.x, e.y, t.z), this.getBatch(n, i).addLinesArrays(vs, s), vs.length = 0;
  }
  drawWireSphere(e, t, s, i, n, a) {
    const o = 2 * Math.PI / i;
    let h = 0;
    for (let c = 0; c < i; c++) {
      const d = Math.sin(h), u = Math.cos(h);
      h += o;
      const f = Math.sin(h), m = Math.cos(h);
      vs.push(e.x + t * d, e.y, e.z + t * u), vs.push(e.x + t * f, e.y, e.z + t * m), vs.push(e.x + t * d, e.y + t * u, e.z), vs.push(e.x + t * f, e.y + t * m, e.z), vs.push(e.x, e.y + t * d, e.z + t * u), vs.push(e.x, e.y + t * f, e.z + t * m);
    }
    this.getBatch(a, n).addLinesArrays(vs, s), vs.length = 0;
  }
  getGraphNode(e) {
    const t = new bt("ImmediateDebug");
    return t.worldTransform = e, t._dirtyWorld = t._dirtyNormal = !1, t;
  }
  onPreRenderLayer(e, t, s) {
    if (this.batchesMap.forEach((i, n) => {
      n === e && i.onPreRender(t, s);
    }), !this.updatedLayers.has(e)) {
      this.updatedLayers.add(e);
      const i = this.layerMeshInstances.get(e);
      if (i) {
        for (let n = 0; n < i.length; n++)
          t.list[t.length + n] = i[n];
        t.length += i.length, i.length = 0;
      }
    }
  }
  onPostRender() {
    this.allBatches.clear(), this.updatedLayers.clear();
  }
}
class pA extends _e {
  constructor(e) {
    super(), this.ambientBake = !1, this.ambientBakeOcclusionBrightness = 0, this.ambientBakeOcclusionContrast = 0, this.ambientLight = new z(0, 0, 0), this.ambientLuminance = 0, this.exposure = 1, this.fogColor = new z(0, 0, 0), this.fogDensity = 0, this.fogEnd = 1e3, this.fogStart = 1, this.lightmapSizeMultiplier = 1, this.lightmapMaxResolution = 2048, this.lightmapMode = mh, this.lightmapFilterEnabled = !1, this.lightmapHDR = !1, this.root = null, this.sky = null, this.physicalUnits = !1, this.device = e || xi.get(), this._gravity = new v(0, -9.8, 0), this._layers = null, this._fog = Hl, this._gammaCorrection = Y_, this._toneMapping = 0, this._skyboxCubeMap = null, this._prefilteredCubemaps = [null, null, null, null, null, null], this._envAtlas = null, this._internalEnvAtlas = null, this._skyboxIntensity = 1, this._skyboxLuminance = 0, this._skyboxMip = 0, this._skyboxRotation = new ee(), this._skyboxRotationMat3 = new is(), this._skyboxRotationMat4 = new j(), this._ambientBakeNumSamples = 1, this._ambientBakeSpherePart = 0.4, this._lightmapFilterRange = 10, this._lightmapFilterSmoothness = 0.2, this._clusteredLightingEnabled = !0, this._lightingParams = new pg(this.device.supportsAreaLights, this.device.maxTextureSize, () => {
      this._layers._dirtyLights = !0;
    }), this._stats = {
      meshInstances: 0,
      lights: 0,
      dynamicLights: 0,
      bakedLights: 0,
      lastStaticPrepareFullTime: 0,
      lastStaticPrepareSearchTime: 0,
      lastStaticPrepareWriteTime: 0,
      lastStaticPrepareTriAabbTime: 0,
      lastStaticPrepareCombineTime: 0,
      updateShadersTime: 0
    }, this.updateShaders = !0, this._shaderVersion = 0, this._statsUpdated = !1, this.immediate = new Qh(this.device);
  }
  get defaultDrawLayer() {
    return this.layers.getLayerById(zh);
  }
  set ambientBakeNumSamples(e) {
    this._ambientBakeNumSamples = U.clamp(Math.floor(e), 1, 255);
  }
  get ambientBakeNumSamples() {
    return this._ambientBakeNumSamples;
  }
  set ambientBakeSpherePart(e) {
    this._ambientBakeSpherePart = U.clamp(e, 1e-3, 1);
  }
  get ambientBakeSpherePart() {
    return this._ambientBakeSpherePart;
  }
  set clusteredLightingEnabled(e) {
    if (!this._clusteredLightingEnabled && e) {
      console.error("Turning on disabled clustered lighting is not currently supported");
      return;
    }
    this._clusteredLightingEnabled = e;
  }
  get clusteredLightingEnabled() {
    return this._clusteredLightingEnabled;
  }
  set drawCalls(e) {
  }
  get drawCalls() {
    let e = this.layers._meshInstances;
    return e.length || (this.layers._update(this.device, this.clusteredLightingEnabled), e = this.layers._meshInstances), e;
  }
  set envAtlas(e) {
    e !== this._envAtlas && (this._envAtlas = e, e && (e.addressU = xt, e.addressV = he, e.minFilter = rt, e.magFilter = rt, e.mipmaps = !1), this.updateShaders = !0);
  }
  get envAtlas() {
    return this._envAtlas;
  }
  set fog(e) {
    e !== this._fog && (this._fog = e, this.updateShaders = !0);
  }
  get fog() {
    return this._fog;
  }
  set gammaCorrection(e) {
    e !== this._gammaCorrection && (this._gammaCorrection = e, this.updateShaders = !0);
  }
  get gammaCorrection() {
    return this._gammaCorrection;
  }
  set layers(e) {
    const t = this._layers;
    this._layers = e, this.fire("set:layers", t, e);
  }
  get layers() {
    return this._layers;
  }
  get lighting() {
    return this._lightingParams;
  }
  set lightmapFilterRange(e) {
    this._lightmapFilterRange = Math.max(e, 1e-3);
  }
  get lightmapFilterRange() {
    return this._lightmapFilterRange;
  }
  set lightmapFilterSmoothness(e) {
    this._lightmapFilterSmoothness = Math.max(e, 1e-3);
  }
  get lightmapFilterSmoothness() {
    return this._lightmapFilterSmoothness;
  }
  set prefilteredCubemaps(e) {
    const t = this._prefilteredCubemaps;
    e = e || [];
    let s = !1, i = !0;
    for (let n = 0; n < 6; ++n) {
      const a = e[n] || null;
      t[n] !== a && (t[n] = a, s = !0), i = i && !!t[n];
    }
    s && (this._resetSky(), i ? (this._internalEnvAtlas = ug.generatePrefilteredAtlas(t, {
      target: this._internalEnvAtlas
    }), this._envAtlas || (this.envAtlas = this._internalEnvAtlas)) : this._internalEnvAtlas && (this._envAtlas === this._internalEnvAtlas && (this.envAtlas = null), this._internalEnvAtlas.destroy(), this._internalEnvAtlas = null));
  }
  get prefilteredCubemaps() {
    return this._prefilteredCubemaps;
  }
  set skybox(e) {
    e !== this._skyboxCubeMap && (this._skyboxCubeMap = e, this._resetSky());
  }
  get skybox() {
    return this._skyboxCubeMap;
  }
  set skyboxIntensity(e) {
    e !== this._skyboxIntensity && (this._skyboxIntensity = e, this._resetSky());
  }
  get skyboxIntensity() {
    return this._skyboxIntensity;
  }
  set skyboxLuminance(e) {
    e !== this._skyboxLuminance && (this._skyboxLuminance = e, this._resetSky());
  }
  get skyboxLuminance() {
    return this._skyboxLuminance;
  }
  set skyboxMip(e) {
    e !== this._skyboxMip && (this._skyboxMip = e, this._resetSky());
  }
  get skyboxMip() {
    return this._skyboxMip;
  }
  set skyboxRotation(e) {
    this._skyboxRotation.equals(e) || (this._skyboxRotation.copy(e), e.equals(ee.IDENTITY) ? this._skyboxRotationMat3.setIdentity() : (this._skyboxRotationMat4.setTRS(v.ZERO, e, v.ONE), this._skyboxRotationMat4.invertTo3x3(this._skyboxRotationMat3)), this._resetSky());
  }
  get skyboxRotation() {
    return this._skyboxRotation;
  }
  set toneMapping(e) {
    e !== this._toneMapping && (this._toneMapping = e, this.updateShaders = !0);
  }
  get toneMapping() {
    return this._toneMapping;
  }
  destroy() {
    this._resetSky(), this.root = null, this.off();
  }
  drawLine(e, t, s = z.WHITE, i = !0, n = this.defaultDrawLayer) {
    this.immediate.getBatch(n, i).addLines([e, t], [s, s]);
  }
  drawLines(e, t, s = !0, i = this.defaultDrawLayer) {
    this.immediate.getBatch(i, s).addLines(e, t);
  }
  drawLineArrays(e, t, s = !0, i = this.defaultDrawLayer) {
    this.immediate.getBatch(i, s).addLinesArrays(e, t);
  }
  applySettings(e) {
    const t = e.physics, s = e.render;
    this._gravity.set(t.gravity[0], t.gravity[1], t.gravity[2]), this.ambientLight.set(s.global_ambient[0], s.global_ambient[1], s.global_ambient[2]), this.ambientLuminance = s.ambientLuminance, this._fog = s.fog, this.fogColor.set(s.fog_color[0], s.fog_color[1], s.fog_color[2]), this.fogStart = s.fog_start, this.fogEnd = s.fog_end, this.fogDensity = s.fog_density, this._gammaCorrection = s.gamma_correction, this._toneMapping = s.tonemapping, this.lightmapSizeMultiplier = s.lightmapSizeMultiplier, this.lightmapMaxResolution = s.lightmapMaxResolution, this.lightmapMode = s.lightmapMode, this.exposure = s.exposure, this._skyboxIntensity = s.skyboxIntensity === void 0 ? 1 : s.skyboxIntensity, this._skyboxLuminance = s.skyboxLuminance === void 0 ? 2e4 : s.skyboxLuminance, this._skyboxMip = s.skyboxMip === void 0 ? 0 : s.skyboxMip, s.skyboxRotation && (this.skyboxRotation = new ee().setFromEulerAngles(s.skyboxRotation[0], s.skyboxRotation[1], s.skyboxRotation[2])), this.clusteredLightingEnabled = s.clusteredLightingEnabled, this.lighting.applySettings(s), ["lightmapFilterEnabled", "lightmapFilterRange", "lightmapFilterSmoothness", "ambientBake", "ambientBakeNumSamples", "ambientBakeSpherePart", "ambientBakeOcclusionBrightness", "ambientBakeOcclusionContrast"].forEach((i) => {
      s.hasOwnProperty(i) && (this[i] = s[i]);
    }), this._resetSky();
  }
  _getSkyboxTex() {
    const e = this._prefilteredCubemaps;
    return this._skyboxMip ? e[[0, 1, 3, 4, 5, 6][this._skyboxMip]] || this._envAtlas || e[0] || this._skyboxCubeMap : this._skyboxCubeMap || e[0] || this._envAtlas;
  }
  _updateSky(e) {
    if (!this.sky) {
      const t = this._getSkyboxTex();
      t && (this.sky = new uA(e, this, t), this.fire("set:skybox", t));
    }
  }
  _resetSky() {
    var e;
    (e = this.sky) == null || e.destroy(), this.sky = null, this.updateShaders = !0;
  }
  setSkybox(e) {
    e ? (this.skybox = e[0] || null, this.prefilteredCubemaps = e.slice(1)) : (this.skybox = null, this.prefilteredCubemaps = [null, null, null, null, null, null]);
  }
  get lightmapPixelFormat() {
    return this.lightmapHDR && this.device.getHdrFormat(!1, !0, !1, !0) || ye;
  }
}
class yg {
  constructor(e, t, s) {
    this.device = e, this.inverseBindPose = t, this.boneNames = s;
  }
}
const _A = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], gA = [0, 1, 3, 2, 3, 1];
class yA extends _e {
  constructor(e, t) {
    super(), this._device = e, this._pixelsPerUnit = t && t.pixelsPerUnit !== void 0 ? t.pixelsPerUnit : 1, this._renderMode = t && t.renderMode !== void 0 ? t.renderMode : Ni, this._atlas = t && t.atlas !== void 0 ? t.atlas : null, this._frameKeys = t && t.frameKeys !== void 0 ? t.frameKeys : null, this._meshes = [], this._updatingProperties = !1, this._meshesDirty = !1, this._atlas && this._frameKeys && this._createMeshes();
  }
  set frameKeys(e) {
    this._frameKeys = e, this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()), this.fire("set:frameKeys", e);
  }
  get frameKeys() {
    return this._frameKeys;
  }
  set atlas(e) {
    e !== this._atlas && (this._atlas && (this._atlas.off("set:frames", this._onSetFrames, this), this._atlas.off("set:frame", this._onFrameChanged, this), this._atlas.off("remove:frame", this._onFrameRemoved, this)), this._atlas = e, this._atlas && this._frameKeys && (this._atlas.on("set:frames", this._onSetFrames, this), this._atlas.on("set:frame", this._onFrameChanged, this), this._atlas.on("remove:frame", this._onFrameRemoved, this), this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()), this.fire("set:atlas", e));
  }
  get atlas() {
    return this._atlas;
  }
  set pixelsPerUnit(e) {
    this._pixelsPerUnit !== e && (this._pixelsPerUnit = e, this.fire("set:pixelsPerUnit", e), this._atlas && this._frameKeys && this.renderMode === Ni && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes()));
  }
  get pixelsPerUnit() {
    return this._pixelsPerUnit;
  }
  set renderMode(e) {
    if (this._renderMode === e)
      return;
    const t = this._renderMode;
    this._renderMode = e, this.fire("set:renderMode", e), (t === Ni || e === Ni) && this._atlas && this._frameKeys && (this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes());
  }
  get renderMode() {
    return this._renderMode;
  }
  get meshes() {
    return this._meshes;
  }
  _createMeshes() {
    const e = this._meshes.length;
    for (let i = 0; i < e; i++) {
      const n = this._meshes[i];
      n && n.destroy();
    }
    const t = this._frameKeys.length;
    this._meshes = new Array(t);
    const s = this.renderMode === ht || this._renderMode === it ? this._create9SliceMesh : this._createSimpleMesh;
    for (let i = 0; i < t; i++) {
      const n = this._atlas.frames[this._frameKeys[i]];
      this._meshes[i] = n ? s.call(this, n) : null;
    }
    this.fire("set:meshes");
  }
  _createSimpleMesh(e) {
    const t = e.rect, s = this._atlas.texture.width, i = this._atlas.texture.height, n = t.z / this._pixelsPerUnit, a = t.w / this._pixelsPerUnit, o = e.pivot.x, h = e.pivot.y, l = [-o * n, -h * a, 0, (1 - o) * n, -h * a, 0, (1 - o) * n, (1 - h) * a, 0, -o * n, (1 - h) * a, 0], c = t.x / s, d = 1 - t.y / i, u = (t.x + t.z) / s, f = 1 - (t.y + t.w) / i, m = [c, d, u, d, u, f, c, f];
    return vi(this._device, l, {
      uvs: m,
      normals: _A,
      indices: gA
    });
  }
  _create9SliceMesh() {
    const e = q.ONE, t = 3, s = 3, i = [], n = [], a = [], o = [];
    let h = 0;
    for (let c = 0; c <= t; c++) {
      const d = c === 0 || c === t ? 0 : 1;
      for (let u = 0; u <= s; u++) {
        const f = -e.x + 2 * e.x * (c <= 1 ? 0 : 3) / t, m = 0, _ = -(-e.y + 2 * e.y * (u <= 1 ? 0 : 3) / s), p = u === 0 || u === s ? 0 : 1;
        i.push(-f, m, _), n.push(0, 1, 0), a.push(d, p), c < t && u < s && (o.push(h + s + 1, h + 1, h), o.push(h + s + 1, h + s + 2, h + 1)), h++;
      }
    }
    const l = {
      normals: n,
      uvs: a,
      indices: o
    };
    return vi(this._device, i, l);
  }
  _onSetFrames(e) {
    this._updatingProperties ? this._meshesDirty = !0 : this._createMeshes();
  }
  _onFrameChanged(e, t) {
    const s = this._frameKeys.indexOf(e);
    s < 0 || (t ? this.renderMode === Ni && (this._meshes[s] = this._createSimpleMesh(t)) : this._meshes[s] = null, this.fire("set:meshes"));
  }
  _onFrameRemoved(e) {
    const t = this._frameKeys.indexOf(e);
    t < 0 || (this._meshes[t] = null, this.fire("set:meshes"));
  }
  startUpdate() {
    this._updatingProperties = !0, this._meshesDirty = !1;
  }
  endUpdate() {
    this._updatingProperties = !1, this._meshesDirty && this._atlas && this._frameKeys && this._createMeshes(), this._meshesDirty = !1;
  }
  destroy() {
    for (const e of this._meshes)
      e && e.destroy();
    this._meshes.length = 0;
  }
}
class Lr {
  constructor(e) {
    this.func = e.func === void 0 ? Mn : e.func, this.ref = e.ref || 0, this.readMask = e.readMask === void 0 ? 255 : e.readMask, this.writeMask = e.writeMask === void 0 ? 255 : e.writeMask, this.fail = e.fail || us, this.zfail = e.zfail || us, this.zpass = e.zpass || us;
  }
  clone() {
    return new Lr({
      func: this.func,
      ref: this.ref,
      readMask: this.readMask,
      writeMask: this.writeMask,
      fail: this.fail,
      zfail: this.zfail,
      zpass: this.zpass
    });
  }
}
class xA extends _e {
  constructor() {
    super(), this._texture = null, this._frames = null;
  }
  set texture(e) {
    this._texture = e, this.fire("set:texture", e);
  }
  get texture() {
    return this._texture;
  }
  set frames(e) {
    this._frames = e, this.fire("set:frames", e);
  }
  get frames() {
    return this._frames;
  }
  setFrame(e, t) {
    let s = this._frames[e];
    s ? (s.rect.copy(t.rect), s.pivot.copy(t.pivot), s.border.copy(t.border)) : (s = {
      rect: t.rect.clone(),
      pivot: t.pivot.clone(),
      border: t.border.clone()
    }, this._frames[e] = s), this.fire("set:frame", e.toString(), s);
  }
  removeFrame(e) {
    const t = this._frames[e];
    t && (delete this._frames[e], this.fire("remove:frame", e.toString(), t));
  }
  destroy() {
    this._texture && this._texture.destroy();
  }
}
class zm {
  constructor(e, t, s, i) {
    this.time = e, this.position = t, this.rotation = s, this.scale = i;
  }
}
class Um {
  constructor() {
    this._name = "", this._keys = [];
  }
}
class Vm {
  constructor() {
    this.name = "", this.duration = 0, this._nodes = [], this._nodeDict = {};
  }
  getNode(e) {
    return this._nodeDict[e];
  }
  addNode(e) {
    this._nodes.push(e), this._nodeDict[e._name] = e;
  }
  get nodes() {
    return this._nodes;
  }
}
class vA {
  constructor() {
    this._written = !1, this._name = "", this._keyFrames = [], this._quat = new ee(), this._pos = new v(), this._scale = new v(), this._targetNode = null;
  }
  getTarget() {
    return this._targetNode;
  }
  setTarget(e) {
    this._targetNode = e;
  }
}
class Dc {
  constructor(e) {
    this.looping = !0, this._animation = null, this._time = 0, this._interpolatedKeys = [], this._interpolatedKeyDict = {}, this._currKeyIndices = {}, this.graph = null;
    const t = (s) => {
      const i = new vA();
      i._name = s.name, this._interpolatedKeys.push(i), this._interpolatedKeyDict[s.name] = i, this._currKeyIndices[s.name] = 0;
      for (let n = 0; n < s._children.length; n++)
        t(s._children[n]);
    };
    t(e);
  }
  set animation(e) {
    this._animation = e, this.currentTime = 0;
  }
  get animation() {
    return this._animation;
  }
  set currentTime(e) {
    this._time = e;
    const t = this._interpolatedKeys.length;
    for (let s = 0; s < t; s++) {
      const n = this._interpolatedKeys[s]._name;
      this._currKeyIndices[n] = 0;
    }
    this.addTime(0), this.updateGraph();
  }
  get currentTime() {
    return this._time;
  }
  get numNodes() {
    return this._interpolatedKeys.length;
  }
  addTime(e) {
    if (this._animation !== null) {
      const t = this._animation._nodes, s = this._animation.duration;
      if (this._time === s && !this.looping)
        return;
      if (this._time += e, this._time > s) {
        this._time = this.looping ? 0 : s;
        for (let n = 0; n < t.length; n++) {
          const o = t[n]._name;
          this._currKeyIndices[o] = 0;
        }
      } else if (this._time < 0) {
        this._time = this.looping ? s : 0;
        for (let n = 0; n < t.length; n++) {
          const a = t[n], o = a._name;
          this._currKeyIndices[o] = a._keys.length - 2;
        }
      }
      const i = e >= 0 ? 1 : -1;
      for (let n = 0; n < t.length; n++) {
        const a = t[n], o = a._name, h = a._keys, l = this._interpolatedKeyDict[o];
        if (l === void 0)
          continue;
        let c = !1;
        if (h.length !== 1)
          for (let d = this._currKeyIndices[o]; d < h.length - 1 && d >= 0; d += i) {
            const u = h[d], f = h[d + 1];
            if (u.time <= this._time && f.time >= this._time) {
              const m = (this._time - u.time) / (f.time - u.time);
              l._pos.lerp(u.position, f.position, m), l._quat.slerp(u.rotation, f.rotation, m), l._scale.lerp(u.scale, f.scale, m), l._written = !0, this._currKeyIndices[o] = d, c = !0;
              break;
            }
          }
        (h.length === 1 || !c && this._time === 0 && this.looping) && (l._pos.copy(h[0].position), l._quat.copy(h[0].rotation), l._scale.copy(h[0].scale), l._written = !0);
      }
    }
  }
  blend(e, t, s) {
    const i = this._interpolatedKeys.length;
    for (let n = 0; n < i; n++) {
      const a = e._interpolatedKeys[n], o = t._interpolatedKeys[n], h = this._interpolatedKeys[n];
      a._written && o._written ? (h._quat.slerp(a._quat, t._interpolatedKeys[n]._quat, s), h._pos.lerp(a._pos, t._interpolatedKeys[n]._pos, s), h._scale.lerp(a._scale, o._scale, s), h._written = !0) : a._written ? (h._quat.copy(a._quat), h._pos.copy(a._pos), h._scale.copy(a._scale), h._written = !0) : o._written && (h._quat.copy(o._quat), h._pos.copy(o._pos), h._scale.copy(o._scale), h._written = !0);
    }
  }
  setGraph(e) {
    if (this.graph = e, e)
      for (let t = 0; t < this._interpolatedKeys.length; t++) {
        const s = this._interpolatedKeys[t], i = e.findByName(s._name);
        this._interpolatedKeys[t].setTarget(i);
      }
    else
      for (let t = 0; t < this._interpolatedKeys.length; t++)
        this._interpolatedKeys[t].setTarget(null);
  }
  updateGraph() {
    if (this.graph)
      for (let e = 0; e < this._interpolatedKeys.length; e++) {
        const t = this._interpolatedKeys[e];
        if (t._written) {
          const s = t.getTarget();
          s.localPosition.copy(t._pos), s.localRotation.copy(t._quat), s.localScale.copy(t._scale), s._dirtyLocal || s._dirtifyLocal(), t._written = !1;
        }
      }
  }
}
class SA {
  constructor(e, t) {
    this.processedCache = /* @__PURE__ */ new Map(), this.definitionsCache = /* @__PURE__ */ new Map(), this._device = e, this._generators = {}, this._isClearingCache = !1, this._precached = !1, this._programsCollection = [], this._defaultStdMatOption = new Zh(), this._defaultStdMatOptionMin = new Zh(), t.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, t, null, [], Er, null), t.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, t, null, [], vn, null), e.on("destroy:shader", (s) => {
      this.removeFromCache(s);
    });
  }
  destroy() {
    this.clearCache();
  }
  register(e, t) {
    this.isRegistered(e) || (this._generators[e] = t);
  }
  unregister(e) {
    this.isRegistered(e) && delete this._generators[e];
  }
  isRegistered(e) {
    return this._generators[e] !== void 0;
  }
  generateShaderDefinition(e, t, s, i) {
    let n = this.definitionsCache.get(s);
    if (!n) {
      var a, o, h;
      let l;
      (a = i.litOptions) != null && a.lights && (l = i.litOptions.lights, i.litOptions.lights = l.map(function(d) {
        const u = d.clone ? d.clone() : d;
        return u.key = d.key, u;
      })), this.storeNewProgram(t, i), (o = i.litOptions) != null && o.lights && (i.litOptions.lights = l), this._precached;
      const c = this._device;
      n = e.createShaderDefinition(c, i), n.name = (h = n.name) != null ? h : i.pass ? `${t}-pass:${i.pass}` : t, this.definitionsCache.set(s, n);
    }
    return n;
  }
  getCachedShader(e) {
    return this.processedCache.get(e);
  }
  setCachedShader(e, t) {
    this.processedCache.set(e, t);
  }
  getProgram(e, t, s) {
    const i = this._generators[e];
    if (!i)
      return null;
    const n = i.generateKey(t), a = s.generateKey(), o = `${n}#${a}`;
    let h = this.getCachedShader(o);
    if (!h) {
      const l = this.generateShaderDefinition(i, e, n, t), c = {
        name: `${l.name}-processed`,
        attributes: l.attributes,
        vshader: l.vshader,
        fshader: l.fshader,
        processingOptions: s
      };
      h = new Vr(this._device, c), this.setCachedShader(o, h);
    }
    return h;
  }
  storeNewProgram(e, t) {
    let s = {};
    if (e === "standard") {
      const i = this._getDefaultStdMatOptions(t.pass);
      for (const n in t)
        (t.hasOwnProperty(n) && i[n] !== t[n] || n === "pass") && (s[n] = t[n]);
      for (const n in t.litOptions)
        s[n] = t.litOptions[n];
    } else
      s = t;
    this._programsCollection.push(JSON.stringify({
      name: e,
      options: s
    }));
  }
  dumpPrograms() {
    let e = `let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;
`;
    e += "let shaders = [", this._programsCollection[0] && (e += `
	` + this._programsCollection[0]);
    for (let s = 1; s < this._programsCollection.length; ++s)
      e += `,
	` + this._programsCollection[s];
    e += `
];
`, e += `device.getProgramLibrary().precompile(shaders);
`, e += 'if (pc.version != "' + t0 + '" || pc.revision != "' + s0 + `")
`, e += '	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");';
    const t = document.createElement("a");
    t.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(e)), t.setAttribute("download", "precompile-shaders.js"), t.style.display = "none", document.body.appendChild(t), t.click(), document.body.removeChild(t);
  }
  clearCache() {
    this._isClearingCache = !0, this.processedCache.forEach((e) => {
      e.destroy();
    }), this.processedCache.clear(), this._isClearingCache = !1;
  }
  removeFromCache(e) {
    this._isClearingCache || this.processedCache.forEach((t, s) => {
      e === t && this.processedCache.delete(s);
    });
  }
  _getDefaultStdMatOptions(e) {
    return e === As || e === Hr || Ut.isShadow(e) ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
  }
  precompile(e) {
    if (e) {
      const t = new Array(e.length);
      for (let s = 0; s < e.length; s++) {
        if (e[s].name === "standard") {
          const i = e[s].options, n = this._getDefaultStdMatOptions(i.pass);
          for (const a in n)
            n.hasOwnProperty(a) && i[a] === void 0 && (i[a] = n[a]);
        }
        t[s] = this.getProgram(e[s].name, e[s].options);
      }
    }
    this._precached = !0;
  }
}
var bA = `
		vec4 dirLm = texture2D(texture_dirLightMap, vUv1);

		if (bakeDir > 0.5) {
				if (dAtten > 0.00001) {
						dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
						dAtten = saturate(dAtten);
						gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
						gl_FragColor.a = dirLm.w + dAtten;
						gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
				} else {
						gl_FragColor = dirLm;
				}
		} else {
				gl_FragColor.rgb = dirLm.xyz;
				gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
		}
`, wA = `
#ifdef LIGHTMAP_RGBM
		gl_FragColor.rgb = dDiffuseLight;
		gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
		gl_FragColor.rgb /= 8.0;
		gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
		gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
		gl_FragColor.rgb /= gl_FragColor.a;
#else
		gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`, TA = `

varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

void main(void) {
		vec4 c = texture2D(source, vUv0);
		c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);
		gl_FragColor = c;
}
`, CA = `
// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and
// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf

// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.
// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.
// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on
// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such
// as color intensity, depth distance, etc.). This preserves sharp edges.

float normpdf3(in vec3 v, in float sigma) {
		return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}

vec3 decodeRGBM(vec4 rgbm) {
		vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
		return color * color;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 encodeRGBM(vec3 color) { // modified RGBM
		vec4 encoded;
		encoded.rgb = pow(color.rgb, vec3(0.5));
		encoded.rgb *= 1.0 / 8.0;

		encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
		encoded.a = ceil(encoded.a * 255.0) / 255.0;

		encoded.rgb /= encoded.a;
		return encoded;
}

// filter size
#define MSIZE 15

varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];

void main(void) {
		
		vec4 pixelRgbm = texture2D(source, vUv0);

		// lightmap specific optimization - skip pixels that were not baked
		// this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero
		// to dilate, which the following blur filter would otherwise modify
		if (pixelRgbm.a <= 0.0) {
				gl_FragColor = pixelRgbm;
				return ;
		}

		// range sigma - controls blurriness based on a pixel distance
		float sigma = sigmas.x;

		// domain sigma - controls blurriness based on a pixel similarity (to preserve edges)
		float bSigma = sigmas.y;

		vec3 pixelHdr = decodeRGBM(pixelRgbm);
		vec3 accumulatedHdr = vec3(0.0);
		float accumulatedFactor = 0.0;

		// read out the texels
		const int kSize = (MSIZE-1)/2;
		for (int i = -kSize; i <= kSize; ++i) {
				for (int j = -kSize; j <= kSize; ++j) {
						
						// sample the pixel with offset
						vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
						vec4 rgbm = texture2D(source, coord);

						// lightmap - only use baked pixels
						if (rgbm.a > 0.0) {
								vec3 hdr = decodeRGBM(rgbm);

								// bilateral factors
								float factor = kernel[kSize + j] * kernel[kSize + i];
								factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;

								// accumulate
								accumulatedHdr += factor * hdr;
								accumulatedFactor += factor;
						}
				}
		}

		gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;
const el = {
  bakeDirLmEndPS: bA,
  bakeLmEndPS: wA,
  dilatePS: TA,
  bilateralDeNoisePS: CA
}, xg = "FILL_WINDOW", Gm = "KEEP_ASPECT", Fd = "AUTO", AA = "FIXED";
let vg;
function qi() {
  return vg;
}
function Od(r) {
  vg = r, xi.set(r == null ? void 0 : r.graphicsDevice);
}
class Cs {
  static push(e, t) {
    t && Cs._types.length > 0 ? console.assert("Script Ordering Error. Contact support@playcanvas.com") : Cs._types.push(e);
  }
}
Cs._types = [];
let tl = !1, Hm = !1;
const fs = {
  app: null,
  create: function(r, e) {
    if (!tl)
      return;
    const t = e(fs.app);
    t._pcScriptName = r, Cs.push(t, tl), this.fire("created", r, e);
  },
  attribute: function(r, e, t, s) {
  },
  createLoadingScreen: function(r) {
    if (Hm)
      return;
    Hm = !0;
    const e = qi();
    r(e);
  }
};
Object.defineProperty(fs, "legacy", {
  get: function() {
    return tl;
  },
  set: function(r) {
    tl = r;
  }
});
mu.attach(fs);
class MA {
  constructor() {
    this.renderPasses = [], this.renderTargetMap = /* @__PURE__ */ new Map();
  }
  addRenderPass(e) {
    this.renderPasses.push(e);
  }
  reset() {
    this.renderPasses.length = 0;
  }
  compile() {
    const e = this.renderTargetMap, t = this.renderPasses;
    for (let n = 0; n < t.length; n++) {
      const a = t[n], o = a.renderTarget;
      if (o !== void 0) {
        const h = e.get(o);
        h && (a.colorOps.clear || (h.colorOps.store = !0), a.depthStencilOps.clearDepth || (h.depthStencilOps.storeDepth = !0), a.depthStencilOps.clearStencil || (h.depthStencilOps.storeStencil = !0)), e.set(o, a);
      }
    }
    let s = null, i = null;
    for (let n = 0; n < t.length; n++) {
      const a = t[n], o = a.renderTarget, h = o == null ? void 0 : o.colorBuffer;
      h != null && h.cubemap ? (s === h && (i.colorOps.mipmaps = !1), s = o.colorBuffer, i = a) : a.requiresCubemaps && (s = null, i = null);
    }
    e.forEach((n, a) => {
      a === null && (n.colorOps.store = !0, n.colorOps.resolve = !1, n.colorOps.mipmaps = !1);
    }), e.clear();
  }
  render(e) {
    this.compile();
    const t = this.renderPasses;
    for (let s = 0; s < t.length; s++)
      t[s].render();
    this.log(e);
  }
  log(e) {
  }
}
class EA {
  constructor(e, t) {
    this.texture0 = e, this.texture1 = t;
  }
  destroy() {
    var e, t;
    (e = this.texture0) == null || e.destroy(), (t = this.texture1) == null || t.destroy();
  }
}
const Wm = new Ji();
class Cn {
  static createTexture(e, t, s, i = "") {
    return new ue(e, {
      width: s,
      height: s,
      format: t,
      addressU: he,
      addressV: he,
      type: Rs,
      magFilter: rt,
      minFilter: Be,
      anisotropy: 1,
      name: `AreaLightLUT${i}`
    });
  }
  static applyTextures(e, t, s) {
    Wm.remove(e), Wm.get(e, () => new EA(t, t === s ? null : s)), e.scope.resolve("areaLightsLutTex1").setValue(t), e.scope.resolve("areaLightsLutTex2").setValue(s);
  }
  static createPlaceholder(e) {
    const t = Cn.createTexture(e, e.areaLightLutFormat, 2, "placeholder");
    t.lock().fill(0), t.unlock(), Cn.applyTextures(e, t, t);
  }
  static set(e, t, s) {
    function i(_, p, g) {
      const b = Cn.createTexture(_, g, 64);
      return b.lock().set(p), b.unlock(), b;
    }
    function n(_, p, g) {
      const b = _.length, x = new Float32Array(b);
      for (let y = 0; y < b; y++) {
        const S = y % 4;
        x[y] = (_[y] + p[S]) * g[S];
      }
      return x;
    }
    function a(_) {
      const p = _.length, g = new Uint16Array(p), b = qe.float2Half;
      for (let x = 0; x < p; x++)
        g[x] = b(_[x]);
      return g;
    }
    function o(_) {
      const p = _.length, g = new Uint8ClampedArray(p);
      for (let b = 0; b < p; b++)
        g[b] = _[b] * 255;
      return g;
    }
    const h = t, l = s;
    let c, d;
    const u = e.areaLightLutFormat;
    if (u === vt)
      c = h, d = l;
    else if (u === Pt)
      c = a(h), d = a(l);
    else {
      const _ = [0, 0.2976, 0.01381, 0], p = [0.999, 3.08737, 1.6546, 0.603249], g = [-0.306897, 0, 0, 0], b = [1.442787, 1, 1, 1];
      c = o(n(h, _, p)), d = o(n(l, g, b));
    }
    const f = i(e, c, u), m = i(e, d, u);
    Cn.applyTextures(e, f, m);
  }
}
const sl = "en-US", il = {
  en: "en-US",
  es: "en-ES",
  zh: "zh-CN",
  "zh-HK": "zh-TW",
  "zh-TW": "zh-HK",
  "zh-MO": "zh-HK",
  fr: "fr-FR",
  de: "de-DE",
  it: "it-IT",
  ru: "ru-RU",
  ja: "ja-JP"
}, Xu = {};
function Qi(r, e) {
  for (let t = 0, s = r.length; t < s; t++)
    Xu[r[t]] = e;
}
function si(r) {
  const e = r.indexOf("-");
  return e !== -1 ? r.substring(0, e) : r;
}
function RA(r, e) {
  const t = r.indexOf("-");
  return t !== -1 ? e + r.substring(t) : e;
}
function Sg(r, e) {
  if (e[r])
    return r;
  let t = il[r];
  if (t && e[t])
    return t;
  const s = si(r);
  return t = il[s], e[t] ? t : e[s] ? s : sl;
}
Qi(["ja", "ko", "th", "vi", "zh", "id"], function(r) {
  return 0;
});
Qi(["fa", "hi"], function(r) {
  return r >= 0 && r <= 1 ? 0 : 1;
});
Qi(["fr", "pt"], function(r) {
  return r >= 0 && r < 2 ? 0 : 1;
});
Qi(["da"], function(r) {
  return r === 1 || !Number.isInteger(r) && r >= 0 && r <= 1 ? 0 : 1;
});
Qi(["de", "en", "it", "el", "es", "tr", "fi", "sv", "nb", "no", "ur"], function(r) {
  return r === 1 ? 0 : 1;
});
Qi(["ru", "uk"], function(r) {
  if (Number.isInteger(r)) {
    const e = r % 10, t = r % 100;
    if (e === 1 && t !== 11)
      return 0;
    if (e >= 2 && e <= 4 && (t < 12 || t > 14))
      return 1;
    if (e === 0 || e >= 5 && e <= 9 || t >= 11 && t <= 14)
      return 2;
  }
  return 3;
});
Qi(["pl"], function(r) {
  if (Number.isInteger(r)) {
    if (r === 1)
      return 0;
    const e = r % 10, t = r % 100;
    if (e >= 2 && e <= 4 && (t < 12 || t > 14))
      return 1;
    if (e >= 0 && e <= 1 || e >= 5 && e <= 9 || t >= 12 && t <= 14)
      return 2;
  }
  return 3;
});
Qi(["ar"], function(r) {
  if (r === 0)
    return 0;
  if (r === 1)
    return 1;
  if (r === 2)
    return 2;
  if (Number.isInteger(r)) {
    const e = r % 100;
    if (e >= 3 && e <= 10)
      return 3;
    if (e >= 11 && e <= 99)
      return 4;
  }
  return 5;
});
const LA = Xu[si(sl)];
function Bc(r) {
  return Xu[r] || LA;
}
const nl = new RegExp("^\\s*(?:(?:[a-z]+[a-z0-9\\-\\+\\.]*:)?//|data:|blob:)", "i");
class PA {
  constructor(e, t, s, i, n, a) {
    this.url = e || "", this.filename = t || "", this.hash = s === void 0 ? null : s, this.size = i === void 0 ? null : i, this.opt = n === void 0 ? null : n, this.contents = a || null;
  }
  equals(e) {
    return this.url === e.url && this.filename === e.filename && this.hash === e.hash && this.size === e.size && this.opt === e.opt && this.contents === e.contents;
  }
}
let IA = -1;
const DA = {
  pvr: "extCompressedTexturePVRTC",
  dxt: "extCompressedTextureS3TC",
  etc2: "extCompressedTextureETC",
  etc1: "extCompressedTextureETC1",
  basis: "canvas"
}, qm = ["pvr", "dxt", "etc2", "etc1", "basis"];
class ce extends _e {
  constructor(e, t, s, i, n) {
    super(), this._id = IA--, this.name = e || "", this.type = t, this.tags = new __(this), this._preload = !1, this._file = null, this._data = i || {}, this.options = n || {}, this._resources = [], this._i18n = {}, this.loaded = !1, this.loading = !1, this.registry = null, s && (this.file = s);
  }
  set id(e) {
    this._id = e;
  }
  get id() {
    return this._id;
  }
  set file(e) {
    if (e && e.variants && ["texture", "textureatlas", "bundle"].indexOf(this.type) !== -1) {
      var t, s;
      const a = ((t = this.registry) == null || (s = t._loader) == null ? void 0 : s._app) || qi(), o = a == null ? void 0 : a.graphicsDevice;
      if (o)
        for (let h = 0, l = qm.length; h < l; h++) {
          const c = qm[h];
          if (e.variants[c] && o[DA[c]]) {
            e = e.variants[c];
            break;
          }
          if (a.enableBundles) {
            const d = a.bundles.listBundlesForAsset(this);
            if (d && d.find((u) => {
              var f;
              return u == null || (f = u.file) == null ? void 0 : f.variants[c];
            }))
              break;
          }
        }
    }
    const i = this._file, n = e ? new PA(e.url, e.filename, e.hash, e.size, e.opt, e.contents) : null;
    (!!n != !!i || n && !n.equals(i)) && (this._file = n, this.fire("change", this, "file", n, i), this.reload());
  }
  get file() {
    return this._file;
  }
  set data(e) {
    const t = this._data;
    this._data = e, e !== t && (this.fire("change", this, "data", e, t), this.loaded && this.registry._loader.patch(this, this.registry));
  }
  get data() {
    return this._data;
  }
  set resource(e) {
    const t = this._resources[0];
    this._resources[0] = e, this.fire("change", this, "resource", e, t);
  }
  get resource() {
    return this._resources[0];
  }
  set resources(e) {
    const t = this._resources;
    this._resources = e, this.fire("change", this, "resources", e, t);
  }
  get resources() {
    return this._resources;
  }
  set preload(e) {
    e = !!e, this._preload !== e && (this._preload = e, this._preload && !this.loaded && !this.loading && this.registry && this.registry.load(this));
  }
  get preload() {
    return this._preload;
  }
  set loadFaces(e) {
    e = !!e, (!this.hasOwnProperty("_loadFaces") || e !== this._loadFaces) && (this._loadFaces = e, this.loaded && this.registry._loader.patch(this, this.registry));
  }
  get loadFaces() {
    return this._loadFaces;
  }
  getFileUrl() {
    const e = this.file;
    if (!e || !e.url)
      return null;
    let t = e.url;
    if (this.registry && this.registry.prefix && !nl.test(t) && (t = this.registry.prefix + t), this.type !== "script" && e.hash) {
      const s = t.indexOf("?") !== -1 ? "&" : "?";
      t += s + "t=" + e.hash;
    }
    return t;
  }
  getAbsoluteUrl(e) {
    if (e.startsWith("blob:") || e.startsWith("data:"))
      return e;
    const t = me.getDirectory(this.file.url);
    return me.join(t, e);
  }
  getLocalizedAssetId(e) {
    return e = Sg(e, this._i18n), this._i18n[e] || null;
  }
  addLocalizedAssetId(e, t) {
    this._i18n[e] = t, this.fire("add:localized", e, t);
  }
  removeLocalizedAssetId(e) {
    const t = this._i18n[e];
    t && (delete this._i18n[e], this.fire("remove:localized", e, t));
  }
  ready(e, t) {
    t = t || this, this.loaded ? e.call(t, this) : this.once("load", function(s) {
      e.call(t, s);
    });
  }
  reload() {
    this.loaded && (this.loaded = !1, this.registry.load(this));
  }
  unload() {
    if (!this.loaded && this._resources.length === 0)
      return;
    this.fire("unload", this), this.registry.fire("unload:" + this.id, this);
    const e = this._resources;
    this.resources = [], this.loaded = !1, this.file && this.registry._loader.clearCache(this.getFileUrl(), this.type);
    for (let t = 0; t < e.length; ++t) {
      const s = e[t];
      s && s.destroy && s.destroy();
    }
  }
  static fetchArrayBuffer(e, t, s, i = 0) {
    var n;
    s != null && (n = s.file) != null && n.contents ? setTimeout(() => {
      t(null, s.file.contents);
    }) : $e.get(e, {
      cache: !0,
      responseType: "arraybuffer",
      retry: i > 0,
      maxRetries: i
    }, t);
  }
}
class BA {
  constructor(e = null) {
    this._index = {}, this._key = void 0, this._key = e;
  }
  addItem(e) {
    const t = e.tags._list;
    for (const s of t)
      this.add(s, e);
  }
  removeItem(e) {
    const t = e.tags._list;
    for (const s of t)
      this.remove(s, e);
  }
  add(e, t) {
    this._index[e] && this._index[e].list.indexOf(t) !== -1 || (this._index[e] || (this._index[e] = {
      list: []
    }, this._key && (this._index[e].keys = {})), this._index[e].list.push(t), this._key && (this._index[e].keys[t[this._key]] = t));
  }
  remove(e, t) {
    if (!this._index[e] || this._key && !this._index[e].keys[t[this._key]])
      return;
    const s = this._index[e].list.indexOf(t);
    s !== -1 && (this._index[e].list.splice(s, 1), this._key && delete this._index[e].keys[t[this._key]], this._index[e].list.length === 0 && delete this._index[e]);
  }
  find(e) {
    const t = {}, s = [];
    let i, n, a, o, h;
    const l = (c, d) => this._index[c].list.length - this._index[d].list.length;
    for (let c = 0; c < e.length; c++) {
      if (n = e[c], n instanceof Array) {
        if (n.length === 0)
          continue;
        if (n.length === 1)
          n = n[0];
        else {
          h = !1;
          for (let d = 0; d < n.length; d++)
            if (!this._index[n[d]]) {
              h = !0;
              break;
            }
          if (h)
            continue;
          a = n.slice(0).sort(l), o = a.slice(1), o.length === 1 && (o = o[0]);
          for (let d = 0; d < this._index[a[0]].list.length; d++)
            i = this._index[a[0]].list[d], (this._key ? !t[i[this._key]] : s.indexOf(i) === -1) && i.tags.has(o) && (this._key && (t[i[this._key]] = !0), s.push(i));
          continue;
        }
      }
      if (n && typeof n == "string" && this._index[n])
        for (let d = 0; d < this._index[n].list.length; d++)
          i = this._index[n].list[d], this._key ? t[i[this._key]] || (t[i[this._key]] = !0, s.push(i)) : s.indexOf(i) === -1 && s.push(i);
    }
    return s;
  }
}
class FA extends _e {
  constructor(e) {
    super(), this._loader = e, this._assets = [], this._cache = {}, this._names = {}, this._tags = new BA("_id"), this._urls = {}, this.prefix = null;
  }
  list(e) {
    return e = e || {}, this._assets.filter((t) => {
      let s = !0;
      return e.preload !== void 0 && (s = t.preload === e.preload), s;
    });
  }
  add(e) {
    const t = this._assets.push(e) - 1;
    let s;
    this._cache[e.id] = t, this._names[e.name] || (this._names[e.name] = []), this._names[e.name].push(t), e.file && (s = e.file.url, this._urls[s] = t), e.registry = this, this._tags.addItem(e), e.tags.on("add", this._onTagAdd, this), e.tags.on("remove", this._onTagRemove, this), this.fire("add", e), this.fire("add:" + e.id, e), s && this.fire("add:url:" + s, e), e.preload && this.load(e);
  }
  remove(e) {
    const t = this._cache[e.id], s = e.file ? e.file.url : null;
    if (t !== void 0) {
      this._assets.splice(t, 1), delete this._cache[e.id], this._names = {}, this._urls = [];
      for (let i = 0, n = this._assets.length; i < n; i++) {
        const a = this._assets[i];
        this._cache[a.id] = i, this._names[a.name] || (this._names[a.name] = []), this._names[a.name].push(i), a.file && (this._urls[a.file.url] = i);
      }
      return this._tags.removeItem(e), e.tags.off("add", this._onTagAdd, this), e.tags.off("remove", this._onTagRemove, this), e.fire("remove", e), this.fire("remove", e), this.fire("remove:" + e.id, e), s && this.fire("remove:url:" + s, e), !0;
    }
    return !1;
  }
  get(e) {
    const t = this._cache[e];
    return this._assets[t];
  }
  getByUrl(e) {
    const t = this._urls[e];
    return this._assets[t];
  }
  load(e) {
    if (e.loading || e.loaded)
      return;
    const t = e.file, s = (n) => {
      n instanceof Array ? e.resources = n : e.resource = n, this._loader.patch(e, this), this.fire("load", e), this.fire("load:" + e.id, e), t && t.url && this.fire("load:url:" + t.url, e), e.fire("load", e);
    }, i = (n, a, o) => {
      if (e.loaded = !0, e.loading = !1, n)
        this.fire("error", n, e), this.fire("error:" + e.id, n, e), e.fire("error", n, e);
      else {
        if (!fs.legacy && e.type === "script") {
          const h = this._loader.getHandler("script");
          h._cache[e.id] && h._cache[e.id].parentNode === document.head && document.head.removeChild(h._cache[e.id]), h._cache[e.id] = o;
        }
        s(a);
      }
    };
    if (t || e.type === "cubemap")
      this.fire("load:start", e), this.fire("load:" + e.id + ":start", e), e.loading = !0, this._loader.load(e.getFileUrl(), e.type, i, e);
    else {
      const n = this._loader.open(e.type, e.data);
      e.loaded = !0, s(n);
    }
  }
  loadFromUrl(e, t, s) {
    this.loadFromUrlAndFilename(e, null, t, s);
  }
  loadFromUrlAndFilename(e, t, s, i) {
    const n = me.getBasename(t || e), a = {
      filename: t || n,
      url: e
    };
    let o = this.getByUrl(e);
    if (!o)
      o = new ce(n, s, a), this.add(o);
    else if (o.loaded) {
      i(o.loadFromUrlError || null, o);
      return;
    }
    const h = (l) => {
      l.once("load", (c) => {
        s === "material" ? this._loadTextures(c, (d, u) => {
          i(d, c);
        }) : i(null, c);
      }), l.once("error", (c) => {
        c && (this.loadFromUrlError = c), i(c, l);
      }), this.load(l);
    };
    o.resource ? i(null, o) : s === "model" ? this._loadModel(o, h) : h(o);
  }
  _loadModel(e, t) {
    const s = e.getFileUrl(), i = me.getExtension(s);
    if (i === ".json" || i === ".glb") {
      const n = me.getDirectory(s), a = me.getBasename(s), o = me.join(n, a.replace(i, ".mapping.json"));
      this._loader.load(o, "json", (h, l) => {
        h ? (e.data = {
          mapping: []
        }, t(e)) : this._loadMaterials(e, l, (c, d) => {
          e.data = l, t(e);
        });
      });
    } else
      t(e);
  }
  _loadMaterials(e, t, s) {
    const i = [];
    let n = 0;
    const a = (o, h) => {
      this._loadTextures(h, (l, c) => {
        i.push(h), i.length === n && s(null, i);
      });
    };
    for (let o = 0; o < t.mapping.length; o++) {
      const h = t.mapping[o].path;
      if (h) {
        n++;
        const l = e.getAbsoluteUrl(h);
        this.loadFromUrl(l, "material", a);
      }
    }
    n === 0 && s(null, i);
  }
  _loadTextures(e, t) {
    const s = [];
    let i = 0;
    const n = e.data;
    if (n.mappingFormat !== "path") {
      t(null, s);
      return;
    }
    const a = (h, l) => {
      h && console.error(h), s.push(l), s.length === i && t(null, s);
    }, o = Xl;
    for (let h = 0; h < o.length; h++) {
      const l = n[o[h]];
      if (l && typeof l == "string") {
        i++;
        const c = e.getAbsoluteUrl(l);
        this.loadFromUrl(c, "texture", a);
      }
    }
    i === 0 && t(null, s);
  }
  findAll(e, t) {
    const s = this._names[e];
    if (s) {
      const i = s.map((n) => this._assets[n]);
      return t ? i.filter((n) => n.type === t) : i;
    }
    return [];
  }
  _onTagAdd(e, t) {
    this._tags.add(e, t);
  }
  _onTagRemove(e, t) {
    this._tags.remove(e, t);
  }
  findByTag() {
    return this._tags.find(arguments);
  }
  filter(e) {
    return this._assets.filter((t) => e(t));
  }
  find(e, t) {
    const s = this.findAll(e, t);
    return s.length > 0 ? s[0] : null;
  }
}
class OA {
  constructor(e) {
    this._assets = e, this._bundleAssets = {}, this._assetsInBundles = {}, this._urlsInBundles = {}, this._fileRequests = {}, this._assets.on("add", this._onAssetAdded, this), this._assets.on("remove", this._onAssetRemoved, this);
  }
  _onAssetAdded(e) {
    if (e.type === "bundle") {
      this._bundleAssets[e.id] = e, this._registerBundleEventListeners(e.id);
      for (let t = 0, s = e.data.assets.length; t < s; t++)
        this._indexAssetInBundle(e.data.assets[t], e);
    } else
      this._assetsInBundles[e.id] && this._indexAssetFileUrls(e);
  }
  _registerBundleEventListeners(e) {
    this._assets.on("load:" + e, this._onBundleLoaded, this), this._assets.on("error:" + e, this._onBundleError, this);
  }
  _unregisterBundleEventListeners(e) {
    this._assets.off("load:" + e, this._onBundleLoaded, this), this._assets.off("error:" + e, this._onBundleError, this);
  }
  _indexAssetInBundle(e, t) {
    if (!this._assetsInBundles[e])
      this._assetsInBundles[e] = [t];
    else {
      const i = this._assetsInBundles[e];
      i.indexOf(t) === -1 && i.push(t);
    }
    const s = this._assets.get(e);
    s && this._indexAssetFileUrls(s);
  }
  _indexAssetFileUrls(e) {
    const t = this._getAssetFileUrls(e);
    if (t)
      for (let s = 0, i = t.length; s < i; s++) {
        const n = t[s];
        this._urlsInBundles[n] = this._assetsInBundles[e.id];
      }
  }
  _getAssetFileUrls(e) {
    let t = e.getFileUrl();
    if (!t)
      return null;
    t = this._normalizeUrl(t);
    const s = [t];
    if (e.type === "font") {
      const i = e.data.info.maps.length;
      for (let n = 1; n < i; n++)
        s.push(t.replace(".png", n + ".png"));
    }
    return s;
  }
  _normalizeUrl(e) {
    return e && e.split("?")[0];
  }
  _onAssetRemoved(e) {
    if (e.type === "bundle") {
      delete this._bundleAssets[e.id], this._unregisterBundleEventListeners(e.id);
      for (const t in this._assetsInBundles) {
        const s = this._assetsInBundles[t], i = s.indexOf(e);
        if (i !== -1 && (s.splice(i, 1), !s.length)) {
          delete this._assetsInBundles[t];
          for (const n in this._urlsInBundles)
            this._urlsInBundles[n] === s && delete this._urlsInBundles[n];
        }
      }
      this._onBundleError(`Bundle ${e.id} was removed`, e);
    } else if (this._assetsInBundles[e.id]) {
      delete this._assetsInBundles[e.id];
      const t = this._getAssetFileUrls(e);
      for (let s = 0, i = t.length; s < i; s++)
        delete this._urlsInBundles[t[s]];
    }
  }
  _onBundleLoaded(e) {
    if (!e.resource) {
      this._onBundleError(`Bundle ${e.id} failed to load`, e);
      return;
    }
    requestAnimationFrame(() => {
      if (this._fileRequests)
        for (const t in this._fileRequests) {
          const s = this._urlsInBundles[t];
          if (!s || s.indexOf(e) === -1)
            continue;
          const i = decodeURIComponent(t);
          let n = null;
          e.resource.hasBlobUrl(i) || (n = `Bundle ${e.id} does not contain URL ${t}`);
          const a = this._fileRequests[t];
          for (let o = 0, h = a.length; o < h; o++)
            n ? a[o](n) : a[o](null, e.resource.getBlobUrl(i));
          delete this._fileRequests[t];
        }
    });
  }
  _onBundleError(e, t) {
    for (const s in this._fileRequests)
      if (!this._findLoadedOrLoadingBundleForUrl(s)) {
        const n = this._fileRequests[s];
        for (let a = 0, o = n.length; a < o; a++)
          n[a](e);
        delete this._fileRequests[s];
      }
  }
  _findLoadedOrLoadingBundleForUrl(e) {
    const t = this._urlsInBundles[e];
    if (!t)
      return null;
    const s = t.length;
    for (let i = 0; i < s; i++)
      if (t[i].loaded && t[i].resource)
        return t[i];
    for (let i = 0; i < s; i++)
      if (t[i].loading)
        return t[i];
    return null;
  }
  listBundlesForAsset(e) {
    return this._assetsInBundles[e.id] || null;
  }
  list() {
    const e = [];
    for (const t in this._bundleAssets)
      e.push(this._bundleAssets[t]);
    return e;
  }
  hasUrl(e) {
    return !!this._urlsInBundles[e];
  }
  canLoadUrl(e) {
    return !!this._findLoadedOrLoadingBundleForUrl(e);
  }
  loadUrl(e, t) {
    const s = this._findLoadedOrLoadingBundleForUrl(e);
    if (!s) {
      t(`URL ${e} not found in any bundles`);
      return;
    }
    if (s.loaded) {
      const i = decodeURIComponent(e);
      if (!s.resource.hasBlobUrl(i)) {
        t(`Bundle ${s.id} does not contain URL ${e}`);
        return;
      }
      t(null, s.resource.getBlobUrl(i));
    } else
      this._fileRequests.hasOwnProperty(e) ? this._fileRequests[e].push(t) : this._fileRequests[e] = [t];
  }
  destroy() {
    this._assets.off("add", this._onAssetAdded, this), this._assets.off("remove", this._onAssetRemoved, this);
    for (const e in this._bundleAssets)
      this._unregisterBundleEventListeners(e);
    this._assets = null, this._bundleAssets = null, this._assetsInBundles = null, this._urlsInBundles = null, this._fileRequests = null;
  }
}
class kA extends _e {
  constructor() {
    super(), this.anim = void 0, this.animation = void 0, this.audiolistener = void 0, this.audiosource = void 0, this.button = void 0, this.camera = void 0, this.collision = void 0, this.element = void 0, this.joint = void 0, this.layoutchild = void 0, this.layoutgroup = void 0, this.light = void 0, this.model = void 0, this.particlesystem = void 0, this.render = void 0, this.rigidbody = void 0, this.screen = void 0, this.script = void 0, this.scrollbar = void 0, this.scrollview = void 0, this.sound = void 0, this.sprite = void 0, this.zone = void 0, this.list = [];
  }
  add(e) {
    const t = e.id;
    if (this[t])
      throw new Error(`ComponentSystem name '${t}' already registered or not allowed`);
    this[t] = e, this.list.push(e);
  }
  remove(e) {
    const t = e.id;
    if (!this[t])
      throw new Error(`No ComponentSystem named '${t}' registered`);
    delete this[t];
    const s = this.list.indexOf(this[t]);
    s !== -1 && this.list.splice(s, 1);
  }
  destroy() {
    this.off();
    for (let e = 0; e < this.list.length; e++)
      this.list[e].destroy();
  }
}
class NA {
  constructor(e) {
    this._blobUrls = {};
    for (let t = 0, s = e.length; t < s; t++)
      e[t].url && (this._blobUrls[e[t].name] = e[t].url);
  }
  hasBlobUrl(e) {
    return !!this._blobUrls[e];
  }
  getBlobUrl(e) {
    return this._blobUrls[e];
  }
  destroy() {
    for (const e in this._blobUrls)
      URL.revokeObjectURL(this._blobUrls[e]);
    this._blobUrls = null;
  }
}
let bg;
function wg(r) {
  let e, t;
  if (typeof TextDecoder < "u")
    try {
      e = new TextDecoder("utf-8"), t = new TextDecoder("windows-1252");
    } catch {
      console.warn("TextDecoder not supported - pc.Untar module will not work");
    }
  else
    console.warn("TextDecoder not supported - pc.Untar module will not work");
  function s(n) {
    this._fields = n;
  }
  s.parse = function(n, a, o) {
    const h = new Uint8Array(n, a, o);
    let l = 0;
    const c = [];
    for (; l < o; ) {
      let d;
      for (d = l; d < o && h[d] !== 32; d++)
        ;
      if (d >= o)
        throw new Error("Invalid PAX header data format.");
      const u = parseInt(e.decode(new Uint8Array(n, a + l, d - l)), 10), m = e.decode(new Uint8Array(n, a + d + 1, u - (d - l) - 2)).split("=");
      if (m.length !== 2)
        throw new Error("Invalid PAX header data format.");
      m[1].length === 0 && (m[1] = null), c.push({
        name: m[0],
        value: m[1]
      }), l += u;
    }
    return new s(c);
  }, s.prototype.applyHeader = function(n) {
    for (let a = 0; a < this._fields.length; a++) {
      let o = this._fields[a].name;
      const h = this._fields[a].value;
      o === "path" && (o = "name"), h === null ? delete n[o] : n[o] = h;
    }
  };
  function i(n) {
    this._arrayBuffer = n || new ArrayBuffer(0), this._bufferView = new DataView(this._arrayBuffer), this._globalPaxHeader = null, this._paxHeader = null, this._bytesRead = 0;
  }
  r || (bg = i), i.prototype._hasNext = function() {
    return this._bytesRead + 4 < this._arrayBuffer.byteLength && this._bufferView.getUint32(this._bytesRead) !== 0;
  }, i.prototype._readNextFile = function() {
    const n = new DataView(this._arrayBuffer, this._bytesRead, 512), a = t.decode(n);
    this._bytesRead += 512;
    let o = a.substring(0, 100).replace(/\0/g, "");
    const h = a.substring(257, 263), l = parseInt(a.substring(124, 136), 8), c = a.substring(156, 157), d = this._bytesRead;
    let u = null, f = !1;
    switch (c) {
      case "0":
      case "":
        if (f = !0, !r) {
          const p = new Blob([this._arrayBuffer.slice(this._bytesRead, this._bytesRead + l)]);
          u = URL.createObjectURL(p);
        }
        break;
      case "g":
        this._globalPaxHeader = s.parse(this._arrayBuffer, this._bytesRead, l);
        break;
      case "x":
        this._paxHeader = s.parse(this._arrayBuffer, this._bytesRead, l);
        break;
    }
    this._bytesRead += l;
    const m = l % 512;
    if (m !== 0 && (this._bytesRead += 512 - m), !f)
      return null;
    if (h.indexOf("ustar") !== -1) {
      const p = a.substring(345, 500).replace(/\0/g, "");
      p.length > 0 && (o = p.trim() + o.trim());
    }
    const _ = {
      name: o,
      start: d,
      size: l,
      url: u
    };
    return this._globalPaxHeader && this._globalPaxHeader.applyHeader(_), this._paxHeader && (this._paxHeader.applyHeader(_), this._paxHeader = null), _;
  }, i.prototype.untar = function(n) {
    if (!e)
      return console.error("Cannot untar because TextDecoder interface is not available for this platform."), [];
    const a = [];
    for (; this._hasNext(); ) {
      const o = this._readNextFile();
      o && (n && o.name && (o.name = n + o.name), a.push(o));
    }
    return a;
  }, r && (self.onmessage = function(n) {
    const a = n.data.id;
    try {
      const h = new i(n.data.arrayBuffer).untar(n.data.prefix);
      postMessage({
        id: a,
        files: h,
        arrayBuffer: n.data.arrayBuffer
      }, [n.data.arrayBuffer]);
    } catch (o) {
      postMessage({
        id: a,
        error: o.toString()
      });
    }
  });
}
let Fc = null;
function zA() {
  if (!Fc) {
    const r = "(" + wg.toString() + `)(true)

`, e = new Blob([r], {
      type: "application/javascript"
    });
    Fc = URL.createObjectURL(e);
  }
  return Fc;
}
class UA {
  constructor(e) {
    this._requestId = 0, this._pendingRequests = {}, this._filenamePrefix = e, this._worker = new Worker(zA()), this._worker.addEventListener("message", this._onMessage.bind(this));
  }
  _onMessage(e) {
    const t = e.data.id;
    if (!this._pendingRequests[t])
      return;
    const s = this._pendingRequests[t];
    if (delete this._pendingRequests[t], e.data.error)
      s(e.data.error);
    else {
      const i = e.data.arrayBuffer;
      for (let n = 0, a = e.data.files.length; n < a; n++) {
        const o = e.data.files[n], h = new Blob([i.slice(o.start, o.start + o.size)]);
        o.url = URL.createObjectURL(h);
      }
      s(null, e.data.files);
    }
  }
  untar(e, t) {
    const s = this._requestId++;
    this._pendingRequests[s] = t, this._worker.postMessage({
      id: s,
      prefix: this._filenamePrefix,
      arrayBuffer: e
    }, [e]);
  }
  hasPendingRequests() {
    return Object.keys(this._pendingRequests).length > 0;
  }
  destroy() {
    this._worker && (this._worker.terminate(), this._worker = null, this._pendingRequests = null);
  }
}
wg();
class VA {
  constructor(e) {
    this.handlerType = "bundle", this._assets = e.assets, this._worker = null, this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = this;
    $e.get(e.load, {
      responseType: ve.ResponseType.ARRAY_BUFFER,
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(i, n) {
      if (i)
        t("Error loading bundle resource " + e.original + ": " + i);
      else
        try {
          s._untar(n, t);
        } catch (a) {
          t("Error loading bundle resource " + e.original + ": " + a);
        }
    });
  }
  _untar(e, t) {
    const s = this;
    if (lt.workers)
      s._worker || (s._worker = new UA(s._assets.prefix)), s._worker.untar(e, function(i, n) {
        t(i, n), s._worker.hasPendingRequests() || (s._worker.destroy(), s._worker = null);
      });
    else {
      const n = new bg(e).untar(s._assets.prefix);
      t(null, n);
    }
  }
  open(e, t) {
    return new NA(t);
  }
  patch(e, t) {
  }
}
class GA {
  constructor(e) {
    this._handlers = {}, this._requests = {}, this._cache = {}, this._app = e;
  }
  addHandler(e, t) {
    this._handlers[e] = t, t._loader = this;
  }
  removeHandler(e) {
    delete this._handlers[e];
  }
  getHandler(e) {
    return this._handlers[e];
  }
  load(e, t, s, i) {
    const n = this._handlers[t];
    if (!n) {
      const o = `No resource handler for asset type: '${t}' when loading [${e}]`;
      s(o);
      return;
    }
    if (!e) {
      this._loadNull(n, s, i);
      return;
    }
    const a = e + t;
    if (this._cache[a] !== void 0)
      s(null, this._cache[a]);
    else if (this._requests[a])
      this._requests[a].push(s);
    else {
      this._requests[a] = [s];
      const o = this, h = function(d, u) {
        if (d) {
          o._onFailure(a, d);
          return;
        }
        n.load(u, function(f, m, _) {
          if (o._requests[a]) {
            if (f) {
              o._onFailure(a, f);
              return;
            }
            try {
              o._onSuccess(a, n.open(u.original, m, i), _);
            } catch (p) {
              o._onFailure(a, p);
            }
          }
        }, i);
      }, l = e.split("?")[0];
      if (this._app.enableBundles && this._app.bundles.hasUrl(l)) {
        if (!this._app.bundles.canLoadUrl(l)) {
          h(`Bundle for ${e} not loaded yet`);
          return;
        }
        this._app.bundles.loadUrl(l, function(c, d) {
          h(c, {
            load: d,
            original: l
          });
        });
      } else
        h(null, {
          load: e,
          original: i && i.file.filename || e
        });
    }
  }
  _loadNull(e, t, s) {
    const i = function(a, o, h) {
      if (a)
        t(a);
      else
        try {
          t(null, e.open(null, o, s), h);
        } catch (l) {
          t(l);
        }
    };
    e.load(null, i, s);
  }
  _onSuccess(e, t, s) {
    this._cache[e] = t;
    for (let i = 0; i < this._requests[e].length; i++)
      this._requests[e][i](null, t, s);
    delete this._requests[e];
  }
  _onFailure(e, t) {
    if (console.error(t), this._requests[e]) {
      for (let s = 0; s < this._requests[e].length; s++)
        this._requests[e][s](t);
      delete this._requests[e];
    }
  }
  open(e, t) {
    const s = this._handlers[e];
    return s ? s.open(null, t) : (console.warn("No resource handler found for: " + e), t);
  }
  patch(e, t) {
    const s = this._handlers[e.type];
    if (!s) {
      console.warn("No resource handler found for: " + e.type);
      return;
    }
    s.patch && s.patch(e, t);
  }
  clearCache(e, t) {
    delete this._cache[e + t];
  }
  getFromCache(e, t) {
    if (this._cache[e + t])
      return this._cache[e + t];
  }
  enableRetry(e = 5) {
    e = Math.max(0, e) || 0;
    for (const t in this._handlers)
      this._handlers[t].maxRetries = e;
  }
  disableRetry() {
    for (const e in this._handlers)
      this._handlers[e].maxRetries = 0;
  }
  destroy() {
    this._handlers = {}, this._requests = {}, this._cache = {};
  }
}
class HA {
  _validate(e) {
    if (!e.header)
      throw new Error('pc.I18n#addData: Missing "header" field');
    if (!e.header.version)
      throw new Error('pc.I18n#addData: Missing "header.version" field');
    if (e.header.version !== 1)
      throw new Error('pc.I18n#addData: Invalid "header.version" field');
    if (e.data) {
      if (!Array.isArray(e.data))
        throw new Error('pc.I18n#addData: "data" field must be an array');
    } else
      throw new Error('pc.I18n#addData: Missing "data" field');
    for (let t = 0, s = e.data.length; t < s; t++) {
      const i = e.data[t];
      if (!i.info)
        throw new Error(`pc.I18n#addData: missing "data[${t}].info" field`);
      if (!i.info.locale)
        throw new Error(`pc.I18n#addData: missing "data[${t}].info.locale" field`);
      if (typeof i.info.locale != "string")
        throw new Error(`pc.I18n#addData: "data[${t}].info.locale" must be a string`);
      if (!i.messages)
        throw new Error(`pc.I18n#addData: missing "data[${t}].messages" field`);
    }
  }
  parse(e) {
    return e.data;
  }
}
class WA extends _e {
  constructor(e) {
    super(), this.locale = sl, this._translations = {}, this._availableLangs = {}, this._app = e, this._assets = [], this._parser = new HA();
  }
  set assets(e) {
    const t = {};
    for (let i = 0, n = e.length; i < n; i++) {
      const a = e[i] instanceof ce ? e[i].id : e[i];
      t[a] = !0;
    }
    let s = this._assets.length;
    for (; s--; ) {
      const i = this._assets[s];
      if (!t[i]) {
        this._app.assets.off("add:" + i, this._onAssetAdd, this);
        const n = this._app.assets.get(i);
        n && this._onAssetRemove(n), this._assets.splice(s, 1);
      }
    }
    for (const i in t) {
      const n = parseInt(i, 10);
      if (this._assets.indexOf(n) !== -1)
        continue;
      this._assets.push(n);
      const a = this._app.assets.get(n);
      a ? this._onAssetAdd(a) : this._app.assets.once("add:" + n, this._onAssetAdd, this);
    }
  }
  get assets() {
    return this._assets;
  }
  set locale(e) {
    if (this._locale === e)
      return;
    let t = si(e);
    if (t === "in" && (t = "id", e = RA(e, t), this._locale === e))
      return;
    const s = this._locale;
    this._locale = e, this._lang = t, this._pluralFn = Bc(this._lang), this.fire("set:locale", e, s);
  }
  get locale() {
    return this._locale;
  }
  static findAvailableLocale(e, t) {
    return Sg(e, t);
  }
  findAvailableLocale(e) {
    if (this._translations[e])
      return e;
    const t = si(e);
    return this._findFallbackLocale(e, t);
  }
  getText(e, t) {
    let s = e, i;
    t || (t = this._locale, i = this._lang);
    let n = this._translations[t];
    return n || (i || (i = si(t)), t = this._findFallbackLocale(t, i), n = this._translations[t]), n && n.hasOwnProperty(e) && (s = n[e], Array.isArray(s) && (s = s[0]), s == null && (s = e)), s;
  }
  getPluralText(e, t, s) {
    let i = e, n, a;
    s ? (n = si(s), a = Bc(n)) : (s = this._locale, n = this._lang, a = this._pluralFn);
    let o = this._translations[s];
    if (o || (s = this._findFallbackLocale(s, n), n = si(s), a = Bc(n), o = this._translations[s]), o && o[e] && a) {
      const h = a(t);
      i = o[e][h], i == null && (i = e);
    }
    return i;
  }
  addData(e) {
    let t;
    try {
      t = this._parser.parse(e);
    } catch (s) {
      console.error(s);
      return;
    }
    for (let s = 0, i = t.length; s < i; s++) {
      const n = t[s], a = n.info.locale, o = n.messages;
      if (!this._translations[a]) {
        this._translations[a] = {};
        const h = si(a);
        this._availableLangs[h] || (this._availableLangs[h] = a);
      }
      Object.assign(this._translations[a], o), this.fire("data:add", a, o);
    }
  }
  removeData(e) {
    let t;
    try {
      t = this._parser.parse(e);
    } catch (s) {
      console.error(s);
      return;
    }
    for (let s = 0, i = t.length; s < i; s++) {
      const n = t[s], a = n.info.locale, o = this._translations[a];
      if (!o)
        continue;
      const h = n.messages;
      for (const l in h)
        delete o[l];
      Object.keys(o).length === 0 && (delete this._translations[a], delete this._availableLangs[si(a)]), this.fire("data:remove", a, h);
    }
  }
  destroy() {
    this._translations = null, this._availableLangs = null, this._assets = null, this._parser = null, this.off();
  }
  _findFallbackLocale(e, t) {
    let s = il[e];
    return s && this._translations[s] || (s = il[t], s && this._translations[s]) || (s = this._availableLangs[t], s && this._translations[s]) ? s : sl;
  }
  _onAssetAdd(e) {
    e.on("load", this._onAssetLoad, this), e.on("change", this._onAssetChange, this), e.on("remove", this._onAssetRemove, this), e.on("unload", this._onAssetUnload, this), e.resource && this._onAssetLoad(e);
  }
  _onAssetLoad(e) {
    this.addData(e.resource);
  }
  _onAssetChange(e) {
    e.resource && this.addData(e.resource);
  }
  _onAssetRemove(e) {
    e.off("load", this._onAssetLoad, this), e.off("change", this._onAssetChange, this), e.off("remove", this._onAssetRemove, this), e.off("unload", this._onAssetUnload, this), e.resource && this.removeData(e.resource), this._app.assets.once("add:" + e.id, this._onAssetAdd, this);
  }
  _onAssetUnload(e) {
    e.resource && this.removeData(e.resource);
  }
}
class qA extends _e {
  constructor(e) {
    super(), this.app = e, this._scripts = {}, this._list = [];
  }
  destroy() {
    this.app = null, this.off();
  }
  add(e) {
    const t = e.__name;
    return this._scripts.hasOwnProperty(t) ? (setTimeout(() => {
      if (e.prototype.swap) {
        const s = this._scripts[t], i = this._list.indexOf(s);
        this._list[i] = e, this._scripts[t] = e, this.fire("swap", t, e), this.fire("swap:" + t, e);
      } else
        console.warn(`script registry already has '${t}' script, define 'swap' method for new script type to enable code hot swapping`);
    }), !1) : (this._scripts[t] = e, this._list.push(e), this.fire("add", t, e), this.fire("add:" + t, e), setTimeout(() => {
      if (!this._scripts.hasOwnProperty(t) || !this.app || !this.app.systems || !this.app.systems.script)
        return;
      const s = this.app.systems.script._components;
      let i;
      const n = [], a = [];
      for (s.loopIndex = 0; s.loopIndex < s.length; s.loopIndex++) {
        const o = s.items[s.loopIndex];
        if (o._scriptsIndex[t] && o._scriptsIndex[t].awaiting) {
          o._scriptsData && o._scriptsData[t] && (i = o._scriptsData[t].attributes);
          const h = o.create(t, {
            preloading: !0,
            ind: o._scriptsIndex[t].ind,
            attributes: i
          });
          h && n.push(h);
        }
      }
      for (let o = 0; o < n.length; o++)
        n[o].__initializeAttributes();
      for (let o = 0; o < n.length; o++)
        n[o].enabled && (n[o]._initialized = !0, a.push(n[o]), n[o].initialize && n[o].initialize());
      for (let o = 0; o < a.length; o++)
        !a[o].enabled || a[o]._postInitialized || (a[o]._postInitialized = !0, a[o].postInitialize && a[o].postInitialize());
    }), !0);
  }
  remove(e) {
    let t = e, s = e;
    if (typeof s != "string" ? s = t.__name : t = this.get(s), this.get(s) !== t)
      return !1;
    delete this._scripts[s];
    const i = this._list.indexOf(t);
    return this._list.splice(i, 1), this.fire("remove", s, t), this.fire("remove:" + s, t), !0;
  }
  get(e) {
    return this._scripts[e] || null;
  }
  has(e) {
    if (typeof e == "string")
      return this._scripts.hasOwnProperty(e);
    if (!e)
      return !1;
    const t = e.__name;
    return this._scripts[t] === e;
  }
  list() {
    return this._list;
  }
}
const ca = [];
class oe extends bt {
  constructor(e, t = qi()) {
    super(e), this.anim = void 0, this.animation = void 0, this.audiolistener = void 0, this.button = void 0, this.camera = void 0, this.collision = void 0, this.element = void 0, this.layoutchild = void 0, this.layoutgroup = void 0, this.light = void 0, this.model = void 0, this.particlesystem = void 0, this.render = void 0, this.rigidbody = void 0, this.screen = void 0, this.script = void 0, this.scrollbar = void 0, this.scrollview = void 0, this.sound = void 0, this.sprite = void 0, this.c = {}, this._app = void 0, this._destroying = !1, this._guid = null, this._template = !1, this._app = t;
  }
  addComponent(e, t) {
    const s = this._app.systems[e];
    return !s || this.c[e] ? null : s.addComponent(this, t);
  }
  removeComponent(e) {
    const t = this._app.systems[e];
    t && this.c[e] && t.removeComponent(this);
  }
  findComponent(e) {
    const t = this.findOne(function(s) {
      return s.c && s.c[e];
    });
    return t && t.c[e];
  }
  findComponents(e) {
    return this.find(function(s) {
      return s.c && s.c[e];
    }).map(function(s) {
      return s.c[e];
    });
  }
  getGuid() {
    return this._guid || this.setGuid(n0.create()), this._guid;
  }
  setGuid(e) {
    const t = this._app._entityIndex;
    this._guid && delete t[this._guid], this._guid = e, t[this._guid] = this;
  }
  _notifyHierarchyStateChanged(e, t) {
    let s = !1;
    e === this && ca.length === 0 && (s = !0), e._beingEnabled = !0, e._onHierarchyStateChanged(t), e._onHierarchyStatePostChanged && ca.push(e);
    const i = e._children;
    for (let n = 0, a = i.length; n < a; n++)
      i[n]._enabled && this._notifyHierarchyStateChanged(i[n], t);
    if (e._beingEnabled = !1, s) {
      for (let n = 0; n < ca.length; n++)
        ca[n]._onHierarchyStatePostChanged();
      ca.length = 0;
    }
  }
  _onHierarchyStateChanged(e) {
    super._onHierarchyStateChanged(e);
    const t = this.c;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s];
        i.enabled && (e ? i.onEnable() : i.onDisable());
      }
  }
  _onHierarchyStatePostChanged() {
    const e = this.c;
    for (const t in e)
      e.hasOwnProperty(t) && e[t].onPostStateChange();
  }
  findByGuid(e) {
    if (this._guid === e)
      return this;
    const t = this._app._entityIndex[e];
    return t && (t === this || t.isDescendantOf(this)) ? t : null;
  }
  destroy() {
    this._destroying = !0;
    for (const t in this.c)
      this.c[t].enabled = !1;
    for (const t in this.c)
      this.c[t].system.removeComponent(this);
    this._parent && this._parent.removeChild(this);
    const e = this._children;
    for (; e.length; ) {
      const t = e.pop();
      t._parent = null, t instanceof oe && t.destroy();
    }
    this.fire("destroy", this), this.off(), this._guid && delete this._app._entityIndex[this._guid], this._destroying = !1;
  }
  clone() {
    const e = {}, t = this._cloneRecursively(e);
    return e[this.getGuid()] = t, Tg(this, this, t, e), t;
  }
  _cloneRecursively(e) {
    const t = new this.constructor(void 0, this._app);
    super._cloneInternal(t);
    for (const s in this.c)
      this.c[s].system.cloneComponent(this, t);
    for (let s = 0; s < this._children.length; s++) {
      const i = this._children[s];
      if (i instanceof oe) {
        const n = i._cloneRecursively(e);
        t.addChild(n), e[i.getGuid()] = n;
      }
    }
    return t;
  }
}
function Tg(r, e, t, s) {
  if (e instanceof oe) {
    const i = e.c;
    for (const o in i) {
      const h = i[o], l = h.system.getPropertiesOfType("entity");
      for (let c = 0, d = l.length; c < d; c++) {
        const f = l[c].name, m = h[f];
        if (!!r.findByGuid(m)) {
          const p = s[m].getGuid();
          p && (t.c[o][f] = p);
        }
      }
    }
    i.script && !t._app.useLegacyScriptAttributeCloning && t.script.resolveDuplicatedEntityReferenceProperties(i.script, s), i.render && t.render.resolveDuplicatedEntityReferenceProperties(i.render, s), i.anim && t.anim.resolveDuplicatedEntityReferenceProperties(i.anim, s);
    const n = e.children.filter(function(o) {
      return o instanceof oe;
    }), a = t.children.filter(function(o) {
      return o instanceof oe;
    });
    for (let o = 0, h = n.length; o < h; o++)
      Tg(r, n[o], a[o], s);
  }
}
class Xm {
  constructor(e, t) {
    this.name = e, this.url = t, this.data = null, this._loading = !1, this._onLoadedCallbacks = [];
  }
  get loaded() {
    return !!this.data;
  }
  get loading() {
    return this._loading;
  }
}
class XA {
  constructor(e) {
    this._app = e, this._list = [], this._index = {}, this._urlIndex = {};
  }
  destroy() {
    this._app = null;
  }
  list() {
    return this._list;
  }
  add(e, t) {
    if (this._index.hasOwnProperty(e))
      return !1;
    const s = new Xm(e, t), i = this._list.push(s);
    return this._index[s.name] = i - 1, this._urlIndex[s.url] = i - 1, !0;
  }
  find(e) {
    return this._index.hasOwnProperty(e) ? this._list[this._index[e]] : null;
  }
  findByUrl(e) {
    return this._urlIndex.hasOwnProperty(e) ? this._list[this._urlIndex[e]] : null;
  }
  remove(e) {
    if (this._index.hasOwnProperty(e)) {
      const t = this._index[e];
      let s = this._list[t];
      delete this._urlIndex[s.url], delete this._index[e], this._list.splice(t, 1);
      for (let i = 0; i < this._list.length; i++)
        s = this._list[i], this._index[s.name] = i, this._urlIndex[s.url] = i;
    }
  }
  _loadSceneData(e, t, s) {
    const i = this._app;
    let n = e;
    if (typeof e == "string" && (e = this.findByUrl(n) || this.find(n) || new Xm("Untitled", n)), n = e.url, !n) {
      s("Cannot find scene to load");
      return;
    }
    if (e.loaded) {
      s(null, e);
      return;
    }
    i.assets && i.assets.prefix && !nl.test(n) && (n = me.join(i.assets.prefix, n)), e._onLoadedCallbacks.push(s), e._loading || i.loader.getHandler("hierarchy").load(n, (o, h) => {
      e.data = h, e._loading = !1;
      for (let l = 0; l < e._onLoadedCallbacks.length; l++)
        e._onLoadedCallbacks[l](o, e);
      t || (e.data = null), e._onLoadedCallbacks.length = 0;
    }), e._loading = !0;
  }
  loadSceneData(e, t) {
    this._loadSceneData(e, !0, t);
  }
  unloadSceneData(e) {
    typeof e == "string" && (e = this.findByUrl(e)), e && (e.data = null);
  }
  _loadSceneHierarchy(e, t, s) {
    this._loadSceneData(e, !1, (i, n) => {
      if (i) {
        s && s(i);
        return;
      }
      t && t(n);
      const a = this._app, o = () => {
        const h = a.loader.getHandler("hierarchy");
        a.systems.script.preloading = !0;
        const l = h.open(n.url, n.data);
        a.systems.script.preloading = !1, a.loader.clearCache(n.url, "hierarchy"), a.root.addChild(l), a.systems.fire("initialize", l), a.systems.fire("postInitialize", l), a.systems.fire("postPostInitialize", l), s && s(null, l);
      };
      a._preloadScripts(n.data, o);
    });
  }
  loadSceneHierarchy(e, t) {
    this._loadSceneHierarchy(e, null, t);
  }
  loadSceneSettings(e, t) {
    this._loadSceneData(e, !1, (s, i) => {
      s ? t && t(s) : (this._app.applySceneSettings(i.data.settings), t && t(null));
    });
  }
  changeScene(e, t) {
    const s = this._app, i = (n) => {
      const a = s.root.children;
      for (; a.length > 0; ) {
        const o = a[0];
        o.reparent(null), o.destroy == null || o.destroy();
      }
      s.applySceneSettings(n.data.settings);
    };
    this._loadSceneHierarchy(e, i, t);
  }
  loadScene(e, t) {
    const s = this._app, i = s.loader.getHandler("scene");
    s.assets && s.assets.prefix && !nl.test(e) && (e = me.join(s.assets.prefix, e)), i.load(e, (n, a) => {
      if (n)
        t && t(n);
      else {
        const o = () => {
          s.systems.script.preloading = !0;
          const h = i.open(e, a), l = this.findByUrl(e);
          l && !l.loaded && (l.data = a), s.systems.script.preloading = !1, s.loader.clearCache(e, "scene"), s.loader.patch({
            resource: h,
            type: "scene"
          }, s.assets), s.root.addChild(h.root), s.systems.rigidbody && typeof Ammo < "u" && s.systems.rigidbody.gravity.set(h._gravity.x, h._gravity.y, h._gravity.z), t && t(null, h);
        };
        s._preloadScripts(a, o);
      }
    });
  }
}
class jA {
  constructor(e) {
    this.frame = {
      fps: 0,
      ms: 0,
      dt: 0,
      updateStart: 0,
      updateTime: 0,
      renderStart: 0,
      renderTime: 0,
      physicsStart: 0,
      physicsTime: 0,
      cullTime: 0,
      sortTime: 0,
      skinTime: 0,
      morphTime: 0,
      instancingTime: 0,
      triangles: 0,
      otherPrimitives: 0,
      shaders: 0,
      materials: 0,
      cameras: 0,
      shadowMapUpdates: 0,
      shadowMapTime: 0,
      depthMapTime: 0,
      forwardTime: 0,
      lightClustersTime: 0,
      lightClusters: 0,
      _timeToCountFrames: 0,
      _fpsAccum: 0
    }, this.drawCalls = {
      forward: 0,
      depth: 0,
      shadow: 0,
      immediate: 0,
      misc: 0,
      total: 0,
      skinned: 0,
      instanced: 0,
      removedByInstancing: 0
    }, this.misc = {
      renderTargetCreationTime: 0
    }, this.particles = {
      updatesPerFrame: 0,
      _updatesPerFrame: 0,
      frameTime: 0,
      _frameTime: 0
    }, this.shaders = e._shaderStats, this.vram = e._vram, Object.defineProperty(this.vram, "totalUsed", {
      get: function() {
        return this.tex + this.vb + this.ib;
      }
    }), Object.defineProperty(this.vram, "geom", {
      get: function() {
        return this.vb + this.ib;
      }
    });
  }
  get scene() {
    return qi().scene._stats;
  }
  get lightmapper() {
    var e;
    return (e = qi().lightmapper) == null ? void 0 : e.stats;
  }
  get batcher() {
    const e = qi()._batcher;
    return e ? e._stats : null;
  }
}
class jm {
  constructor(e) {
    this.length = e, this.count = 0;
  }
  inc() {
    this.count++;
  }
  done() {
    return this.count === this.length;
  }
}
class Pr extends _e {
  constructor(e) {
    super(), Pr._applications[e.id] = this, Od(this), this._destroyRequested = !1, this._inFrameUpdate = !1, this._time = 0, this.timeScale = 1, this.maxDeltaTime = 0.1, this.frame = 0, this.autoRender = !0, this.renderNextFrame = !1, this.useLegacyScriptAttributeCloning = fs.legacy, this._librariesLoaded = !1, this._fillMode = Gm, this._resolutionMode = AA, this._allowResize = !0, this.context = this;
  }
  init(e) {
    const t = e.graphicsDevice;
    this.graphicsDevice = t, xi.set(t), this._initDefaultMaterial(), this._initProgramLibrary(), this.stats = new jA(t), this._soundManager = e.soundManager, this.loader = new GA(this), ke.init(t), this._entityIndex = {}, this.scene = new pA(t), this._registerSceneImmediate(this.scene), this.root = new oe(), this.root._enabledInHierarchy = !0, this.assets = new FA(this.loader), e.assetPrefix && (this.assets.prefix = e.assetPrefix), this.bundles = new OA(this.assets), this.enableBundles = typeof TextDecoder < "u", this.scriptsOrder = e.scriptsOrder || [], this.scripts = new qA(this), this.i18n = new WA(this), this.scenes = new XA(this);
    const s = this;
    this.defaultLayerWorld = new Sn({
      name: "World",
      id: wi
    }), this.sceneGrab = new mg(this.graphicsDevice, this.scene), this.defaultLayerDepth = this.sceneGrab.layer, this.defaultLayerSkybox = new Sn({
      enabled: !0,
      name: "Skybox",
      id: Pu,
      opaqueSortMode: Rd
    }), this.defaultLayerUi = new Sn({
      enabled: !0,
      name: "UI",
      id: Xa,
      transparentSortMode: Mv,
      passThrough: !1
    }), this.defaultLayerImmediate = new Sn({
      enabled: !0,
      name: "Immediate",
      id: zh,
      opaqueSortMode: Rd,
      passThrough: !0
    });
    const i = new Cm("default");
    i.pushOpaque(this.defaultLayerWorld), i.pushOpaque(this.defaultLayerDepth), i.pushOpaque(this.defaultLayerSkybox), i.pushTransparent(this.defaultLayerWorld), i.pushOpaque(this.defaultLayerImmediate), i.pushTransparent(this.defaultLayerImmediate), i.pushTransparent(this.defaultLayerUi), this.scene.layers = i, this.scene.on("set:layers", function(n, a) {
      const o = a.layerList;
      let h;
      for (let l = 0; l < o.length; l++)
        switch (h = o[l], h.id) {
          case kt:
            s.sceneGrab.patch(h);
            break;
          case Xa:
            h.passThrough = s.defaultLayerUi.passThrough;
            break;
          case zh:
            h.passThrough = s.defaultLayerImmediate.passThrough;
            break;
        }
    }), Cn.createPlaceholder(t), this.renderer = new GC(t), this.renderer.scene = this.scene, this.frameGraph = new MA(), this.lightmapper = null, e.lightmapper && (this.lightmapper = new e.lightmapper(t, this.root, this.scene, this.renderer, this.assets), this.once("prerender", this._firstBake, this)), this._batcher = null, e.batchManager && (this._batcher = new e.batchManager(t, this.root, this.scene), this.once("prerender", this._firstBatch, this)), this.keyboard = e.keyboard || null, this.mouse = e.mouse || null, this.touch = e.touch || null, this.gamepads = e.gamepads || null, this.elementInput = e.elementInput || null, this.elementInput && (this.elementInput.app = this), this.xr = e.xr ? new e.xr(this) : null, this.elementInput && this.elementInput.attachSelectEvents(), this._inTools = !1, this._skyboxAsset = null, this._scriptPrefix = e.scriptPrefix || "", this.enableBundles && this.loader.addHandler("bundle", new VA(this)), e.resourceHandlers.forEach((n) => {
      const a = new n(this);
      this.loader.addHandler(a.handlerType, a);
    }), this.systems = new kA(), e.componentSystems.forEach((n) => {
      this.systems.add(new n(this));
    }), this._visibilityChangeHandler = this.onVisibilityChange.bind(this), typeof document < "u" && (document.hidden !== void 0 ? (this._hiddenAttr = "hidden", document.addEventListener("visibilitychange", this._visibilityChangeHandler, !1)) : document.mozHidden !== void 0 ? (this._hiddenAttr = "mozHidden", document.addEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1)) : document.msHidden !== void 0 ? (this._hiddenAttr = "msHidden", document.addEventListener("msvisibilitychange", this._visibilityChangeHandler, !1)) : document.webkitHidden !== void 0 && (this._hiddenAttr = "webkitHidden", document.addEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1))), this.tick = $A(this);
  }
  static getApplication(e) {
    return e ? Pr._applications[e] : qi();
  }
  _initDefaultMaterial() {
    const e = new Ht();
    e.name = "Default Material", e.shadingModel = Wl, ST(this.graphicsDevice, e);
  }
  _initProgramLibrary() {
    const e = new SA(this.graphicsDevice, new Ht());
    pT(this.graphicsDevice, e);
  }
  get soundManager() {
    return this._soundManager;
  }
  get batcher() {
    return this._batcher;
  }
  get fillMode() {
    return this._fillMode;
  }
  get resolutionMode() {
    return this._resolutionMode;
  }
  configure(e, t) {
    $e.get(e, (s, i) => {
      if (s) {
        t(s);
        return;
      }
      const n = i.application_properties, a = i.scenes, o = i.assets;
      this._parseApplicationProperties(n, (h) => {
        this._parseScenes(a), this._parseAssets(o), t(h || null);
      });
    });
  }
  preload(e) {
    this.fire("preload:start");
    const t = this.assets.list({
      preload: !0
    }), s = new jm(t.length);
    let i = !1;
    const n = () => {
      this.graphicsDevice && !i && s.done() && (i = !0, this.fire("preload:end"), e());
    }, a = t.length;
    if (s.length) {
      const o = (l) => {
        s.inc(), this.fire("preload:progress", s.count / a), s.done() && n();
      }, h = (l, c) => {
        s.inc(), this.fire("preload:progress", s.count / a), s.done() && n();
      };
      for (let l = 0; l < t.length; l++)
        t[l].loaded ? (s.inc(), this.fire("preload:progress", s.count / a), s.done() && n()) : (t[l].once("load", o), t[l].once("error", h), this.assets.load(t[l]));
    } else
      n();
  }
  _preloadScripts(e, t) {
    if (!fs.legacy) {
      t();
      return;
    }
    this.systems.script.preloading = !0;
    const s = this._getScriptReferences(e), i = s.length, n = new jm(i), a = /^http(s)?:\/\//;
    if (i) {
      const o = (h, l) => {
        h && console.error(h), n.inc(), n.done() && (this.systems.script.preloading = !1, t());
      };
      for (let h = 0; h < i; h++) {
        let l = s[h];
        !a.test(l.toLowerCase()) && this._scriptPrefix && (l = me.join(this._scriptPrefix, s[h])), this.loader.load(l, "script", o);
      }
    } else
      this.systems.script.preloading = !1, t();
  }
  _parseApplicationProperties(e, t) {
    if (typeof e.maxAssetRetries == "number" && e.maxAssetRetries > 0 && this.loader.enableRetry(e.maxAssetRetries), e.useDevicePixelRatio || (e.useDevicePixelRatio = e.use_device_pixel_ratio), e.resolutionMode || (e.resolutionMode = e.resolution_mode), e.fillMode || (e.fillMode = e.fill_mode), this._width = e.width, this._height = e.height, e.useDevicePixelRatio && (this.graphicsDevice.maxPixelRatio = window.devicePixelRatio), this.setCanvasResolution(e.resolutionMode, this._width, this._height), this.setCanvasFillMode(e.fillMode, this._width, this._height), e.layers && e.layerOrder) {
      const s = new Cm("application"), i = {};
      for (const n in e.layers) {
        const a = e.layers[n];
        a.id = parseInt(n, 10), a.enabled = a.id !== kt, i[n] = new Sn(a);
      }
      for (let n = 0, a = e.layerOrder.length; n < a; n++) {
        const o = e.layerOrder[n], h = i[o.layer];
        h && (o.transparent ? s.pushTransparent(h) : s.pushOpaque(h), s.subLayerEnabled[n] = o.enabled);
      }
      this.scene.layers = s;
    }
    if (e.batchGroups) {
      const s = this.batcher;
      if (s)
        for (let i = 0, n = e.batchGroups.length; i < n; i++) {
          const a = e.batchGroups[i];
          s.addGroup(a.name, a.dynamic, a.maxAabbSize, a.id, a.layers);
        }
    }
    e.i18nAssets && (this.i18n.assets = e.i18nAssets), this._loadLibraries(e.libraries, t);
  }
  _loadLibraries(e, t) {
    const s = e.length;
    let i = s;
    const n = /^http(s)?:\/\//;
    if (s) {
      const a = (o, h) => {
        i--, o ? t(o) : i === 0 && (this.onLibrariesLoaded(), t(null));
      };
      for (let o = 0; o < s; ++o) {
        let h = e[o];
        !n.test(h.toLowerCase()) && this._scriptPrefix && (h = me.join(this._scriptPrefix, h)), this.loader.load(h, "script", a);
      }
    } else
      this.onLibrariesLoaded(), t(null);
  }
  _parseScenes(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.scenes.add(e[t].name, e[t].url);
  }
  _parseAssets(e) {
    const t = [], s = {}, i = {};
    if (fs.legacy) {
      if (this.enableBundles)
        for (const n in e)
          e[n].type === "bundle" && (i[n] = !0, t.push(e[n]));
      for (const n in e)
        i[n] || t.push(e[n]);
    } else {
      for (let n = 0; n < this.scriptsOrder.length; n++) {
        const a = this.scriptsOrder[n];
        e[a] && (s[a] = !0, t.push(e[a]));
      }
      if (this.enableBundles)
        for (const n in e)
          e[n].type === "bundle" && (i[n] = !0, t.push(e[n]));
      for (const n in e)
        s[n] || i[n] || t.push(e[n]);
    }
    for (let n = 0; n < t.length; n++) {
      const a = t[n], o = new ce(a.name, a.type, a.file, a.data);
      if (o.id = parseInt(a.id, 10), o.preload = a.preload ? a.preload : !1, o.loaded = a.type === "script" && a.data && a.data.loadingType > 0, o.tags.add(a.tags), a.i18n)
        for (const h in a.i18n)
          o.addLocalizedAssetId(h, a.i18n[h]);
      this.assets.add(o);
    }
  }
  _getScriptReferences(e) {
    let t = [];
    e.settings.priority_scripts && (t = e.settings.priority_scripts);
    const s = [], i = {};
    for (let a = 0; a < t.length; a++)
      s.push(t[a]), i[t[a]] = !0;
    const n = e.entities;
    for (const a in n) {
      if (!n[a].components.script)
        continue;
      const o = n[a].components.script.scripts;
      for (let h = 0; h < o.length; h++)
        i[o[h].url] || (s.push(o[h].url), i[o[h].url] = !0);
    }
    return s;
  }
  start() {
    this.frame = 0, this.fire("start", {
      timestamp: Xi(),
      target: this
    }), this._librariesLoaded || this.onLibrariesLoaded(), this.systems.fire("initialize", this.root), this.fire("initialize"), this.systems.fire("postInitialize", this.root), this.systems.fire("postPostInitialize", this.root), this.fire("postinitialize"), this.tick();
  }
  inputUpdate(e) {
    this.controller && this.controller.update(e), this.mouse && this.mouse.update(), this.keyboard && this.keyboard.update(), this.gamepads && this.gamepads.update();
  }
  update(e) {
    this.frame++, this.graphicsDevice.updateClientRect(), fs.legacy && this.systems.fire("fixedUpdate", 1 / 60), this.systems.fire(this._inTools ? "toolsUpdate" : "update", e), this.systems.fire("animationUpdate", e), this.systems.fire("postUpdate", e), this.fire("update", e), this.inputUpdate(e);
  }
  render() {
    this.fire("prerender"), this.root.syncHierarchy(), this._batcher && this._batcher.updateAll(), this.renderComposition(this.scene.layers), this.fire("postrender");
  }
  renderComposition(e) {
    this.renderer.buildFrameGraph(this.frameGraph, e), this.frameGraph.render(this.graphicsDevice);
  }
  _fillFrameStatsBasic(e, t, s) {
    const i = this.stats.frame;
    i.dt = t, i.ms = s, e > i._timeToCountFrames ? (i.fps = i._fpsAccum, i._fpsAccum = 0, i._timeToCountFrames = e + 1e3) : i._fpsAccum++, this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame, this.graphicsDevice._drawCallsPerFrame = 0;
  }
  _fillFrameStats() {
    let e = this.stats.frame;
    e.cameras = this.renderer._camerasRendered, e.materials = this.renderer._materialSwitches, e.shaders = this.graphicsDevice._shaderSwitchesPerFrame, e.shadowMapUpdates = this.renderer._shadowMapUpdates, e.shadowMapTime = this.renderer._shadowMapTime, e.depthMapTime = this.renderer._depthMapTime, e.forwardTime = this.renderer._forwardTime;
    const t = this.graphicsDevice._primsPerFrame;
    e.triangles = t[Es] / 3 + Math.max(t[jr] - 2, 0) + Math.max(t[Dn] - 2, 0), e.cullTime = this.renderer._cullTime, e.sortTime = this.renderer._sortTime, e.skinTime = this.renderer._skinTime, e.morphTime = this.renderer._morphTime, e.lightClusters = this.renderer._lightClusters, e.lightClustersTime = this.renderer._lightClustersTime, e.otherPrimitives = 0;
    for (let s = 0; s < t.length; s++)
      s < Es && (e.otherPrimitives += t[s]), t[s] = 0;
    this.renderer._camerasRendered = 0, this.renderer._materialSwitches = 0, this.renderer._shadowMapUpdates = 0, this.graphicsDevice._shaderSwitchesPerFrame = 0, this.renderer._cullTime = 0, this.renderer._layerCompositionUpdateTime = 0, this.renderer._lightClustersTime = 0, this.renderer._sortTime = 0, this.renderer._skinTime = 0, this.renderer._morphTime = 0, this.renderer._shadowMapTime = 0, this.renderer._depthMapTime = 0, this.renderer._forwardTime = 0, e = this.stats.drawCalls, e.forward = this.renderer._forwardDrawCalls, e.culled = this.renderer._numDrawCallsCulled, e.depth = 0, e.shadow = this.renderer._shadowDrawCalls, e.skinned = this.renderer._skinDrawCalls, e.immediate = 0, e.instanced = 0, e.removedByInstancing = 0, e.misc = e.total - (e.forward + e.shadow), this.renderer._depthDrawCalls = 0, this.renderer._shadowDrawCalls = 0, this.renderer._forwardDrawCalls = 0, this.renderer._numDrawCallsCulled = 0, this.renderer._skinDrawCalls = 0, this.renderer._immediateRendered = 0, this.renderer._instancedDrawCalls = 0, this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime, e = this.stats.particles, e.updatesPerFrame = e._updatesPerFrame, e.frameTime = e._frameTime, e._updatesPerFrame = 0, e._frameTime = 0;
  }
  setCanvasFillMode(e, t, s) {
    this._fillMode = e, this.resizeCanvas(t, s);
  }
  setCanvasResolution(e, t, s) {
    this._resolutionMode = e, e === Fd && t === void 0 && (t = this.graphicsDevice.canvas.clientWidth, s = this.graphicsDevice.canvas.clientHeight), this.graphicsDevice.resizeCanvas(t, s);
  }
  isHidden() {
    return document[this._hiddenAttr];
  }
  onVisibilityChange() {
    this.isHidden() ? this._soundManager && this._soundManager.suspend() : this._soundManager && this._soundManager.resume();
  }
  resizeCanvas(e, t) {
    if (!this._allowResize || this.xr && this.xr.session)
      return;
    const s = window.innerWidth, i = window.innerHeight;
    if (this._fillMode === Gm) {
      const n = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height, a = s / i;
      n > a ? (e = s, t = e / n) : (t = i, e = t * n);
    } else
      this._fillMode === xg && (e = s, t = i);
    return this.graphicsDevice.canvas.style.width = e + "px", this.graphicsDevice.canvas.style.height = t + "px", this.updateCanvasSize(), {
      width: e,
      height: t
    };
  }
  updateCanvasSize() {
    var e;
    if (!(!this._allowResize || (e = this.xr) != null && e.active) && this._resolutionMode === Fd) {
      const t = this.graphicsDevice.canvas;
      this.graphicsDevice.resizeCanvas(t.clientWidth, t.clientHeight);
    }
  }
  onLibrariesLoaded() {
    this._librariesLoaded = !0, this.systems.rigidbody && this.systems.rigidbody.onLibraryLoaded();
  }
  applySceneSettings(e) {
    let t;
    if (this.systems.rigidbody && typeof Ammo < "u") {
      const s = e.physics.gravity;
      this.systems.rigidbody.gravity.set(s[0], s[1], s[2]);
    }
    this.scene.applySettings(e), e.render.hasOwnProperty("skybox") && (e.render.skybox ? (t = this.assets.get(e.render.skybox), t ? this.setSkybox(t) : this.assets.once("add:" + e.render.skybox, this.setSkybox, this)) : this.setSkybox(null));
  }
  setAreaLightLuts(e, t) {
    e && t && Cn.set(this.graphicsDevice, e, t);
  }
  setSkybox(e) {
    if (e !== this._skyboxAsset) {
      const t = () => {
        this.setSkybox(null);
      }, s = () => {
        this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
      };
      this._skyboxAsset && (this.assets.off("load:" + this._skyboxAsset.id, s, this), this.assets.off("remove:" + this._skyboxAsset.id, t, this), this._skyboxAsset.off("change", s, this)), this._skyboxAsset = e, this._skyboxAsset && (this.assets.on("load:" + this._skyboxAsset.id, s, this), this.assets.once("remove:" + this._skyboxAsset.id, t, this), this._skyboxAsset.on("change", s, this), this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces && (this._skyboxAsset.loadFaces = !0), this.assets.load(this._skyboxAsset)), s();
    }
  }
  _firstBake() {
    var e;
    (e = this.lightmapper) == null || e.bake(null, this.scene.lightmapMode);
  }
  _firstBatch() {
    var e;
    (e = this.batcher) == null || e.generate();
  }
  _processTimestamp(e) {
    return e;
  }
  drawLine(e, t, s, i, n) {
    this.scene.drawLine(e, t, s, i, n);
  }
  drawLines(e, t, s = !0, i = this.scene.defaultDrawLayer) {
    this.scene.drawLines(e, t, s, i);
  }
  drawLineArrays(e, t, s = !0, i = this.scene.defaultDrawLayer) {
    this.scene.drawLineArrays(e, t, s, i);
  }
  drawWireSphere(e, t, s = z.WHITE, i = 20, n = !0, a = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawWireSphere(e, t, s, i, n, a);
  }
  drawWireAlignedBox(e, t, s = z.WHITE, i = !0, n = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawWireAlignedBox(e, t, s, i, n);
  }
  drawMeshInstance(e, t = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(null, null, null, e, t);
  }
  drawMesh(e, t, s, i = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(t, s, e, null, i);
  }
  drawQuad(e, t, s = this.scene.defaultDrawLayer) {
    this.scene.immediate.drawMesh(t, e, this.scene.immediate.getQuadMesh(), null, s);
  }
  drawTexture(e, t, s, i, n, a, o = this.scene.defaultDrawLayer) {
    const h = new j();
    h.setTRS(new v(e, t, 0), ee.IDENTITY, new v(s, i, 0)), a || (a = new Ki(), a.setParameter("colorMap", n), a.shader = this.scene.immediate.getTextureShader(), a.update()), this.drawQuad(h, a, o);
  }
  drawDepthTexture(e, t, s, i, n = this.scene.defaultDrawLayer) {
    const a = new Ki();
    a.shader = this.scene.immediate.getDepthTextureShader(), a.update(), this.drawTexture(e, t, s, i, null, a, n);
  }
  destroy() {
    var e;
    if (this._inFrameUpdate) {
      this._destroyRequested = !0;
      return;
    }
    const t = this.graphicsDevice.canvas.id;
    this.off("librariesloaded"), typeof document < "u" && (document.removeEventListener("visibilitychange", this._visibilityChangeHandler, !1), document.removeEventListener("mozvisibilitychange", this._visibilityChangeHandler, !1), document.removeEventListener("msvisibilitychange", this._visibilityChangeHandler, !1), document.removeEventListener("webkitvisibilitychange", this._visibilityChangeHandler, !1)), this._visibilityChangeHandler = null, this.root.destroy(), this.root = null, this.mouse && (this.mouse.off(), this.mouse.detach(), this.mouse = null), this.keyboard && (this.keyboard.off(), this.keyboard.detach(), this.keyboard = null), this.touch && (this.touch.off(), this.touch.detach(), this.touch = null), this.elementInput && (this.elementInput.detach(), this.elementInput = null), this.controller && (this.controller = null), this.systems.destroy(), this.scene.layers && this.scene.layers.destroy();
    const s = this.assets.list();
    for (let i = 0; i < s.length; i++)
      s[i].unload(), s[i].off();
    this.assets.off(), this.bundles.destroy(), this.bundles = null, this.i18n.destroy(), this.i18n = null;
    for (const i in this.loader.getHandler("script")._cache) {
      const n = this.loader.getHandler("script")._cache[i], a = n.parentNode;
      a && a.removeChild(n);
    }
    this.loader.getHandler("script")._cache = {}, this.loader.destroy(), this.loader = null, this.scene.destroy(), this.scene = null, this.systems = null, this.context = null, this.scripts.destroy(), this.scripts = null, this.scenes.destroy(), this.scenes = null, (e = this.lightmapper) == null || e.destroy(), this.lightmapper = null, this._batcher && (this._batcher.destroy(), this._batcher = null), this._entityIndex = {}, this.defaultLayerDepth.onPreRenderOpaque = null, this.defaultLayerDepth.onPostRenderOpaque = null, this.defaultLayerDepth.onDisable = null, this.defaultLayerDepth.onEnable = null, this.defaultLayerDepth = null, this.defaultLayerWorld = null, this == null || this.xr.end(), this == null || this.xr.destroy(), this.renderer.destroy(), this.renderer = null, this.graphicsDevice.destroy(), this.graphicsDevice = null, this.tick = null, this.off(), this._soundManager && (this._soundManager.destroy(), this._soundManager = null), fs.app = null, Pr._applications[t] = null, qi() === this && Od(null);
  }
  getEntityFromIndex(e) {
    return this._entityIndex[e];
  }
  _registerSceneImmediate(e) {
    this.on("postrender", e.immediate.onPostRender, e.immediate);
  }
}
Pr._applications = {};
const Oc = {}, $A = function(e) {
  const t = e;
  let s;
  return function(i, n) {
    var a;
    if (!t.graphicsDevice)
      return;
    Od(t), s && (window.cancelAnimationFrame(s), s = null);
    const o = t._processTimestamp(i) || Xi(), h = o - (t._time || o);
    let l = h / 1e3;
    if (l = U.clamp(l, 0, t.maxDeltaTime), l *= t.timeScale, t._time = o, (a = t.xr) != null && a.session ? s = t.xr.session.requestAnimationFrame(t.tick) : s = lt.browser ? window.requestAnimationFrame(t.tick) : null, t.graphicsDevice.contextLost)
      return;
    t._fillFrameStatsBasic(o, l, h), t._inFrameUpdate = !0, t.fire("frameupdate", h);
    let c = !0;
    if (n) {
      var d;
      c = (d = t.xr) == null ? void 0 : d.update(n), t.graphicsDevice.defaultFramebuffer = n.session.renderState.baseLayer.framebuffer;
    } else
      t.graphicsDevice.defaultFramebuffer = null;
    c && (t.update(l), t.fire("framerender"), (t.autoRender || t.renderNextFrame) && (t.updateCanvasSize(), t.render(), t.renderNextFrame = !1), Oc.timestamp = Xi(), Oc.target = t, t.fire("frameend", Oc)), t._inFrameUpdate = !1, t._destroyRequested && t.destroy();
  };
};
class YA {
  constructor() {
    this.elementInput = void 0, this.keyboard = void 0, this.mouse = void 0, this.touch = void 0, this.gamepads = void 0, this.scriptPrefix = void 0, this.assetPrefix = void 0, this.scriptsOrder = void 0, this.soundManager = void 0, this.graphicsDevice = void 0, this.lightmapper = void 0, this.batchManager = void 0, this.xr = void 0, this.componentSystems = [], this.resourceHandlers = [];
  }
}
const da = new pl();
class Cg {
  constructor(e, t) {
    this.scene = e, this.light = t, this.store(), t.numCascades = 1, t.type !== de && (t._node.getWorldTransform(), t.getBoundingSphere(da), this.lightBounds = new Pe(), this.lightBounds.center.copy(da.center), this.lightBounds.halfExtents.set(da.radius, da.radius, da.radius));
  }
  store() {
    this.mask = this.light.mask, this.shadowUpdateMode = this.light.shadowUpdateMode, this.enabled = this.light.enabled, this.intensity = this.light.intensity, this.rotation = this.light._node.getLocalRotation().clone(), this.numCascades = this.light.numCascades;
  }
  restore() {
    const e = this.light;
    e.mask = this.mask, e.shadowUpdateMode = this.shadowUpdateMode, e.enabled = this.enabled, e.intensity = this.intensity, e._node.setLocalRotation(this.rotation), e.numCascades = this.numCascades;
  }
  startBake() {
    this.light.enabled = !0, this.light._destroyShadowMap(), this.light.beginFrame();
  }
  endBake(e) {
    const t = this.light;
    t.enabled = !1, t.shadowMap && (t.shadowMap.cached && e.add(t, t.shadowMap), t.shadowMap = null);
  }
}
const Go = new q();
class KA extends Cg {
  get numVirtualLights() {
    return this.light.type === de ? this.light.bakeNumSamples : 1;
  }
  prepareVirtualLight(e, t) {
    const s = this.light;
    if (s._node.setLocalRotation(this.rotation), e > 0) {
      const a = s.bakeArea;
      ao.circlePointDeterministic(Go, e, t), Go.mulScalar(a * 0.5), s._node.rotateLocal(Go.x, 0, Go.y);
    }
    s._node.getWorldTransform();
    const i = this.scene.gammaCorrection ? 2.2 : 1, n = Math.pow(this.intensity, i);
    s.intensity = Math.pow(n / t, 1 / i);
  }
}
const $m = new v();
class Ym extends Cg {
  constructor(e) {
    const t = new oe("AmbientLight");
    t.addComponent("light", {
      type: "directional",
      affectDynamic: !0,
      affectLightmapped: !1,
      bake: !0,
      bakeNumSamples: e.ambientBakeNumSamples,
      castShadows: !0,
      normalOffsetBias: 0.05,
      shadowBias: 0.2,
      shadowDistance: 1,
      shadowResolution: 2048,
      shadowType: gt,
      color: z.WHITE,
      intensity: 1,
      bakeDir: !1
    }), super(e, t.light.light);
  }
  get numVirtualLights() {
    return this.light.bakeNumSamples;
  }
  prepareVirtualLight(e, t) {
    ao.spherePointDeterministic($m, e, t, 0, this.scene.ambientBakeSpherePart), this.light._node.lookAt($m.mulScalar(-1)), this.light._node.rotateLocal(90, 0, 0);
    const s = this.scene.gammaCorrection ? 2.2 : 1, i = 2 * Math.PI * this.scene.ambientBakeSpherePart, n = Math.pow(i, s);
    this.light.intensity = Math.pow(n / t, 1 / s);
  }
}
class Ho {
  constructor(e, t = null) {
    this.node = e, this.component = e.render || e.model, t = t || this.component.meshInstances, this.store(), this.meshInstances = t, this.bounds = null, this.renderTargets = [];
  }
  store() {
    this.castShadows = this.component.castShadows;
  }
  restore() {
    this.component.castShadows = this.castShadows;
  }
}
const Km = 15;
class ZA {
  constructor(e) {
    this.device = e, this.shaderDilate = ps(e, N.fullscreenQuadVS, el.dilatePS, "lmDilate"), this.constantTexSource = e.scope.resolve("source"), this.constantPixelOffset = e.scope.resolve("pixelOffset"), this.pixelOffset = new Float32Array(2), this.shaderDenoise = null, this.sigmas = null, this.constantSigmas = null, this.kernel = null;
  }
  setSourceTexture(e) {
    this.constantTexSource.setValue(e);
  }
  prepare(e, t) {
    this.pixelOffset[0] = 1 / e, this.pixelOffset[1] = 1 / t, this.constantPixelOffset.setValue(this.pixelOffset);
  }
  prepareDenoise(e, t) {
    this.shaderDenoise || (this.shaderDenoise = ps(this.device, N.fullscreenQuadVS, el.bilateralDeNoisePS, "lmBilateralDeNoise"), this.sigmas = new Float32Array(2), this.constantSigmas = this.device.scope.resolve("sigmas"), this.constantKernel = this.device.scope.resolve("kernel[0]"), this.bZnorm = this.device.scope.resolve("bZnorm")), this.sigmas[0] = e, this.sigmas[1] = t, this.constantSigmas.setValue(this.sigmas), this.evaluateDenoiseUniforms(e, t);
  }
  evaluateDenoiseUniforms(e, t) {
    function s(o, h) {
      return 0.39894 * Math.exp(-0.5 * o * o / (h * h)) / h;
    }
    this.kernel = this.kernel || new Float32Array(Km);
    const i = this.kernel, n = Math.floor((Km - 1) / 2);
    for (let o = 0; o <= n; ++o) {
      const h = s(o, e);
      i[n + o] = h, i[n - o] = h;
    }
    this.constantKernel.setValue(this.kernel);
    const a = 1 / s(0, t);
    this.bZnorm.setValue(a);
  }
}
const JA = 2048, QA = 0, e1 = 1, Wo = new v();
class t1 {
  constructor(e, t, s, i, n) {
    this.device = e, this.root = t, this.scene = s, this.renderer = i, this.assets = n, this.shadowMapCache = i.shadowMapCache, this._tempSet = /* @__PURE__ */ new Set(), this._initCalled = !1, this.passMaterials = [], this.ambientAOMaterial = null, this.fog = "", this.ambientLight = new z(), this.renderTargets = /* @__PURE__ */ new Map(), this.stats = {
      renderPasses: 0,
      lightmapCount: 0,
      totalRenderTime: 0,
      forwardTime: 0,
      fboTime: 0,
      shadowMapTime: 0,
      compileTime: 0,
      shadersLinked: 0
    };
  }
  destroy() {
    ai.decRef(this.blackTex), this.blackTex = null, ai.destroy(), this.device = null, this.root = null, this.scene = null, this.renderer = null, this.assets = null;
  }
  initBake(e) {
    if (!this._initCalled) {
      this._initCalled = !0, this.lightmapFilters = new ZA(e), this.constantBakeDir = e.scope.resolve("bakeDir"), this.materials = [], this.blackTex = new ue(this.device, {
        width: 4,
        height: 4,
        format: ye,
        type: _i,
        name: "lightmapBlack"
      }), ai.incRef(this.blackTex);
      const t = new ro();
      t.clearColor.set(0, 0, 0, 0), t.clearColorBuffer = !0, t.clearDepthBuffer = !1, t.clearStencilBuffer = !1, t.frustumCulling = !1, t.projection = Mr, t.aspectRatio = 1, t.node = new bt(), this.camera = t;
    }
    if (this.scene.clusteredLightingEnabled) {
      const t = new pg(e.supportsAreaLights, e.maxTextureSize, () => {
      });
      this.lightingParams = t;
      const s = this.scene.lighting;
      t.shadowsEnabled = s.shadowsEnabled, t.shadowAtlasResolution = s.shadowAtlasResolution, t.cookiesEnabled = s.cookiesEnabled, t.cookieAtlasResolution = s.cookieAtlasResolution, t.areaLightsEnabled = s.areaLightsEnabled, t.cells = new v(3, 3, 3), t.maxLightsPerCell = 4, this.worldClusters = new Pd(e), this.worldClusters.name = "ClusterLightmapper";
    }
  }
  finishBake(e) {
    this.materials = [];
    function t(s) {
      ai.decRef(s.colorBuffer), s.destroy();
    }
    this.renderTargets.forEach((s) => {
      t(s);
    }), this.renderTargets.clear(), e.forEach((s) => {
      s.renderTargets.forEach((i) => {
        t(i);
      }), s.renderTargets.length = 0;
    }), this.ambientAOMaterial = null, this.worldClusters && (this.worldClusters.destroy(), this.worldClusters = null);
  }
  createMaterialForPass(e, t, s, i) {
    const n = new Ht();
    if (n.name = `lmMaterial-pass:${s}-ambient:${i}`, n.chunks.APIVersion = sx, n.chunks.transformVS = `#define UV1LAYOUT
` + N.transformVS, s === QA) {
      let a = el.bakeLmEndPS;
      i ? a = `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${t.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${t.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + a : (n.ambient = new z(0, 0, 0), n.ambientTint = !0), n.chunks.basePS = N.basePS + (t.lightmapPixelFormat === ye ? `
#define LIGHTMAP_RGBM
` : ""), n.chunks.endPS = a, n.lightMap = this.blackTex;
    } else
      n.chunks.basePS = N.basePS + `
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`, n.chunks.endPS = el.bakeDirLmEndPS;
    return n.chunks.outputAlphaPS = `
`, n.chunks.outputAlphaOpaquePS = `
`, n.chunks.outputAlphaPremulPS = `
`, n.cull = Ft, n.forceUv1 = !0, n.update(), n;
  }
  createMaterials(e, t, s) {
    for (let i = 0; i < s; i++)
      this.passMaterials[i] || (this.passMaterials[i] = this.createMaterialForPass(e, t, i, !1));
    this.ambientAOMaterial || (this.ambientAOMaterial = this.createMaterialForPass(e, t, 0, !0), this.ambientAOMaterial.onUpdateShader = function(i) {
      return i.litOptions.lightMapWithoutAmbient = !0, i.litOptions.separateAmbient = !0, i;
    });
  }
  createTexture(e, t) {
    return new ue(this.device, {
      width: e,
      height: e,
      format: this.scene.lightmapPixelFormat,
      mipmaps: !1,
      type: this.scene.lightmapPixelFormat === ye ? _i : Rs,
      minFilter: Be,
      magFilter: Be,
      addressU: he,
      addressV: he,
      name: t
    });
  }
  collectModels(e, t, s) {
    var i, n, a;
    if (!e.enabled)
      return;
    let o;
    if ((i = e.model) != null && i.model && (n = e.model) != null && n.enabled && (s && s.push(new Ho(e)), e.model.lightmapped && t && (o = e.model.model.meshInstances)), (a = e.render) != null && a.enabled && (s && s.push(new Ho(e)), e.render.lightmapped && t && (o = e.render.meshInstances)), o) {
      let h = !0;
      for (let l = 0; l < o.length; l++)
        if (!o[l].mesh.vertexBuffer.format.hasUv1) {
          h = !1;
          break;
        }
      if (h) {
        const l = [];
        for (let c = 0; c < o.length; c++) {
          const d = o[c].mesh;
          this._tempSet.has(d) ? t.push(new Ho(e, [o[c]])) : l.push(o[c]), this._tempSet.add(d);
        }
        this._tempSet.clear(), l.length > 0 && t.push(new Ho(e, l));
      }
    }
    for (let h = 0; h < e._children.length; h++)
      this.collectModels(e._children[h], t, s);
  }
  prepareShadowCasters(e) {
    const t = [];
    for (let s = 0; s < e.length; s++) {
      const i = e[s].component;
      if (i.castShadows = i.castShadowsLightmap, i.castShadowsLightmap) {
        const n = e[s].meshInstances;
        for (let a = 0; a < n.length; a++)
          n[a].visibleThisFrame = !0, t.push(n[a]);
      }
    }
    return t;
  }
  updateTransforms(e) {
    for (let t = 0; t < e.length; t++) {
      const s = e[t].meshInstances;
      for (let i = 0; i < s.length; i++)
        s[i].node.getWorldTransform();
    }
  }
  calculateLightmapSize(e) {
    let t;
    const s = this.scene.lightmapSizeMultiplier || 16, i = Wo;
    let n, a;
    e.model ? (a = e.model.lightmapSizeMultiplier, e.model.asset ? (t = this.assets.get(e.model.asset).data, t.area && (n = t.area)) : e.model._area && (t = e.model, t._area && (n = t._area))) : e.render && (a = e.render.lightmapSizeMultiplier, e.render.type !== "asset" && e.render._area && (t = e.render, t._area && (n = t._area)));
    const o = {
      x: 1,
      y: 1,
      z: 1,
      uv: 1
    };
    n && (o.x = n.x, o.y = n.y, o.z = n.z, o.uv = n.uv);
    const h = a || 1;
    o.x *= h, o.y *= h, o.z *= h;
    const l = e.render || e.model, c = this.computeNodeBounds(l.meshInstances);
    i.copy(c.halfExtents);
    let d = o.x * i.y * i.z + o.y * i.x * i.z + o.z * i.x * i.y;
    return d /= o.uv, d = Math.sqrt(d), Math.min(U.nextPowerOfTwo(d * s), this.scene.lightmapMaxResolution || JA);
  }
  setLightmapping(e, t, s, i) {
    for (let n = 0; n < e.length; n++) {
      const a = e[n], o = a.meshInstances;
      for (let h = 0; h < o.length; h++) {
        const l = o[h];
        if (l.setLightmapped(t), t) {
          i && (l._shaderDefs |= i), l.mask = di;
          for (let c = 0; c < s; c++) {
            const d = a.renderTargets[c].colorBuffer;
            d.minFilter = rt, d.magFilter = rt, l.setRealtimeLightmap(we.lightmapParamNames[c], d);
          }
        }
      }
    }
  }
  bake(e, t = mh) {
    const s = this.device, i = Xi();
    this.scene._updateSky(s), this.stats.renderPasses = 0, this.stats.shadowMapTime = 0, this.stats.forwardTime = 0;
    const n = s._shaderStats.linked, a = s._renderTargetCreationTime, o = s._shaderStats.compileTime, h = [], l = [];
    if (e) {
      for (let d = 0; d < e.length; d++)
        this.collectModels(e[d], h, null);
      this.collectModels(this.root, null, l);
    } else
      this.collectModels(this.root, h, l);
    if (h.length > 0) {
      const d = t === mh ? 2 : 1;
      this.setLightmapping(h, !1, d), this.initBake(s), this.bakeInternal(d, h, l);
      let u = Wh;
      t === mh && (u |= Bu), this.scene.ambientBake && (u |= Fu), this.setLightmapping(h, !0, d, u), this.finishBake(h);
    }
    const c = Xi();
    this.stats.totalRenderTime = c - i, this.stats.shadersLinked = s._shaderStats.linked - n, this.stats.compileTime = s._shaderStats.compileTime - o, this.stats.fboTime = s._renderTargetCreationTime - a, this.stats.lightmapCount = h.length;
  }
  allocateTextures(e, t) {
    for (let s = 0; s < e.length; s++) {
      const i = e[s], n = this.calculateLightmapSize(i.node);
      for (let a = 0; a < t; a++) {
        const o = this.createTexture(n, "lightmapper_lightmap_" + s);
        ai.incRef(o), i.renderTargets[a] = new Dt({
          colorBuffer: o,
          depth: !1
        });
      }
      if (!this.renderTargets.has(n)) {
        const a = this.createTexture(n, "lightmapper_temp_lightmap_" + n);
        ai.incRef(a), this.renderTargets.set(n, new Dt({
          colorBuffer: a,
          depth: !1
        }));
      }
    }
  }
  prepareLightsToBake(e, t, s) {
    if (this.scene.ambientBake) {
      const n = new Ym(this.scene);
      s.push(n);
    }
    const i = e._lights;
    for (let n = 0; n < i.length; n++) {
      const a = i[n], o = new KA(this.scene, a);
      t.push(o), a.enabled && a.mask & ui && (a.isStatic = !1, a.mask = 4294967295, a.shadowUpdateMode = a.type === de ? Ou : Gr, s.push(o));
    }
    s.sort();
  }
  restoreLights(e) {
    for (let t = 0; t < e.length; t++)
      e[t].restore();
  }
  setupScene() {
    this.revertStatic = !1, this.scene._needsStaticPrepare && (this.scene._needsStaticPrepare = !1, this.revertStatic = !0), this.fog = this.scene.fog, this.ambientLight.copy(this.scene.ambientLight), this.scene.fog = Hl, this.scene.ambientBake || this.scene.ambientLight.set(0, 0, 0), this.renderer.setSceneConstants();
  }
  restoreScene() {
    this.scene.fog = this.fog, this.scene.ambientLight.copy(this.ambientLight), this.revertStatic && (this.scene._needsStaticPrepare = !0);
  }
  computeNodeBounds(e) {
    const t = new Pe();
    if (e.length > 0) {
      t.copy(e[0].aabb);
      for (let s = 1; s < e.length; s++)
        t.add(e[s].aabb);
    }
    return t;
  }
  computeNodesBounds(e) {
    for (let t = 0; t < e.length; t++) {
      const s = e[t].meshInstances;
      e[t].bounds = this.computeNodeBounds(s);
    }
  }
  computeBounds(e) {
    const t = new Pe();
    for (let s = 0; s < e.length; s++) {
      t.copy(e[0].aabb);
      for (let i = 1; i < e.length; i++)
        t.add(e[i].aabb);
    }
    return t;
  }
  backupMaterials(e) {
    for (let t = 0; t < e.length; t++)
      this.materials[t] = e[t].material;
  }
  restoreMaterials(e) {
    for (let t = 0; t < e.length; t++)
      e[t].material = this.materials[t];
  }
  lightCameraPrepare(e, t) {
    const s = t.light;
    let i;
    return s.type === Ee && (i = s.getRenderData(null, 0).shadowCamera, i._node.setPosition(s._node.getPosition()), i._node.setRotation(s._node.getRotation()), i._node.rotateLocal(-90, 0, 0), i.projection = Bs, i.nearClip = s.attenuationEnd / 1e3, i.farClip = s.attenuationEnd, i.aspectRatio = 1, i.fov = s._outerConeAngle * 2, this.renderer.updateCameraFrustum(i)), i;
  }
  lightCameraPrepareAndCull(e, t, s, i) {
    const n = e.light;
    let a = !0;
    if (n.type === de) {
      Wo.copy(i.center), Wo.y += i.halfExtents.y, this.camera.node.setPosition(Wo), this.camera.node.setEulerAngles(-90, 0, 0), this.camera.nearClip = 0, this.camera.farClip = i.halfExtents.y * 2;
      const o = Math.max(i.halfExtents.x, i.halfExtents.z);
      this.camera.orthoHeight = o;
    } else
      e.lightBounds.intersects(t.bounds) || (a = !1);
    if (n.type === Ee) {
      let o = !1;
      const h = t.meshInstances;
      for (let l = 0; l < h.length; l++)
        if (h[l]._isVisible(s)) {
          o = !0;
          break;
        }
      o || (a = !1);
    }
    return a;
  }
  setupLightArray(e, t) {
    e[de].length = 0, e[Se].length = 0, e[Ee].length = 0, e[t.type][0] = t, t.visibleThisFrame = !0;
  }
  renderShadowMap(e, t, s, i) {
    const n = i.light;
    return !e && n.castShadows && (!n.shadowMap && !this.scene.clusteredLightingEnabled && (n.shadowMap = this.shadowMapCache.get(this.device, n)), n.type === de ? (this.renderer._shadowRendererDirectional.cull(n, t, this.camera), this.renderer.shadowRenderer.render(n, this.camera)) : (this.renderer._shadowRendererLocal.cull(n, t), this.renderer.renderShadowsLocal(s[n.type], this.camera))), !0;
  }
  postprocessTextures(e, t, s) {
    const n = this.lightmapFilters.shaderDilate, a = this.scene.lightmapFilterEnabled;
    a && this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);
    for (let o = 0; o < t.length; o++) {
      const h = t[o];
      for (let l = 0; l < s; l++) {
        const c = h.renderTargets[l], d = c.colorBuffer, u = this.renderTargets.get(d.width), f = u.colorBuffer;
        this.lightmapFilters.prepare(d.width, d.height);
        for (let m = 0; m < 1; m++)
          this.lightmapFilters.setSourceTexture(d), Yi(e, u, a && l === 0 && m === 0 ? this.lightmapFilters.shaderDenoise : n), this.lightmapFilters.setSourceTexture(f), Yi(e, c, n);
      }
    }
  }
  bakeInternal(e, t, s) {
    const i = this.scene, n = this.device, a = i.clusteredLightingEnabled;
    this.createMaterials(n, i, e), this.setupScene(), i.layers._update(), this.computeNodesBounds(t), this.allocateTextures(t, e);
    const o = [], h = [];
    this.prepareLightsToBake(i.layers, o, h), this.updateTransforms(s);
    const l = this.prepareShadowCasters(s);
    this.renderer.updateCpuSkinMatrices(l), this.renderer.gpuUpdate(l);
    const c = this.computeBounds(l);
    let d, u, f, m;
    for (d = 0; d < t.length; d++)
      for (f = t[d].meshInstances, u = 0; u < f.length; u++)
        m = f[u], m.setLightmapped(!1), m.mask = ui, m.setRealtimeLightmap(we.lightmapParamNames[0], m.material.lightMap ? m.material.lightMap : this.blackTex), m.setRealtimeLightmap(we.lightmapParamNames[1], this.blackTex);
    for (u = 0; u < h.length; u++)
      h[u].light.enabled = !1;
    const _ = [[], [], []];
    let p, g, b = !1;
    for (d = 0; d < h.length; d++) {
      const x = h[d], y = x instanceof Ym;
      let S = x.numVirtualLights;
      e > 1 && S > 1 && x.light.bakeDir && (S = 1);
      for (let C = 0; C < S; C++) {
        S > 1 && x.prepareVirtualLight(C, S), x.startBake();
        let w = !1;
        const M = this.lightCameraPrepare(n, x);
        for (g = 0; g < t.length; g++) {
          const T = t[g];
          if (f = T.meshInstances, !!this.lightCameraPrepareAndCull(x, T, M, c)) {
            if (this.setupLightArray(_, x.light), a && this.renderer.lightTextureAtlas.update(_[Ee], _[Se], this.lightingParams), w = this.renderShadowMap(w, l, _, x), a) {
              const L = _[Ee].concat(_[Se]);
              this.worldClusters.update(L, this.scene.gammaCorrection, this.lightingParams);
            }
            for (this.backupMaterials(f), p = 0; p < e && !(p > 0 && C > 0 || y && p > 0); p++) {
              const L = T.renderTargets[p], O = T.renderTargets[p].colorBuffer.width, I = this.renderTargets.get(O), D = I.colorBuffer;
              p === 0 ? b = i.updateShaders : b && (i.updateShaders = !0);
              let G = this.passMaterials[p];
              for (y && C + 1 === S && p === 0 && (G = this.ambientAOMaterial), u = 0; u < f.length; u++)
                f[u].material = G;
              for (this.renderer.updateShaders(f), this.renderer.setCamera(this.camera, I, !0), p === e1 && this.constantBakeDir.setValue(x.light.bakeDir ? 1 : 0), a && this.worldClusters.activate(this.renderer.lightTextureAtlas), this.renderer._forwardTime = 0, this.renderer._shadowMapTime = 0, this.renderer.renderForward(this.camera, f, f.length, _, fi), n.updateEnd(), T.renderTargets[p] = I, this.renderTargets.set(O, L), u = 0; u < f.length; u++)
                m = f[u], m.setRealtimeLightmap(we.lightmapParamNames[p], D), m._shaderDefs |= Wh;
            }
            this.restoreMaterials(f);
          }
        }
        x.endBake(this.shadowMapCache);
      }
    }
    for (this.postprocessTextures(n, t, e), g = 0; g < s.length; g++)
      s[g].restore();
    this.restoreLights(o), this.restoreScene(), a || this.shadowMapCache.clear();
  }
}
class le extends _e {
  constructor(e, t) {
    super(), this.system = void 0, this.entity = void 0, this.system = e, this.entity = t, this.system.schema && !this._accessorsBuilt && this.buildAccessors(this.system.schema), this.on("set", function(s, i, n) {
      this.fire("set_" + s, s, i, n);
    }), this.on("set_enabled", this.onSetEnabled, this);
  }
  static _buildAccessors(e, t) {
    t.forEach(function(s) {
      const i = typeof s == "object" ? s.name : s;
      Object.defineProperty(e, i, {
        get: function() {
          return this.data[i];
        },
        set: function(n) {
          const a = this.data, o = a[i];
          a[i] = n, this.fire("set", i, o, n);
        },
        configurable: !0
      });
    }), e._accessorsBuilt = !0;
  }
  buildAccessors(e) {
    le._buildAccessors(this, e);
  }
  onSetEnabled(e, t, s) {
    t !== s && this.entity.enabled && (s ? this.onEnable() : this.onDisable());
  }
  onEnable() {
  }
  onDisable() {
  }
  onPostStateChange() {
  }
  get data() {
    const e = this.system.store[this.entity.getGuid()];
    return e ? e.data : null;
  }
}
class Ye extends _e {
  constructor(e) {
    super(), this.app = e, this.store = {}, this.schema = [];
  }
  addComponent(e, t = {}) {
    const s = new this.ComponentType(this, e), i = new this.DataType();
    return this.store[e.getGuid()] = {
      entity: e,
      data: i
    }, e[this.id] = s, e.c[this.id] = s, this.initializeComponentData(s, t, []), this.fire("add", e, s), s;
  }
  removeComponent(e) {
    const t = this.store[e.getGuid()], s = e.c[this.id];
    this.fire("beforeremove", e, s), delete this.store[e.getGuid()], e[this.id] = void 0, delete e.c[this.id], this.fire("remove", e, t.data);
  }
  cloneComponent(e, t) {
    const s = this.store[e.getGuid()];
    return this.addComponent(t, s.data);
  }
  initializeComponentData(e, t = {}, s) {
    for (let i = 0, n = s.length; i < n; i++) {
      const a = s[i];
      let o, h;
      typeof a == "object" ? (o = a.name, h = a.type) : (o = a, h = void 0);
      let l = t[o];
      l !== void 0 ? (h !== void 0 && (l = s1(l, h)), e[o] = l) : e[o] = e.data[o];
    }
    e.enabled && e.entity.enabled && e.onEnable();
  }
  getPropertiesOfType(e) {
    const t = [];
    return (this.schema || []).forEach(function(i) {
      i && typeof i == "object" && i.type === e && t.push(i);
    }), t;
  }
  destroy() {
    this.off();
  }
}
function s1(r, e) {
  if (!r)
    return r;
  switch (e) {
    case "rgb":
      return r instanceof z ? r.clone() : new z(r[0], r[1], r[2]);
    case "rgba":
      return r instanceof z ? r.clone() : new z(r[0], r[1], r[2], r[3]);
    case "vec2":
      return r instanceof q ? r.clone() : new q(r[0], r[1]);
    case "vec3":
      return r instanceof v ? r.clone() : new v(r[0], r[1], r[2]);
    case "vec4":
      return r instanceof Z ? r.clone() : new Z(r[0], r[1], r[2], r[3]);
    case "boolean":
    case "number":
    case "string":
      return r;
    case "entity":
      return r;
    default:
      throw new Error("Could not convert unhandled type: " + e);
  }
}
const Ag = 0, kd = 1, Nd = 2;
class i1 {
  constructor() {
    this._left = 1 / 0, this._right = -1 / 0, this._len = 0, this._recip = 0, this._p0 = 0, this._p1 = 0, this._t = 0, this._hermite = {
      valid: !1,
      p0: 0,
      m0: 0,
      p1: 0,
      m1: 0
    };
  }
  update(e, t) {
    if (e < this._left || e >= this._right) {
      const s = t.length;
      if (!s)
        this._left = -1 / 0, this._right = 1 / 0, this._len = 0, this._recip = 0, this._p0 = this._p1 = 0;
      else if (e < t[0])
        this._left = -1 / 0, this._right = t[0], this._len = 0, this._recip = 0, this._p0 = this._p1 = 0;
      else if (e >= t[s - 1])
        this._left = t[s - 1], this._right = 1 / 0, this._len = 0, this._recip = 0, this._p0 = this._p1 = s - 1;
      else {
        const i = this._findKey(e, t);
        this._left = t[i], this._right = t[i + 1], this._len = this._right - this._left;
        const n = 1 / this._len;
        this._recip = isFinite(n) ? n : 0, this._p0 = i, this._p1 = i + 1;
      }
    }
    this._t = this._recip === 0 ? 0 : (e - this._left) * this._recip, this._hermite.valid = !1;
  }
  _findKey(e, t) {
    let s = 0;
    for (; e >= t[s + 1]; )
      s++;
    return s;
  }
  eval(e, t, s) {
    const i = s._data, n = s._components, a = this._p0 * n;
    if (t === Ag)
      for (let o = 0; o < n; ++o)
        e[o] = i[a + o];
    else {
      const o = this._t, h = this._p1 * n;
      switch (t) {
        case kd:
          for (let l = 0; l < n; ++l)
            e[l] = U.lerp(i[a + l], i[h + l], o);
          break;
        case Nd: {
          const l = this._hermite;
          if (!l.valid) {
            const m = o * o, _ = o + o, p = 1 - o, g = p * p;
            l.valid = !0, l.p0 = (1 + _) * g, l.m0 = o * g, l.p1 = m * (3 - _), l.m1 = m * (o - 1);
          }
          const c = (this._p0 * 3 + 1) * n, d = (this._p0 * 3 + 2) * n, u = (this._p1 * 3 + 1) * n, f = (this._p1 * 3 + 0) * n;
          for (let m = 0; m < n; ++m)
            e[m] = l.p0 * i[c + m] + l.m0 * i[d + m] * this._len + l.p1 * i[u + m] + l.m1 * i[f + m] * this._len;
          break;
        }
      }
    }
  }
}
class n1 {
  constructor(e) {
    this._name = e.name + "Snapshot", this._time = -1, this._cache = [], this._results = [];
    for (let i = 0; i < e._inputs.length; ++i)
      this._cache[i] = new i1();
    const t = e._curves, s = e._outputs;
    for (let i = 0; i < t.length; ++i) {
      const n = t[i], a = s[n._output], o = [];
      for (let h = 0; h < a._components; ++h)
        o[h] = 0;
      this._results[i] = o;
    }
  }
}
class Mg {
  constructor(e, t, s, i, n, a) {
    this._name = e.name, this._track = e, this._snapshot = new n1(e), this._playing = i, this._time = t, this._speed = s, this._loop = n, this._blendWeight = 1, this._blendOrder = 0, this._eventHandler = a, this.alignCursorToCurrentTime();
  }
  set name(e) {
    this._name = e;
  }
  get name() {
    return this._name;
  }
  get track() {
    return this._track;
  }
  get snapshot() {
    return this._snapshot;
  }
  set time(e) {
    this._time = e, this.alignCursorToCurrentTime();
  }
  get time() {
    return this._time;
  }
  set speed(e) {
    this._speed = e;
  }
  get speed() {
    return this._speed;
  }
  set loop(e) {
    this._loop = e;
  }
  get loop() {
    return this._loop;
  }
  set blendWeight(e) {
    this._blendWeight = e;
  }
  get blendWeight() {
    return this._blendWeight;
  }
  set blendOrder(e) {
    this._blendOrder = e;
  }
  get blendOrder() {
    return this._blendOrder;
  }
  set eventCursor(e) {
    this._eventCursor = e;
  }
  get eventCursor() {
    return this._eventCursor;
  }
  alignCursorToCurrentTime() {
    for (this._eventCursor = 0; this._track.events[this._eventCursor] && this._track.events[this._eventCursor].time < this.time; )
      this._eventCursor++;
  }
  activeEventsForFrame(e, t) {
    e === 0 && (this.eventCursor = 0);
    let s;
    for (t > this.track.duration && (s = t - this.track.duration, t = this.track.duration); this.track.events[this.eventCursor] && this.track.events[this.eventCursor].time >= e && (t === this.track.duration ? this.track.events[this.eventCursor].time <= t : this.track.events[this.eventCursor].time < t); ) {
      const i = this.track.events[this.eventCursor];
      this._eventHandler.fire(i.name, On({
        track: this.track
      }, i)), this.eventCursor++;
    }
    Number.isFinite(s) && this.activeEventsForFrame(0, s);
  }
  progressForTime(e) {
    return e * this._speed / this._track.duration;
  }
  _update(e) {
    if (this._playing) {
      let t = this._time;
      const s = this._track.duration, i = this._speed, n = this._loop;
      this._track.events.length > 0 && s > 0 && this.activeEventsForFrame(t, t + i * e), t += i * e, i >= 0 ? t > s && (n ? t = t % s || 0 : (t = this._track.duration, this.pause())) : t < 0 && (n ? t = s + (t % s || 0) : (t = 0, this.pause())), this._time = t;
    }
    this._time !== this._snapshot._time && this._track.eval(this._time, this._snapshot);
  }
  play() {
    this._playing = !0, this._time = 0;
  }
  stop() {
    this._playing = !1, this._time = 0;
  }
  pause() {
    this._playing = !1;
  }
  resume() {
    this._playing = !0;
  }
  reset() {
    this._time = 0;
  }
}
const Eg = "NONE", r1 = "PREV_STATE", a1 = "NEXT_STATE", o1 = "PREV_STATE_NEXT_STATE", h1 = "NEXT_STATE_PREV_STATE", l1 = "GREATER_THAN", c1 = "LESS_THAN", d1 = "GREATER_THAN_EQUAL_TO", u1 = "LESS_THAN_EQUAL_TO", f1 = "EQUAL_TO", m1 = "NOT_EQUAL_TO", Zm = "INTEGER", Jm = "FLOAT", Qm = "BOOLEAN", gh = "TRIGGER", p1 = "1D", _1 = "2D_DIRECTIONAL", g1 = "2D_CARTESIAN", y1 = "DIRECT", pr = "START", yh = "END", gn = "ANY", rl = [pr, yh, gn], Rg = "OVERWRITE", x1 = "ADDITIVE";
class Lt {
  static dot(e, t) {
    const s = e.length;
    let i = 0;
    for (let n = 0; n < s; ++n)
      i += e[n] * t[n];
    return i;
  }
  static normalize(e) {
    let t = Lt.dot(e, e);
    if (t > 0) {
      t = 1 / Math.sqrt(t);
      const s = e.length;
      for (let i = 0; i < s; ++i)
        e[i] *= t;
    }
  }
  static set(e, t, s) {
    const i = e.length;
    if (s === "quaternion") {
      let n = Lt.dot(t, t);
      n > 0 && (n = 1 / Math.sqrt(n));
      for (let a = 0; a < i; ++a)
        e[a] = t[a] * n;
    } else
      for (let n = 0; n < i; ++n)
        e[n] = t[n];
  }
  static blendVec(e, t, s, i) {
    const n = i ? 1 : 1 - s, a = e.length;
    for (let o = 0; o < a; ++o)
      e[o] = e[o] * n + t[o] * s;
  }
  static blendQuat(e, t, s, i) {
    const n = e.length, a = i ? 1 : 1 - s;
    Lt.dot(e, t) < 0 && (s = -s);
    for (let o = 0; o < n; ++o)
      e[o] = e[o] * a + t[o] * s;
    i || Lt.normalize(e);
  }
  static blend(e, t, s, i, n) {
    i === "quaternion" ? Lt.blendQuat(e, t, s, n) : Lt.blendVec(e, t, s, n);
  }
  static stableSort(e, t) {
    const s = e.length;
    for (let i = 0; i < s - 1; ++i)
      for (let n = i + 1; n < s; ++n)
        if (t(e[n], e[i])) {
          const a = e[i];
          e[i] = e[n], e[n] = a;
        }
  }
}
class Ve {
  constructor(e, t) {
    this._component = e, this.mask = new Int8Array(e.layers.length), this.weights = new Float32Array(e.layers.length), this.totalWeight = 0, this.counter = 0, this.layerCounter = 0, this.valueType = t, this.dirty = !0, this.value = t === Ve.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0], this.baseValue = null, this.setter = null;
  }
  get _normalizeWeights() {
    return this._component.normalizeWeights;
  }
  getWeight(e) {
    return this.dirty && this.updateWeights(), this._normalizeWeights && this.totalWeight === 0 || !this.mask[e] ? 0 : this._normalizeWeights ? this.weights[e] / this.totalWeight : U.clamp(this.weights[e], 0, 1);
  }
  _layerBlendType(e) {
    return this._component.layers[e].blendType;
  }
  setMask(e, t) {
    this.mask[e] = t, this._normalizeWeights && (this._component.layers[e].blendType === Rg && (this.mask = this.mask.fill(0, 0, e)), this.dirty = !0);
  }
  updateWeights() {
    this.totalWeight = 0;
    for (let e = 0; e < this.weights.length; e++)
      this.weights[e] = this._component.layers[e].weight, this.totalWeight += this.mask[e] * this.weights[e];
    this.dirty = !1;
  }
  updateValue(e, t) {
    if (this.counter === 0 && (Lt.set(this.value, Ve.IDENTITY_QUAT_ARR, this.valueType), this._normalizeWeights || Lt.blend(this.value, this.baseValue, 1, this.valueType)), !(!this.mask[e] || this.getWeight(e) === 0)) {
      if (this._layerBlendType(e) === x1 && !this._normalizeWeights)
        if (this.valueType === Ve.TYPE_QUAT) {
          const s = Ve.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]), i = Ve.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]), n = Ve.q3.set(t[0], t[1], t[2], t[3]), a = i.invert().mul(n);
          a.slerp(ee.IDENTITY, a, this.getWeight(e)), s.mul(a), Ve.quatArr[0] = s.x, Ve.quatArr[1] = s.y, Ve.quatArr[2] = s.z, Ve.quatArr[3] = s.w, Lt.set(this.value, Ve.quatArr, this.valueType);
        } else
          Ve.vecArr[0] = t[0] - this.baseValue[0], Ve.vecArr[1] = t[1] - this.baseValue[1], Ve.vecArr[2] = t[2] - this.baseValue[2], Lt.blend(this.value, Ve.vecArr, this.getWeight(e), this.valueType, !0);
      else
        Lt.blend(this.value, t, this.getWeight(e), this.valueType);
      this.setter && this.setter(this.value);
    }
  }
  unbind() {
    this.setter && this.setter(this.baseValue);
  }
}
Ve.TYPE_QUAT = "quaternion";
Ve.TYPE_VEC3 = "vector3";
Ve.q1 = new ee();
Ve.q2 = new ee();
Ve.q3 = new ee();
Ve.quatArr = [0, 0, 0, 1];
Ve.vecArr = [0, 0, 0];
Ve.IDENTITY_QUAT_ARR = [0, 0, 0, 1];
class Lg {
  constructor(e) {
    this._binder = e, this._clips = [], this._inputs = [], this._outputs = [], this._targets = {};
  }
  get clips() {
    return this._clips;
  }
  addClip(e) {
    const t = this._targets, s = this._binder, i = e.track.curves, n = e.snapshot, a = [], o = [];
    for (let h = 0; h < i.length; ++h) {
      const c = i[h].paths;
      for (let d = 0; d < c.length; ++d) {
        const u = c[d], f = s.resolve(u);
        let m = t[f && f.targetPath || null];
        if (!m && f) {
          m = {
            target: f,
            value: [],
            curves: 0,
            blendCounter: 0
          };
          for (let _ = 0; _ < m.target.components; ++_)
            m.value.push(0);
          if (t[f.targetPath] = m, s.animComponent) {
            if (!s.animComponent.targets[f.targetPath]) {
              let _;
              f.targetPath.substring(f.targetPath.length - 13) === "localRotation" ? _ = Ve.TYPE_QUAT : _ = Ve.TYPE_VEC3, s.animComponent.targets[f.targetPath] = new Ve(s.animComponent, _);
            }
            s.animComponent.targets[f.targetPath].layerCounter++, s.animComponent.targets[f.targetPath].setMask(s.layerIndex, 1);
          }
        }
        m && (m.curves++, a.push(n._results[h]), o.push(m));
      }
    }
    this._clips.push(e), this._inputs.push(a), this._outputs.push(o);
  }
  removeClip(e) {
    const t = this._targets, s = this._binder, i = this._clips, a = i[e].track.curves;
    for (let o = 0; o < a.length; ++o) {
      const l = a[o].paths;
      for (let c = 0; c < l.length; ++c) {
        const d = l[c], u = this._binder.resolve(d);
        u && (u.curves--, u.curves === 0 && (s.unresolve(d), delete t[u.targetPath], s.animComponent && s.animComponent.targets[u.targetPath].layerCounter--));
      }
    }
    i.splice(e, 1), this._inputs.splice(e, 1), this._outputs.splice(e, 1);
  }
  removeClips() {
    for (; this._clips.length > 0; )
      this.removeClip(0);
  }
  findClip(e) {
    const t = this._clips;
    for (let s = 0; s < t.length; ++s) {
      const i = t[s];
      if (i.name === e)
        return i;
    }
    return null;
  }
  rebind() {
    this._binder.rebind(), this._targets = {};
    const e = [...this.clips];
    this.removeClips(), e.forEach((t) => {
      this.addClip(t);
    });
  }
  assignMask(e) {
    return this._binder.assignMask(e);
  }
  update(e) {
    const t = this._clips, s = t.map(function(a, o) {
      return o;
    });
    Lt.stableSort(s, function(a, o) {
      return t[a].blendOrder < t[o].blendOrder;
    });
    for (let a = 0; a < s.length; ++a) {
      const o = s[a], h = t[o], l = this._inputs[o], c = this._outputs[o], d = h.blendWeight;
      d > 0 && h._update(e);
      let u, f, m;
      if (d >= 1)
        for (let _ = 0; _ < l.length; ++_)
          u = l[_], f = c[_], m = f.value, Lt.set(m, u, f.target.type), f.blendCounter++;
      else if (d > 0)
        for (let _ = 0; _ < l.length; ++_)
          u = l[_], f = c[_], m = f.value, f.blendCounter === 0 ? Lt.set(m, u, f.target.type) : Lt.blend(m, u, d, f.target.type), f.blendCounter++;
    }
    const i = this._targets, n = this._binder;
    for (const a in i)
      if (i.hasOwnProperty(a)) {
        const o = i[a];
        if (n.animComponent && o.target.isTransform) {
          const h = n.animComponent.targets[a];
          h.counter === h.layerCounter && (h.counter = 0), h.path || (h.path = a, h.baseValue = o.target.get(), h.setter = o.target.set), h.updateValue(n.layerIndex, o.value), h.counter++;
        } else
          o.target.set(o.value);
        o.blendCounter = 0;
      }
    n.update(e);
  }
}
class Pg {
  constructor(e) {
    this._events = [...e], this._events.sort((t, s) => t.time - s.time);
  }
  get events() {
    return this._events;
  }
}
class Yl {
  constructor(e, t, s, i, n, a = new Pg([])) {
    this._name = e, this._duration = t, this._inputs = s, this._outputs = i, this._curves = n, this._animEvents = a;
  }
  get name() {
    return this._name;
  }
  get duration() {
    return this._duration;
  }
  get inputs() {
    return this._inputs;
  }
  get outputs() {
    return this._outputs;
  }
  get curves() {
    return this._curves;
  }
  set events(e) {
    this._animEvents = e;
  }
  get events() {
    return this._animEvents.events;
  }
  eval(e, t) {
    t._time = e;
    const s = this._inputs, i = this._outputs, n = this._curves, a = t._cache, o = t._results;
    for (let h = 0; h < s.length; ++h)
      a[h].update(e, s[h]._data);
    for (let h = 0; h < n.length; ++h) {
      const l = n[h], c = i[l._output], d = o[h];
      a[l._input].eval(d, l._interpolation, c);
    }
  }
}
class Tr {
  static joinPath(e, t) {
    t = t || ".";
    const s = function(n) {
      return n.replace(/\\/g, "\\\\").replace(new RegExp("\\" + t, "g"), "\\" + t);
    };
    return e.map(s).join(t);
  }
  static splitPath(e, t) {
    t = t || ".";
    const s = [];
    let i = "", n = 0;
    for (; n < e.length; ) {
      let a = e[n++];
      a === "\\" && n < e.length ? (a = e[n++], a === "\\" || a === t ? i += a : i += "\\" + a) : a === t ? (s.push(i), i = "") : i += a;
    }
    return i.length > 0 && s.push(i), s;
  }
  static encode(e, t, s) {
    return `${Array.isArray(e) ? e.join("/") : e}/${t}/${Array.isArray(s) ? s.join("/") : s}`;
  }
  resolve(e) {
    return null;
  }
  unresolve(e) {
  }
  update(e) {
  }
}
class zd {
  constructor(e, t, s, i) {
    e.set ? (this._set = e.set, this._get = e.get) : this._set = e, this._type = t, this._components = s, this._targetPath = i, this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === "localRotation" || this._targetPath.substring(this._targetPath.length - 13) === "localPosition" || this._targetPath.substring(this._targetPath.length - 10) === "localScale";
  }
  get set() {
    return this._set;
  }
  get get() {
    return this._get;
  }
  get type() {
    return this._type;
  }
  get components() {
    return this._components;
  }
  get targetPath() {
    return this._targetPath;
  }
  get isTransform() {
    return this._isTransform;
  }
}
class zi {
  constructor(e) {
    if (this._isPathInMask = (n, a) => {
      const o = this._mask[n];
      if (o) {
        if (o.children || a && o.value !== !1)
          return !0;
      } else
        return !1;
      return !1;
    }, this.graph = e, !e)
      return;
    this._mask = null;
    const t = {};
    (function n(a) {
      t[a.name] = a;
      for (let o = 0; o < a.children.length; ++o)
        n(a.children[o]);
    })(e), this.nodes = t, this.targetCache = {};
    const i = function(a) {
      let o = a;
      for (; o && !(o instanceof oe); )
        o = o.parent;
      let h;
      return o && (o.render ? h = o.render.meshInstances : o.model && (h = o.model.meshInstances)), h;
    };
    this.nodeCounts = {}, this.activeNodes = [], this.handlers = {
      localPosition: function(n) {
        const a = n.localPosition, o = function(l) {
          a.set(...l);
        };
        return zi.createAnimTarget(o, "vector", 3, n, "localPosition");
      },
      localRotation: function(n) {
        const a = n.localRotation, o = function(l) {
          a.set(...l);
        };
        return zi.createAnimTarget(o, "quaternion", 4, n, "localRotation");
      },
      localScale: function(n) {
        const a = n.localScale, o = function(l) {
          a.set(...l);
        };
        return zi.createAnimTarget(o, "vector", 3, n, "localScale");
      },
      weight: function(n, a) {
        a.indexOf("name.") === 0 ? a = a.replace("name.", "") : a = Number(a);
        const o = i(n);
        let h;
        if (o) {
          for (let l = 0; l < o.length; ++l)
            if (o[l].node.name === n.name && o[l].morphInstance) {
              const c = o[l].morphInstance, d = (u) => {
                c.setWeight(a, u[0]);
              };
              h || (h = []), h.push(d);
            }
        }
        if (h) {
          const l = (c) => {
            for (let d = 0; d < h.length; ++d)
              h[d](c);
          };
          return zi.createAnimTarget(l, "number", 1, n, `weight.${a}`);
        }
        return null;
      },
      materialTexture: (n, a) => {
        const o = i(n);
        if (o) {
          let h;
          for (let l = 0; l < o.length; ++l)
            if (o[l].node.name === n.name) {
              h = o[l];
              break;
            }
          if (h) {
            const l = (c) => {
              const d = this.animComponent.system.app.assets.get(c[0]);
              d && d.resource && d.type === "texture" && (h.material[a] = d.resource, h.material.update());
            };
            return zi.createAnimTarget(l, "vector", 1, n, "materialTexture", "material");
          }
        }
        return null;
      }
    };
  }
  _isPathActive(e) {
    if (!this._mask)
      return !0;
    const t = [e.entityPath[0], this.graph.name];
    for (let s = 0; s < t.length; ++s) {
      let i = t[s];
      if (this._isPathInMask(i, e.entityPath.length === 1))
        return !0;
      for (let n = 1; n < e.entityPath.length; n++)
        if (i += "/" + e.entityPath[n], this._isPathInMask(i, n === e.entityPath.length - 1))
          return !0;
    }
    return !1;
  }
  findNode(e) {
    if (!this._isPathActive(e))
      return null;
    let t;
    return this.graph && (t = this.graph.findByPath(e.entityPath), t || (t = this.graph.findByPath(e.entityPath.slice(1)))), t || (t = this.nodes[e.entityPath[e.entityPath.length - 1] || ""]), t;
  }
  static createAnimTarget(e, t, s, i, n, a) {
    const o = Tr.encode(i.path, a || "entity", n);
    return new zd(e, t, s, o);
  }
  resolve(e) {
    const t = Tr.encode(e.entityPath, e.component, e.propertyPath);
    let s = this.targetCache[t];
    if (s)
      return s;
    const i = this.findNode(e);
    if (!i)
      return null;
    const n = this.handlers[e.propertyPath];
    return !n || (s = n(i), !s) ? null : (this.targetCache[t] = s, this.nodeCounts[i.path] ? this.nodeCounts[i.path]++ : (this.activeNodes.push(i), this.nodeCounts[i.path] = 1), s);
  }
  unresolve(e) {
    if (e.component !== "graph")
      return;
    const t = this.nodes[e.entityPath[e.entityPath.length - 1] || ""];
    if (this.nodeCounts[t.path]--, this.nodeCounts[t.path] === 0) {
      const s = this.activeNodes, i = s.indexOf(t.node), n = s.length;
      i < n - 1 && (s[i] = s[n - 1]), s.pop();
    }
  }
  update(e) {
    const t = this.activeNodes;
    for (let s = 0; s < t.length; ++s)
      t[s]._dirtifyLocal();
  }
  assignMask(e) {
    return e !== this._mask ? (this._mask = e, !0) : !1;
  }
}
class Ig extends le {
  constructor(e, t) {
    super(e, t), this._animations = {}, this._assets = [], this._loop = !0, this.animEvaluator = null, this.model = null, this.skeleton = null, this.fromSkel = null, this.toSkel = null, this.animationsIndex = {}, this.prevAnim = null, this.currAnim = null, this.blend = 0, this.blending = !1, this.blendSpeed = 0, this.activate = !0, this.speed = 1;
  }
  set animations(e) {
    this._animations = e, this.onSetAnimations();
  }
  get animations() {
    return this._animations;
  }
  set assets(e) {
    const t = this._assets;
    if (t && t.length) {
      for (let i = 0; i < t.length; i++)
        if (t[i]) {
          const n = this.system.app.assets.get(t[i]);
          if (n) {
            n.off("change", this.onAssetChanged, this), n.off("remove", this.onAssetRemoved, this);
            const a = this.animationsIndex[n.id];
            this.currAnim === a && this._stopCurrentAnimation(), delete this.animations[a], delete this.animationsIndex[n.id];
          }
        }
    }
    this._assets = e;
    const s = e.map((i) => i instanceof ce ? i.id : i);
    this.loadAnimationAssets(s);
  }
  get assets() {
    return this._assets;
  }
  set currentTime(e) {
    if (this.skeleton && (this.skeleton.currentTime = e, this.skeleton.addTime(0), this.skeleton.updateGraph()), this.animEvaluator) {
      const t = this.animEvaluator.clips;
      for (let s = 0; s < t.length; ++s)
        t[s].time = e;
    }
  }
  get currentTime() {
    if (this.skeleton)
      return this.skeleton._time;
    if (this.animEvaluator) {
      const e = this.animEvaluator.clips;
      if (e.length > 0)
        return e[e.length - 1].time;
    }
    return 0;
  }
  get duration() {
    return this.currAnim ? this.animations[this.currAnim].duration : 0;
  }
  set loop(e) {
    if (this._loop = e, this.skeleton && (this.skeleton.looping = e), this.animEvaluator)
      for (let t = 0; t < this.animEvaluator.clips.length; ++t)
        this.animEvaluator.clips[t].loop = e;
  }
  get loop() {
    return this._loop;
  }
  play(e, t = 0) {
    if (!(!this.enabled || !this.entity.enabled) && this.animations[e]) {
      if (this.prevAnim = this.currAnim, this.currAnim = e, this.model) {
        !this.skeleton && !this.animEvaluator && this._createAnimationController();
        const s = this.animations[this.prevAnim], i = this.animations[this.currAnim];
        if (this.blending = t > 0 && !!this.prevAnim, this.blending && (this.blend = 0, this.blendSpeed = 1 / t), this.skeleton && (this.blending ? (this.fromSkel.animation = s, this.fromSkel.addTime(this.skeleton._time), this.toSkel.animation = i) : this.skeleton.animation = i), this.animEvaluator) {
          const n = this.animEvaluator;
          if (this.blending)
            for (; n.clips.length > 1; )
              n.removeClip(0);
          else
            this.animEvaluator.removeClips();
          const a = new Mg(this.animations[this.currAnim], 0, 1, !0, this.loop);
          a.name = this.currAnim, a.blendWeight = this.blending ? 0 : 1, a.reset(), this.animEvaluator.addClip(a);
        }
      }
      this.playing = !0;
    }
  }
  getAnimation(e) {
    return this.animations[e];
  }
  setModel(e) {
    e !== this.model && (this._resetAnimationController(), this.model = e, this.animations && this.currAnim && this.animations[this.currAnim] && this.play(this.currAnim));
  }
  onSetAnimations() {
    const e = this.entity.model;
    if (e) {
      const t = e.model;
      t && t !== this.model && this.setModel(t);
    }
    if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
      const t = Object.keys(this._animations);
      t.length > 0 && this.play(t[0]);
    }
  }
  _resetAnimationController() {
    this.skeleton = null, this.fromSkel = null, this.toSkel = null, this.animEvaluator = null;
  }
  _createAnimationController() {
    const e = this.model, t = this.animations;
    let s = !1, i = !1;
    for (const a in t)
      t.hasOwnProperty(a) && (t[a].constructor === Yl ? i = !0 : s = !0);
    const n = e.getGraph();
    s ? (this.fromSkel = new Dc(n), this.toSkel = new Dc(n), this.skeleton = new Dc(n), this.skeleton.looping = this.loop, this.skeleton.setGraph(n)) : i && (this.animEvaluator = new Lg(new zi(this.entity)));
  }
  loadAnimationAssets(e) {
    if (!e || !e.length)
      return;
    const t = this.system.app.assets, s = (n) => {
      if (n.resources.length > 1)
        for (let a = 0; a < n.resources.length; a++)
          this.animations[n.resources[a].name] = n.resources[a], this.animationsIndex[n.id] = n.resources[a].name;
      else
        this.animations[n.name] = n.resource, this.animationsIndex[n.id] = n.name;
      this.animations = this.animations;
    }, i = (n) => {
      n.off("change", this.onAssetChanged, this), n.on("change", this.onAssetChanged, this), n.off("remove", this.onAssetRemoved, this), n.on("remove", this.onAssetRemoved, this), n.resource ? s(n) : (n.once("load", s, this), this.enabled && this.entity.enabled && t.load(n));
    };
    for (let n = 0, a = e.length; n < a; n++) {
      const o = t.get(e[n]);
      o ? i(o) : t.on("add:" + e[n], i);
    }
  }
  onAssetChanged(e, t, s, i) {
    if (t === "resource" || t === "resources")
      if (t === "resources" && s && s.length === 0 && (s = null), s) {
        let n = !1;
        if (s.length > 1) {
          if (i && i.length > 1)
            for (let a = 0; a < i.length; a++)
              delete this.animations[i[a].name];
          else
            delete this.animations[e.name];
          n = !1;
          for (let a = 0; a < s.length; a++)
            this.animations[s[a].name] = s[a], !n && this.currAnim === s[a].name && this.playing && this.enabled && this.entity.enabled && (n = !0, this.play(s[a].name));
          n || (this._stopCurrentAnimation(), this.onSetAnimations());
        } else {
          if (i && i.length > 1)
            for (let a = 0; a < i.length; a++)
              delete this.animations[i[a].name];
          this.animations[e.name] = s[0] || s, n = !1, this.currAnim === e.name && this.playing && this.enabled && this.entity.enabled && (n = !0, this.play(e.name)), n || (this._stopCurrentAnimation(), this.onSetAnimations());
        }
        this.animationsIndex[e.id] = e.name;
      } else {
        if (i.length > 1)
          for (let n = 0; n < i.length; n++)
            delete this.animations[i[n].name], this.currAnim === i[n].name && this._stopCurrentAnimation();
        else
          delete this.animations[e.name], this.currAnim === e.name && this._stopCurrentAnimation();
        delete this.animationsIndex[e.id];
      }
  }
  onAssetRemoved(e) {
    if (e.off("remove", this.onAssetRemoved, this), this.animations) {
      if (e.resources.length > 1)
        for (let t = 0; t < e.resources.length; t++)
          delete this.animations[e.resources[t].name], this.currAnim === e.resources[t].name && this._stopCurrentAnimation();
      else
        delete this.animations[e.name], this.currAnim === e.name && this._stopCurrentAnimation();
      delete this.animationsIndex[e.id];
    }
  }
  _stopCurrentAnimation() {
    if (this.currAnim = null, this.playing = !1, this.skeleton && (this.skeleton.currentTime = 0, this.skeleton.animation = null), this.animEvaluator) {
      for (let e = 0; e < this.animEvaluator.clips.length; ++e)
        this.animEvaluator.clips[e].stop();
      this.animEvaluator.update(0), this.animEvaluator.removeClips();
    }
  }
  onEnable() {
    super.onEnable();
    const e = this.assets, t = this.system.app.assets;
    if (e)
      for (let s = 0, i = e.length; s < i; s++) {
        let n = e[s];
        n instanceof ce || (n = t.get(n)), n && !n.resource && t.load(n);
      }
    if (this.activate && !this.currAnim) {
      const s = Object.keys(this.animations);
      s.length > 0 && this.play(s[0]);
    }
  }
  onBeforeRemove() {
    for (let e = 0; e < this.assets.length; e++) {
      let t = this.assets[e];
      typeof t == "number" && (t = this.system.app.assets.get(t)), t && (t.off("change", this.onAssetChanged, this), t.off("remove", this.onAssetRemoved, this));
    }
    this.skeleton = null, this.fromSkel = null, this.toSkel = null, this.animEvaluator = null;
  }
  update(e) {
    if (this.blending && (this.blend += e * this.blendSpeed, this.blend >= 1 && (this.blend = 1)), this.playing) {
      const s = this.skeleton;
      if (s !== null && this.model !== null) {
        if (this.blending)
          s.blend(this.fromSkel, this.toSkel, this.blend);
        else {
          const i = e * this.speed;
          s.addTime(i), this.speed > 0 && s._time === s.animation.duration && !this.loop ? this.playing = !1 : this.speed < 0 && s._time === 0 && !this.loop && (this.playing = !1);
        }
        this.blending && this.blend === 1 && (s.animation = this.toSkel.animation), s.updateGraph();
      }
    }
    const t = this.animEvaluator;
    if (t) {
      for (let s = 0; s < t.clips.length; ++s) {
        const i = t.clips[s];
        i.speed = this.speed, this.playing ? i.resume() : i.pause();
      }
      this.blending && t.clips.length > 1 && (t.clips[1].blendWeight = this.blend), t.update(e);
    }
    this.blending && this.blend === 1 && (this.blending = !1);
  }
}
class v1 {
  constructor() {
    this.enabled = !0;
  }
}
const Ud = ["enabled"];
class S1 extends Ye {
  constructor(e) {
    super(e), this.id = "animation", this.ComponentType = Ig, this.DataType = v1, this.schema = Ud, this.on("beforeremove", this.onBeforeRemove, this), this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    s = ["activate", "enabled", "loop", "speed", "assets"];
    for (const i of s)
      t.hasOwnProperty(i) && (e[i] = t[i]);
    super.initializeComponentData(e, t, Ud);
  }
  cloneComponent(e, t) {
    this.addComponent(t, {}), t.animation.assets = e.animation.assets.slice(), t.animation.speed = e.animation.speed, t.animation.loop = e.animation.loop, t.animation.activate = e.animation.activate, t.animation.enabled = e.animation.enabled;
    const s = {}, i = e.animation.animations;
    for (const o in i)
      i.hasOwnProperty(o) && (s[o] = i[o]);
    t.animation.animations = s;
    const n = {}, a = e.animation.animationsIndex;
    for (const o in a)
      a.hasOwnProperty(o) && (n[o] = a[o]);
    return t.animation.animationsIndex = n, t.animation;
  }
  onBeforeRemove(e, t) {
    t.onBeforeRemove();
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s];
        i.data.enabled && i.entity.enabled && i.entity.animation.update(e);
      }
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(Ig.prototype, Ud);
class Ka {
  constructor(e, t, s, i, n = 1) {
    this._state = e, this._parent = t, this._name = s, Array.isArray(i) ? (this._point = new q(i[0], i[1]), this._pointLength = this._point.length()) : (this._point = i, this._pointLength = i), this._speed = n, this._weightedSpeed = 1, this._weight = 1, this._animTrack = null;
  }
  get parent() {
    return this._parent;
  }
  get name() {
    return this._name;
  }
  get path() {
    return this._parent ? this._parent.path + "." + this._name : this._name;
  }
  get point() {
    return this._point;
  }
  get pointLength() {
    return this._pointLength;
  }
  set weight(e) {
    this._weight = e;
  }
  get weight() {
    return this._parent ? this._parent.weight * this._weight : this._weight;
  }
  get normalizedWeight() {
    const e = this._state.totalWeight;
    return e === 0 ? 0 : this.weight / e;
  }
  get speed() {
    return this._weightedSpeed * this._speed;
  }
  get absoluteSpeed() {
    return Math.abs(this._speed);
  }
  set weightedSpeed(e) {
    this._weightedSpeed = e;
  }
  get weightedSpeed() {
    return this._weightedSpeed;
  }
  set animTrack(e) {
    this._animTrack = e;
  }
  get animTrack() {
    return this._animTrack;
  }
}
class Yr extends Ka {
  constructor(e, t, s, i, n, a, o, h, l) {
    super(e, t, s, i), this._parameters = n, this._parameterValues = new Array(n.length), this._children = [], this._findParameter = l, this._syncAnimations = o !== !1, this._pointCache = {};
    for (let c = 0; c < a.length; c++) {
      const d = a[c];
      d.children ? this._children.push(h(d.type, this, null, s, 1, d.parameter ? [d.parameter] : d.parameters, d.children, h, l)) : this._children.push(new Ka(e, this, d.name, d.point, d.speed));
    }
  }
  get weight() {
    return this.calculateWeights(), this._parent ? this._parent.weight * this._weight : this._weight;
  }
  get syncAnimations() {
    return this._syncAnimations;
  }
  getChild(e) {
    for (let t = 0; t < this._children.length; t++)
      if (this._children[t].name === e)
        return this._children[t];
    return null;
  }
  updateParameterValues() {
    let e = !0;
    for (let t = 0; t < this._parameterValues.length; t++) {
      const s = this._findParameter(this._parameters[t]).value;
      this._parameterValues[t] !== s && (this._parameterValues[t] = s, e = !1);
    }
    return e;
  }
  getNodeWeightedDuration(e) {
    return this._children[e].animTrack.duration / this._children[e].speedMultiplier * this._children[e].weight;
  }
  getNodeCount() {
    let e = 0;
    for (let t = 0; t < this._children.length; t++)
      this._children[t].constructor === Yr ? e += this._children[t].getNodeCount() : e++;
    return e;
  }
}
class b1 extends Yr {
  constructor(e, t, s, i, n, a, o, h, l) {
    a.sort((c, d) => c.point - d.point), super(e, t, s, i, n, a, o, h, l);
  }
  calculateWeights() {
    if (this.updateParameterValues())
      return;
    let e = 0;
    this._children[0].weight = 0;
    for (let t = 0; t < this._children.length; t++) {
      const s = this._children[t];
      if (t !== this._children.length - 1) {
        const i = this._children[t + 1];
        if (s.point === i.point)
          s.weight = 0.5, i.weight = 0.5;
        else if (U.between(this._parameterValues[0], s.point, i.point, !0)) {
          const n = Math.abs(s.point - i.point), a = Math.abs(s.point - this._parameterValues[0]), o = (n - a) / n;
          s.weight = o, i.weight = 1 - o;
        } else
          i.weight = 0;
      }
      this._syncAnimations && (e += s.animTrack.duration / s.absoluteSpeed * s.weight);
    }
    if (this._syncAnimations)
      for (let t = 0; t < this._children.length; t++) {
        const s = this._children[t];
        s.weightedSpeed = s.animTrack.duration / s.absoluteSpeed / e;
      }
  }
}
class oi extends Yr {
  pointDistanceCache(e, t) {
    const s = `${e}${t}`;
    return this._pointCache[s] || (this._pointCache[s] = this._children[t].point.clone().sub(this._children[e].point)), this._pointCache[s];
  }
  calculateWeights() {
    if (this.updateParameterValues())
      return;
    let e, t;
    oi._p.set(...this._parameterValues), e = 0, t = 0;
    for (let s = 0; s < this._children.length; s++) {
      const i = this._children[s], n = i.point;
      oi._pip.set(oi._p.x, oi._p.y).sub(n);
      let a = Number.MAX_VALUE;
      for (let o = 0; o < this._children.length; o++) {
        if (s === o)
          continue;
        const h = this.pointDistanceCache(s, o), l = U.clamp(1 - oi._pip.dot(h) / h.lengthSq(), 0, 1);
        l < a && (a = l);
      }
      i.weight = a, e += a, this._syncAnimations && (t += i.animTrack.duration / i.absoluteSpeed * i.weight);
    }
    for (let s = 0; s < this._children.length; s++) {
      const i = this._children[s];
      i.weight = i._weight / e, this._syncAnimations && (i.weightedSpeed = i.animTrack.duration / i.absoluteSpeed / t);
    }
  }
}
oi._p = new q();
oi._pip = new q();
class hi extends Yr {
  pointCache(e, t) {
    const s = `${e}${t}`;
    return this._pointCache[s] || (this._pointCache[s] = new q((this._children[t].pointLength - this._children[e].pointLength) / ((this._children[t].pointLength + this._children[e].pointLength) / 2), q.angleRad(this._children[e].point, this._children[t].point) * 2)), this._pointCache[s];
  }
  calculateWeights() {
    if (this.updateParameterValues())
      return;
    let e, t;
    hi._p.set(...this._parameterValues);
    const s = hi._p.length();
    e = 0, t = 0;
    for (let i = 0; i < this._children.length; i++) {
      const n = this._children[i], a = n.point, o = n.pointLength;
      let h = Number.MAX_VALUE;
      for (let l = 0; l < this._children.length; l++) {
        if (i === l)
          continue;
        const c = this.pointCache(i, l), d = this._children[l].pointLength;
        hi._pip.set((s - o) / ((d + o) / 2), q.angleRad(a, hi._p) * 2);
        const u = U.clamp(1 - Math.abs(hi._pip.dot(c) / c.lengthSq()), 0, 1);
        u < h && (h = u);
      }
      n.weight = h, e += h, this._syncAnimations && (t += n.animTrack.duration / n.absoluteSpeed * n.weight);
    }
    for (let i = 0; i < this._children.length; i++) {
      const n = this._children[i];
      if (n.weight = n._weight / e, this._syncAnimations) {
        const a = n.animTrack.duration / t * e;
        n.weightedSpeed = n.absoluteSpeed * a;
      }
    }
  }
}
hi._p = new q();
hi._pip = new q();
class w1 extends Yr {
  calculateWeights() {
    if (this.updateParameterValues())
      return;
    let e = 0, t = 0;
    for (let s = 0; s < this._children.length; s++)
      if (e += Math.max(this._parameterValues[s], 0), this._syncAnimations) {
        const i = this._children[s];
        t += i.animTrack.duration / i.absoluteSpeed * i.weight;
      }
    for (let s = 0; s < this._children.length; s++) {
      const i = this._children[s], n = Math.max(this._parameterValues[s], 0);
      e ? (i.weight = n / e, this._syncAnimations && (i.weightedSpeed = i.animTrack.duration / i.absoluteSpeed / t)) : (i.weight = 0, this._syncAnimations && (i.weightedSpeed = 0));
    }
  }
}
class ep {
  constructor(e, t, s, i, n) {
    this._controller = e, this._name = t, this._animations = {}, this._animationList = [], this._speed = s || 1, this._loop = i === void 0 ? !0 : i;
    const a = this._controller.findParameter.bind(this._controller);
    n ? this._blendTree = this._createTree(n.type, this, null, t, 1, n.parameter ? [n.parameter] : n.parameters, n.children, n.syncAnimations, this._createTree, a) : this._blendTree = new Ka(this, null, t, 1, s);
  }
  _createTree(e, t, s, i, n, a, o, h, l, c) {
    switch (e) {
      case p1:
        return new b1(t, s, i, n, a, o, h, l, c);
      case g1:
        return new oi(t, s, i, n, a, o, h, l, c);
      case _1:
        return new hi(t, s, i, n, a, o, h, l, c);
      case y1:
        return new w1(t, s, i, n, a, o, h, l, c);
    }
  }
  _getNodeFromPath(e) {
    let t = this._blendTree;
    for (let s = 1; s < e.length; s++)
      t = t.getChild(e[s]);
    return t;
  }
  addAnimation(e, t) {
    const s = e.join("."), i = this._animationList.findIndex(function(n) {
      return n.path === s;
    });
    if (i >= 0)
      this._animationList[i].animTrack = t;
    else {
      const n = this._getNodeFromPath(e);
      n.animTrack = t, this._animationList.push(n);
    }
  }
  get name() {
    return this._name;
  }
  set animations(e) {
    this._animationList = e;
  }
  get animations() {
    return this._animationList;
  }
  set speed(e) {
    this._speed = e;
  }
  get speed() {
    return this._speed;
  }
  set loop(e) {
    this._loop = e;
  }
  get loop() {
    return this._loop;
  }
  get nodeCount() {
    return !this._blendTree || this._blendTree.constructor === Ka ? 1 : this._blendTree.getNodeCount();
  }
  get playable() {
    return rl.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
  }
  get looping() {
    if (this.animations.length > 0) {
      const e = this.name + "." + this.animations[0].animTrack.name, t = this._controller.animEvaluator.findClip(e);
      if (t)
        return t.loop;
    }
    return !1;
  }
  get totalWeight() {
    let e = 0;
    for (let t = 0; t < this.animations.length; t++)
      e += this.animations[t].weight;
    return e;
  }
  get timelineDuration() {
    let e = 0;
    for (let t = 0; t < this.animations.length; t++) {
      const s = this.animations[t];
      s.animTrack.duration > e && (e = s.animTrack.duration);
    }
    return e;
  }
}
class al {
  constructor({
    from: e,
    to: t,
    time: s = 0,
    priority: i = 0,
    conditions: n = [],
    exitTime: a = null,
    transitionOffset: o = null,
    interruptionSource: h = Eg
  }) {
    this._from = e, this._to = t, this._time = s, this._priority = i, this._conditions = n, this._exitTime = a, this._transitionOffset = o, this._interruptionSource = h;
  }
  get from() {
    return this._from;
  }
  set to(e) {
    this._to = e;
  }
  get to() {
    return this._to;
  }
  get time() {
    return this._time;
  }
  get priority() {
    return this._priority;
  }
  get conditions() {
    return this._conditions;
  }
  get exitTime() {
    return this._exitTime;
  }
  get transitionOffset() {
    return this._transitionOffset;
  }
  get interruptionSource() {
    return this._interruptionSource;
  }
  get hasExitTime() {
    return !!this.exitTime;
  }
}
class T1 {
  constructor(e, t, s, i, n, a, o) {
    this._animEvaluator = e, this._states = {}, this._stateNames = [], this._eventHandler = a, this._consumedTriggers = o;
    for (let h = 0; h < t.length; h++)
      this._states[t[h].name] = new ep(this, t[h].name, t[h].speed, t[h].loop, t[h].blendTree), this._stateNames.push(t[h].name);
    this._transitions = s.map((h) => new al(On({}, h))), this._findTransitionsFromStateCache = {}, this._findTransitionsBetweenStatesCache = {}, this._parameters = i, this._previousStateName = null, this._activeStateName = pr, this._playing = !1, this._activate = n, this._currTransitionTime = 1, this._totalTransitionTime = 1, this._isTransitioning = !1, this._transitionInterruptionSource = Eg, this._transitionPreviousStates = [], this._timeInState = 0, this._timeInStateBefore = 0;
  }
  get animEvaluator() {
    return this._animEvaluator;
  }
  set activeState(e) {
    this._activeStateName = e;
  }
  get activeState() {
    return this._findState(this._activeStateName);
  }
  get activeStateName() {
    return this._activeStateName;
  }
  get activeStateAnimations() {
    return this.activeState.animations;
  }
  set previousState(e) {
    this._previousStateName = e;
  }
  get previousState() {
    return this._findState(this._previousStateName);
  }
  get previousStateName() {
    return this._previousStateName;
  }
  get playable() {
    let e = !0;
    for (let t = 0; t < this._stateNames.length; t++)
      this._states[this._stateNames[t]].playable || (e = !1);
    return e;
  }
  set playing(e) {
    this._playing = e;
  }
  get playing() {
    return this._playing;
  }
  get activeStateProgress() {
    return this._getActiveStateProgressForTime(this._timeInState);
  }
  get activeStateDuration() {
    if (this.activeStateName === pr || this.activeStateName === yh)
      return 0;
    let e = 0;
    for (let t = 0; t < this.activeStateAnimations.length; t++) {
      const s = this._animEvaluator.findClip(this.activeStateAnimations[t].name);
      s && (e = Math.max(e, s.track.duration));
    }
    return e;
  }
  set activeStateCurrentTime(e) {
    this._timeInStateBefore = e, this._timeInState = e;
    for (let t = 0; t < this.activeStateAnimations.length; t++) {
      const s = this.animEvaluator.findClip(this.activeStateAnimations[t].name);
      s && (s.time = e);
    }
  }
  get activeStateCurrentTime() {
    return this._timeInState;
  }
  get transitioning() {
    return this._isTransitioning;
  }
  get transitionProgress() {
    return this._currTransitionTime / this._totalTransitionTime;
  }
  get states() {
    return this._stateNames;
  }
  assignMask(e) {
    return this._animEvaluator.assignMask(e);
  }
  _findState(e) {
    return this._states[e];
  }
  _getActiveStateProgressForTime(e) {
    if (this.activeStateName === pr || this.activeStateName === yh || this.activeStateName === gn)
      return 1;
    const t = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
    return t ? t.progressForTime(e) : null;
  }
  _findTransitionsFromState(e) {
    let t = this._findTransitionsFromStateCache[e];
    return t || (t = this._transitions.filter(function(s) {
      return s.from === e;
    }), $a(t), this._findTransitionsFromStateCache[e] = t), t;
  }
  _findTransitionsBetweenStates(e, t) {
    let s = this._findTransitionsBetweenStatesCache[e + "->" + t];
    return s || (s = this._transitions.filter(function(i) {
      return i.from === e && i.to === t;
    }), $a(s), this._findTransitionsBetweenStatesCache[e + "->" + t] = s), s;
  }
  _transitionHasConditionsMet(e) {
    const t = e.conditions;
    for (let s = 0; s < t.length; s++) {
      const i = t[s], n = this.findParameter(i.parameterName);
      switch (i.predicate) {
        case l1:
          if (!(n.value > i.value))
            return !1;
          break;
        case c1:
          if (!(n.value < i.value))
            return !1;
          break;
        case d1:
          if (!(n.value >= i.value))
            return !1;
          break;
        case u1:
          if (!(n.value <= i.value))
            return !1;
          break;
        case f1:
          if (n.value !== i.value)
            return !1;
          break;
        case m1:
          if (n.value === i.value)
            return !1;
          break;
      }
    }
    return !0;
  }
  _findTransition(e, t) {
    let s = [];
    if (e && t)
      s = s.concat(this._findTransitionsBetweenStates(e, t));
    else if (!this._isTransitioning)
      s = s.concat(this._findTransitionsFromState(this._activeStateName)), s = s.concat(this._findTransitionsFromState(gn));
    else
      switch (this._transitionInterruptionSource) {
        case r1:
          s = s.concat(this._findTransitionsFromState(this._previousStateName)), s = s.concat(this._findTransitionsFromState(gn));
          break;
        case a1:
          s = s.concat(this._findTransitionsFromState(this._activeStateName)), s = s.concat(this._findTransitionsFromState(gn));
          break;
        case o1:
          s = s.concat(this._findTransitionsFromState(this._previousStateName)), s = s.concat(this._findTransitionsFromState(this._activeStateName)), s = s.concat(this._findTransitionsFromState(gn));
          break;
        case h1:
          s = s.concat(this._findTransitionsFromState(this._activeStateName)), s = s.concat(this._findTransitionsFromState(this._previousStateName)), s = s.concat(this._findTransitionsFromState(gn));
          break;
      }
    if (s = s.filter((i) => {
      if (i.to === this.activeStateName)
        return !1;
      if (i.hasExitTime) {
        let n = this._getActiveStateProgressForTime(this._timeInStateBefore), a = this._getActiveStateProgressForTime(this._timeInState);
        if (i.exitTime < 1 && this.activeState.loop && (n -= Math.floor(n), a -= Math.floor(a)), !(i.exitTime > n && i.exitTime <= a))
          return null;
      }
      return this._transitionHasConditionsMet(i);
    }), s.length > 0) {
      const i = s[0];
      if (i.to === yh) {
        const n = this._findTransitionsFromState(pr)[0];
        i.to = n.to;
      }
      return i;
    }
    return null;
  }
  updateStateFromTransition(e) {
    let t, s, i;
    this.previousState = e.from ? this.activeStateName : null, this.activeState = e.to;
    for (let l = 0; l < e.conditions.length; l++) {
      const c = e.conditions[l];
      this.findParameter(c.parameterName).type === gh && this._consumedTriggers.add(c.parameterName);
    }
    if (this.previousState) {
      this._isTransitioning || (this._transitionPreviousStates = []), this._transitionPreviousStates.push({
        name: this._previousStateName,
        weight: 1
      });
      const l = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1);
      for (let c = 0; c < this._transitionPreviousStates.length; c++) {
        this._isTransitioning ? c !== this._transitionPreviousStates.length - 1 ? this._transitionPreviousStates[c].weight *= 1 - l : this._transitionPreviousStates[c].weight = l : this._transitionPreviousStates[c].weight = 1, t = this._findState(this._transitionPreviousStates[c].name);
        for (let d = 0; d < t.animations.length; d++)
          s = t.animations[d], i = this._animEvaluator.findClip(s.name + ".previous." + c), i || (i = this._animEvaluator.findClip(s.name), i.name = s.name + ".previous." + c), c !== this._transitionPreviousStates.length - 1 && i.pause();
      }
    }
    this._isTransitioning = !0, this._totalTransitionTime = e.time, this._currTransitionTime = 0, this._transitionInterruptionSource = e.interruptionSource;
    const n = this.activeState, a = e.transitionOffset && e.transitionOffset > 0 && e.transitionOffset < 1;
    let o = 0, h = 0;
    if (a) {
      const l = n.timelineDuration * e.transitionOffset;
      o = l, h = l;
    }
    this._timeInState = o, this._timeInStateBefore = h;
    for (let l = 0; l < n.animations.length; l++) {
      if (i = this._animEvaluator.findClip(n.animations[l].name), i)
        i.reset();
      else {
        const c = Number.isFinite(n.animations[l].speed) ? n.animations[l].speed : n.speed;
        i = new Mg(n.animations[l].animTrack, this._timeInState, c, !0, n.loop, this._eventHandler), i.name = n.animations[l].name, this._animEvaluator.addClip(i);
      }
      if (e.time > 0 ? i.blendWeight = 0 : i.blendWeight = n.animations[l].normalizedWeight, i.play(), a)
        i.time = n.timelineDuration * e.transitionOffset;
      else {
        const c = n.speed >= 0 ? 0 : this.activeStateDuration;
        i.time = c;
      }
    }
  }
  _transitionToState(e) {
    if (!this._findState(e))
      return;
    let t = this._findTransition(this._activeStateName, e);
    t || (this._animEvaluator.removeClips(), t = new al({
      from: null,
      to: e
    })), this.updateStateFromTransition(t);
  }
  assignAnimation(e, t, s, i) {
    const n = e.split(".");
    let a = this._findState(n[0]);
    a || (a = new ep(this, n[0], 1), this._states[n[0]] = a, this._stateNames.push(n[0])), a.addAnimation(n, t), s !== void 0 && (a.speed = s), i !== void 0 && (a.loop = i), !this._playing && this._activate && this.playable && this.play();
  }
  removeNodeAnimations(e) {
    if (rl.indexOf(e) !== -1)
      return !1;
    const t = this._findState(e);
    return t ? (t.animations = [], !0) : !1;
  }
  play(e) {
    e && this._transitionToState(e), this._playing = !0;
  }
  pause() {
    this._playing = !1;
  }
  reset() {
    this._previousStateName = null, this._activeStateName = pr, this._playing = !1, this._currTransitionTime = 1, this._totalTransitionTime = 1, this._isTransitioning = !1, this._timeInState = 0, this._timeInStateBefore = 0, this._animEvaluator.removeClips();
  }
  rebind() {
    this._animEvaluator.rebind();
  }
  update(e) {
    if (!this._playing)
      return;
    let t, s, i;
    this._timeInStateBefore = this._timeInState, this._timeInState += e * this.activeState.speed;
    const n = this._findTransition(this._activeStateName);
    if (n && this.updateStateFromTransition(n), this._isTransitioning)
      if (this._currTransitionTime += e, this._currTransitionTime <= this._totalTransitionTime) {
        const a = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
        for (let o = 0; o < this._transitionPreviousStates.length; o++) {
          t = this._findState(this._transitionPreviousStates[o].name);
          const h = this._transitionPreviousStates[o].weight;
          for (let l = 0; l < t.animations.length; l++)
            s = t.animations[l], i = this._animEvaluator.findClip(s.name + ".previous." + o), i && (i.blendWeight = (1 - a) * s.normalizedWeight * h);
        }
        t = this.activeState;
        for (let o = 0; o < t.animations.length; o++)
          s = t.animations[o], this._animEvaluator.findClip(s.name).blendWeight = a * s.normalizedWeight;
      } else {
        this._isTransitioning = !1;
        const a = this.activeStateAnimations.length, o = this._animEvaluator.clips.length;
        for (let h = 0; h < o - a; h++)
          this._animEvaluator.removeClip(0);
        this._transitionPreviousStates = [], t = this.activeState;
        for (let h = 0; h < t.animations.length; h++)
          s = t.animations[h], i = this._animEvaluator.findClip(s.name), i && (i.blendWeight = s.normalizedWeight);
      }
    else if (this.activeState._blendTree.constructor !== Ka) {
      t = this.activeState;
      for (let a = 0; a < t.animations.length; a++)
        s = t.animations[a], i = this._animEvaluator.findClip(s.name), i && (i.blendWeight = s.normalizedWeight, s.parent.syncAnimations && (i.speed = s.speed));
    }
    this._animEvaluator.update(e);
  }
  findParameter(e) {
    return this._parameters[e];
  }
}
const kc = new q(), qo = new v(), ua = new Z(), fa = new z(), ma = new ee();
class ii extends zi {
  constructor(e, t, s, i, n) {
    super(t), this.animComponent = e, this._mask = i, this.layerName = s, this.layerIndex = n;
  }
  static _packFloat(e) {
    return e[0];
  }
  static _packBoolean(e) {
    return !!e[0];
  }
  static _packVec2(e) {
    return kc.x = e[0], kc.y = e[1], kc;
  }
  static _packVec3(e) {
    return qo.x = e[0], qo.y = e[1], qo.z = e[2], qo;
  }
  static _packVec4(e) {
    return ua.x = e[0], ua.y = e[1], ua.z = e[2], ua.w = e[3], ua;
  }
  static _packColor(e) {
    return fa.r = e[0], fa.g = e[1], fa.b = e[2], fa.a = e[3], fa;
  }
  static _packQuat(e) {
    return ma.x = e[0], ma.y = e[1], ma.z = e[2], ma.w = e[3], ma;
  }
  resolve(e) {
    const t = Tr.encode(e.entityPath, e.component, e.propertyPath);
    let s = this.targetCache[t];
    if (s)
      return s;
    let i, n, a;
    switch (e.component) {
      case "entity":
        i = this._getEntityFromHierarchy(e.entityPath), a = Tr.encode(i.path, "entity", e.propertyPath), n = i;
        break;
      case "graph":
        if (n = this.findNode(e), !n)
          return null;
        a = Tr.encode(n.path, "graph", e.propertyPath);
        break;
      default:
        if (i = this._getEntityFromHierarchy(e.entityPath), n = i.findComponent(e.component), !n)
          return null;
        a = Tr.encode(i.path, e.component, e.propertyPath);
        break;
    }
    return s = this._createAnimTargetForProperty(n, e.propertyPath, a), this.targetCache[t] = s, s;
  }
  update(e) {
    const t = this.activeNodes;
    if (t)
      for (let s = 0; s < t.length; s++)
        t[s]._dirtifyLocal();
  }
  _getEntityFromHierarchy(e) {
    if (!this.animComponent.entity.name === e[0])
      return null;
    const t = this.animComponent.entity;
    return e.length === 1 ? t : t._parent.findByPath(e);
  }
  _resolvePath(e, t, s) {
    const i = t.length - (s ? 0 : 1);
    for (let n = 0; n < i; n++)
      e = e[t[n]];
    return e;
  }
  _setter(e, t, s) {
    const i = this._resolvePath(e, t), n = t[t.length - 1], a = "set" + n.substring(0, 1).toUpperCase() + n.substring(1);
    if (i[a]) {
      let l = i["get" + n.substring(0, 1).toUpperCase() + n.substring(1)].bind(i)();
      l = [l.x, l.y, l.z, l.w];
      const c = i[a].bind(i);
      return {
        set: (d) => {
          c(s(d));
        },
        get: () => l
      };
    }
    const o = i[n];
    if (typeof o == "object" && o.hasOwnProperty("copy"))
      return function(h) {
        o.copy(s(h));
      };
    if ([q, v, Z, z, ee].indexOf(i.constructor) !== -1 && t.length > 1) {
      const h = t.length > 2 ? this._resolvePath(e, t.slice(0, -1)) : e, l = t[t.length - 2];
      return function(c) {
        i[n] = s(c), h[l] = i;
      };
    }
    return function(h) {
      i[n] = s(h);
    };
  }
  _createAnimTargetForProperty(e, t, s) {
    if (this.handlers && t[0].startsWith("weight."))
      return this.handlers.weight(e, t[0].replace("weight.", ""));
    if (this.handlers && t[0] === "material" && t.length === 2) {
      const h = t[1];
      if (h.endsWith("Map"))
        return this.handlers.materialTexture(e, h);
    }
    const i = this._resolvePath(e, t, !0);
    if (typeof i > "u")
      return null;
    let n, a, o;
    if (typeof i == "number")
      n = this._setter(e, t, ii._packFloat), a = "vector", o = 1;
    else if (typeof i == "boolean")
      n = this._setter(e, t, ii._packBoolean), a = "vector", o = 1;
    else if (typeof i == "object")
      switch (i.constructor) {
        case q:
          n = this._setter(e, t, ii._packVec2), a = "vector", o = 2;
          break;
        case v:
          n = this._setter(e, t, ii._packVec3), a = "vector", o = 3;
          break;
        case Z:
          n = this._setter(e, t, ii._packVec4), a = "vector", o = 4;
          break;
        case z:
          n = this._setter(e, t, ii._packColor), a = "vector", o = 4;
          break;
        case ee:
          n = this._setter(e, t, ii._packQuat), a = "quaternion", o = 4;
          break;
        default:
          return null;
      }
    return t.indexOf("material") !== -1 ? new zd(function(h) {
      n(h), e.material.update();
    }, a, o, s) : new zd(n, a, o, s);
  }
  rebind() {
    this.targetCache = {}, this.animComponent.rootBone ? this.graph = this.animComponent.rootBone : this.graph = this.animComponent.entity;
    const e = {};
    (function s(i) {
      e[i.name] = i;
      for (let n = 0; n < i.children.length; ++n)
        s(i.children[n]);
    })(this.graph), this.nodes = e;
  }
}
class C1 {
  constructor(e, t, s, i = 1, n = Rg, a = !0) {
    this._name = e, this._controller = t, this._component = s, this._weight = i, this._blendType = n, this._normalizedWeight = a, this._mask = null, this._blendTime = 0, this._blendTimeElapsed = 0, this._startingWeight = 0, this._targetWeight = 0;
  }
  get name() {
    return this._name;
  }
  set playing(e) {
    this._controller.playing = e;
  }
  get playing() {
    return this._controller.playing;
  }
  get playable() {
    return this._controller.playable;
  }
  get activeState() {
    return this._controller.activeStateName;
  }
  get previousState() {
    return this._controller.previousStateName;
  }
  get activeStateProgress() {
    return this._controller.activeStateProgress;
  }
  get activeStateDuration() {
    return this._controller.activeStateDuration;
  }
  set activeStateCurrentTime(e) {
    const t = this._controller, s = t.playing;
    t.playing = !0, t.activeStateCurrentTime = e, s || t.update(0), t.playing = s;
  }
  get activeStateCurrentTime() {
    return this._controller.activeStateCurrentTime;
  }
  get transitioning() {
    return this._controller.transitioning;
  }
  get transitionProgress() {
    return this.transitioning ? this._controller.transitionProgress : null;
  }
  get states() {
    return this._controller.states;
  }
  set weight(e) {
    this._weight = e, this._component.dirtifyTargets();
  }
  get weight() {
    return this._weight;
  }
  set blendType(e) {
    e !== this._blendType && (this._blendType = e, this._controller.normalizeWeights && this._component.rebind());
  }
  get blendType() {
    return this._blendType;
  }
  set mask(e) {
    this._controller.assignMask(e) && this._component.rebind(), this._mask = e;
  }
  get mask() {
    return this._mask;
  }
  play(e) {
    this._controller.play(e);
  }
  pause() {
    this._controller.pause();
  }
  reset() {
    this._controller.reset();
  }
  rebind() {
    this._controller.rebind();
  }
  update(e) {
    this._blendTime && (this._blendTimeElapsed < this._blendTime ? (this.weight = U.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime), this._blendTimeElapsed += e) : (this.weight = this._targetWeight, this._blendTime = 0, this._blendTimeElapsed = 0, this._startingWeight = 0, this._targetWeight = 0)), this._controller.update(e);
  }
  blendToWeight(e, t) {
    this._startingWeight = this.weight, this._targetWeight = e, this._blendTime = Math.max(0, t), this._blendTimeElapsed = 0;
  }
  assignMask(e) {
    this._controller.assignMask(e) && this._component.rebind(), this._mask = e;
  }
  assignAnimation(e, t, s, i) {
    t.constructor === Yl && (this._controller.assignAnimation(e, t, s, i), this._controller._transitions.length === 0 && this._controller._transitions.push(new al({
      from: "START",
      to: e
    })), this._component.activate && this._component.playable && (this._component.playing = !0));
  }
  removeNodeAnimations(e) {
    this._controller.removeNodeAnimations(e) && (this._component.playing = !1);
  }
  getAnimationAsset(e) {
    return this._component.animationAssets[`${this.name}:${e}`];
  }
  transition(e, t = 0, s = null) {
    this._controller.updateStateFromTransition(new al({
      from: this._controller.activeStateName,
      to: e,
      time: t,
      transitionOffset: s
    }));
  }
}
class xh {
  constructor(e) {
    if (this._layers = [], this._parameters = {}, Array.isArray(e.layers))
      this._layers = e.layers;
    else
      for (const t in e.layers) {
        const s = e.layers[t], i = {
          name: s.name,
          blendType: s.blendType,
          weight: s.weight,
          states: [],
          transitions: []
        };
        for (let n = 0; n < s.states.length; n++)
          i.states.push(e.states[s.states[n]]);
        for (let n = 0; n < s.transitions.length; n++) {
          const a = e.transitions[s.transitions[n]];
          if (a.conditions && !Array.isArray(a.conditions)) {
            const o = Object.keys(a.conditions), h = [];
            for (let l = 0; l < o.length; l++) {
              const c = a.conditions[o[l]];
              c.parameterName && h.push(c);
            }
            a.conditions = h;
          }
          Number.isInteger(a.from) && (a.from = e.states[a.from].name), Number.isInteger(a.to) && (a.to = e.states[a.to].name), i.transitions.push(a);
        }
        this._layers.push(i);
      }
    for (const t in e.parameters) {
      const s = e.parameters[t];
      this._parameters[s.name] = {
        type: s.type,
        value: s.value
      };
    }
  }
  get parameters() {
    return Object.assign({}, this._parameters);
  }
  get layers() {
    return this._layers;
  }
}
class Dg extends le {
  constructor(e, t) {
    super(e, t), this._stateGraphAsset = null, this._animationAssets = {}, this._speed = 1, this._activate = !0, this._playing = !1, this._rootBone = null, this._stateGraph = null, this._layers = [], this._layerIndices = {}, this._parameters = {}, this._targets = {}, this._consumedTriggers = /* @__PURE__ */ new Set(), this._normalizeWeights = !1;
  }
  set stateGraphAsset(e) {
    if (e === null) {
      this.removeStateGraph();
      return;
    }
    this._stateGraphAsset && this.system.app.assets.get(this._stateGraphAsset).off("change", this._onStateGraphAssetChangeEvent, this);
    let t, s;
    e instanceof ce ? (t = e.id, s = this.system.app.assets.get(t), s || (this.system.app.assets.add(e), s = this.system.app.assets.get(t))) : (t = e, s = this.system.app.assets.get(t)), !(!s || this._stateGraphAsset === t) && (s.resource ? (this._stateGraph = s.resource, this.loadStateGraph(this._stateGraph), s.on("change", this._onStateGraphAssetChangeEvent, this)) : (s.once("load", (i) => {
      this._stateGraph = i.resource, this.loadStateGraph(this._stateGraph);
    }), s.on("change", this._onStateGraphAssetChangeEvent, this), this.system.app.assets.load(s)), this._stateGraphAsset = t);
  }
  get stateGraphAsset() {
    return this._stateGraphAsset;
  }
  set normalizeWeights(e) {
    this._normalizeWeights = e, this.unbind();
  }
  get normalizeWeights() {
    return this._normalizeWeights;
  }
  set animationAssets(e) {
    this._animationAssets = e, this.loadAnimationAssets();
  }
  get animationAssets() {
    return this._animationAssets;
  }
  set speed(e) {
    this._speed = e;
  }
  get speed() {
    return this._speed;
  }
  set activate(e) {
    this._activate = e;
  }
  get activate() {
    return this._activate;
  }
  set playing(e) {
    this._playing = e;
  }
  get playing() {
    return this._playing;
  }
  set rootBone(e) {
    if (typeof e == "string") {
      const t = this.entity.root.findByGuid(e);
      this._rootBone = t;
    } else
      e instanceof oe ? this._rootBone = e : this._rootBone = null;
    this.rebind();
  }
  get rootBone() {
    return this._rootBone;
  }
  set stateGraph(e) {
    this._stateGraph = e;
  }
  get stateGraph() {
    return this._stateGraph;
  }
  get layers() {
    return this._layers;
  }
  set layerIndices(e) {
    this._layerIndices = e;
  }
  get layerIndices() {
    return this._layerIndices;
  }
  set parameters(e) {
    this._parameters = e;
  }
  get parameters() {
    return this._parameters;
  }
  set targets(e) {
    this._targets = e;
  }
  get targets() {
    return this._targets;
  }
  get playable() {
    for (let e = 0; e < this._layers.length; e++)
      if (!this._layers[e].playable)
        return !1;
    return !0;
  }
  get baseLayer() {
    return this._layers.length > 0 ? this._layers[0] : null;
  }
  _onStateGraphAssetChangeEvent(e) {
    const t = this.animationAssets, s = this.layers.map((i) => i.mask);
    this.removeStateGraph(), this._stateGraph = new xh(e._data), this.loadStateGraph(this._stateGraph), this.animationAssets = t, this.loadAnimationAssets(), this.layers.forEach((i, n) => {
      i.mask = s[n];
    }), this.rebind();
  }
  dirtifyTargets() {
    const e = Object.values(this._targets);
    for (let t = 0; t < e.length; t++)
      e[t].dirty = !0;
  }
  _addLayer({
    name: e,
    states: t,
    transitions: s,
    weight: i,
    mask: n,
    blendType: a
  }) {
    let o;
    this.rootBone ? o = this.rootBone : o = this.entity;
    const h = this._layers.length, l = new ii(this, o, e, n, h), c = new Lg(l), d = new T1(c, t, s, this._parameters, this._activate, this, this._consumedTriggers);
    return this._layers.push(new C1(e, d, this, i, a)), this._layerIndices[e] = h, this._layers[h];
  }
  addLayer(e, t, s, i) {
    const n = this.findAnimationLayer(e);
    if (n)
      return n;
    const a = [{
      name: "START",
      speed: 1
    }], o = [];
    return this._addLayer({
      name: e,
      states: a,
      transitions: o,
      weight: t,
      mask: s,
      blendType: i
    });
  }
  loadStateGraph(e) {
    this._stateGraph = e, this._parameters = {};
    const t = Object.keys(e.parameters);
    for (let s = 0; s < t.length; s++) {
      const i = t[s];
      this._parameters[i] = {
        type: e.parameters[i].type,
        value: e.parameters[i].value
      };
    }
    this._layers = [];
    for (let s = 0; s < e.layers.length; s++) {
      const i = e.layers[s];
      this._addLayer.bind(this)(On({}, i));
    }
    this.setupAnimationAssets();
  }
  setupAnimationAssets() {
    for (let e = 0; e < this._layers.length; e++) {
      const t = this._layers[e], s = t.name;
      for (let i = 0; i < t.states.length; i++) {
        const n = t.states[i];
        if (rl.indexOf(n) === -1) {
          const a = s + ":" + n;
          this._animationAssets[a] || (this._animationAssets[a] = {
            asset: null
          });
        }
      }
    }
    this.loadAnimationAssets();
  }
  loadAnimationAssets() {
    for (let e = 0; e < this._layers.length; e++) {
      const t = this._layers[e];
      for (let s = 0; s < t.states.length; s++) {
        const i = t.states[s];
        if (rl.indexOf(i) !== -1)
          continue;
        const n = this._animationAssets[t.name + ":" + i];
        if (!n || !n.asset) {
          this.removeNodeAnimations(i, t.name);
          continue;
        }
        const a = n.asset, o = this.system.app.assets.get(a);
        o && (o.resource ? this.onAnimationAssetLoaded(t.name, i, o) : (o.once("load", function(h, l) {
          return function(c) {
            this.onAnimationAssetLoaded(h, l, c);
          }.bind(this);
        }.bind(this)(t.name, i)), this.system.app.assets.load(o)));
      }
    }
  }
  onAnimationAssetLoaded(e, t, s) {
    this.findAnimationLayer(e).assignAnimation(t, s.resource);
  }
  removeStateGraph() {
    this._stateGraph = null, this._stateGraphAsset = null, this._animationAssets = {}, this._layers = [], this._layerIndices = {}, this._parameters = {}, this._playing = !1, this.unbind(), this._targets = {};
  }
  reset() {
    this._parameters = Object.assign({}, this._stateGraph.parameters);
    for (let e = 0; e < this._layers.length; e++) {
      const t = this._layers[e].playing;
      this._layers[e].reset(), this._layers[e].playing = t;
    }
  }
  unbind() {
    this._normalizeWeights || Object.keys(this._targets).forEach((e) => {
      this._targets[e].unbind();
    });
  }
  rebind() {
    this._targets = {};
    for (let e = 0; e < this._layers.length; e++)
      this._layers[e].rebind();
  }
  findAnimationLayer(e) {
    const t = this._layerIndices[e];
    return this._layers[t] || null;
  }
  addAnimationState(e, t, s = 1, i = !0, n = "Base") {
    this._stateGraph || this.loadStateGraph(new xh({
      layers: [{
        name: n,
        states: [{
          name: "START",
          speed: 1
        }, {
          name: e,
          speed: s,
          loop: i,
          defaultState: !0
        }],
        transitions: [{
          from: "START",
          to: e
        }]
      }],
      parameters: {}
    }));
    const a = this.findAnimationLayer(n);
    if (a)
      a.assignAnimation(e, t, s, i);
    else {
      var o;
      (o = this.addLayer(n)) == null || o.assignAnimation(e, t, s, i);
    }
  }
  assignAnimation(e, t, s, i = 1, n = !0) {
    if (!this._stateGraph && e.indexOf(".") === -1) {
      this.loadStateGraph(new xh({
        layers: [{
          name: "Base",
          states: [{
            name: "START",
            speed: 1
          }, {
            name: e,
            speed: i,
            loop: n,
            defaultState: !0
          }],
          transitions: [{
            from: "START",
            to: e
          }]
        }],
        parameters: {}
      })), this.baseLayer.assignAnimation(e, t);
      return;
    }
    const a = s ? this.findAnimationLayer(s) : this.baseLayer;
    a && a.assignAnimation(e, t, i, n);
  }
  removeNodeAnimations(e, t) {
    const s = t ? this.findAnimationLayer(t) : this.baseLayer;
    s && s.removeNodeAnimations(e);
  }
  getParameterValue(e, t) {
    const s = this._parameters[e];
    if (s && s.type === t)
      return s.value;
  }
  setParameterValue(e, t, s) {
    const i = this._parameters[e];
    if (i && i.type === t) {
      i.value = s;
      return;
    }
  }
  getFloat(e) {
    return this.getParameterValue(e, Jm);
  }
  setFloat(e, t) {
    this.setParameterValue(e, Jm, t);
  }
  getInteger(e) {
    return this.getParameterValue(e, Zm);
  }
  setInteger(e, t) {
    typeof t == "number" && t % 1 === 0 && this.setParameterValue(e, Zm, t);
  }
  getBoolean(e) {
    return this.getParameterValue(e, Qm);
  }
  setBoolean(e, t) {
    this.setParameterValue(e, Qm, !!t);
  }
  getTrigger(e) {
    return this.getParameterValue(e, gh);
  }
  setTrigger(e, t = !1) {
    this.setParameterValue(e, gh, !0), t && this._consumedTriggers.add(e);
  }
  resetTrigger(e) {
    this.setParameterValue(e, gh, !1);
  }
  onBeforeRemove() {
    Number.isFinite(this._stateGraphAsset) && this.system.app.assets.get(this._stateGraphAsset).off("change", this._onStateGraphAssetChangeEvent, this);
  }
  update(e) {
    for (let t = 0; t < this.layers.length; t++)
      this.layers[t].update(e * this.speed);
    this._consumedTriggers.forEach((t) => {
      this.parameters[t].value = !1;
    }), this._consumedTriggers.clear();
  }
  resolveDuplicatedEntityReferenceProperties(e, t) {
    e.rootBone && t[e.rootBone.getGuid()] ? this.rootBone = t[e.rootBone.getGuid()] : this.rebind();
  }
}
class A1 {
  constructor() {
    this.enabled = !0;
  }
}
const Vd = ["enabled"];
class M1 extends Ye {
  constructor(e) {
    super(e), this.id = "anim", this.ComponentType = Dg, this.DataType = A1, this.schema = Vd, this.on("beforeremove", this.onBeforeRemove, this), this.app.systems.on("animationUpdate", this.onAnimationUpdate, this);
  }
  initializeComponentData(e, t, s) {
    super.initializeComponentData(e, t, Vd);
    const i = ["animationAssets", "stateGraph", "layers", "masks"];
    Object.keys(t).forEach((n) => {
      i.includes(n) || (e[n] = t[n]);
    }), t.stateGraph && (e.stateGraph = t.stateGraph, e.loadStateGraph(e.stateGraph)), t.layers ? t.layers.forEach((n, a) => {
      n._controller.states.forEach((o) => {
        n._controller._states[o]._animationList.forEach((h) => {
          e.layers[a].assignAnimation(h.name, h.animTrack);
        });
      });
    }) : t.animationAssets && (e.animationAssets = Object.assign(e.animationAssets, t.animationAssets)), t.masks && Object.keys(t.masks).forEach((n) => {
      if (e.layers[n]) {
        const a = t.masks[n].mask, o = {};
        Object.keys(a).forEach((h) => {
          o[decodeURI(h)] = a[h];
        }), e.layers[n].mask = o;
      }
    });
  }
  onAnimationUpdate(e) {
    const t = this.store;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s].entity.anim;
        i.data.enabled && i.entity.enabled && i.playing && i.update(e);
      }
  }
  cloneComponent(e, t) {
    let s;
    (!e.anim.rootBone || e.anim.rootBone === e) && (s = {}, e.anim.layers.forEach((n, a) => {
      if (n.mask) {
        const o = {};
        Object.keys(n.mask).forEach((h) => {
          const l = h.split("/");
          l.shift();
          const c = [t.name, ...l].join("/");
          o[c] = n.mask[h];
        }), s[a] = {
          mask: o
        };
      }
    }));
    const i = {
      stateGraphAsset: e.anim.stateGraphAsset,
      animationAssets: e.anim.animationAssets,
      speed: e.anim.speed,
      activate: e.anim.activate,
      playing: e.anim.playing,
      rootBone: e.anim.rootBone,
      stateGraph: e.anim.stateGraph,
      layers: e.anim.layers,
      layerIndices: e.anim.layerIndices,
      parameters: e.anim.parameters,
      normalizeWeights: e.anim.normalizeWeights,
      masks: s
    };
    return this.addComponent(t, i);
  }
  onBeforeRemove(e, t) {
    t.onBeforeRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("animationUpdate", this.onAnimationUpdate, this);
  }
}
le._buildAccessors(Dg.prototype, Vd);
class Bg extends le {
  constructor(e, t) {
    super(e, t);
  }
  setCurrentListener() {
    if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
      this.system.current = this.entity;
      const e = this.system.current.getPosition();
      this.system.manager.listener.setPosition(e);
    }
  }
  onEnable() {
    this.setCurrentListener();
  }
  onDisable() {
    this.system.current === this.entity && (this.system.current = null);
  }
}
class E1 {
  constructor() {
    this.enabled = !0;
  }
}
const Fg = ["enabled"];
class R1 extends Ye {
  constructor(e) {
    super(e), this.id = "audiolistener", this.ComponentType = Bg, this.DataType = E1, this.schema = Fg, this.manager = e.soundManager, this.current = null, this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    s = ["enabled"], super.initializeComponentData(e, t, s);
  }
  onUpdate(e) {
    if (this.current) {
      const t = this.current.getPosition();
      this.manager.listener.setPosition(t);
      const s = this.current.getWorldTransform();
      this.manager.listener.setOrientation(s);
    }
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(Bg.prototype, Fg);
class Og extends le {
  constructor(e, t) {
    super(e, t), this.on("set_assets", this.onSetAssets, this), this.on("set_loop", this.onSetLoop, this), this.on("set_volume", this.onSetVolume, this), this.on("set_pitch", this.onSetPitch, this), this.on("set_minDistance", this.onSetMinDistance, this), this.on("set_maxDistance", this.onSetMaxDistance, this), this.on("set_rollOffFactor", this.onSetRollOffFactor, this), this.on("set_distanceModel", this.onSetDistanceModel, this), this.on("set_3d", this.onSet3d, this);
  }
  play(e) {
    if (!this.enabled || !this.entity.enabled)
      return;
    this.channel && this.stop();
    let t;
    const s = this.data;
    if (s.sources[e])
      if (!s["3d"])
        t = this.system.manager.playSound(s.sources[e], s), s.currentSource = e, s.channel = t;
      else {
        const i = this.entity.getPosition();
        t = this.system.manager.playSound3d(s.sources[e], i, s), s.currentSource = e, s.channel = t;
      }
  }
  pause() {
    this.channel && this.channel.pause();
  }
  unpause() {
    this.channel && this.channel.paused && this.channel.unpause();
  }
  stop() {
    this.channel && (this.channel.stop(), this.channel = null);
  }
  onSetAssets(e, t, s) {
    const i = [], n = s.length;
    if (t && t.length) {
      for (let a = 0; a < t.length; a++)
        if (t[a]) {
          const o = this.system.app.assets.get(t[a]);
          o && (o.off("change", this.onAssetChanged, this), o.off("remove", this.onAssetRemoved, this), this.currentSource === o.name && this.stop());
        }
    }
    if (n)
      for (let a = 0; a < n; a++)
        t.indexOf(s[a]) < 0 && (s[a] instanceof ce ? i.push(s[a].id) : i.push(s[a]));
    !this.system._inTools && i.length && this.loadAudioSourceAssets(i);
  }
  onAssetChanged(e, t, s, i) {
    t === "resource" && this.data.sources && (this.data.sources[e.name] = s, this.data.currentSource === e.name && this.channel && (this.channel.paused ? (this.play(e.name), this.pause()) : this.play(e.name)));
  }
  onAssetRemoved(e) {
    e.off("remove", this.onAssetRemoved, this), this.data.sources[e.name] && (delete this.data.sources[e.name], this.data.currentSource === e.name && (this.stop(), this.data.currentSource = null));
  }
  onSetLoop(e, t, s) {
    t !== s && this.channel && this.channel.setLoop(s);
  }
  onSetVolume(e, t, s) {
    t !== s && this.channel && this.channel.setVolume(s);
  }
  onSetPitch(e, t, s) {
    t !== s && this.channel && this.channel.setPitch(s);
  }
  onSetMaxDistance(e, t, s) {
    t !== s && this.channel instanceof Vi && this.channel.setMaxDistance(s);
  }
  onSetMinDistance(e, t, s) {
    t !== s && this.channel instanceof Vi && this.channel.setMinDistance(s);
  }
  onSetRollOffFactor(e, t, s) {
    t !== s && this.channel instanceof Vi && this.channel.setRollOffFactor(s);
  }
  onSetDistanceModel(e, t, s) {
    t !== s && this.channel instanceof Vi && this.channel.setDistanceModel(s);
  }
  onSet3d(e, t, s) {
    if (t !== s && this.system.initialized && this.currentSource) {
      let i = !1, n = !1;
      this.channel && (i = this.channel.paused, n = this.channel.suspended), this.play(this.currentSource), this.channel && (this.channel.paused = i, this.channel.suspended = n);
    }
  }
  onEnable() {
    const e = this.data.assets;
    if (e) {
      const t = this.system.app.assets;
      for (let s = 0, i = e.length; s < i; s++) {
        let n = e[s];
        n instanceof ce || (n = t.get(n)), n && !n.resource && t.load(n);
      }
    }
    this.system.initialized && (this.data.activate && !this.channel ? this.play(this.currentSource) : this.unpause());
  }
  onDisable() {
    this.pause();
  }
  loadAudioSourceAssets(e) {
    const t = e.map((h) => this.system.app.assets.get(h)), s = {};
    let i = null, n = t.length;
    const a = (h) => {
      n--;
    }, o = () => {
      this.data.sources = s, this.data.currentSource = i, this.enabled && this.activate && i && this.onEnable();
    };
    t.forEach((h, l) => {
      h ? (i = i || h.name, h.off("change", this.onAssetChanged, this), h.on("change", this.onAssetChanged, this), h.off("remove", this.onAssetRemoved, this), h.on("remove", this.onAssetRemoved, this), h.off("error", a, this), h.on("error", a, this), h.ready((c) => {
        s[c.name] = c.resource, n--, n === 0 && o();
      }), !h.resource && this.enabled && this.entity.enabled && this.system.app.assets.load(h)) : (n--, n === 0 && o(), this.system.app.assets.on("add:" + e[l], (c) => {
        c.ready((d) => {
          this.data.sources[d.name] = d.resource;
        }), c.resource || this.system.app.assets.load(c);
      }));
    });
  }
}
class L1 {
  constructor() {
    this.enabled = !0, this.assets = [], this.activate = !0, this.volume = 1, this.pitch = 1, this.loop = !1, this["3d"] = !0, this.minDistance = 1, this.maxDistance = 1e4, this.rollOffFactor = 1, this.distanceModel = gl, this.paused = !0, this.sources = {}, this.currentSource = null, this.channel = null;
  }
}
const kg = ["enabled", "assets", "volume", "pitch", "loop", "activate", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "sources", "currentSource", "channel"];
class P1 extends Ye {
  constructor(e) {
    super(e), this.id = "audiosource", this.ComponentType = Og, this.DataType = L1, this.schema = kg, this.manager = e.soundManager, this.initialized = !1, this.app.systems.on("initialize", this.onInitialize, this), this.app.systems.on("update", this.onUpdate, this), this.on("remove", this.onRemove, this);
  }
  initializeComponentData(e, t, s) {
    s = ["activate", "volume", "pitch", "loop", "3d", "minDistance", "maxDistance", "rollOffFactor", "distanceModel", "enabled", "assets"], super.initializeComponentData(e, t, s), e.paused = !(e.enabled && e.activate);
  }
  onInitialize(e) {
    e.audiosource && e.enabled && e.audiosource.enabled && e.audiosource.activate && e.audiosource.play(e.audiosource.currentSource);
    const t = e._children;
    for (let s = 0, i = t.length; s < i; s++)
      t[s] instanceof oe && this.onInitialize(t[s]);
    this.initialized = !0;
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s], n = i.entity, a = i.data;
        if (a.enabled && n.enabled && a.channel instanceof Vi) {
          const o = n.getPosition();
          a.channel.setPosition(o);
        }
      }
  }
  onRemove(e, t) {
    t.channel && (t.channel.stop(), t.channel = null);
  }
  setVolume(e) {
    this.manager.setVolume(e);
  }
  destroy() {
    super.destroy(), this.app.systems.off("initialize", this.onInitialize, this), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(Og.prototype, kg);
class An extends _e {
  constructor(e, t, s) {
    if (super(), !e || !(e instanceof le))
      throw new Error("The parentComponent argument is required and must be a Component");
    if (!t || typeof t != "string")
      throw new Error("The propertyName argument is required and must be a string");
    if (s && typeof s != "object")
      throw new Error("If provided, the eventConfig argument must be an object");
    this._parentComponent = e, this._entityPropertyName = t, this._entity = null, this._app = e.system.app, this._configureEventListeners(s || {}, {
      "entity#destroy": this._onEntityDestroy
    }), this._toggleLifecycleListeners("on");
  }
  _configureEventListeners(e, t) {
    const s = this._parseEventListenerConfig(e, "external", this._parentComponent), i = this._parseEventListenerConfig(t, "internal", this);
    this._eventListenerConfigs = s.concat(i), this._listenerStatusFlags = {}, this._gainListeners = {}, this._loseListeners = {};
  }
  _parseEventListenerConfig(e, t, s) {
    return Object.keys(e).map(function(i, n) {
      const a = i.split("#"), o = a[0], h = a[1], l = e[i];
      if (a.length !== 2 || typeof o != "string" || o.length === 0 || typeof h != "string" || h.length === 0)
        throw new Error("Invalid event listener description: `" + i + "`");
      if (typeof l != "function")
        throw new Error("Invalid or missing callback for event listener `" + i + "`");
      return {
        id: t + "_" + n + "_" + i,
        sourceName: o,
        eventName: h,
        callback: l,
        scope: s
      };
    }, this);
  }
  _toggleLifecycleListeners(e) {
    this._parentComponent[e]("set_" + this._entityPropertyName, this._onSetEntity, this), this._parentComponent.system[e]("beforeremove", this._onParentComponentRemove, this), this._app.systems[e]("postPostInitialize", this._updateEntityReference, this), this._app[e]("tools:sceneloaded", this._onSceneLoaded, this);
    const t = [];
    for (let s = 0; s < this._eventListenerConfigs.length; ++s) {
      const i = this._eventListenerConfigs[s], n = this._app.systems[i.sourceName];
      n && (t.indexOf(n) === -1 && t.push(n), n && i.eventName === "gain" && (this._gainListeners[i.sourceName] = i), n && i.eventName === "lose" && (this._loseListeners[i.sourceName] = i));
    }
    for (let s = 0; s < t.length; ++s)
      t[s][e]("add", this._onComponentAdd, this), t[s][e]("beforeremove", this._onComponentRemove, this);
  }
  _onSetEntity(e, t, s) {
    if (s instanceof oe)
      this._updateEntityReference();
    else {
      if (s != null && typeof s != "string") {
        console.warn("Entity field `" + this._entityPropertyName + "` was set to unexpected type '" + typeof s + "'");
        return;
      }
      t !== s && this._updateEntityReference();
    }
  }
  onParentComponentEnable() {
    this._entity || this._updateEntityReference();
  }
  _onSceneLoaded() {
    this._updateEntityReference();
  }
  _updateEntityReference() {
    let e = this._parentComponent.data[this._entityPropertyName], t;
    if (e instanceof oe)
      t = e, e = t.getGuid(), this._parentComponent.data[this._entityPropertyName] = e;
    else {
      const i = this._parentComponent.system.app.root;
      t = this._parentComponent.entity.isDescendantOf(i) && e ? i.findByGuid(e) : null;
    }
    this._entity !== t && (this._entity && this._onBeforeEntityChange(), this._entity = t, this._entity && this._onAfterEntityChange(), this.fire("set:entity", this._entity));
  }
  _onBeforeEntityChange() {
    this._toggleEntityListeners("off"), this._callAllGainOrLoseListeners(this._loseListeners);
  }
  _onAfterEntityChange() {
    this._toggleEntityListeners("on"), this._callAllGainOrLoseListeners(this._gainListeners);
  }
  _onComponentAdd(e, t) {
    const s = t.system.id;
    e === this._entity && (this._callGainOrLoseListener(s, this._gainListeners), this._toggleComponentListeners("on", s));
  }
  _onComponentRemove(e, t) {
    const s = t.system.id;
    e === this._entity && (this._callGainOrLoseListener(s, this._loseListeners), this._toggleComponentListeners("off", s, !0));
  }
  _callAllGainOrLoseListeners(e) {
    for (const t in this._entity.c)
      this._callGainOrLoseListener(t, e);
  }
  _callGainOrLoseListener(e, t) {
    if (this._entity.c.hasOwnProperty(e) && t[e]) {
      const s = t[e];
      s.callback.call(s.scope);
    }
  }
  _toggleEntityListeners(e, t) {
    if (this._entity)
      for (let s = 0; s < this._eventListenerConfigs.length; ++s)
        this._safeToggleListener(e, this._eventListenerConfigs[s], t);
  }
  _toggleComponentListeners(e, t, s) {
    for (let i = 0; i < this._eventListenerConfigs.length; ++i) {
      const n = this._eventListenerConfigs[i];
      n.sourceName === t && this._safeToggleListener(e, n, s);
    }
  }
  _safeToggleListener(e, t, s) {
    const i = e === "on";
    if (i && this._listenerStatusFlags[t.id])
      return;
    const n = this._getEventSource(t.sourceName, s);
    n && (n[e](t.eventName, t.callback, t.scope), this._listenerStatusFlags[t.id] = i);
  }
  _getEventSource(e, t) {
    if (e === "entity")
      return this._entity;
    const s = this._entity[e];
    return s || (t || console.warn("Entity has no component with name " + e), null);
  }
  _onEntityDestroy(e) {
    this._entity === e && (this._toggleEntityListeners("off", !0), this._entity = null);
  }
  _onParentComponentRemove(e, t) {
    t === this._parentComponent && (this._toggleLifecycleListeners("off"), this._toggleEntityListeners("off", !0));
  }
  hasComponent(e) {
    return this._entity && this._entity.c ? !!this._entity.c[e] : !1;
  }
  get entity() {
    return this._entity;
  }
}
const Gd = 0, tp = 1, vh = "group", Hd = "image", ni = "text", Sh = "stretch", I1 = "contain", D1 = "cover", st = {
  DEFAULT: "DEFAULT",
  HOVER: "HOVER",
  PRESSED: "PRESSED",
  INACTIVE: "INACTIVE"
}, oo = {};
oo[st.DEFAULT] = "_defaultTint";
oo[st.HOVER] = "hoverTint";
oo[st.PRESSED] = "pressedTint";
oo[st.INACTIVE] = "inactiveTint";
const ho = {};
ho[st.DEFAULT] = "_defaultSpriteAsset";
ho[st.HOVER] = "hoverSpriteAsset";
ho[st.PRESSED] = "pressedSpriteAsset";
ho[st.INACTIVE] = "inactiveSpriteAsset";
const lo = {};
lo[st.DEFAULT] = "_defaultSpriteFrame";
lo[st.HOVER] = "hoverSpriteFrame";
lo[st.PRESSED] = "pressedSpriteFrame";
lo[st.INACTIVE] = "inactiveSpriteFrame";
class Ng extends le {
  constructor(e, t) {
    super(e, t), this._visualState = st.DEFAULT, this._isHovering = !1, this._hoveringCounter = 0, this._isPressed = !1, this._defaultTint = new z(1, 1, 1, 1), this._defaultSpriteAsset = null, this._defaultSpriteFrame = 0, this._imageReference = new An(this, "imageEntity", {
      "element#gain": this._onImageElementGain,
      "element#lose": this._onImageElementLose,
      "element#set:color": this._onSetColor,
      "element#set:opacity": this._onSetOpacity,
      "element#set:spriteAsset": this._onSetSpriteAsset,
      "element#set:spriteFrame": this._onSetSpriteFrame
    }), this._toggleLifecycleListeners("on", e);
  }
  _toggleLifecycleListeners(e, t) {
    this[e]("set_active", this._onSetActive, this), this[e]("set_transitionMode", this._onSetTransitionMode, this), this[e]("set_hoverTint", this._onSetTransitionValue, this), this[e]("set_pressedTint", this._onSetTransitionValue, this), this[e]("set_inactiveTint", this._onSetTransitionValue, this), this[e]("set_hoverSpriteAsset", this._onSetTransitionValue, this), this[e]("set_hoverSpriteFrame", this._onSetTransitionValue, this), this[e]("set_pressedSpriteAsset", this._onSetTransitionValue, this), this[e]("set_pressedSpriteFrame", this._onSetTransitionValue, this), this[e]("set_inactiveSpriteAsset", this._onSetTransitionValue, this), this[e]("set_inactiveSpriteFrame", this._onSetTransitionValue, this), t.app.systems.element[e]("add", this._onElementComponentAdd, this), t.app.systems.element[e]("beforeremove", this._onElementComponentRemove, this);
  }
  _onSetActive(e, t, s) {
    t !== s && this._updateVisualState();
  }
  _onSetTransitionMode(e, t, s) {
    t !== s && (this._cancelTween(), this._resetToDefaultVisualState(t), this._forceReapplyVisualState());
  }
  _onSetTransitionValue(e, t, s) {
    t !== s && this._forceReapplyVisualState();
  }
  _onElementComponentRemove(e) {
    this.entity === e && this._toggleHitElementListeners("off");
  }
  _onElementComponentAdd(e) {
    this.entity === e && this._toggleHitElementListeners("on");
  }
  _onImageElementLose() {
    this._cancelTween(), this._resetToDefaultVisualState(this.transitionMode);
  }
  _onImageElementGain() {
    this._storeDefaultVisualState(), this._forceReapplyVisualState();
  }
  _toggleHitElementListeners(e) {
    if (this.entity.element) {
      const t = e === "on";
      if (t && this._hasHitElementListeners)
        return;
      this.entity.element[e]("mouseenter", this._onMouseEnter, this), this.entity.element[e]("mouseleave", this._onMouseLeave, this), this.entity.element[e]("mousedown", this._onMouseDown, this), this.entity.element[e]("mouseup", this._onMouseUp, this), this.entity.element[e]("touchstart", this._onTouchStart, this), this.entity.element[e]("touchend", this._onTouchEnd, this), this.entity.element[e]("touchleave", this._onTouchLeave, this), this.entity.element[e]("touchcancel", this._onTouchCancel, this), this.entity.element[e]("selectstart", this._onSelectStart, this), this.entity.element[e]("selectend", this._onSelectEnd, this), this.entity.element[e]("selectenter", this._onSelectEnter, this), this.entity.element[e]("selectleave", this._onSelectLeave, this), this.entity.element[e]("click", this._onClick, this), this._hasHitElementListeners = t;
    }
  }
  _storeDefaultVisualState() {
    if (this._imageReference.hasComponent("element")) {
      const e = this._imageReference.entity.element;
      e.type !== vh && (this._storeDefaultColor(e.color), this._storeDefaultOpacity(e.opacity), this._storeDefaultSpriteAsset(e.spriteAsset), this._storeDefaultSpriteFrame(e.spriteFrame));
    }
  }
  _storeDefaultColor(e) {
    this._defaultTint.r = e.r, this._defaultTint.g = e.g, this._defaultTint.b = e.b;
  }
  _storeDefaultOpacity(e) {
    this._defaultTint.a = e;
  }
  _storeDefaultSpriteAsset(e) {
    this._defaultSpriteAsset = e;
  }
  _storeDefaultSpriteFrame(e) {
    this._defaultSpriteFrame = e;
  }
  _onSetColor(e) {
    this._isApplyingTint || (this._storeDefaultColor(e), this._forceReapplyVisualState());
  }
  _onSetOpacity(e) {
    this._isApplyingTint || (this._storeDefaultOpacity(e), this._forceReapplyVisualState());
  }
  _onSetSpriteAsset(e) {
    this._isApplyingSprite || (this._storeDefaultSpriteAsset(e), this._forceReapplyVisualState());
  }
  _onSetSpriteFrame(e) {
    this._isApplyingSprite || (this._storeDefaultSpriteFrame(e), this._forceReapplyVisualState());
  }
  _onMouseEnter(e) {
    this._isHovering = !0, this._updateVisualState(), this._fireIfActive("mouseenter", e);
  }
  _onMouseLeave(e) {
    this._isHovering = !1, this._isPressed = !1, this._updateVisualState(), this._fireIfActive("mouseleave", e);
  }
  _onMouseDown(e) {
    this._isPressed = !0, this._updateVisualState(), this._fireIfActive("mousedown", e);
  }
  _onMouseUp(e) {
    this._isPressed = !1, this._updateVisualState(), this._fireIfActive("mouseup", e);
  }
  _onTouchStart(e) {
    this._isPressed = !0, this._updateVisualState(), this._fireIfActive("touchstart", e);
  }
  _onTouchEnd(e) {
    e.event.preventDefault(), this._isPressed = !1, this._updateVisualState(), this._fireIfActive("touchend", e);
  }
  _onTouchLeave(e) {
    this._isPressed = !1, this._updateVisualState(), this._fireIfActive("touchleave", e);
  }
  _onTouchCancel(e) {
    this._isPressed = !1, this._updateVisualState(), this._fireIfActive("touchcancel", e);
  }
  _onSelectStart(e) {
    this._isPressed = !0, this._updateVisualState(), this._fireIfActive("selectstart", e);
  }
  _onSelectEnd(e) {
    this._isPressed = !1, this._updateVisualState(), this._fireIfActive("selectend", e);
  }
  _onSelectEnter(e) {
    this._hoveringCounter++, this._hoveringCounter === 1 && (this._isHovering = !0, this._updateVisualState()), this._fireIfActive("selectenter", e);
  }
  _onSelectLeave(e) {
    this._hoveringCounter--, this._hoveringCounter === 0 && (this._isHovering = !1, this._isPressed = !1, this._updateVisualState()), this._fireIfActive("selectleave", e);
  }
  _onClick(e) {
    this._fireIfActive("click", e);
  }
  _fireIfActive(e, t) {
    this.data.active && this.fire(e, t);
  }
  _updateVisualState(e) {
    const t = this._visualState, s = this._determineVisualState();
    if ((t !== s || e) && this.enabled)
      switch (this._visualState = s, t === st.HOVER && this._fireIfActive("hoverend"), t === st.PRESSED && this._fireIfActive("pressedend"), s === st.HOVER && this._fireIfActive("hoverstart"), s === st.PRESSED && this._fireIfActive("pressedstart"), this.transitionMode) {
        case Gd: {
          const i = oo[this._visualState], n = this[i];
          this._applyTint(n);
          break;
        }
        case tp: {
          const i = ho[this._visualState], n = lo[this._visualState], a = this[i], o = this[n];
          this._applySprite(a, o);
          break;
        }
      }
  }
  _forceReapplyVisualState() {
    this._updateVisualState(!0);
  }
  _resetToDefaultVisualState(e) {
    if (this._imageReference.hasComponent("element"))
      switch (e) {
        case Gd:
          this._cancelTween(), this._applyTintImmediately(this._defaultTint);
          break;
        case tp:
          this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
          break;
      }
  }
  _determineVisualState() {
    if (this.active) {
      if (this._isPressed)
        return st.PRESSED;
      if (this._isHovering)
        return st.HOVER;
    } else
      return st.INACTIVE;
    return st.DEFAULT;
  }
  _applySprite(e, t) {
    t = t || 0, this._imageReference.hasComponent("element") && (this._isApplyingSprite = !0, this._imageReference.entity.element.spriteAsset !== e && (this._imageReference.entity.element.spriteAsset = e), this._imageReference.entity.element.spriteFrame !== t && (this._imageReference.entity.element.spriteFrame = t), this._isApplyingSprite = !1);
  }
  _applyTint(e) {
    this._cancelTween(), this.fadeDuration === 0 ? this._applyTintImmediately(e) : this._applyTintWithTween(e);
  }
  _applyTintImmediately(e) {
    if (!e || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === vh)
      return;
    const t = sp(e);
    this._isApplyingTint = !0, t.equals(this._imageReference.entity.element.color) || (this._imageReference.entity.element.color = t), this._imageReference.entity.element.opacity !== e.a && (this._imageReference.entity.element.opacity = e.a), this._isApplyingTint = !1;
  }
  _applyTintWithTween(e) {
    if (!e || !this._imageReference.hasComponent("element") || this._imageReference.entity.element.type === vh)
      return;
    const t = sp(e), s = this._imageReference.entity.element.color, i = this._imageReference.entity.element.opacity;
    t.equals(s) && e.a === i || (this._tweenInfo = {
      startTime: Xi(),
      from: new z(s.r, s.g, s.b, i),
      to: e.clone(),
      lerpColor: new z()
    });
  }
  _updateTintTween() {
    const e = Xi() - this._tweenInfo.startTime;
    let t = this.fadeDuration === 0 ? 1 : e / this.fadeDuration;
    if (t = U.clamp(t, 0, 1), Math.abs(t - 1) > 1e-5) {
      const s = this._tweenInfo.lerpColor;
      s.lerp(this._tweenInfo.from, this._tweenInfo.to, t), this._applyTintImmediately(new z(s.r, s.g, s.b, s.a));
    } else
      this._applyTintImmediately(this._tweenInfo.to), this._cancelTween();
  }
  _cancelTween() {
    delete this._tweenInfo;
  }
  onUpdate() {
    this._tweenInfo && this._updateTintTween();
  }
  onEnable() {
    this._isHovering = !1, this._hoveringCounter = 0, this._isPressed = !1, this._imageReference.onParentComponentEnable(), this._toggleHitElementListeners("on"), this._forceReapplyVisualState();
  }
  onDisable() {
    this._toggleHitElementListeners("off"), this._resetToDefaultVisualState(this.transitionMode);
  }
  onRemove() {
    this._toggleLifecycleListeners("off", this.system), this.onDisable();
  }
}
function sp(r) {
  return new z(r.r, r.g, r.b);
}
class B1 {
  constructor() {
    this.enabled = !0, this.active = !0, this.imageEntity = null, this.hitPadding = new Z(), this.transitionMode = Gd, this.hoverTint = new z(0.75, 0.75, 0.75), this.pressedTint = new z(0.5, 0.5, 0.5), this.inactiveTint = new z(0.25, 0.25, 0.25), this.fadeDuration = 0, this.hoverSpriteAsset = null, this.hoverSpriteFrame = 0, this.pressedSpriteAsset = null, this.pressedSpriteFrame = 0, this.inactiveSpriteAsset = null, this.inactiveSpriteFrame = 0;
  }
}
const Wd = ["enabled", "active", {
  name: "imageEntity",
  type: "entity"
}, {
  name: "hitPadding",
  type: "vec4"
}, "transitionMode", {
  name: "hoverTint",
  type: "rgba"
}, {
  name: "pressedTint",
  type: "rgba"
}, {
  name: "inactiveTint",
  type: "rgba"
}, "fadeDuration", "hoverSpriteAsset", "hoverSpriteFrame", "pressedSpriteAsset", "pressedSpriteFrame", "inactiveSpriteAsset", "inactiveSpriteFrame"];
class F1 extends Ye {
  constructor(e) {
    super(e), this.id = "button", this.ComponentType = Ng, this.DataType = B1, this.schema = Wd, this.on("beforeremove", this._onRemoveComponent, this), this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    super.initializeComponentData(e, t, Wd);
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t) {
      const i = t[s].entity, n = i.button;
      n.enabled && i.enabled && n.onUpdate();
    }
  }
  _onRemoveComponent(e, t) {
    t.onRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(Ng.prototype, Wd);
const ip = new v(), np = new ee();
class zg extends le {
  constructor(e, t) {
    super(e, t), this._compoundParent = null, this._hasOffset = !1, this.entity.on("insert", this._onInsert, this), this.on("set_type", this.onSetType, this), this.on("set_halfExtents", this.onSetHalfExtents, this), this.on("set_linearOffset", this.onSetOffset, this), this.on("set_angularOffset", this.onSetOffset, this), this.on("set_radius", this.onSetRadius, this), this.on("set_height", this.onSetHeight, this), this.on("set_axis", this.onSetAxis, this), this.on("set_asset", this.onSetAsset, this), this.on("set_renderAsset", this.onSetRenderAsset, this), this.on("set_model", this.onSetModel, this), this.on("set_render", this.onSetRender, this);
  }
  onSetType(e, t, s) {
    t !== s && this.system.changeType(this, t, s);
  }
  onSetHalfExtents(e, t, s) {
    const i = this.data.type;
    this.data.initialized && i === "box" && this.system.recreatePhysicalShapes(this);
  }
  onSetOffset(e, t, s) {
    this._hasOffset = !this.data.linearOffset.equals(v.ZERO) || !this.data.angularOffset.equals(ee.IDENTITY), this.data.initialized && this.system.recreatePhysicalShapes(this);
  }
  onSetRadius(e, t, s) {
    const i = this.data.type;
    this.data.initialized && (i === "sphere" || i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this);
  }
  onSetHeight(e, t, s) {
    const i = this.data.type;
    this.data.initialized && (i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this);
  }
  onSetAxis(e, t, s) {
    const i = this.data.type;
    this.data.initialized && (i === "capsule" || i === "cylinder" || i === "cone") && this.system.recreatePhysicalShapes(this);
  }
  onSetAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && n.off("remove", this.onAssetRemoved, this);
    }
    if (s) {
      s instanceof ce && (this.data.asset = s.id);
      const n = i.get(this.data.asset);
      n && (n.off("remove", this.onAssetRemoved, this), n.on("remove", this.onAssetRemoved, this));
    }
    this.data.initialized && this.data.type === "mesh" && (s || (this.data.model = null), this.system.recreatePhysicalShapes(this));
  }
  onSetRenderAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && n.off("remove", this.onRenderAssetRemoved, this);
    }
    if (s) {
      s instanceof ce && (this.data.renderAsset = s.id);
      const n = i.get(this.data.renderAsset);
      n && (n.off("remove", this.onRenderAssetRemoved, this), n.on("remove", this.onRenderAssetRemoved, this));
    }
    this.data.initialized && this.data.type === "mesh" && (s || (this.data.render = null), this.system.recreatePhysicalShapes(this));
  }
  onSetModel(e, t, s) {
    this.data.initialized && this.data.type === "mesh" && this.system.implementations.mesh.doRecreatePhysicalShape(this);
  }
  onSetRender(e, t, s) {
    this.onSetModel(e, t, s);
  }
  onAssetRemoved(e) {
    e.off("remove", this.onAssetRemoved, this), this.data.asset === e.id && (this.asset = null);
  }
  onRenderAssetRemoved(e) {
    e.off("remove", this.onRenderAssetRemoved, this), this.data.renderAsset === e.id && (this.renderAsset = null);
  }
  _getCompoundChildShapeIndex(e) {
    const t = this.data.shape, s = t.getNumChildShapes();
    for (let i = 0; i < s; i++)
      if (t.getChildShape(i).ptr === e.ptr)
        return i;
    return null;
  }
  _onInsert(e) {
    if (!(typeof Ammo > "u")) {
      if (this._compoundParent)
        this.system.recreatePhysicalShapes(this);
      else if (!this.entity.rigidbody) {
        let t = this.entity.parent;
        for (; t; ) {
          if (t.collision && t.collision.type === "compound") {
            t.collision.shape.getNumChildShapes() === 0 ? this.system.recreatePhysicalShapes(t.collision) : this.system.recreatePhysicalShapes(this);
            break;
          }
          t = t.parent;
        }
      }
    }
  }
  _updateCompound() {
    const e = this.entity;
    if (e._dirtyWorld) {
      let t = e._dirtyLocal, s = e;
      for (; s && !t && !(s.collision && s.collision === this._compoundParent); )
        s._dirtyLocal && (t = !0), s = s.parent;
      if (t) {
        e.forEach(this.system.implementations.compound._updateEachDescendantTransform, e);
        const i = this._compoundParent.entity.rigidbody;
        i && i.activate();
      }
    }
  }
  getShapePosition() {
    const e = this.entity.getPosition();
    if (this._hasOffset) {
      const t = this.entity.getRotation(), s = this.data.linearOffset;
      return np.copy(t).transformVector(s, ip), ip.add(e);
    }
    return e;
  }
  getShapeRotation() {
    const e = this.entity.getRotation();
    return this._hasOffset ? np.copy(e).mul(this.data.angularOffset) : e;
  }
  onEnable() {
    if (this.data.type === "mesh" && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
      const e = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
      if (e && (!e.resource || !this.data.shape)) {
        this.system.recreatePhysicalShapes(this);
        return;
      }
    }
    if (this.entity.rigidbody)
      this.entity.rigidbody.enabled && this.entity.rigidbody.enableSimulation();
    else if (this._compoundParent && this !== this._compoundParent)
      if (this._compoundParent.shape.getNumChildShapes() === 0)
        this.system.recreatePhysicalShapes(this._compoundParent);
      else {
        const e = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
        this._compoundParent.shape.addChildShape(e, this.data.shape), Ammo.destroy(e), this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate();
      }
    else
      this.entity.trigger && this.entity.trigger.enable();
  }
  onDisable() {
    this.entity.rigidbody ? this.entity.rigidbody.disableSimulation() : this._compoundParent && this !== this._compoundParent ? this._compoundParent.entity._destroying || (this.system._removeCompoundChild(this._compoundParent, this.data.shape), this._compoundParent.entity.rigidbody && this._compoundParent.entity.rigidbody.activate()) : this.entity.trigger && this.entity.trigger.disable();
  }
  onBeforeRemove() {
    this.asset && (this.asset = null), this.renderAsset && (this.renderAsset = null), this.entity.off("insert", this._onInsert, this), this.off();
  }
}
class O1 {
  constructor() {
    this.enabled = !0, this.type = "box", this.halfExtents = new v(0.5, 0.5, 0.5), this.linearOffset = new v(), this.angularOffset = new ee(), this.radius = 0.5, this.axis = 1, this.height = 2, this.asset = null, this.renderAsset = null, this.shape = null, this.model = null, this.render = null, this.initialized = !1;
  }
}
const pa = "static", Ss = "dynamic", sr = "kinematic", k1 = 2, Sa = 4, qd = 1, rp = 4, Ug = 5, N1 = 1, ap = 2, z1 = 4, op = 16, hp = 65535, Xd = 65533;
let bs, hn, ir;
class Vg {
  constructor(e, t, s) {
    this.entity = t.entity, this.component = t, this.app = e, typeof Ammo < "u" && !bs && (bs = new Ammo.btVector3(), hn = new Ammo.btQuaternion(), ir = new Ammo.btTransform()), this.initialize(s);
  }
  initialize(e) {
    const t = this.entity, s = e.shape;
    if (s && typeof Ammo < "u") {
      t.trigger && t.trigger.destroy();
      const i = 1, n = this.component;
      if (n) {
        const o = n.getShapePosition(), h = n.getShapeRotation();
        bs.setValue(o.x, o.y, o.z), hn.setValue(h.x, h.y, h.z, h.w);
      } else {
        const o = t.getPosition(), h = t.getRotation();
        bs.setValue(o.x, o.y, o.z), hn.setValue(h.x, h.y, h.z, h.w);
      }
      ir.setOrigin(bs), ir.setRotation(hn);
      const a = this.app.systems.rigidbody.createBody(i, s, ir);
      a.setRestitution(0), a.setFriction(0), a.setDamping(0, 0), bs.setValue(0, 0, 0), a.setLinearFactor(bs), a.setAngularFactor(bs), a.setCollisionFlags(a.getCollisionFlags() | Sa), a.entity = t, this.body = a, this.component.enabled && t.enabled && this.enable();
    }
  }
  destroy() {
    const e = this.body;
    e && (this.disable(), this.app.systems.rigidbody.destroyBody(e));
  }
  _getEntityTransform(e) {
    const t = this.component;
    if (t) {
      const s = t.getShapePosition(), i = t.getShapeRotation();
      bs.setValue(s.x, s.y, s.z), hn.setValue(i.x, i.y, i.z, i.w);
    } else {
      const s = this.entity.getPosition(), i = this.entity.getRotation();
      bs.setValue(s.x, s.y, s.z), hn.setValue(i.x, i.y, i.z, i.w);
    }
    e.setOrigin(bs), e.setRotation(hn);
  }
  updateTransform() {
    this._getEntityTransform(ir);
    const e = this.body;
    e.setWorldTransform(ir), e.activate();
  }
  enable() {
    const e = this.body;
    if (!e)
      return;
    const t = this.app.systems;
    t.rigidbody.addBody(e, op, Xd ^ op), t.rigidbody._triggers.push(this), e.forceActivationState(qd), this.updateTransform();
  }
  disable() {
    const e = this.body;
    if (!e)
      return;
    const t = this.app.systems, s = t.rigidbody._triggers.indexOf(this);
    s > -1 && t.rigidbody._triggers.splice(s, 1), t.rigidbody.removeBody(e), e.forceActivationState(Ug);
  }
}
const Xo = new j(), nr = new v(), ln = new ee(), U1 = new bt(), Gg = ["enabled", "type", "halfExtents", "linearOffset", "angularOffset", "radius", "axis", "height", "asset", "renderAsset", "shape", "model", "render"];
class Gn {
  constructor(e) {
    this.system = e;
  }
  beforeInitialize(e, t) {
    t.shape = null, t.model = new Ti(), t.model.graph = new bt();
  }
  afterInitialize(e, t) {
    this.recreatePhysicalShapes(e), e.data.initialized = !0;
  }
  reset(e, t) {
    this.beforeInitialize(e, t), this.afterInitialize(e, t);
  }
  recreatePhysicalShapes(e) {
    const t = e.entity, s = e.data;
    if (typeof Ammo < "u") {
      t.trigger && (t.trigger.destroy(), delete t.trigger), s.shape && (e._compoundParent && (this.system._removeCompoundChild(e._compoundParent, s.shape), e._compoundParent.entity.rigidbody && e._compoundParent.entity.rigidbody.activate()), Ammo.destroy(s.shape), s.shape = null), s.shape = this.createPhysicalShape(e.entity, s);
      const i = !e._compoundParent;
      if (s.type === "compound" && (!e._compoundParent || e === e._compoundParent))
        e._compoundParent = e, t.forEach(this._addEachDescendant, e);
      else if (s.type !== "compound" && (e._compoundParent && e === e._compoundParent && t.forEach(this.system.implementations.compound._updateEachDescendant, e), !e.rigidbody)) {
        e._compoundParent = null;
        let n = t.parent;
        for (; n; ) {
          if (n.collision && n.collision.type === "compound") {
            e._compoundParent = n.collision;
            break;
          }
          n = n.parent;
        }
      }
      e._compoundParent && e !== e._compoundParent && (i && e._compoundParent.shape.getNumChildShapes() === 0 ? this.system.recreatePhysicalShapes(e._compoundParent) : (this.system.updateCompoundChildTransform(t), e._compoundParent.entity.rigidbody && e._compoundParent.entity.rigidbody.activate())), t.rigidbody ? (t.rigidbody.disableSimulation(), t.rigidbody.createBody(), t.enabled && t.rigidbody.enabled && t.rigidbody.enableSimulation()) : e._compoundParent || (t.trigger ? t.trigger.initialize(s) : t.trigger = new Vg(this.system.app, e, s));
    }
  }
  createPhysicalShape(e, t) {
  }
  updateTransform(e, t, s, i) {
    e.entity.trigger && e.entity.trigger.updateTransform();
  }
  beforeRemove(e, t) {
    t.data.shape && (t._compoundParent && !t._compoundParent.entity._destroying && (this.system._removeCompoundChild(t._compoundParent, t.data.shape), t._compoundParent.entity.rigidbody && t._compoundParent.entity.rigidbody.activate()), t._compoundParent = null, Ammo.destroy(t.data.shape), t.data.shape = null);
  }
  remove(e, t) {
    e.rigidbody && e.rigidbody.body && e.rigidbody.disableSimulation(), e.trigger && (e.trigger.destroy(), delete e.trigger);
  }
  clone(e, t) {
    const s = this.system.store[e.getGuid()], i = {
      enabled: s.data.enabled,
      type: s.data.type,
      halfExtents: [s.data.halfExtents.x, s.data.halfExtents.y, s.data.halfExtents.z],
      linearOffset: [s.data.linearOffset.x, s.data.linearOffset.y, s.data.linearOffset.z],
      angularOffset: [s.data.angularOffset.x, s.data.angularOffset.y, s.data.angularOffset.z, s.data.angularOffset.w],
      radius: s.data.radius,
      axis: s.data.axis,
      height: s.data.height,
      asset: s.data.asset,
      renderAsset: s.data.renderAsset,
      model: s.data.model,
      render: s.data.render
    };
    return this.system.addComponent(t, i);
  }
}
class V1 extends Gn {
  createPhysicalShape(e, t) {
    if (typeof Ammo < "u") {
      const s = t.halfExtents, i = new Ammo.btVector3(s ? s.x : 0.5, s ? s.y : 0.5, s ? s.z : 0.5), n = new Ammo.btBoxShape(i);
      return Ammo.destroy(i), n;
    }
  }
}
class G1 extends Gn {
  createPhysicalShape(e, t) {
    if (typeof Ammo < "u")
      return new Ammo.btSphereShape(t.radius);
  }
}
class H1 extends Gn {
  createPhysicalShape(e, t) {
    const s = t.axis !== void 0 ? t.axis : 1, i = t.radius || 0.5, n = Math.max((t.height || 2) - 2 * i, 0);
    let a = null;
    if (typeof Ammo < "u")
      switch (s) {
        case 0:
          a = new Ammo.btCapsuleShapeX(i, n);
          break;
        case 1:
          a = new Ammo.btCapsuleShape(i, n);
          break;
        case 2:
          a = new Ammo.btCapsuleShapeZ(i, n);
          break;
      }
    return a;
  }
}
class W1 extends Gn {
  createPhysicalShape(e, t) {
    const s = t.axis !== void 0 ? t.axis : 1, i = t.radius !== void 0 ? t.radius : 0.5, n = t.height !== void 0 ? t.height : 1;
    let a = null, o = null;
    if (typeof Ammo < "u")
      switch (s) {
        case 0:
          a = new Ammo.btVector3(n * 0.5, i, i), o = new Ammo.btCylinderShapeX(a);
          break;
        case 1:
          a = new Ammo.btVector3(i, n * 0.5, i), o = new Ammo.btCylinderShape(a);
          break;
        case 2:
          a = new Ammo.btVector3(i, i, n * 0.5), o = new Ammo.btCylinderShapeZ(a);
          break;
      }
    return a && Ammo.destroy(a), o;
  }
}
class q1 extends Gn {
  createPhysicalShape(e, t) {
    const s = t.axis !== void 0 ? t.axis : 1, i = t.radius !== void 0 ? t.radius : 0.5, n = t.height !== void 0 ? t.height : 1;
    let a = null;
    if (typeof Ammo < "u")
      switch (s) {
        case 0:
          a = new Ammo.btConeShapeX(i, n);
          break;
        case 1:
          a = new Ammo.btConeShape(i, n);
          break;
        case 2:
          a = new Ammo.btConeShapeZ(i, n);
          break;
      }
    return a;
  }
}
class X1 extends Gn {
  beforeInitialize(e, t) {
  }
  createAmmoMesh(e, t, s) {
    let i;
    if (this.system._triMeshCache[e.id])
      i = this.system._triMeshCache[e.id];
    else {
      const l = e.vertexBuffer, c = l.getFormat();
      let d, u;
      for (let C = 0; C < c.elements.length; C++) {
        const w = c.elements[C];
        if (w.name === et) {
          u = new Float32Array(l.lock(), w.offset), d = w.stride / 4;
          break;
        }
      }
      const f = [];
      e.getIndices(f);
      const m = e.primitive[0].count / 3, _ = new Ammo.btVector3(), p = new Ammo.btVector3(), g = new Ammo.btVector3();
      let b, x, y;
      const S = e.primitive[0].base;
      i = new Ammo.btTriangleMesh(), this.system._triMeshCache[e.id] = i;
      for (let C = 0; C < m; C++)
        b = f[S + C * 3] * d, x = f[S + C * 3 + 1] * d, y = f[S + C * 3 + 2] * d, _.setValue(u[b], u[b + 1], u[b + 2]), p.setValue(u[x], u[x + 1], u[x + 2]), g.setValue(u[y], u[y + 1], u[y + 2]), i.addTriangle(_, p, g, !0);
      Ammo.destroy(_), Ammo.destroy(p), Ammo.destroy(g);
    }
    const n = !0, a = new Ammo.btBvhTriangleMeshShape(i, n), o = this.system._getNodeScaling(t);
    a.setLocalScaling(o), Ammo.destroy(o);
    const h = this.system._getNodeTransform(t);
    s.addChildShape(h, a), Ammo.destroy(h);
  }
  createPhysicalShape(e, t) {
    if (!(typeof Ammo > "u") && (t.model || t.render)) {
      const s = new Ammo.btCompoundShape();
      if (t.model) {
        const o = t.model.meshInstances;
        for (let h = 0; h < o.length; h++)
          this.createAmmoMesh(o[h].mesh, o[h].node, s);
      } else if (t.render) {
        const o = t.render.meshes;
        for (let h = 0; h < o.length; h++)
          this.createAmmoMesh(o[h], U1, s);
      }
      const n = e.getWorldTransform().getScale(), a = new Ammo.btVector3(n.x, n.y, n.z);
      return s.setLocalScaling(a), Ammo.destroy(a), s;
    }
  }
  recreatePhysicalShapes(e) {
    const t = e.data;
    if ((t.renderAsset || t.asset) && e.enabled && e.entity.enabled) {
      this.loadAsset(e, t.renderAsset || t.asset, t.renderAsset ? "render" : "model");
      return;
    }
    this.doRecreatePhysicalShape(e);
  }
  loadAsset(e, t, s) {
    const i = e.data, n = this.system.app.assets, a = n.get(t);
    a ? (a.ready((o) => {
      i[s] = o.resource, this.doRecreatePhysicalShape(e);
    }), n.load(a)) : n.once("add:" + t, (o) => {
      o.ready((h) => {
        i[s] = h.resource, this.doRecreatePhysicalShape(e);
      }), n.load(o);
    });
  }
  doRecreatePhysicalShape(e) {
    const t = e.entity, s = e.data;
    s.model || s.render ? (this.destroyShape(s), s.shape = this.createPhysicalShape(t, s), t.rigidbody ? (t.rigidbody.disableSimulation(), t.rigidbody.createBody(), t.enabled && t.rigidbody.enabled && t.rigidbody.enableSimulation()) : t.trigger ? t.trigger.initialize(s) : t.trigger = new Vg(this.system.app, e, s)) : (this.beforeRemove(t, e), this.remove(t, s));
  }
  updateTransform(e, t, s, i) {
    if (e.shape) {
      const a = e.entity.getWorldTransform().getScale(), o = e.shape.getLocalScaling();
      (a.x !== o.x() || a.y !== o.y() || a.z !== o.z()) && this.doRecreatePhysicalShape(e);
    }
    super.updateTransform(e, t, s, i);
  }
  destroyShape(e) {
    if (!e.shape)
      return;
    const t = e.shape.getNumChildShapes();
    for (let s = 0; s < t; s++) {
      const i = e.shape.getChildShape(s);
      Ammo.destroy(i);
    }
    Ammo.destroy(e.shape), e.shape = null;
  }
  remove(e, t) {
    this.destroyShape(t), super.remove(e, t);
  }
}
class j1 extends Gn {
  createPhysicalShape(e, t) {
    if (typeof Ammo < "u")
      return new Ammo.btCompoundShape();
  }
  _addEachDescendant(e) {
    !e.collision || e.rigidbody || (e.collision._compoundParent = this, e !== this.entity && e.collision.system.recreatePhysicalShapes(e.collision));
  }
  _updateEachDescendant(e) {
    e.collision && e.collision._compoundParent === this && (e.collision._compoundParent = null, e !== this.entity && !e.rigidbody && e.collision.system.recreatePhysicalShapes(e.collision));
  }
  _updateEachDescendantTransform(e) {
    !e.collision || e.collision._compoundParent !== this.collision._compoundParent || this.collision.system.updateCompoundChildTransform(e);
  }
}
class $1 extends Ye {
  constructor(e) {
    super(e), this.id = "collision", this.ComponentType = zg, this.DataType = O1, this.schema = Gg, this.implementations = {}, this._triMeshCache = {}, this.on("beforeremove", this.onBeforeRemove, this), this.on("remove", this.onRemove, this);
  }
  initializeComponentData(e, t, s) {
    s = ["type", "halfExtents", "radius", "axis", "height", "shape", "model", "asset", "render", "renderAsset", "enabled", "linearOffset", "angularOffset"];
    const i = {};
    for (let o = 0, h = s.length; o < h; o++) {
      const l = s[o];
      i[l] = t[l];
    }
    let n;
    if (t.hasOwnProperty("asset") ? (n = s.indexOf("model"), n !== -1 && s.splice(n, 1), n = s.indexOf("render"), n !== -1 && s.splice(n, 1)) : t.hasOwnProperty("model") && (n = s.indexOf("asset"), n !== -1 && s.splice(n, 1)), i.type || (i.type = e.data.type), e.data.type = i.type, Array.isArray(i.halfExtents) && (i.halfExtents = new v(i.halfExtents)), Array.isArray(i.linearOffset) && (i.linearOffset = new v(i.linearOffset)), Array.isArray(i.angularOffset)) {
      const o = i.angularOffset;
      o.length === 3 ? i.angularOffset = new ee().setFromEulerAngles(o[0], o[1], o[2]) : i.angularOffset = new ee(i.angularOffset);
    }
    const a = this._createImplementation(i.type);
    a.beforeInitialize(e, i), super.initializeComponentData(e, i, s), a.afterInitialize(e, i);
  }
  _createImplementation(e) {
    if (this.implementations[e] === void 0) {
      let t;
      switch (e) {
        case "box":
          t = new V1(this);
          break;
        case "sphere":
          t = new G1(this);
          break;
        case "capsule":
          t = new H1(this);
          break;
        case "cylinder":
          t = new W1(this);
          break;
        case "cone":
          t = new q1(this);
          break;
        case "mesh":
          t = new X1(this);
          break;
        case "compound":
          t = new j1(this);
          break;
      }
      this.implementations[e] = t;
    }
    return this.implementations[e];
  }
  _getImplementation(e) {
    return this.implementations[e.collision.data.type];
  }
  cloneComponent(e, t) {
    return this._getImplementation(e).clone(e, t);
  }
  onBeforeRemove(e, t) {
    this.implementations[t.data.type].beforeRemove(e, t), t.onBeforeRemove();
  }
  onRemove(e, t) {
    this.implementations[t.type].remove(e, t);
  }
  updateCompoundChildTransform(e) {
    if (this._removeCompoundChild(e.collision._compoundParent, e.collision.data.shape), e.enabled && e.collision.enabled) {
      const t = this._getNodeTransform(e, e.collision._compoundParent.entity);
      e.collision._compoundParent.shape.addChildShape(t, e.collision.data.shape), Ammo.destroy(t);
    }
  }
  _removeCompoundChild(e, t) {
    if (e.shape.removeChildShape)
      e.shape.removeChildShape(t);
    else {
      const s = e._getCompoundChildShapeIndex(t);
      s !== null && e.shape.removeChildShapeByIndex(s);
    }
  }
  onTransformChanged(e, t, s, i) {
    this.implementations[e.data.type].updateTransform(e, t, s, i);
  }
  changeType(e, t, s) {
    this.implementations[t].beforeRemove(e.entity, e), this.implementations[t].remove(e.entity, e.data), this._createImplementation(s).reset(e, e.data);
  }
  recreatePhysicalShapes(e) {
    this.implementations[e.data.type].recreatePhysicalShapes(e);
  }
  _calculateNodeRelativeTransform(e, t) {
    if (e === t) {
      const s = e.getWorldTransform().getScale();
      Xo.setScale(s.x, s.y, s.z);
    } else
      this._calculateNodeRelativeTransform(e.parent, t), Xo.mul(e.getLocalTransform());
  }
  _getNodeScaling(e) {
    const s = e.getWorldTransform().getScale();
    return new Ammo.btVector3(s.x, s.y, s.z);
  }
  _getNodeTransform(e, t) {
    let s, i;
    t ? (this._calculateNodeRelativeTransform(e, t), s = nr, i = ln, Xo.getTranslation(s), i.setFromMat4(Xo)) : (s = e.getPosition(), i = e.getRotation());
    const n = new Ammo.btQuaternion(), a = new Ammo.btTransform();
    a.setIdentity();
    const o = a.getOrigin(), h = e.collision;
    if (h && h._hasOffset) {
      const l = h.data.linearOffset, c = h.data.angularOffset;
      ln.copy(i).transformVector(l, nr), nr.add(s), ln.copy(i).mul(c), o.setValue(nr.x, nr.y, nr.z), n.setValue(ln.x, ln.y, ln.z, ln.w);
    } else
      o.setValue(s.x, s.y, s.z), n.setValue(i.x, i.y, i.z, i.w);
    return a.setRotation(n), Ammo.destroy(n), Ammo.destroy(o), a;
  }
  destroy() {
    for (const e in this._triMeshCache)
      Ammo.destroy(this._triMeshCache[e]);
    this._triMeshCache = null, super.destroy();
  }
}
le._buildAccessors(zg.prototype, Gg);
class Y1 {
  constructor(e, t, s) {
    this._entity = e, this._element = e.element, this.model = new Ti(), this.node = new bt(), this.model.graph = this.node, this.mesh = t, this.meshInstance = new we(this.mesh, s, this.node), this.meshInstance.name = "ImageElement: " + e.name, this.meshInstance.castShadow = !1, this.meshInstance.receiveShadow = !1, this._meshDirty = !1, this.model.meshInstances.push(this.meshInstance), this._entity.addChild(this.model.graph), this.model._entity = this._entity, this.unmaskMeshInstance = null;
  }
  destroy() {
    this.setMaterial(null), this._element.removeModelFromLayers(this.model), this.model.destroy(), this.model = null, this.node = null, this.mesh = null, this.meshInstance = null, this._entity = null, this._element = null;
  }
  setMesh(e) {
    this.meshInstance && (this.mesh = e, this.meshInstance.mesh = e, this.meshInstance.visible = !!e, this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = e), this.forceUpdateAabb());
  }
  setMask(e) {
    if (this.meshInstance) {
      if (e) {
        this.unmaskMeshInstance = new we(this.mesh, this.meshInstance.material, this.node), this.unmaskMeshInstance.name = "Unmask: " + this._entity.name, this.unmaskMeshInstance.castShadow = !1, this.unmaskMeshInstance.receiveShadow = !1, this.unmaskMeshInstance.pick = !1, this.model.meshInstances.push(this.unmaskMeshInstance);
        for (const t in this.meshInstance.parameters)
          this.unmaskMeshInstance.setParameter(t, this.meshInstance.parameters[t].data);
      } else {
        const t = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
        t >= 0 && this.model.meshInstances.splice(t, 1), this.unmaskMeshInstance = null;
      }
      this._entity.enabled && this._element.enabled && (this._element.removeModelFromLayers(this.model), this._element.addModelToLayers(this.model));
    }
  }
  setMaterial(e) {
    this.meshInstance && (this.meshInstance.material = e, this.unmaskMeshInstance && (this.unmaskMeshInstance.material = e));
  }
  setParameter(e, t) {
    this.meshInstance && (this.meshInstance.setParameter(e, t), this.unmaskMeshInstance && this.unmaskMeshInstance.setParameter(e, t));
  }
  deleteParameter(e) {
    this.meshInstance && (this.meshInstance.deleteParameter(e), this.unmaskMeshInstance && this.unmaskMeshInstance.deleteParameter(e));
  }
  setUnmaskDrawOrder() {
    if (!this.meshInstance)
      return;
    const e = function t(s) {
      let i;
      const n = s.children, a = n.length;
      if (a) {
        for (let h = 0; h < a; h++)
          n[h].element && (i = n[h]);
        if (!i)
          return null;
        const o = t(i);
        return o || i;
      }
      return null;
    };
    if (this.unmaskMeshInstance) {
      const t = e(this._entity);
      t && t.element ? this.unmaskMeshInstance.drawOrder = t.element.drawOrder + t.element.getMaskOffset() : this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
    }
  }
  setDrawOrder(e) {
    this.meshInstance && (this.meshInstance.drawOrder = e);
  }
  setCull(e) {
    if (!this.meshInstance)
      return;
    const t = this._element;
    let s = null;
    e && t._isScreenSpace() && (s = function(i) {
      return t.isVisibleForCamera(i);
    }), this.meshInstance.cull = e, this.meshInstance.isVisibleFunc = s, this.unmaskMeshInstance && (this.unmaskMeshInstance.cull = e, this.unmaskMeshInstance.isVisibleFunc = s);
  }
  setScreenSpace(e) {
    this.meshInstance && (this.meshInstance.screenSpace = e, this.unmaskMeshInstance && (this.unmaskMeshInstance.screenSpace = e));
  }
  setLayer(e) {
    this.meshInstance && (this.meshInstance.layer = e, this.unmaskMeshInstance && (this.unmaskMeshInstance.layer = e));
  }
  forceUpdateAabb(e) {
    this.meshInstance && (this.meshInstance._aabbVer = -1, this.unmaskMeshInstance && (this.unmaskMeshInstance._aabbVer = -1));
  }
  setAabbFunc(e) {
    this.meshInstance && (this.meshInstance._updateAabbFunc = e, this.unmaskMeshInstance && (this.unmaskMeshInstance._updateAabbFunc = e));
  }
}
class K1 {
  constructor(e) {
    this._element = e, this._entity = e.entity, this._system = e.system, this._textureAsset = null, this._texture = null, this._materialAsset = null, this._material = null, this._spriteAsset = null, this._sprite = null, this._spriteFrame = 0, this._pixelsPerUnit = null, this._targetAspectRatio = -1, this._rect = new Z(0, 0, 1, 1), this._mask = !1, this._maskRef = 0, this._outerScale = new q(), this._outerScaleUniform = new Float32Array(2), this._innerOffset = new Z(), this._innerOffsetUniform = new Float32Array(4), this._atlasRect = new Z(), this._atlasRectUniform = new Float32Array(4), this._defaultMesh = this._createMesh(), this._renderable = new Y1(this._entity, this._defaultMesh, this._material), this._color = new z(1, 1, 1, 1), this._colorUniform = new Float32Array([1, 1, 1]), this._renderable.setParameter("material_emissive", this._colorUniform), this._renderable.setParameter("material_opacity", 1), this._updateAabbFunc = this._updateAabb.bind(this), this._onScreenChange(this._element.screen), this._element.on("resize", this._onParentResizeOrPivotChange, this), this._element.on("set:pivot", this._onParentResizeOrPivotChange, this), this._element.on("screen:set:screenspace", this._onScreenSpaceChange, this), this._element.on("set:screen", this._onScreenChange, this), this._element.on("set:draworder", this._onDrawOrderChange, this), this._element.on("screen:set:resolution", this._onResolutionChange, this);
  }
  destroy() {
    this.textureAsset = null, this.spriteAsset = null, this.materialAsset = null, this._renderable.setMesh(this._defaultMesh), this._renderable.destroy(), this._defaultMesh = null, this._element.off("resize", this._onParentResizeOrPivotChange, this), this._element.off("set:pivot", this._onParentResizeOrPivotChange, this), this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this), this._element.off("set:screen", this._onScreenChange, this), this._element.off("set:draworder", this._onDrawOrderChange, this), this._element.off("screen:set:resolution", this._onResolutionChange, this);
  }
  _onResolutionChange(e) {
  }
  _onParentResizeOrPivotChange() {
    this._renderable.mesh && this._updateMesh(this._renderable.mesh);
  }
  _onScreenSpaceChange(e) {
    this._updateMaterial(e);
  }
  _onScreenChange(e, t) {
    e ? this._updateMaterial(e.screen.screenSpace) : this._updateMaterial(!1);
  }
  _onDrawOrderChange(e) {
    this._renderable.setDrawOrder(e), this.mask && this._element.screen && this._element.screen.screen.once("syncdraworder", function() {
      this._renderable.setUnmaskDrawOrder();
    }, this);
  }
  _hasUserMaterial() {
    return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
  }
  _use9Slicing() {
    return this.sprite && (this.sprite.renderMode === ht || this.sprite.renderMode === it);
  }
  _updateMaterial(e) {
    const t = !!this._mask, s = !!(this.sprite && this.sprite.renderMode === ht), i = !!(this.sprite && this.sprite.renderMode === it);
    this._hasUserMaterial() || (this._material = this._system.getImageElementMaterial(e, t, s, i)), this._renderable && (this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled()), this._renderable.setMaterial(this._material), this._renderable.setScreenSpace(e), this._renderable.setLayer(e ? av : j_));
  }
  _createMesh() {
    const e = this._element, t = e.calculatedWidth, s = e.calculatedHeight, i = this._rect, n = new ArrayBuffer(4 * 8 * 4), a = new Float32Array(n);
    a[5] = 1, a[6] = i.x, a[7] = 1 - i.y, a[8] = t, a[13] = 1, a[14] = i.x + i.z, a[15] = 1 - i.y, a[16] = t, a[17] = s, a[21] = 1, a[22] = i.x + i.z, a[23] = 1 - (i.y + i.w), a[25] = s, a[29] = 1, a[30] = i.x, a[31] = 1 - (i.y + i.w);
    const o = [{
      semantic: et,
      components: 3,
      type: Ie
    }, {
      semantic: Gt,
      components: 3,
      type: Ie
    }, {
      semantic: rs,
      components: 2,
      type: Ie
    }], h = this._system.app.graphicsDevice, l = new Ot(h, o), c = new yi(h, l, 4, ns, n), d = new _s(h);
    return d.vertexBuffer = c, d.primitive[0].type = Dn, d.primitive[0].base = 0, d.primitive[0].count = 4, d.primitive[0].indexed = !1, d.aabb.setMinMax(v.ZERO, new v(t, s, 0)), this._updateMesh(d), d;
  }
  _updateMesh(e) {
    const t = this._element;
    let s = t.calculatedWidth, i = t.calculatedHeight;
    if (t.fitMode !== Sh && this._targetAspectRatio > 0) {
      const a = t.calculatedWidth / t.calculatedHeight;
      t.fitMode === I1 && a > this._targetAspectRatio || t.fitMode === D1 && a < this._targetAspectRatio ? s = t.calculatedHeight * this._targetAspectRatio : i = t.calculatedWidth / this._targetAspectRatio;
    }
    const n = t._isScreenSpace();
    if (this._updateMaterial(n), this._renderable && this._renderable.forceUpdateAabb(), this.sprite && (this.sprite.renderMode === ht || this.sprite.renderMode === it)) {
      const a = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]], o = 2 / a.rect.z, h = 2 / a.rect.w;
      this._innerOffset.set(a.border.x * o, a.border.y * h, a.border.z * o, a.border.w * h);
      const l = this.sprite.atlas.texture;
      this._atlasRect.set(a.rect.x / l.width, a.rect.y / l.height, a.rect.z / l.width, a.rect.w / l.height);
      const c = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit, d = a.rect.z / c, u = a.rect.w / c;
      this._outerScale.set(Math.max(s, this._innerOffset.x * d), Math.max(i, this._innerOffset.y * u));
      let f = d, m = u;
      this._outerScale.x /= d, this._outerScale.y /= u, f *= U.clamp(s / (this._innerOffset.x * d), 1e-4, 1), m *= U.clamp(i / (this._innerOffset.y * u), 1e-4, 1), this._renderable && (this._innerOffsetUniform[0] = this._innerOffset.x, this._innerOffsetUniform[1] = this._innerOffset.y, this._innerOffsetUniform[2] = this._innerOffset.z, this._innerOffsetUniform[3] = this._innerOffset.w, this._renderable.setParameter("innerOffset", this._innerOffsetUniform), this._atlasRectUniform[0] = this._atlasRect.x, this._atlasRectUniform[1] = this._atlasRect.y, this._atlasRectUniform[2] = this._atlasRect.z, this._atlasRectUniform[3] = this._atlasRect.w, this._renderable.setParameter("atlasRect", this._atlasRectUniform), this._outerScaleUniform[0] = this._outerScale.x, this._outerScaleUniform[1] = this._outerScale.y, this._renderable.setParameter("outerScale", this._outerScaleUniform), this._renderable.setAabbFunc(this._updateAabbFunc), this._renderable.node.setLocalScale(f, m, 1), this._renderable.node.setLocalPosition((0.5 - t.pivot.x) * s, (0.5 - t.pivot.y) * i, 0));
    } else {
      const a = e.vertexBuffer, o = new Float32Array(a.lock()), h = t.pivot.x, l = t.pivot.y;
      o[0] = 0 - h * s, o[1] = 0 - l * i, o[8] = s - h * s, o[9] = 0 - l * i, o[16] = s - h * s, o[17] = i - l * i, o[24] = 0 - h * s, o[25] = i - l * i;
      let c = 1, d = 1, u = this._rect;
      if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
        const _ = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
        _ && (u = _.rect, c = this._sprite.atlas.texture.width, d = this._sprite.atlas.texture.height);
      }
      o[6] = u.x / c, o[7] = 1 - u.y / d, o[14] = (u.x + u.z) / c, o[15] = 1 - u.y / d, o[22] = (u.x + u.z) / c, o[23] = 1 - (u.y + u.w) / d, o[30] = u.x / c, o[31] = 1 - (u.y + u.w) / d, a.unlock();
      const f = new v(0 - h * s, 0 - l * i, 0), m = new v(s - h * s, i - l * i, 0);
      e.aabb.setMinMax(f, m), this._renderable && (this._renderable.node.setLocalScale(1, 1, 1), this._renderable.node.setLocalPosition(0, 0, 0), this._renderable.setAabbFunc(null));
    }
    this._meshDirty = !1;
  }
  _updateSprite() {
    let e = !1, t = null;
    if (this._targetAspectRatio = -1, this._sprite && this._sprite.atlas) {
      t = this._sprite.meshes[this.spriteFrame], e = this._sprite.renderMode === ht || this._sprite.renderMode === it;
      const s = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
      (s == null ? void 0 : s.rect.w) > 0 && (this._targetAspectRatio = s.rect.z / s.rect.w);
    }
    this.mesh = e ? t : this._defaultMesh, this.refreshMesh();
  }
  refreshMesh() {
    this.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this.mesh));
  }
  _updateAabb(e) {
    return e.center.set(0, 0, 0), e.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 1e-3), e.setFromTransformedAabb(e, this._renderable.node.getWorldTransform()), e;
  }
  _toggleMask() {
    this._element._dirtifyMask();
    const e = this._element._isScreenSpace();
    this._updateMaterial(e), this._renderable.setMask(!!this._mask);
  }
  _onMaterialLoad(e) {
    this.material = e.resource;
  }
  _onMaterialAdded(e) {
    this._system.app.assets.off("add:" + e.id, this._onMaterialAdded, this), this._materialAsset === e.id && this._bindMaterialAsset(e);
  }
  _bindMaterialAsset(e) {
    this._entity.enabled && (e.on("load", this._onMaterialLoad, this), e.on("change", this._onMaterialChange, this), e.on("remove", this._onMaterialRemove, this), e.resource ? this._onMaterialLoad(e) : this._system.app.assets.load(e));
  }
  _unbindMaterialAsset(e) {
    e.off("load", this._onMaterialLoad, this), e.off("change", this._onMaterialChange, this), e.off("remove", this._onMaterialRemove, this);
  }
  _onMaterialChange() {
  }
  _onMaterialRemove() {
  }
  _onTextureAdded(e) {
    this._system.app.assets.off("add:" + e.id, this._onTextureAdded, this), this._textureAsset === e.id && this._bindTextureAsset(e);
  }
  _bindTextureAsset(e) {
    this._entity.enabled && (e.on("load", this._onTextureLoad, this), e.on("change", this._onTextureChange, this), e.on("remove", this._onTextureRemove, this), e.resource ? this._onTextureLoad(e) : this._system.app.assets.load(e));
  }
  _unbindTextureAsset(e) {
    e.off("load", this._onTextureLoad, this), e.off("change", this._onTextureChange, this), e.off("remove", this._onTextureRemove, this);
  }
  _onTextureLoad(e) {
    this.texture = e.resource;
  }
  _onTextureChange(e) {
  }
  _onTextureRemove(e) {
  }
  _onSpriteAssetAdded(e) {
    this._system.app.assets.off("add:" + e.id, this._onSpriteAssetAdded, this), this._spriteAsset === e.id && this._bindSpriteAsset(e);
  }
  _bindSpriteAsset(e) {
    this._entity.enabled && (e.on("load", this._onSpriteAssetLoad, this), e.on("change", this._onSpriteAssetChange, this), e.on("remove", this._onSpriteAssetRemove, this), e.resource ? this._onSpriteAssetLoad(e) : this._system.app.assets.load(e));
  }
  _unbindSpriteAsset(e) {
    e.off("load", this._onSpriteAssetLoad, this), e.off("change", this._onSpriteAssetChange, this), e.off("remove", this._onSpriteAssetRemove, this), e.data.textureAtlasAsset && this._system.app.assets.off("load:" + e.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
  }
  _onSpriteAssetLoad(e) {
    if (!e || !e.resource)
      this.sprite = null;
    else if (e.resource.atlas)
      this.sprite = e.resource;
    else {
      const t = e.data.textureAtlasAsset;
      if (t) {
        const s = this._system.app.assets;
        s.off("load:" + t, this._onTextureAtlasLoad, this), s.once("load:" + t, this._onTextureAtlasLoad, this);
      }
    }
  }
  _onSpriteAssetChange(e) {
    this._onSpriteAssetLoad(e);
  }
  _onSpriteAssetRemove(e) {
  }
  _bindSprite(e) {
    e.on("set:meshes", this._onSpriteMeshesChange, this), e.on("set:pixelsPerUnit", this._onSpritePpuChange, this), e.on("set:atlas", this._onAtlasTextureChange, this), e.atlas && e.atlas.on("set:texture", this._onAtlasTextureChange, this);
  }
  _unbindSprite(e) {
    e.off("set:meshes", this._onSpriteMeshesChange, this), e.off("set:pixelsPerUnit", this._onSpritePpuChange, this), e.off("set:atlas", this._onAtlasTextureChange, this), e.atlas && e.atlas.off("set:texture", this._onAtlasTextureChange, this);
  }
  _onSpriteMeshesChange() {
    this._sprite && (this._spriteFrame = U.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1)), this._updateSprite();
  }
  _onSpritePpuChange() {
    this.sprite.renderMode !== Ni && this._pixelsPerUnit === null && this._updateSprite();
  }
  _onAtlasTextureChange() {
    this.sprite && this.sprite.atlas && this.sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture), this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"), this._renderable.deleteParameter("texture_opacityMap"));
  }
  _onTextureAtlasLoad(e) {
    const t = this._spriteAsset;
    t instanceof ce ? this._onSpriteAssetLoad(t) : this._onSpriteAssetLoad(this._system.app.assets.get(t));
  }
  onEnable() {
    if (this._materialAsset) {
      const e = this._system.app.assets.get(this._materialAsset);
      e && e.resource !== this._material && this._bindMaterialAsset(e);
    }
    if (this._textureAsset) {
      const e = this._system.app.assets.get(this._textureAsset);
      e && e.resource !== this._texture && this._bindTextureAsset(e);
    }
    if (this._spriteAsset) {
      const e = this._system.app.assets.get(this._spriteAsset);
      e && e.resource !== this._sprite && this._bindSpriteAsset(e);
    }
    this._element.addModelToLayers(this._renderable.model);
  }
  onDisable() {
    this._element.removeModelFromLayers(this._renderable.model);
  }
  _setStencil(e) {
    this._renderable.meshInstance.stencilFront = e, this._renderable.meshInstance.stencilBack = e;
    let t = 0;
    if (this._element.maskedBy && (t = this._element.maskedBy.element._image._maskRef), this._renderable.unmaskMeshInstance) {
      const s = new Lr({
        ref: t + 1,
        func: Eh,
        zpass: z0
      });
      this._renderable.unmaskMeshInstance.stencilFront = s, this._renderable.unmaskMeshInstance.stencilBack = s;
    }
  }
  set color(e) {
    const t = e.r, s = e.g, i = e.b;
    (this._color.r !== t || this._color.g !== s || this._color.b !== i) && (this._color.r = t, this._color.g = s, this._color.b = i, this._colorUniform[0] = t, this._colorUniform[1] = s, this._colorUniform[2] = i, this._renderable.setParameter("material_emissive", this._colorUniform)), this._element && this._element.fire("set:color", this._color);
  }
  get color() {
    return this._color;
  }
  set opacity(e) {
    e !== this._color.a && (this._color.a = e, this._renderable.setParameter("material_opacity", e)), this._element && this._element.fire("set:opacity", e);
  }
  get opacity() {
    return this._color.a;
  }
  set rect(e) {
    let t, s, i, n;
    e instanceof Z ? (t = e.x, s = e.y, i = e.z, n = e.w) : (t = e[0], s = e[1], i = e[2], n = e[3]), !(t === this._rect.x && s === this._rect.y && i === this._rect.z && n === this._rect.w) && (this._rect.set(t, s, i, n), this._renderable.mesh && (this._element._beingInitialized ? this._meshDirty = !0 : this._updateMesh(this._renderable.mesh)));
  }
  get rect() {
    return this._rect;
  }
  set material(e) {
    if (this._material !== e) {
      if (!e) {
        const t = this._element._isScreenSpace();
        this.mask ? e = t ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial : e = t ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
      }
      this._material = e, e && (this._renderable.setMaterial(e), this._hasUserMaterial() ? (this._renderable.deleteParameter("material_opacity"), this._renderable.deleteParameter("material_emissive")) : (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._renderable.setParameter("material_emissive", this._colorUniform), this._renderable.setParameter("material_opacity", this._color.a)));
    }
  }
  get material() {
    return this._material;
  }
  set materialAsset(e) {
    const t = this._system.app.assets;
    let s = e;
    if (e instanceof ce && (s = e.id), this._materialAsset !== s) {
      if (this._materialAsset) {
        t.off("add:" + this._materialAsset, this._onMaterialAdded, this);
        const i = t.get(this._materialAsset);
        i && (i.off("load", this._onMaterialLoad, this), i.off("change", this._onMaterialChange, this), i.off("remove", this._onMaterialRemove, this));
      }
      if (this._materialAsset = s, this._materialAsset) {
        const i = t.get(this._materialAsset);
        i ? this._bindMaterialAsset(i) : (this.material = null, t.on("add:" + this._materialAsset, this._onMaterialAdded, this));
      } else
        this.material = null;
    }
  }
  get materialAsset() {
    return this._materialAsset;
  }
  set texture(e) {
    if (this._texture !== e) {
      if (this._textureAsset) {
        const t = this._system.app.assets.get(this._textureAsset);
        t && t.resource !== e && (this.textureAsset = null);
      }
      if (this._texture = e, e) {
        this._spriteAsset && (this.spriteAsset = null), this._renderable.setParameter("texture_emissiveMap", this._texture), this._renderable.setParameter("texture_opacityMap", this._texture), this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._renderable.setParameter("material_emissive", this._colorUniform), this._renderable.setParameter("material_opacity", this._color.a);
        const t = this._texture.width / this._texture.height;
        t !== this._targetAspectRatio && (this._targetAspectRatio = t, this._element.fitMode !== Sh && this.refreshMesh());
      } else
        this._renderable.deleteParameter("texture_emissiveMap"), this._renderable.deleteParameter("texture_opacityMap"), this._targetAspectRatio = -1, this._element.fitMode !== Sh && this.refreshMesh();
    }
  }
  get texture() {
    return this._texture;
  }
  set textureAsset(e) {
    const t = this._system.app.assets;
    let s = e;
    if (e instanceof ce && (s = e.id), this._textureAsset !== s) {
      if (this._textureAsset) {
        t.off("add:" + this._textureAsset, this._onTextureAdded, this);
        const i = t.get(this._textureAsset);
        i && (i.off("load", this._onTextureLoad, this), i.off("change", this._onTextureChange, this), i.off("remove", this._onTextureRemove, this));
      }
      if (this._textureAsset = s, this._textureAsset) {
        const i = t.get(this._textureAsset);
        i ? this._bindTextureAsset(i) : (this.texture = null, t.on("add:" + this._textureAsset, this._onTextureAdded, this));
      } else
        this.texture = null;
    }
  }
  get textureAsset() {
    return this._textureAsset;
  }
  set spriteAsset(e) {
    const t = this._system.app.assets;
    let s = e;
    if (e instanceof ce && (s = e.id), this._spriteAsset !== s) {
      if (this._spriteAsset) {
        t.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
        const i = t.get(this._spriteAsset);
        i && this._unbindSpriteAsset(i);
      }
      if (this._spriteAsset = s, this._spriteAsset) {
        const i = t.get(this._spriteAsset);
        i ? this._bindSpriteAsset(i) : (this.sprite = null, t.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this));
      } else
        this.sprite = null;
    }
    this._element && this._element.fire("set:spriteAsset", s);
  }
  get spriteAsset() {
    return this._spriteAsset;
  }
  set sprite(e) {
    if (this._sprite !== e) {
      if (this._sprite && this._unbindSprite(this._sprite), this._spriteAsset) {
        const t = this._system.app.assets.get(this._spriteAsset);
        t && t.resource !== e && (this.spriteAsset = null);
      }
      this._sprite = e, this._sprite && (this._bindSprite(this._sprite), this._textureAsset && (this.textureAsset = null)), this._sprite && this._sprite.atlas && this._sprite.atlas.texture ? (this._renderable.setParameter("texture_emissiveMap", this._sprite.atlas.texture), this._renderable.setParameter("texture_opacityMap", this._sprite.atlas.texture)) : (this._renderable.deleteParameter("texture_emissiveMap"), this._renderable.deleteParameter("texture_opacityMap")), this._sprite && (this._spriteFrame = U.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1)), this._updateSprite();
    }
  }
  get sprite() {
    return this._sprite;
  }
  set spriteFrame(e) {
    const t = this._spriteFrame;
    this._sprite ? this._spriteFrame = U.clamp(e, 0, this._sprite.frameKeys.length - 1) : this._spriteFrame = e, this._spriteFrame !== t && this._updateSprite(), this._element && this._element.fire("set:spriteFrame", e);
  }
  get spriteFrame() {
    return this._spriteFrame;
  }
  set mesh(e) {
    this._renderable.setMesh(e), this._defaultMesh === e ? this._renderable.setAabbFunc(null) : this._renderable.setAabbFunc(this._updateAabbFunc);
  }
  get mesh() {
    return this._renderable.mesh;
  }
  set mask(e) {
    this._mask !== e && (this._mask = e, this._toggleMask());
  }
  get mask() {
    return this._mask;
  }
  set pixelsPerUnit(e) {
    this._pixelsPerUnit !== e && (this._pixelsPerUnit = e, this._sprite && (this._sprite.renderMode === ht || this._sprite.renderMode === it) && this._updateSprite());
  }
  get pixelsPerUnit() {
    return this._pixelsPerUnit;
  }
  get aabb() {
    return this._renderable.meshInstance ? this._renderable.meshInstance.aabb : null;
  }
}
class Z1 extends _e {
  constructor(e) {
    super(), this._app = e, e.i18n.on("set:locale", this._onSetLocale, this), this._autoLoad = !1, this._disableLocalization = !1, this._defaultAsset = null, this._localizedAsset = null;
  }
  set defaultAsset(e) {
    const t = e instanceof ce ? e.id : e;
    this._defaultAsset !== t && (this._defaultAsset && this._unbindDefaultAsset(), this._defaultAsset = t, this._defaultAsset && this._bindDefaultAsset(), this._onSetLocale(this._app.i18n.locale));
  }
  get defaultAsset() {
    return this._defaultAsset;
  }
  set localizedAsset(e) {
    const t = e instanceof ce ? e.id : e;
    this._localizedAsset !== t && (this._localizedAsset && (this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this), this._unbindLocalizedAsset(), this._localizedAsset = null), this._localizedAsset = t, this._localizedAsset && (this._app.assets.get(this._localizedAsset) ? this._bindLocalizedAsset() : this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this)));
  }
  get localizedAsset() {
    return this._localizedAsset;
  }
  set autoLoad(e) {
    this._autoLoad !== e && (this._autoLoad = e, this._autoLoad && this._localizedAsset && (this._unbindLocalizedAsset(), this._bindLocalizedAsset()));
  }
  get autoLoad() {
    return this._autoLoad;
  }
  set disableLocalization(e) {
    this._disableLocalization !== e && (this._disableLocalization = e, this._onSetLocale(this._app.i18n.locale));
  }
  get disableLocalization() {
    return this._disableLocalization;
  }
  _bindDefaultAsset() {
    const e = this._app.assets.get(this._defaultAsset);
    e ? this._onDefaultAssetAdd(e) : this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
  }
  _unbindDefaultAsset() {
    if (!this._defaultAsset)
      return;
    this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
    const e = this._app.assets.get(this._defaultAsset);
    e && (e.off("add:localized", this._onLocaleAdd, this), e.off("remove:localized", this._onLocaleRemove, this), e.off("remove", this._onDefaultAssetRemove, this));
  }
  _onDefaultAssetAdd(e) {
    this._defaultAsset === e.id && (e.on("add:localized", this._onLocaleAdd, this), e.on("remove:localized", this._onLocaleRemove, this), e.once("remove", this._onDefaultAssetRemove, this));
  }
  _onDefaultAssetRemove(e) {
    this._defaultAsset === e.id && (e.off("add:localized", this._onLocaleAdd, this), e.off("remove:localized", this._onLocaleAdd, this), this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this));
  }
  _bindLocalizedAsset() {
    if (!this._autoLoad)
      return;
    const e = this._app.assets.get(this._localizedAsset);
    e && (e.on("load", this._onLocalizedAssetLoad, this), e.on("change", this._onLocalizedAssetChange, this), e.on("remove", this._onLocalizedAssetRemove, this), e.resource ? this._onLocalizedAssetLoad(e) : this._app.assets.load(e));
  }
  _unbindLocalizedAsset() {
    const e = this._app.assets.get(this._localizedAsset);
    e && (e.off("load", this._onLocalizedAssetLoad, this), e.off("change", this._onLocalizedAssetChange, this), e.off("remove", this._onLocalizedAssetRemove, this));
  }
  _onLocalizedAssetAdd(e) {
    this._localizedAsset === e.id && this._bindLocalizedAsset();
  }
  _onLocalizedAssetLoad(e) {
    this.fire("load", e);
  }
  _onLocalizedAssetChange(e, t, s, i) {
    this.fire("change", e, t, s, i);
  }
  _onLocalizedAssetRemove(e) {
    this._localizedAsset === e.id && (this.localizedAsset = this._defaultAsset), this.fire("remove", e);
  }
  _onLocaleAdd(e, t) {
    this._app.i18n.locale === e && this._onSetLocale(e);
  }
  _onLocaleRemove(e, t) {
    this._app.i18n.locale === e && this._onSetLocale(e);
  }
  _onSetLocale(e) {
    if (!this._defaultAsset) {
      this.localizedAsset = null;
      return;
    }
    const t = this._app.assets.get(this._defaultAsset);
    if (!t || this._disableLocalization) {
      this.localizedAsset = this._defaultAsset;
      return;
    }
    const s = t.getLocalizedAssetId(e);
    if (!s) {
      this.localizedAsset = this._defaultAsset;
      return;
    }
    this.localizedAsset = s;
  }
  destroy() {
    this.defaultAsset = null, this._app.i18n.off("set:locale", this._onSetLocale, this), this.off();
  }
}
const ol = "msdf", J1 = "bitmap", ba = 0, _r = 1, jd = 2, Hg = 3, $d = 4, Yd = 5, Kd = 6, Zd = 7, lp = 8, Q1 = ` 	
\r\v\f`, eM = /[A-Z|a-z|0-9|_|-|/]/;
class tM {
  constructor(e) {
    this._symbols = e, this._index = 0, this._last = 0, this._cur = this._symbols.length > 0 ? this._symbols[0] : null, this._buf = [], this._mode = "text", this._error = null;
  }
  read() {
    let e = this._read();
    for (; e === lp; )
      e = this._read();
    return e !== ba && e !== _r && (this._last = this._index), e;
  }
  buf() {
    return this._buf;
  }
  last() {
    return this._last;
  }
  error() {
    return this._error;
  }
  debugPrint() {
    const e = ["EOF", "ERROR", "TEXT", "OPEN_BRACKET", "CLOSE_BRACKET", "EQUALS", "STRING", "IDENTIFIER", "WHITESPACE"];
    let t = this.read(), s = "";
    for (; s += (s.length > 0 ? `
` : "") + e[t] + " '" + this.buf().join("") + "'", !(t === ba || t === _r); )
      t = this.read();
    return s;
  }
  _read() {
    return this._buf = [], this._eof() ? ba : this._mode === "text" ? this._text() : this._tag();
  }
  _text() {
    for (; ; )
      switch (this._cur) {
        case null:
          return this._buf.length > 0 ? jd : ba;
        case "[":
          return this._mode = "tag", this._buf.length > 0 ? jd : this._tag();
        case "\\":
          switch (this._next(), this._cur) {
            case "[":
              this._store();
              break;
            default:
              this._output("\\");
              break;
          }
          break;
        default:
          this._store();
          break;
      }
  }
  _tag() {
    switch (this._cur) {
      case null:
        return this._error = "unexpected end of input reading tag", _r;
      case "[":
        return this._store(), Hg;
      case "]":
        return this._store(), this._mode = "text", $d;
      case "=":
        return this._store(), Yd;
      case " ":
      case "	":
      case `
`:
      case "\r":
      case "\v":
      case "\f":
        return this._whitespace();
      case '"':
        return this._string();
      default:
        return this._isIdentifierSymbol(this._cur) ? this._identifier() : (this._error = "unrecognized character", _r);
    }
  }
  _whitespace() {
    for (this._store(); Q1.indexOf(this._cur) !== -1; )
      this._store();
    return lp;
  }
  _string() {
    for (this._next(); ; )
      switch (this._cur) {
        case null:
          return this._error = "unexpected end of input reading string", _r;
        case '"':
          return this._next(), Kd;
        default:
          this._store();
          break;
      }
  }
  _identifier() {
    for (this._store(); this._cur !== null && this._isIdentifierSymbol(this._cur); )
      this._store();
    return Zd;
  }
  _isIdentifierSymbol(e) {
    return e.length === 1 && e.match(eM) !== null;
  }
  _eof() {
    return this._cur === null;
  }
  _next() {
    return this._eof() || (this._index++, this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null), this._cur;
  }
  _store() {
    return this._buf.push(this._cur), this._next();
  }
  _output(e) {
    this._buf.push(e);
  }
}
class sM {
  constructor(e) {
    this._scanner = new tM(e), this._error = null;
  }
  parse(e, t) {
    for (; ; )
      switch (this._scanner.read()) {
        case ba:
          return !0;
        case _r:
          return !1;
        case jd:
          Array.prototype.push.apply(e, this._scanner.buf());
          break;
        case Hg:
          if (!this._parseTag(e, t))
            return !1;
          break;
        default:
          return !1;
      }
  }
  error() {
    return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
  }
  _parseTag(e, t) {
    let s = this._scanner.read();
    if (s !== Zd)
      return this._error = "expected identifier", !1;
    const i = this._scanner.buf().join("");
    if (i[0] === "/") {
      for (let a = t.length - 1; a >= 0; --a)
        if (i === "/" + t[a].name && t[a].end === null)
          return t[a].end = e.length, s = this._scanner.read(), s !== $d ? (this._error = "expected close bracket", !1) : !0;
      return this._error = "failed to find matching tag", !1;
    }
    const n = {
      name: i,
      value: null,
      attributes: {},
      start: e.length,
      end: null
    };
    if (s = this._scanner.read(), s === Yd) {
      if (s = this._scanner.read(), s !== Kd)
        return this._error = "expected string", !1;
      n.value = this._scanner.buf().join(""), s = this._scanner.read();
    }
    for (; ; ) {
      switch (s) {
        case $d:
          return t.push(n), !0;
        case Zd: {
          const a = this._scanner.buf().join("");
          if (s = this._scanner.read(), s !== Yd)
            return this._error = "expected equals", !1;
          if (s = this._scanner.read(), s !== Kd)
            return this._error = "expected string", !1;
          const o = this._scanner.buf().join("");
          n.attributes[a] = o;
          break;
        }
        default:
          return this._error = "expected close bracket or identifier", !1;
      }
      s = this._scanner.read();
    }
  }
}
function Wg(r, e) {
  for (const t in e) {
    if (!e.hasOwnProperty(t))
      continue;
    const s = e[t];
    s instanceof Object ? (r.hasOwnProperty(t) || (r[t] = {}), Wg(r[t], e[t])) : r[t] = s;
  }
}
function iM(r) {
  if (r.length === 0)
    return null;
  const e = {};
  for (let t = 0; t < r.length; ++t) {
    const s = r[t], i = {};
    i[s.name] = {
      value: s.value,
      attributes: s.attributes
    }, Wg(e, i);
  }
  return e;
}
function nM(r, e) {
  if (r.length === 0)
    return null;
  const t = {};
  for (let c = 0; c < r.length; ++c) {
    const d = r[c];
    t.hasOwnProperty(d.start) ? t[d.start].open === null ? t[d.start].open = [d] : t[d.start].open.push(d) : t[d.start] = {
      open: [d],
      close: null
    }, t.hasOwnProperty(d.end) ? t[d.end].close === null ? t[d.end].close = [d] : t[d.end].close.push(d) : t[d.end] = {
      open: null,
      close: [d]
    };
  }
  let s = [];
  function i(c) {
    s = s.filter(function(d) {
      return c.find(function(u) {
        return u === d;
      }) === void 0;
    });
  }
  function n(c) {
    for (let d = 0; d < c.length; ++d)
      s.push(c[d]);
  }
  const a = Object.keys(t).sort(function(c, d) {
    return c - d;
  }), o = [];
  for (let c = 0; c < a.length; ++c) {
    const d = t[a[c]];
    d.close !== null && i(d.close), d.open !== null && n(d.open), o.push({
      start: a[c],
      tags: iM(s)
    });
  }
  const h = [];
  let l = null;
  for (let c = 0; c < o.length; ++c) {
    const d = o[c];
    for (; h.length < d.start; )
      h.push(l ? l.tags : null);
    l = d;
  }
  for (; h.length < e; )
    h.push(null);
  return h;
}
function rM(r) {
  const e = new sM(r), t = [], s = [];
  if (!e.parse(t, s))
    return console.warn(e.error()), {
      symbols: r,
      tags: null
    };
  const i = s.find(function(a) {
    return a.end === null;
  });
  if (i)
    return console.warn(`Markup error: found unclosed tag='${i.name}'`), {
      symbols: r,
      tags: null
    };
  const n = nM(s, t.length);
  return {
    symbols: t,
    tags: n
  };
}
class aM {
  static evaluate(e) {
    return rM(e);
  }
}
class oM {
  constructor() {
    this.count = 0, this.quad = 0, this.lines = {}, this.positions = [], this.normals = [], this.uvs = [], this.colors = [], this.indices = [], this.outlines = [], this.shadows = [], this.meshInstance = null;
  }
}
function hM(r, e) {
  const t = new _s(r);
  return t.setPositions(e.positions), t.setNormals(e.normals), t.setColors32(e.colors), t.setUvs(0, e.uvs), t.setIndices(e.indices), t.setVertexStream(En, e.outlines, 3, void 0, Ie, !1), t.setVertexStream(Rn, e.shadows, 3, void 0, Ie, !1), t.update(), t;
}
const cp = /^[\r\n]$/, lM = /^[ \t]$/, dp = /^[ \t\-]|[\u200b]$/, cM = /^[a-z0-9]$/i, up = /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/, dM = /^[]$/, uM = ["", "", "", "", "", "", "", "", "", "", "", "", ""], fM = {
  width: 0,
  height: 0,
  xadvance: 0,
  xoffset: 0,
  yoffset: 0
}, fp = new z(), mM = new q();
class pM {
  constructor(e) {
    this._element = e, this._system = e.system, this._entity = e.entity, this._text = "", this._symbols = [], this._colorPalette = [], this._outlinePalette = [], this._shadowPalette = [], this._symbolColors = null, this._symbolOutlineParams = null, this._symbolShadowParams = null, this._i18nKey = null, this._fontAsset = new Z1(this._system.app), this._fontAsset.disableLocalization = !0, this._fontAsset.on("load", this._onFontLoad, this), this._fontAsset.on("change", this._onFontChange, this), this._fontAsset.on("remove", this._onFontRemove, this), this._font = null, this._color = new z(1, 1, 1, 1), this._colorUniform = new Float32Array(3), this._spacing = 1, this._fontSize = 32, this._fontMinY = 0, this._fontMaxY = 0, this._originalFontSize = 32, this._maxFontSize = 32, this._minFontSize = 8, this._autoFitWidth = !1, this._autoFitHeight = !1, this._maxLines = -1, this._lineHeight = 32, this._scaledLineHeight = 32, this._wrapLines = !1, this._drawOrder = 0, this._alignment = new q(0.5, 0.5), this._autoWidth = !0, this._autoHeight = !0, this.width = 0, this.height = 0, this._node = new bt(), this._model = new Ti(), this._model.graph = this._node, this._entity.addChild(this._node), this._meshInfo = [], this._material = null, this._aabbDirty = !0, this._aabb = new Pe(), this._noResize = !1, this._currentMaterialType = null, this._maskedMaterialSrc = null, this._rtlReorder = !1, this._unicodeConverter = !1, this._rtl = !1, this._outlineColor = new z(0, 0, 0, 1), this._outlineColorUniform = new Float32Array(4), this._outlineThicknessScale = 0.2, this._outlineThickness = 0, this._shadowColor = new z(0, 0, 0, 1), this._shadowColorUniform = new Float32Array(4), this._shadowOffsetScale = 5e-3, this._shadowOffset = new q(0, 0), this._shadowOffsetUniform = new Float32Array(2), this._enableMarkup = !1, this._onScreenChange(this._element.screen), e.on("resize", this._onParentResize, this), e.on("set:screen", this._onScreenChange, this), e.on("screen:set:screenspace", this._onScreenSpaceChange, this), e.on("set:draworder", this._onDrawOrderChange, this), e.on("set:pivot", this._onPivotChange, this), this._system.app.i18n.on("set:locale", this._onLocaleSet, this), this._system.app.i18n.on("data:add", this._onLocalizationData, this), this._system.app.i18n.on("data:remove", this._onLocalizationData, this), this._rangeStart = 0, this._rangeEnd = 0;
  }
  destroy() {
    this._setMaterial(null), this._model && (this._element.removeModelFromLayers(this._model), this._model.destroy(), this._model = null), this._fontAsset.destroy(), this.font = null, this._element.off("resize", this._onParentResize, this), this._element.off("set:screen", this._onScreenChange, this), this._element.off("screen:set:screenspace", this._onScreenSpaceChange, this), this._element.off("set:draworder", this._onDrawOrderChange, this), this._element.off("set:pivot", this._onPivotChange, this), this._system.app.i18n.off("set:locale", this._onLocaleSet, this), this._system.app.i18n.off("data:add", this._onLocalizationData, this), this._system.app.i18n.off("data:remove", this._onLocalizationData, this);
  }
  _onParentResize(e, t) {
    this._noResize || this._font && this._updateText();
  }
  _onScreenChange(e) {
    e ? this._updateMaterial(e.screen.screenSpace) : this._updateMaterial(!1);
  }
  _onScreenSpaceChange(e) {
    this._updateMaterial(e);
  }
  _onDrawOrderChange(e) {
    if (this._drawOrder = e, this._model)
      for (let t = 0, s = this._model.meshInstances.length; t < s; t++)
        this._model.meshInstances[t].drawOrder = e;
  }
  _onPivotChange(e) {
    this._font && this._updateText();
  }
  _onLocaleSet(e) {
    if (this._i18nKey) {
      if (this.fontAsset) {
        const t = this._system.app.assets.get(this.fontAsset);
        (!t || !t.resource || t.resource !== this._font) && (this.font = null);
      }
      this._resetLocalizedText();
    }
  }
  _onLocalizationData(e, t) {
    this._i18nKey && t[this._i18nKey] && this._resetLocalizedText();
  }
  _resetLocalizedText() {
    this._setText(this._system.app.i18n.getText(this._i18nKey));
  }
  _setText(e) {
    if (this.unicodeConverter) {
      const t = this._system.getUnicodeConverter();
      t ? e = t(e) : console.warn("Element created with unicodeConverter option but no unicodeConverter function registered");
    }
    this._text !== e && (this._font && this._updateText(e), this._text = e);
  }
  _updateText(e) {
    let t;
    if (e === void 0 && (e = this._text), this._symbols = dh.getSymbols(e.normalize ? e.normalize("NFC") : e), this._symbols.length === 0 && (this._symbols = [" "]), this._enableMarkup) {
      const d = aM.evaluate(this._symbols);
      this._symbols = d.symbols, t = d.tags || [];
    }
    if (this._rtlReorder) {
      const d = this._system.app.systems.element.getRtlReorder();
      if (d) {
        const u = d(this._symbols);
        this._rtl = u.rtl, this._symbols = u.mapping.map(function(f) {
          return this._symbols[f];
        }, this), t && (t = u.mapping.map(function(f) {
          return t[f];
        }));
      } else
        console.warn("Element created with rtlReorder option but no rtlReorder function registered");
    } else
      this._rtl = !1;
    const s = (d, u) => `${d.toString(!0).toLowerCase()}:${u.toFixed(2)}`, i = (d, u) => `${d.toString(!0).toLowerCase()}:${u.x.toFixed(2)}:${u.y.toFixed(2)}`;
    if (t) {
      const d = {}, u = {}, f = {};
      this._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)], this._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)], this._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)], this._symbolColors = [], this._symbolOutlineParams = [], this._symbolShadowParams = [], d[this._color.toString(!1).toLowerCase()] = 0, u[s(this._outlineColor, this._outlineThickness)] = 0, f[i(this._shadowColor, this._shadowOffset)] = 0;
      for (let m = 0, _ = this._symbols.length; m < _; ++m) {
        const p = t[m];
        let g = 0;
        if (p && p.color && p.color.value) {
          const y = p.color.value;
          if (y.length === 7 && y[0] === "#") {
            const S = y.substring(1).toLowerCase();
            d.hasOwnProperty(S) ? g = d[S] : /^([0-9a-f]{2}){3}$/.test(S) && (g = this._colorPalette.length / 3, d[S] = g, this._colorPalette.push(parseInt(S.substring(0, 2), 16)), this._colorPalette.push(parseInt(S.substring(2, 4), 16)), this._colorPalette.push(parseInt(S.substring(4, 6), 16)));
          }
        }
        this._symbolColors.push(g);
        let b = 0;
        if (p && p.outline && (p.outline.attributes.color || p.outline.attributes.thickness)) {
          let y = p.outline.attributes.color ? fp.fromString(p.outline.attributes.color) : this._outlineColor, S = Number(p.outline.attributes.thickness);
          (Number.isNaN(y.r) || Number.isNaN(y.g) || Number.isNaN(y.b) || Number.isNaN(y.a)) && (y = this._outlineColor), Number.isNaN(S) && (S = this._outlineThickness);
          const C = s(y, S);
          u.hasOwnProperty(C) ? b = u[C] : (b = this._outlinePalette.length / 5, u[C] = b, this._outlinePalette.push(Math.round(y.r * 255), Math.round(y.g * 255), Math.round(y.b * 255), Math.round(y.a * 255), Math.round(S * 255)));
        }
        this._symbolOutlineParams.push(b);
        let x = 0;
        if (p && p.shadow && (p.shadow.attributes.color || p.shadow.attributes.offset || p.shadow.attributes.offsetX || p.shadow.attributes.offsetY)) {
          let y = p.shadow.attributes.color ? fp.fromString(p.shadow.attributes.color) : this._shadowColor;
          const S = Number(p.shadow.attributes.offset), C = Number(p.shadow.attributes.offsetX), w = Number(p.shadow.attributes.offsetY);
          (Number.isNaN(y.r) || Number.isNaN(y.g) || Number.isNaN(y.b) || Number.isNaN(y.a)) && (y = this._shadowColor);
          const M = mM.set(Number.isNaN(C) ? Number.isNaN(S) ? this._shadowOffset.x : S : C, Number.isNaN(w) ? Number.isNaN(S) ? this._shadowOffset.y : S : w), T = i(y, M);
          f.hasOwnProperty(T) ? x = f[T] : (x = this._shadowPalette.length / 6, f[T] = x, this._shadowPalette.push(Math.round(y.r * 255), Math.round(y.g * 255), Math.round(y.b * 255), Math.round(y.a * 255), Math.round(M.x * 127), Math.round(M.y * 127)));
        }
        this._symbolShadowParams.push(x);
      }
    } else
      this._colorPalette = [], this._symbolColors = null, this._symbolOutlineParams = null, this._symbolShadowParams = null;
    this._updateMaterialEmissive(), this._updateMaterialOutline(), this._updateMaterialShadow();
    const n = this._calculateCharsPerTexture();
    let a = !1;
    const o = this._element, h = o._isScreenSpace(), l = o._isScreenCulled(), c = function(u) {
      return o.isVisibleForCamera(u);
    };
    for (let d = 0, u = this._meshInfo.length; d < u; d++) {
      const f = n[d] || 0, m = this._meshInfo[d];
      if (m.count !== f) {
        if (a || (o.removeModelFromLayers(this._model), a = !0), m.count = f, m.positions.length = m.normals.length = f * 3 * 4, m.indices.length = f * 3 * 2, m.uvs.length = f * 2 * 4, m.colors.length = f * 4 * 4, m.outlines.length = f * 4 * 3, m.shadows.length = f * 4 * 3, m.meshInstance && this._removeMeshInstance(m.meshInstance), f === 0) {
          m.meshInstance = null;
          continue;
        }
        for (let g = 0; g < f; g++)
          m.indices[g * 3 * 2 + 0] = g * 4, m.indices[g * 3 * 2 + 1] = g * 4 + 1, m.indices[g * 3 * 2 + 2] = g * 4 + 3, m.indices[g * 3 * 2 + 3] = g * 4 + 2, m.indices[g * 3 * 2 + 4] = g * 4 + 3, m.indices[g * 3 * 2 + 5] = g * 4 + 1, m.normals[g * 4 * 3 + 0] = 0, m.normals[g * 4 * 3 + 1] = 0, m.normals[g * 4 * 3 + 2] = -1, m.normals[g * 4 * 3 + 3] = 0, m.normals[g * 4 * 3 + 4] = 0, m.normals[g * 4 * 3 + 5] = -1, m.normals[g * 4 * 3 + 6] = 0, m.normals[g * 4 * 3 + 7] = 0, m.normals[g * 4 * 3 + 8] = -1, m.normals[g * 4 * 3 + 9] = 0, m.normals[g * 4 * 3 + 10] = 0, m.normals[g * 4 * 3 + 11] = -1;
        const _ = hM(this._system.app.graphicsDevice, m), p = new we(_, this._material, this._node);
        if (p.name = "Text Element: " + this._entity.name, p.castShadow = !1, p.receiveShadow = !1, p.cull = !h, p.screenSpace = h, p.drawOrder = this._drawOrder, l && (p.cull = !0, p.isVisibleFunc = c), this._setTextureParams(p, this._font.textures[d]), p.setParameter("material_emissive", this._colorUniform), p.setParameter("material_opacity", this._color.a), p.setParameter("font_sdfIntensity", this._font.intensity), p.setParameter("font_pxrange", this._getPxRange(this._font)), p.setParameter("font_textureWidth", this._font.data.info.maps[d].width), p.setParameter("outline_color", this._outlineColorUniform), p.setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness), p.setParameter("shadow_color", this._shadowColorUniform), this._symbolShadowParams)
          this._shadowOffsetUniform[0] = 0, this._shadowOffsetUniform[1] = 0;
        else {
          const g = -this._font.data.info.maps[d].width / this._font.data.info.maps[d].height;
          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x, this._shadowOffsetUniform[1] = g * this._shadowOffsetScale * this._shadowOffset.y;
        }
        p.setParameter("shadow_offset", this._shadowOffsetUniform), m.meshInstance = p, this._model.meshInstances.push(p);
      }
    }
    this._element.maskedBy && this._element._setMaskedBy(this._element.maskedBy), a && this._element.enabled && this._entity.enabled && this._element.addModelToLayers(this._model), this._updateMeshes(), this._rangeStart = 0, this._rangeEnd = this._symbols.length, this._updateRenderRange();
  }
  _removeMeshInstance(e) {
    e.destroy();
    const t = this._model.meshInstances.indexOf(e);
    t !== -1 && this._model.meshInstances.splice(t, 1);
  }
  _setMaterial(e) {
    if (this._material = e, this._model)
      for (let t = 0, s = this._model.meshInstances.length; t < s; t++) {
        const i = this._model.meshInstances[t];
        i.material = e;
      }
  }
  _updateMaterial(e) {
    const t = this._element, s = t._isScreenCulled(), i = function(o) {
      return t.isVisibleForCamera(o);
    }, n = this._font && this._font.type === ol;
    if (this._material = this._system.getTextElementMaterial(e, n, this._enableMarkup), this._model)
      for (let a = 0, o = this._model.meshInstances.length; a < o; a++) {
        const h = this._model.meshInstances[a];
        h.cull = !e, h.material = this._material, h.screenSpace = e, s ? (h.cull = !0, h.isVisibleFunc = i) : h.isVisibleFunc = null;
      }
  }
  _updateMaterialEmissive() {
    this._symbolColors ? (this._colorUniform[0] = 1, this._colorUniform[1] = 1, this._colorUniform[2] = 1) : (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b);
  }
  _updateMaterialOutline() {
    this._symbolOutlineParams ? (this._outlineColorUniform[0] = 0, this._outlineColorUniform[1] = 0, this._outlineColorUniform[2] = 0, this._outlineColorUniform[3] = 1) : (this._outlineColorUniform[0] = this._outlineColor.r, this._outlineColorUniform[1] = this._outlineColor.g, this._outlineColorUniform[2] = this._outlineColor.b, this._outlineColorUniform[3] = this._outlineColor.a);
  }
  _updateMaterialShadow() {
    this._symbolOutlineParams ? (this._shadowColorUniform[0] = 0, this._shadowColorUniform[1] = 0, this._shadowColorUniform[2] = 0, this._shadowColorUniform[3] = 0) : (this._shadowColorUniform[0] = this._shadowColor.r, this._shadowColorUniform[1] = this._shadowColor.g, this._shadowColorUniform[2] = this._shadowColor.b, this._shadowColorUniform[3] = this._shadowColor.a);
  }
  _isWordBoundary(e) {
    return dp.test(e);
  }
  _isValidNextChar(e) {
    return e !== null && !dM.test(e);
  }
  _isNextCJKBoundary(e, t) {
    return up.test(e) && (dp.test(t) || cM.test(t));
  }
  _isNextCJKWholeWord(e) {
    return up.test(e);
  }
  _updateMeshes() {
    const e = this._font.data, t = this, s = Math.min(this._minFontSize, this._maxFontSize), i = this._maxFontSize, n = this._shouldAutoFit();
    n && (this._fontSize = this._maxFontSize);
    const a = 32, o = this._symbols.length;
    let h = 0, l = 0, c = 0, d = 0, u = 1, f = 0, m = 0, _ = 0, p = 0, g = 0, b = 0;
    const x = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 1e-4;
    let y = this._element.calculatedWidth;
    (this.autoWidth && !x || !this._wrapLines) && (y = Number.POSITIVE_INFINITY);
    let S = 0, C = 0, w, M, T, A;
    function L(E, P, B) {
      t._lineWidths.push(Math.abs(B));
      const k = _ > P ? P + 1 : _, H = _ > P ? _ + 1 : P, V = E.slice(k, H);
      if (b) {
        let K = V.length;
        for (; K-- && b > 0; )
          cp.test(V[K]) && (V.splice(K, 1), b--);
      }
      t._lineContents.push(V.join("")), h = 0, l -= t._scaledLineHeight, u++, p = 0, g = 0, b = 0, f = 0, _ = P;
    }
    let O = !0;
    for (; O; ) {
      O = !1, n ? this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 1e-4) : this._scaledLineHeight = this._lineHeight, this.width = 0, this.height = 0, this._lineWidths = [], this._lineContents = [], h = 0, l = 0, c = 0, d = 0, u = 1, f = 0, m = 0, _ = 0, p = 0, g = 0, b = 0;
      const E = this._fontSize / a;
      S = this._fontMinY * E, C = this._fontMaxY * E;
      for (let $ = 0; $ < this._meshInfo.length; $++)
        this._meshInfo[$].quad = 0, this._meshInfo[$].lines = {};
      let P = 255, B = 255, k = 255, H = 255 + 255 * 256, V = 255 + 255 * 256, K = 0, Q = 255 + 255 * 256, se = 255 + 255 * 256, J = 127 + 127 * 256;
      for (let $ = 0; $ < o; $++) {
        if (w = this._symbols[$], A = $ + 1 >= o ? null : this._symbols[$ + 1], cp.test(w)) {
          b++, (!this._wrapLines || this._maxLines < 0 || u < this._maxLines) && (L(this._symbols, $, d), m = $ + 1, _ = $ + 1);
          continue;
        }
        let Je = 0, Ke = 0, at = 0, gs = 1, lf, cf;
        if (M = e.chars[w], !M)
          if (uM.indexOf(w) !== -1)
            M = fM;
          else if (e.chars[" "])
            M = e.chars[" "];
          else
            for (const Ne in e.chars) {
              M = e.chars[Ne];
              break;
            }
        if (M) {
          let Ne = 0;
          if (g > 0) {
            const fo = this._font.data.kerning;
            if (fo) {
              const mo = fo[dh.getCodePoint(this._symbols[$ - 1]) || 0];
              mo && (Ne = mo[dh.getCodePoint(this._symbols[$]) || 0] || 0);
            }
          }
          lf = M.scale || 1, cf = (M.width + M.height) / 2, gs = E * cf / lf, at = (M.xadvance + Ne) * E, Je = (M.xoffset - Ne) * E, Ke = M.yoffset * E;
        } else
          console.error(`Couldn't substitute missing character: '${w}'`);
        const df = lM.test(w), Ql = M && M.map || 0, $y = -this._font.data.info.maps[Ql].width / this._font.data.info.maps[Ql].height, te = this._meshInfo[Ql], uf = h + this._spacing * at;
        if (uf > y && g > 0 && !df && (this._maxLines < 0 || u < this._maxLines))
          if (p === 0)
            m = $, L(this._symbols, $, d);
          else {
            const Ne = Math.max($ - m, 0);
            if (this._meshInfo.length <= 1)
              te.lines[u - 1] -= Ne, te.quad -= Ne;
            else {
              const fo = m, mo = $;
              for (let sc = fo; sc < mo; sc++) {
                const Yy = this._symbols[sc], mf = e.chars[Yy], pf = this._meshInfo[mf && mf.map || 0];
                pf.lines[u - 1] -= 1, pf.quad -= 1;
              }
            }
            $ -= Ne + 1, L(this._symbols, m, f);
            continue;
          }
        T = te.quad, te.lines[u - 1] = T;
        let uo = h - Je, ec = uo + gs;
        const tc = l - Ke, ff = tc + gs;
        if (this._rtl) {
          const Ne = gs - Je - this._spacing * at - Je;
          uo -= Ne, ec -= Ne;
        }
        te.positions[T * 4 * 3 + 0] = uo, te.positions[T * 4 * 3 + 1] = tc, te.positions[T * 4 * 3 + 2] = c, te.positions[T * 4 * 3 + 3] = ec, te.positions[T * 4 * 3 + 4] = tc, te.positions[T * 4 * 3 + 5] = c, te.positions[T * 4 * 3 + 6] = ec, te.positions[T * 4 * 3 + 7] = ff, te.positions[T * 4 * 3 + 8] = c, te.positions[T * 4 * 3 + 9] = uo, te.positions[T * 4 * 3 + 10] = ff, te.positions[T * 4 * 3 + 11] = c, this.width = Math.max(this.width, uf);
        let Ci;
        if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth && (Ci = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 1e-4)), Ci = U.clamp(Ci, s, i), Ci !== this._element.fontSize)) {
          this._fontSize = Ci, O = !0;
          break;
        }
        if (this.height = Math.max(this.height, C - (l + S)), this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight && (Ci = U.clamp(this._fontSize - 1, s, i), Ci !== this._element.fontSize)) {
          this._fontSize = Ci, O = !0;
          break;
        }
        h += this._spacing * at, df || (d = h), (this._isWordBoundary(w) || this._isValidNextChar(A) && (this._isNextCJKBoundary(w, A) || this._isNextCJKWholeWord(A))) && (p++, f = d, m = $ + 1), g++;
        const Ai = this._getUv(w);
        if (te.uvs[T * 4 * 2 + 0] = Ai[0], te.uvs[T * 4 * 2 + 1] = 1 - Ai[1], te.uvs[T * 4 * 2 + 2] = Ai[2], te.uvs[T * 4 * 2 + 3] = 1 - Ai[1], te.uvs[T * 4 * 2 + 4] = Ai[2], te.uvs[T * 4 * 2 + 5] = 1 - Ai[3], te.uvs[T * 4 * 2 + 6] = Ai[0], te.uvs[T * 4 * 2 + 7] = 1 - Ai[3], this._symbolColors) {
          const Ne = this._symbolColors[$] * 3;
          P = this._colorPalette[Ne], B = this._colorPalette[Ne + 1], k = this._colorPalette[Ne + 2];
        }
        if (te.colors[T * 4 * 4 + 0] = P, te.colors[T * 4 * 4 + 1] = B, te.colors[T * 4 * 4 + 2] = k, te.colors[T * 4 * 4 + 3] = 255, te.colors[T * 4 * 4 + 4] = P, te.colors[T * 4 * 4 + 5] = B, te.colors[T * 4 * 4 + 6] = k, te.colors[T * 4 * 4 + 7] = 255, te.colors[T * 4 * 4 + 8] = P, te.colors[T * 4 * 4 + 9] = B, te.colors[T * 4 * 4 + 10] = k, te.colors[T * 4 * 4 + 11] = 255, te.colors[T * 4 * 4 + 12] = P, te.colors[T * 4 * 4 + 13] = B, te.colors[T * 4 * 4 + 14] = k, te.colors[T * 4 * 4 + 15] = 255, this._symbolOutlineParams) {
          const Ne = this._symbolOutlineParams[$] * 5;
          H = this._outlinePalette[Ne] + this._outlinePalette[Ne + 1] * 256, V = this._outlinePalette[Ne + 2] + this._outlinePalette[Ne + 3] * 256, K = this._outlinePalette[Ne + 4];
        }
        if (te.outlines[T * 4 * 3 + 0] = H, te.outlines[T * 4 * 3 + 1] = V, te.outlines[T * 4 * 3 + 2] = K, te.outlines[T * 4 * 3 + 3] = H, te.outlines[T * 4 * 3 + 4] = V, te.outlines[T * 4 * 3 + 5] = K, te.outlines[T * 4 * 3 + 6] = H, te.outlines[T * 4 * 3 + 7] = V, te.outlines[T * 4 * 3 + 8] = K, te.outlines[T * 4 * 3 + 9] = H, te.outlines[T * 4 * 3 + 10] = V, te.outlines[T * 4 * 3 + 11] = K, this._symbolShadowParams) {
          const Ne = this._symbolShadowParams[$] * 6;
          Q = this._shadowPalette[Ne] + this._shadowPalette[Ne + 1] * 256, se = this._shadowPalette[Ne + 2] + this._shadowPalette[Ne + 3] * 256, J = this._shadowPalette[Ne + 4] + 127 + Math.round($y * this._shadowPalette[Ne + 5] + 127) * 256;
        }
        te.shadows[T * 4 * 3 + 0] = Q, te.shadows[T * 4 * 3 + 1] = se, te.shadows[T * 4 * 3 + 2] = J, te.shadows[T * 4 * 3 + 3] = Q, te.shadows[T * 4 * 3 + 4] = se, te.shadows[T * 4 * 3 + 5] = J, te.shadows[T * 4 * 3 + 6] = Q, te.shadows[T * 4 * 3 + 7] = se, te.shadows[T * 4 * 3 + 8] = J, te.shadows[T * 4 * 3 + 9] = Q, te.shadows[T * 4 * 3 + 10] = se, te.shadows[T * 4 * 3 + 11] = J, te.quad++;
      }
      O || _ < o && L(this._symbols, o, h);
    }
    this._noResize = !0, this.autoWidth = this._autoWidth, this.autoHeight = this._autoHeight, this._noResize = !1;
    const I = this._element.pivot.x, D = this._element.pivot.y, G = this._alignment.x, X = this._alignment.y;
    for (let E = 0; E < this._meshInfo.length; E++) {
      if (this._meshInfo[E].count === 0)
        continue;
      let P = 0;
      for (const V in this._meshInfo[E].lines) {
        const K = this._meshInfo[E].lines[V], Q = this._lineWidths[parseInt(V, 10)], se = -I * this._element.calculatedWidth + G * (this._element.calculatedWidth - Q) * (this._rtl ? -1 : 1), J = (1 - D) * this._element.calculatedHeight - C - (1 - X) * (this._element.calculatedHeight - this.height);
        for (let $ = P; $ <= K; $++)
          this._meshInfo[E].positions[$ * 4 * 3] += se, this._meshInfo[E].positions[$ * 4 * 3 + 3] += se, this._meshInfo[E].positions[$ * 4 * 3 + 6] += se, this._meshInfo[E].positions[$ * 4 * 3 + 9] += se, this._meshInfo[E].positions[$ * 4 * 3 + 1] += J, this._meshInfo[E].positions[$ * 4 * 3 + 4] += J, this._meshInfo[E].positions[$ * 4 * 3 + 7] += J, this._meshInfo[E].positions[$ * 4 * 3 + 10] += J;
        if (this._rtl)
          for (let $ = P; $ <= K; $++) {
            const Re = $ * 4 * 3;
            for (let at = 0; at < 4; ++at)
              this._meshInfo[E].positions[Re + at * 3] = this._element.calculatedWidth - this._meshInfo[E].positions[Re + at * 3] + se * 2;
            const Je = this._meshInfo[E].positions[Re + 3], Ke = this._meshInfo[E].positions[Re + 6];
            this._meshInfo[E].positions[Re + 3] = this._meshInfo[E].positions[Re + 0], this._meshInfo[E].positions[Re + 6] = this._meshInfo[E].positions[Re + 9], this._meshInfo[E].positions[Re + 0] = Je, this._meshInfo[E].positions[Re + 9] = Ke;
          }
        P = K + 1;
      }
      const B = this._meshInfo[E].count * 4, k = this._meshInfo[E].quad * 4, H = new Da(this._meshInfo[E].meshInstance.mesh.vertexBuffer);
      for (let V = 0; V < B; V++)
        V >= k ? (H.element[et].set(0, 0, 0), H.element[rs].set(0, 0), H.element[It].set(0, 0, 0, 0), H.element[En].set(0, 0, 0, 0), H.element[Rn].set(0, 0, 0, 0)) : (H.element[et].set(this._meshInfo[E].positions[V * 3 + 0], this._meshInfo[E].positions[V * 3 + 1], this._meshInfo[E].positions[V * 3 + 2]), H.element[rs].set(this._meshInfo[E].uvs[V * 2 + 0], this._meshInfo[E].uvs[V * 2 + 1]), H.element[It].set(this._meshInfo[E].colors[V * 4 + 0], this._meshInfo[E].colors[V * 4 + 1], this._meshInfo[E].colors[V * 4 + 2], this._meshInfo[E].colors[V * 4 + 3]), H.element[En].set(this._meshInfo[E].outlines[V * 3 + 0], this._meshInfo[E].outlines[V * 3 + 1], this._meshInfo[E].outlines[V * 3 + 2]), H.element[Rn].set(this._meshInfo[E].shadows[V * 3 + 0], this._meshInfo[E].shadows[V * 3 + 1], this._meshInfo[E].shadows[V * 3 + 2])), H.next();
      H.end(), this._meshInfo[E].meshInstance.mesh.aabb.compute(this._meshInfo[E].positions), this._meshInfo[E].meshInstance._aabbVer = -1;
    }
    this._aabbDirty = !0;
  }
  _onFontRender() {
    this.font = this._font;
  }
  _onFontLoad(e) {
    this.font !== e.resource && (this.font = e.resource);
  }
  _onFontChange(e, t, s, i) {
    if (t === "data") {
      this._font.data = s;
      const n = this._font.data.info.maps.length;
      for (let a = 0; a < n; a++) {
        if (!this._meshInfo[a])
          continue;
        const o = this._meshInfo[a].meshInstance;
        o && (o.setParameter("font_sdfIntensity", this._font.intensity), o.setParameter("font_pxrange", this._getPxRange(this._font)), o.setParameter("font_textureWidth", this._font.data.info.maps[a].width));
      }
    }
  }
  _onFontRemove(e) {
  }
  _setTextureParams(e, t) {
    this._font && (this._font.type === ol ? (e.deleteParameter("texture_emissiveMap"), e.deleteParameter("texture_opacityMap"), e.setParameter("texture_msdfMap", t)) : this._font.type === J1 && (e.deleteParameter("texture_msdfMap"), e.setParameter("texture_emissiveMap", t), e.setParameter("texture_opacityMap", t)));
  }
  _getPxRange(e) {
    const t = Object.keys(this._font.data.chars);
    for (let s = 0; s < t.length; s++) {
      const i = this._font.data.chars[t[s]];
      if (i.range)
        return (i.scale || 1) * i.range;
    }
    return 2;
  }
  _getUv(e) {
    const t = this._font.data;
    if (!t.chars[e]) {
      const f = " ";
      return t.chars[f] ? this._getUv(f) : [0, 0, 0, 0];
    }
    const s = t.chars[e].map, i = t.info.maps[s].width, n = t.info.maps[s].height, a = t.chars[e].x, o = t.chars[e].y, h = a, l = o, c = a + t.chars[e].width, d = o - t.chars[e].height, u = 1 - t.chars[e].height / n;
    return [h / i, u - l / n, c / i, u - d / n];
  }
  onEnable() {
    this._fontAsset.autoLoad = !0, this._model && this._element.addModelToLayers(this._model);
  }
  onDisable() {
    this._fontAsset.autoLoad = !1, this._model && this._element.removeModelFromLayers(this._model);
  }
  _setStencil(e) {
    if (this._model) {
      const t = this._model.meshInstances;
      for (let s = 0; s < t.length; s++)
        t[s].stencilFront = e, t[s].stencilBack = e;
    }
  }
  _shouldAutoFitWidth() {
    return this._autoFitWidth && !this._autoWidth;
  }
  _shouldAutoFitHeight() {
    return this._autoFitHeight && !this._autoHeight;
  }
  _shouldAutoFit() {
    return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
  }
  _calculateCharsPerTexture(e) {
    const t = {};
    e === void 0 && (e = this._symbols.length);
    for (let s = 0, i = e; s < i; s++) {
      const n = this._symbols[s];
      let a = this._font.data.chars[n];
      a || (a = this._font.data.chars[" "], a || (a = this._font.data.chars[Object.keys(this._font.data.chars)[0]]));
      const o = a.map;
      t[o] ? t[o]++ : t[o] = 1;
    }
    return t;
  }
  _updateRenderRange() {
    const e = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart), t = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
    for (let s = 0, i = this._meshInfo.length; s < i; s++) {
      const n = e[s] || 0, a = t[s] || 0, o = this._meshInfo[s].meshInstance;
      if (o) {
        const h = o.mesh;
        h && (h.primitive[0].base = n * 3 * 2, h.primitive[0].count = (a - n) * 3 * 2);
      }
    }
  }
  set text(e) {
    this._i18nKey = null;
    const t = e != null && e.toString() || "";
    this._setText(t);
  }
  get text() {
    return this._text;
  }
  set key(e) {
    const t = e !== null ? e.toString() : null;
    this._i18nKey !== t && (this._i18nKey = t, t ? (this._fontAsset.disableLocalization = !1, this._resetLocalizedText()) : this._fontAsset.disableLocalization = !0);
  }
  get key() {
    return this._i18nKey;
  }
  set color(e) {
    const t = e.r, s = e.g, i = e.b;
    if (!(this._color.r === t && this._color.g === s && this._color.b === i) && (this._color.r = t, this._color.g = s, this._color.b = i, !!this._model)) {
      if (this._symbolColors)
        this._font && this._updateText();
      else {
        this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b;
        for (let n = 0, a = this._model.meshInstances.length; n < a; n++)
          this._model.meshInstances[n].setParameter("material_emissive", this._colorUniform);
      }
      this._element && this._element.fire("set:color", this._color);
    }
  }
  get color() {
    return this._color;
  }
  set opacity(e) {
    if (this._color.a !== e && (this._color.a = e, this._model))
      for (let t = 0, s = this._model.meshInstances.length; t < s; t++)
        this._model.meshInstances[t].setParameter("material_opacity", e);
    this._element && this._element.fire("set:opacity", e);
  }
  get opacity() {
    return this._color.a;
  }
  set lineHeight(e) {
    const t = this._lineHeight;
    this._lineHeight = e, this._scaledLineHeight = e, t !== e && this._font && this._updateText();
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set wrapLines(e) {
    const t = this._wrapLines;
    this._wrapLines = e, t !== e && this._font && this._updateText();
  }
  get wrapLines() {
    return this._wrapLines;
  }
  get lines() {
    return this._lineContents;
  }
  set spacing(e) {
    const t = this._spacing;
    this._spacing = e, t !== e && this._font && this._updateText();
  }
  get spacing() {
    return this._spacing;
  }
  set fontSize(e) {
    const t = this._fontSize;
    this._fontSize = e, this._originalFontSize = e, t !== e && this._font && this._updateText();
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontAsset(e) {
    this._fontAsset.defaultAsset = e;
  }
  get fontAsset() {
    return this._fontAsset.localizedAsset;
  }
  set font(e) {
    let t;
    if (this._font && (t = this._font.type, this._font.off && this._font.off("render", this._onFontRender, this)), this._font = e, this._fontMinY = 0, this._fontMaxY = 0, !e)
      return;
    const s = this._font.data;
    for (const n in s.chars) {
      const a = s.chars[n];
      a.bounds && (this._fontMinY = Math.min(this._fontMinY, a.bounds[1]), this._fontMaxY = Math.max(this._fontMaxY, a.bounds[3]));
    }
    if (this._font.on && this._font.on("render", this._onFontRender, this), this._fontAsset.localizedAsset && this._system.app.assets.get(this._fontAsset.localizedAsset).resource !== this._font && (this._fontAsset.defaultAsset = null), e.type !== t) {
      const n = this._element._isScreenSpace();
      this._updateMaterial(n);
    }
    for (let n = 0, a = this._font.textures.length; n < a; n++)
      if (!this._meshInfo[n])
        this._meshInfo[n] = new oM();
      else {
        const o = this._meshInfo[n].meshInstance;
        o && (o.setParameter("font_sdfIntensity", this._font.intensity), o.setParameter("font_pxrange", this._getPxRange(this._font)), o.setParameter("font_textureWidth", this._font.data.info.maps[n].width), this._setTextureParams(o, this._font.textures[n]));
      }
    let i = !1;
    for (let n = this._font.textures.length; n < this._meshInfo.length; n++)
      this._meshInfo[n].meshInstance && (i || (this._element.removeModelFromLayers(this._model), i = !0), this._removeMeshInstance(this._meshInfo[n].meshInstance));
    this._meshInfo.length > this._font.textures.length && (this._meshInfo.length = this._font.textures.length), this._updateText();
  }
  get font() {
    return this._font;
  }
  set alignment(e) {
    e instanceof q ? this._alignment.set(e.x, e.y) : this._alignment.set(e[0], e[1]), this._font && this._updateText();
  }
  get alignment() {
    return this._alignment;
  }
  set autoWidth(e) {
    const t = this._autoWidth;
    if (this._autoWidth = e, e && Math.abs(this._element.anchor.x - this._element.anchor.z) < 1e-4 && (this._element.width = this.width), t !== e) {
      const s = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
      s !== this._fontSize && (this._fontSize = s, this._font && this._updateText());
    }
  }
  get autoWidth() {
    return this._autoWidth;
  }
  set autoHeight(e) {
    const t = this._autoHeight;
    if (this._autoHeight = e, e && Math.abs(this._element.anchor.y - this._element.anchor.w) < 1e-4 && (this._element.height = this.height), t !== e) {
      const s = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
      s !== this._fontSize && (this._fontSize = s, this._font && this._updateText());
    }
  }
  get autoHeight() {
    return this._autoHeight;
  }
  set rtlReorder(e) {
    this._rtlReorder !== e && (this._rtlReorder = e, this._font && this._updateText());
  }
  get rtlReorder() {
    return this._rtlReorder;
  }
  set unicodeConverter(e) {
    this._unicodeConverter !== e && (this._unicodeConverter = e, this._setText(this._text));
  }
  get unicodeConverter() {
    return this._unicodeConverter;
  }
  get aabb() {
    if (this._aabbDirty) {
      let e = !1;
      for (let t = 0; t < this._meshInfo.length; t++)
        this._meshInfo[t].meshInstance && (e ? this._aabb.add(this._meshInfo[t].meshInstance.aabb) : (this._aabb.copy(this._meshInfo[t].meshInstance.aabb), e = !0));
      this._aabbDirty = !1;
    }
    return this._aabb;
  }
  set outlineColor(e) {
    const t = e instanceof z ? e.r : e[0], s = e instanceof z ? e.g : e[1], i = e instanceof z ? e.b : e[2], n = e instanceof z ? e.a : e[3];
    if (!(this._outlineColor.r === t && this._outlineColor.g === s && this._outlineColor.b === i && this._outlineColor.a === n) && (this._outlineColor.r = t, this._outlineColor.g = s, this._outlineColor.b = i, this._outlineColor.a = n, !!this._model)) {
      if (this._symbolOutlineParams)
        this._font && this._updateText();
      else {
        this._outlineColorUniform[0] = this._outlineColor.r, this._outlineColorUniform[1] = this._outlineColor.g, this._outlineColorUniform[2] = this._outlineColor.b, this._outlineColorUniform[3] = this._outlineColor.a;
        for (let a = 0, o = this._model.meshInstances.length; a < o; a++)
          this._model.meshInstances[a].setParameter("outline_color", this._outlineColorUniform);
      }
      this._element && this._element.fire("set:outline", this._color);
    }
  }
  get outlineColor() {
    return this._outlineColor;
  }
  set outlineThickness(e) {
    const t = this._outlineThickness;
    if (this._outlineThickness = e, t !== e && this._font) {
      if (!this._model)
        return;
      if (this._symbolOutlineParams)
        this._font && this._updateText();
      else
        for (let s = 0, i = this._model.meshInstances.length; s < i; s++)
          this._model.meshInstances[s].setParameter("outline_thickness", this._outlineThicknessScale * this._outlineThickness);
    }
  }
  get outlineThickness() {
    return this._outlineThickness;
  }
  set shadowColor(e) {
    const t = e instanceof z ? e.r : e[0], s = e instanceof z ? e.g : e[1], i = e instanceof z ? e.b : e[2], n = e instanceof z ? e.a : e[3];
    if (!(this._shadowColor.r === t && this._shadowColor.g === s && this._shadowColor.b === i && this._shadowColor.a === n) && (this._shadowColor.r = t, this._shadowColor.g = s, this._shadowColor.b = i, this._shadowColor.a = n, !!this._model))
      if (this._symbolShadowParams)
        this._font && this._updateText();
      else {
        this._shadowColorUniform[0] = this._shadowColor.r, this._shadowColorUniform[1] = this._shadowColor.g, this._shadowColorUniform[2] = this._shadowColor.b, this._shadowColorUniform[3] = this._shadowColor.a;
        for (let a = 0, o = this._model.meshInstances.length; a < o; a++)
          this._model.meshInstances[a].setParameter("shadow_color", this._shadowColorUniform);
      }
  }
  get shadowColor() {
    return this._shadowColor;
  }
  set shadowOffset(e) {
    const t = e instanceof q ? e.x : e[0], s = e instanceof q ? e.y : e[1];
    if (!(this._shadowOffset.x === t && this._shadowOffset.y === s) && (this._shadowOffset.set(t, s), this._font && this._model))
      if (this._symbolShadowParams)
        this._updateText();
      else
        for (let i = 0, n = this._model.meshInstances.length; i < n; i++) {
          const a = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
          this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x, this._shadowOffsetUniform[1] = a * this._shadowOffsetScale * this._shadowOffset.y, this._model.meshInstances[i].setParameter("shadow_offset", this._shadowOffsetUniform);
        }
  }
  get shadowOffset() {
    return this._shadowOffset;
  }
  set minFontSize(e) {
    this._minFontSize !== e && (this._minFontSize = e, this.font && this._shouldAutoFit() && this._updateText());
  }
  get minFontSize() {
    return this._minFontSize;
  }
  set maxFontSize(e) {
    this._maxFontSize !== e && (this._maxFontSize = e, this.font && this._shouldAutoFit() && this._updateText());
  }
  get maxFontSize() {
    return this._maxFontSize;
  }
  set autoFitWidth(e) {
    this._autoFitWidth !== e && (this._autoFitWidth = e, this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, this.font && this._updateText());
  }
  get autoFitWidth() {
    return this._autoFitWidth;
  }
  set autoFitHeight(e) {
    this._autoFitHeight !== e && (this._autoFitHeight = e, this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize, this.font && this._updateText());
  }
  get autoFitHeight() {
    return this._autoFitHeight;
  }
  set maxLines(e) {
    this._maxLines !== e && (e === null && this._maxLines === -1 || (this._maxLines = e === null ? -1 : e, this.font && this._wrapLines && this._updateText()));
  }
  get maxLines() {
    return this._maxLines;
  }
  set enableMarkup(e) {
    if (e = !!e, this._enableMarkup === e)
      return;
    this._enableMarkup = e, this.font && this._updateText();
    const t = this._element._isScreenSpace();
    this._updateMaterial(t);
  }
  get enableMarkup() {
    return this._enableMarkup;
  }
  get symbols() {
    return this._symbols;
  }
  get symbolColors() {
    return this._symbolColors === null ? null : this._symbolColors.map(function(e) {
      return this._colorPalette.slice(e * 3, e * 3 + 3);
    }, this);
  }
  get symbolOutlineParams() {
    return this._symbolOutlineParams === null ? null : this._symbolOutlineParams.map(function(e) {
      return this._outlinePalette.slice(e * 5, e * 5 + 5);
    }, this);
  }
  get symbolShadowParams() {
    return this._symbolShadowParams === null ? null : this._symbolShadowParams.map(function(e) {
      return this._shadowPalette.slice(e * 6, e * 6 + 6);
    }, this);
  }
  get rtl() {
    return this._rtl;
  }
  set rangeStart(e) {
    e = Math.max(0, Math.min(e, this._symbols.length)), e !== this._rangeStart && (this._rangeStart = e, this._updateRenderRange());
  }
  get rangeStart() {
    return this._rangeStart;
  }
  set rangeEnd(e) {
    e = Math.max(this._rangeStart, Math.min(e, this._symbols.length)), e !== this._rangeEnd && (this._rangeEnd = e, this._updateRenderRange());
  }
  get rangeEnd() {
    return this._rangeEnd;
  }
}
const Nc = new v(), mp = new j(), ei = new v(), _M = new v(), os = new j(), jo = new j(), $o = new j(), rr = new j();
class Kl extends le {
  constructor(e, t) {
    super(e, t), this._beingInitialized = !1, this._anchor = new Z(), this._localAnchor = new Z(), this._pivot = new q(), this._width = this._calculatedWidth = 32, this._height = this._calculatedHeight = 32, this._margin = new Z(0, 0, -32, -32), this._modelTransform = new j(), this._screenToWorld = new j(), this._anchorTransform = new j(), this._anchorDirty = !0, this._parentWorldTransform = new j(), this._screenTransform = new j(), this._screenCorners = [new v(), new v(), new v(), new v()], this._canvasCorners = [new q(), new q(), new q(), new q()], this._worldCorners = [new v(), new v(), new v(), new v()], this._cornersDirty = !0, this._canvasCornersDirty = !0, this._worldCornersDirty = !0, this.entity.on("insert", this._onInsert, this), this._patch(), this.screen = null, this._type = vh, this._image = null, this._text = null, this._group = null, this._drawOrder = 0, this._fitMode = Sh, this._useInput = !1, this._layers = [Xa], this._addedModels = [], this._batchGroupId = -1, this._offsetReadAt = 0, this._maskOffset = 0.5, this._maskedBy = null;
  }
  get _absLeft() {
    return this._localAnchor.x + this._margin.x;
  }
  get _absRight() {
    return this._localAnchor.z - this._margin.z;
  }
  get _absTop() {
    return this._localAnchor.w - this._margin.w;
  }
  get _absBottom() {
    return this._localAnchor.y + this._margin.y;
  }
  get _hasSplitAnchorsX() {
    return Math.abs(this._anchor.x - this._anchor.z) > 1e-3;
  }
  get _hasSplitAnchorsY() {
    return Math.abs(this._anchor.y - this._anchor.w) > 1e-3;
  }
  get aabb() {
    return this._image ? this._image.aabb : this._text ? this._text.aabb : null;
  }
  set anchor(e) {
    e instanceof Z ? this._anchor.copy(e) : this._anchor.set(...e), !this.entity._parent && !this.screen ? this._calculateLocalAnchors() : this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY), this._anchorDirty = !0, this.entity._dirtyLocal || this.entity._dirtifyLocal(), this.fire("set:anchor", this._anchor);
  }
  get anchor() {
    return this._anchor;
  }
  set batchGroupId(e) {
    if (this._batchGroupId !== e) {
      if (this.entity.enabled && this._batchGroupId >= 0) {
        var t;
        (t = this.system.app.batcher) == null || t.remove(nt.ELEMENT, this.batchGroupId, this.entity);
      }
      if (this.entity.enabled && e >= 0) {
        var s;
        (s = this.system.app.batcher) == null || s.insert(nt.ELEMENT, e, this.entity);
      }
      e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && (this._image && this._image._renderable.model ? this.addModelToLayers(this._image._renderable.model) : this._text && this._text._model && this.addModelToLayers(this._text._model)), this._batchGroupId = e;
    }
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set bottom(e) {
    this._margin.y = e;
    const t = this.entity.getLocalPosition(), s = this._absTop, i = this._localAnchor.y + e;
    this._setHeight(s - i), t.y = e + this._calculatedHeight * this._pivot.y, this.entity.setLocalPosition(t);
  }
  get bottom() {
    return this._margin.y;
  }
  set calculatedWidth(e) {
    this._setCalculatedWidth(e, !0);
  }
  get calculatedWidth() {
    return this._calculatedWidth;
  }
  set calculatedHeight(e) {
    this._setCalculatedHeight(e, !0);
  }
  get calculatedHeight() {
    return this._calculatedHeight;
  }
  get canvasCorners() {
    if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace)
      return this._canvasCorners;
    const e = this.system.app.graphicsDevice, t = this.screenCorners, s = e.canvas.clientWidth / e.width, i = e.canvas.clientHeight / e.height;
    for (let n = 0; n < 4; n++)
      this._canvasCorners[n].set(t[n].x * s, (e.height - t[n].y) * i);
    return this._canvasCornersDirty = !1, this._canvasCorners;
  }
  set drawOrder(e) {
    let t = 0;
    this.screen && (t = this.screen.screen.priority), e > 16777215 && (e = 16777215), this._drawOrder = (t << 24) + e, this.fire("set:draworder", this._drawOrder);
  }
  get drawOrder() {
    return this._drawOrder;
  }
  set height(e) {
    this._height = e, this._hasSplitAnchorsY || this._setCalculatedHeight(e, !0), this.fire("set:height", this._height);
  }
  get height() {
    return this._height;
  }
  set layers(e) {
    if (this._addedModels.length)
      for (let t = 0; t < this._layers.length; t++) {
        const s = this.system.app.scene.layers.getLayerById(this._layers[t]);
        if (s)
          for (let i = 0; i < this._addedModels.length; i++)
            s.removeMeshInstances(this._addedModels[i].meshInstances);
      }
    if (this._layers = e, !(!this.enabled || !this.entity.enabled || !this._addedModels.length))
      for (let t = 0; t < this._layers.length; t++) {
        const s = this.system.app.scene.layers.getLayerById(this._layers[t]);
        if (s)
          for (let i = 0; i < this._addedModels.length; i++)
            s.addMeshInstances(this._addedModels[i].meshInstances);
      }
  }
  get layers() {
    return this._layers;
  }
  set left(e) {
    this._margin.x = e;
    const t = this.entity.getLocalPosition(), s = this._absRight, i = this._localAnchor.x + e;
    this._setWidth(s - i), t.x = e + this._calculatedWidth * this._pivot.x, this.entity.setLocalPosition(t);
  }
  get left() {
    return this._margin.x;
  }
  set margin(e) {
    this._margin.copy(e), this._calculateSize(!0, !0), this.fire("set:margin", this._margin);
  }
  get margin() {
    return this._margin;
  }
  get maskedBy() {
    return this._maskedBy;
  }
  set pivot(e) {
    const {
      pivot: t,
      margin: s
    } = this, i = t.x, n = t.y;
    e instanceof q ? t.copy(e) : t.set(...e);
    const a = s.x + s.z, o = t.x - i;
    s.x += a * o, s.z -= a * o;
    const h = s.y + s.w, l = t.y - n;
    s.y += h * l, s.w -= h * l, this._anchorDirty = !0, this._cornersDirty = !0, this._worldCornersDirty = !0, this._calculateSize(!1, !1), this._flagChildrenAsDirty(), this.fire("set:pivot", t);
  }
  get pivot() {
    return this._pivot;
  }
  set right(e) {
    this._margin.z = e;
    const t = this.entity.getLocalPosition(), s = this._absLeft, i = this._localAnchor.z - e;
    this._setWidth(i - s), t.x = this._localAnchor.z - this._localAnchor.x - e - this._calculatedWidth * (1 - this._pivot.x), this.entity.setLocalPosition(t);
  }
  get right() {
    return this._margin.z;
  }
  get screenCorners() {
    if (!this._cornersDirty || !this.screen)
      return this._screenCorners;
    const e = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
    this._screenCorners[0].set(this._absLeft, this._absBottom, 0), this._screenCorners[1].set(this._absRight, this._absBottom, 0), this._screenCorners[2].set(this._absRight, this._absTop, 0), this._screenCorners[3].set(this._absLeft, this._absTop, 0);
    const t = this.screen.screen.screenSpace;
    for (let s = 0; s < 4; s++)
      this._screenTransform.transformPoint(this._screenCorners[s], this._screenCorners[s]), t && this._screenCorners[s].mulScalar(this.screen.screen.scale), e && this._screenCorners[s].add(e);
    return this._cornersDirty = !1, this._canvasCornersDirty = !0, this._worldCornersDirty = !0, this._screenCorners;
  }
  get textWidth() {
    return this._text ? this._text.width : 0;
  }
  get textHeight() {
    return this._text ? this._text.height : 0;
  }
  set top(e) {
    this._margin.w = e;
    const t = this.entity.getLocalPosition(), s = this._absBottom, i = this._localAnchor.w - e;
    this._setHeight(i - s), t.y = this._localAnchor.w - this._localAnchor.y - e - this._calculatedHeight * (1 - this._pivot.y), this.entity.setLocalPosition(t);
  }
  get top() {
    return this._margin.w;
  }
  set type(e) {
    e !== this._type && (this._type = e, this._image && (this._image.destroy(), this._image = null), this._text && (this._text.destroy(), this._text = null), e === Hd ? this._image = new K1(this) : e === ni && (this._text = new pM(this)));
  }
  get type() {
    return this._type;
  }
  set useInput(e) {
    this._useInput !== e && (this._useInput = e, this.system.app.elementInput ? e ? this.enabled && this.entity.enabled && this.system.app.elementInput.addElement(this) : this.system.app.elementInput.removeElement(this) : this._useInput, this.fire("set:useInput", e));
  }
  get useInput() {
    return this._useInput;
  }
  set fitMode(e) {
    this._fitMode = e, this._calculateSize(!0, !0), this._image && this._image.refreshMesh();
  }
  get fitMode() {
    return this._fitMode;
  }
  set width(e) {
    this._width = e, this._hasSplitAnchorsX || this._setCalculatedWidth(e, !0), this.fire("set:width", this._width);
  }
  get width() {
    return this._width;
  }
  get worldCorners() {
    if (!this._worldCornersDirty)
      return this._worldCorners;
    if (this.screen) {
      const e = this.screenCorners;
      if (!this.screen.screen.screenSpace) {
        os.copy(this.screen.screen._screenMatrix), os.data[13] = -os.data[13], os.mul2(this.screen.getWorldTransform(), os);
        for (let t = 0; t < 4; t++)
          os.transformPoint(e[t], this._worldCorners[t]);
      }
    } else {
      const e = this.entity.getLocalPosition();
      os.setTranslate(-e.x, -e.y, -e.z), jo.setTRS(v.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale()), $o.setTranslate(e.x, e.y, e.z);
      const t = this.entity.parent ? this.entity.parent : this.entity;
      rr.copy(t.getWorldTransform()), rr.mul($o).mul(jo).mul(os), ei.set(e.x - this.pivot.x * this.calculatedWidth, e.y - this.pivot.y * this.calculatedHeight, e.z), rr.transformPoint(ei, this._worldCorners[0]), ei.set(e.x + (1 - this.pivot.x) * this.calculatedWidth, e.y - this.pivot.y * this.calculatedHeight, e.z), rr.transformPoint(ei, this._worldCorners[1]), ei.set(e.x + (1 - this.pivot.x) * this.calculatedWidth, e.y + (1 - this.pivot.y) * this.calculatedHeight, e.z), rr.transformPoint(ei, this._worldCorners[2]), ei.set(e.x - this.pivot.x * this.calculatedWidth, e.y + (1 - this.pivot.y) * this.calculatedHeight, e.z), rr.transformPoint(ei, this._worldCorners[3]);
    }
    return this._worldCornersDirty = !1, this._worldCorners;
  }
  _patch() {
    this.entity._sync = this._sync, this.entity.setPosition = this._setPosition, this.entity.setLocalPosition = this._setLocalPosition;
  }
  _unpatch() {
    this.entity._sync = oe.prototype._sync, this.entity.setPosition = oe.prototype.setPosition, this.entity.setLocalPosition = oe.prototype.setLocalPosition;
  }
  _setPosition(e, t, s) {
    if (!this.element.screen) {
      oe.prototype.setPosition.call(this, e, t, s);
      return;
    }
    e instanceof v ? Nc.copy(e) : Nc.set(e, t, s), this.getWorldTransform(), mp.copy(this.element._screenToWorld).invert(), mp.transformPoint(Nc, this.localPosition), this._dirtyLocal || this._dirtifyLocal();
  }
  _setLocalPosition(e, t, s) {
    e instanceof v ? this.localPosition.copy(e) : this.localPosition.set(e, t, s);
    const i = this.element, n = this.localPosition, a = i._pivot;
    i._margin.x = n.x - i._calculatedWidth * a.x, i._margin.z = i._localAnchor.z - i._localAnchor.x - i._calculatedWidth - i._margin.x, i._margin.y = n.y - i._calculatedHeight * a.y, i._margin.w = i._localAnchor.w - i._localAnchor.y - i._calculatedHeight - i._margin.y, this._dirtyLocal || this._dirtifyLocal();
  }
  _sync() {
    const e = this.element, t = e.screen;
    if (t) {
      if (e._anchorDirty) {
        let s = 0, i = 0, n = 0, a = 1;
        if (this._parent && this._parent.element)
          s = this._parent.element.calculatedWidth, i = this._parent.element.calculatedHeight, n = this._parent.element.pivot.x, a = this._parent.element.pivot.y;
        else {
          const o = t.screen.resolution;
          s = o.x / t.screen.scale, i = o.y / t.screen.scale;
        }
        e._anchorTransform.setTranslate(s * (e.anchor.x - n), -(i * (a - e.anchor.y)), 0), e._anchorDirty = !1, e._calculateLocalAnchors();
      }
      e._sizeDirty && e._calculateSize(!1, !1);
    }
    if (this._dirtyLocal) {
      this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
      const s = this.localPosition, i = e._pivot;
      e._margin.x = s.x - e._calculatedWidth * i.x, e._margin.z = e._localAnchor.z - e._localAnchor.x - e._calculatedWidth - e._margin.x, e._margin.y = s.y - e._calculatedHeight * i.y, e._margin.w = e._localAnchor.w - e._localAnchor.y - e._calculatedHeight - e._margin.y, this._dirtyLocal = !1;
    }
    if (!t)
      return this._dirtyWorld && (e._cornersDirty = !0, e._canvasCornersDirty = !0, e._worldCornersDirty = !0), oe.prototype._sync.call(this);
    if (this._dirtyWorld) {
      if (this._parent === null)
        this.worldTransform.copy(this.localTransform);
      else if (this._parent.element ? e._screenToWorld.mul2(this._parent.element._modelTransform, e._anchorTransform) : e._screenToWorld.copy(e._anchorTransform), e._modelTransform.mul2(e._screenToWorld, this.localTransform), t) {
        e._screenToWorld.mul2(t.screen._screenMatrix, e._screenToWorld), t.screen.screenSpace || e._screenToWorld.mul2(t.worldTransform, e._screenToWorld), this.worldTransform.mul2(e._screenToWorld, this.localTransform);
        const s = e._parentWorldTransform;
        s.setIdentity();
        const i = this._parent;
        i && i.element && i !== t && (os.setTRS(v.ZERO, i.getLocalRotation(), i.getLocalScale()), s.mul2(i.element._parentWorldTransform, os));
        const n = ei;
        n.set(0, 0, this.localPosition.z);
        const a = _M;
        a.set(e._absLeft + e._pivot.x * e.calculatedWidth, e._absBottom + e._pivot.y * e.calculatedHeight, 0), os.setTranslate(-a.x, -a.y, -a.z), jo.setTRS(n, this.getLocalRotation(), this.getLocalScale()), $o.setTranslate(a.x, a.y, a.z), e._screenTransform.mul2(e._parentWorldTransform, $o).mul(jo).mul(os), e._cornersDirty = !0, e._canvasCornersDirty = !0, e._worldCornersDirty = !0;
      } else
        this.worldTransform.copy(e._modelTransform);
      this._dirtyWorld = !1;
    }
  }
  _onInsert(e) {
    const t = this._parseUpToScreen();
    this.entity._dirtifyWorld(), this._updateScreen(t.screen), this._dirtifyMask();
  }
  _dirtifyMask() {
    let e = this.entity;
    for (; e; ) {
      const t = e.parent;
      if ((t === null || t.screen) && e.element) {
        (!this.system._prerender || !this.system._prerender.length) && (this.system._prerender = [], this.system.app.once("prerender", this._onPrerender, this));
        const s = this.system._prerender.indexOf(this.entity);
        s >= 0 && this.system._prerender.splice(s, 1), this.system._prerender.indexOf(e) < 0 && this.system._prerender.push(e);
      }
      e = t;
    }
  }
  _onPrerender() {
    for (let e = 0; e < this.system._prerender.length; e++) {
      const t = this.system._prerender[e];
      t.element && t.element.syncMask(1);
    }
    this.system._prerender.length = 0;
  }
  _bindScreen(e) {
    e._bindElement(this);
  }
  _unbindScreen(e) {
    e._unbindElement(this);
  }
  _updateScreen(e) {
    this.screen && this.screen !== e && this._unbindScreen(this.screen.screen);
    const t = this.screen;
    this.screen = e, this.screen && this._bindScreen(this.screen.screen), this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY), this.fire("set:screen", this.screen, t), this._anchorDirty = !0;
    const s = this.entity.children;
    for (let i = 0, n = s.length; i < n; i++)
      s[i].element && s[i].element._updateScreen(e);
    this.screen && this.screen.screen.syncDrawOrder();
  }
  syncMask(e) {
    const t = this._parseUpToScreen();
    this._updateMask(t.mask, e);
  }
  _setMaskedBy(e) {
    const t = this._image || this._text;
    if (e) {
      const s = e.element._image._maskRef, i = new Lr({
        ref: s,
        func: Eh
      });
      t && t._setStencil && t._setStencil(i), this._maskedBy = e;
    } else
      t && t._setStencil && t._setStencil(null), this._maskedBy = null;
  }
  _updateMask(e, t) {
    if (e) {
      if (this._setMaskedBy(e), this.mask) {
        const i = e.element._image._maskRef, n = new Lr({
          ref: i,
          func: Eh,
          zpass: N0
        });
        this._image._setStencil(n), this._image._maskRef = t, t++, e = this.entity;
      }
      const s = this.entity.children;
      for (let i = 0, n = s.length; i < n; i++)
        s[i].element && s[i].element._updateMask(e, t);
      this.mask && t--;
    } else {
      if (this._setMaskedBy(null), this.mask) {
        const i = new Lr({
          ref: t,
          func: Mn,
          zpass: k0
        });
        this._image._setStencil(i), this._image._maskRef = t, t++, e = this.entity;
      }
      const s = this.entity.children;
      for (let i = 0, n = s.length; i < n; i++)
        s[i].element && s[i].element._updateMask(e, t);
      this.mask && t--;
    }
  }
  _parseUpToScreen() {
    const e = {
      screen: null,
      mask: null
    };
    let t = this.entity._parent;
    for (; t && !t.screen; )
      t.element && t.element.mask && (e.mask || (e.mask = t)), t = t.parent;
    return t && t.screen && (e.screen = t), e;
  }
  _onScreenResize(e) {
    this._anchorDirty = !0, this._cornersDirty = !0, this._worldCornersDirty = !0, this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY), this.fire("screen:set:resolution", e);
  }
  _onScreenSpaceChange() {
    this.fire("screen:set:screenspace", this.screen.screen.screenSpace);
  }
  _onScreenRemove() {
    this.screen && (this.screen._destroying ? this.screen = null : this._updateScreen(null));
  }
  _calculateLocalAnchors() {
    let e = 1e3, t = 1e3;
    const s = this.entity._parent;
    if (s && s.element)
      e = s.element.calculatedWidth, t = s.element.calculatedHeight;
    else if (this.screen) {
      const i = this.screen.screen.resolution, n = this.screen.screen.scale;
      e = i.x / n, t = i.y / n;
    }
    this._localAnchor.set(this._anchor.x * e, this._anchor.y * t, this._anchor.z * e, this._anchor.w * t);
  }
  getOffsetPosition(e, t) {
    const s = this.entity.getLocalPosition().clone();
    return s.x += e, s.y += t, this._screenToWorld.transformPoint(s, s), s;
  }
  onLayersChanged(e, t) {
    this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    this.layers.indexOf(e.id) < 0 || (this._image ? e.addMeshInstances(this._image._renderable.model.meshInstances) : this._text && e.addMeshInstances(this._text._model.meshInstances));
  }
  onLayerRemoved(e) {
    this.layers.indexOf(e.id) < 0 || (this._image ? e.removeMeshInstances(this._image._renderable.model.meshInstances) : this._text && e.removeMeshInstances(this._text._model.meshInstances));
  }
  onEnable() {
    if (this._image && this._image.onEnable(), this._text && this._text.onEnable(), this._group && this._group.onEnable(), this.useInput && this.system.app.elementInput && this.system.app.elementInput.addElement(this), this.system.app.scene.on("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)), this._batchGroupId >= 0) {
      var e;
      (e = this.system.app.batcher) == null || e.insert(nt.ELEMENT, this.batchGroupId, this.entity);
    }
    this.fire("enableelement");
  }
  onDisable() {
    if (this.system.app.scene.off("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)), this._image && this._image.onDisable(), this._text && this._text.onDisable(), this._group && this._group.onDisable(), this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this), this._batchGroupId >= 0) {
      var e;
      (e = this.system.app.batcher) == null || e.remove(nt.ELEMENT, this.batchGroupId, this.entity);
    }
    this.fire("disableelement");
  }
  onRemove() {
    this.entity.off("insert", this._onInsert, this), this._unpatch(), this._image && this._image.destroy(), this._text && this._text.destroy(), this.system.app.elementInput && this.useInput && this.system.app.elementInput.removeElement(this), this.screen && this.screen.screen && (this._unbindScreen(this.screen.screen), this.screen.screen.syncDrawOrder()), this.off();
  }
  _calculateSize(e, t) {
    if (!this.entity._parent && !this.screen)
      return;
    this._calculateLocalAnchors();
    const s = this._absRight - this._absLeft, i = this._absTop - this._absBottom;
    e ? this._setWidth(s) : this._setCalculatedWidth(s, !1), t ? this._setHeight(i) : this._setCalculatedHeight(i, !1);
    const n = this.entity.getLocalPosition();
    n.x = this._margin.x + this._calculatedWidth * this._pivot.x, n.y = this._margin.y + this._calculatedHeight * this._pivot.y, this.entity.setLocalPosition(n), this._sizeDirty = !1;
  }
  _setWidth(e) {
    this._width = e, this._setCalculatedWidth(e, !1), this.fire("set:width", this._width);
  }
  _setHeight(e) {
    this._height = e, this._setCalculatedHeight(e, !1), this.fire("set:height", this._height);
  }
  _setCalculatedWidth(e, t) {
    if (!(Math.abs(e - this._calculatedWidth) <= 1e-4)) {
      if (this._calculatedWidth = e, this.entity._dirtifyLocal(), t) {
        const s = this.entity.getLocalPosition(), i = this._pivot;
        this._margin.x = s.x - this._calculatedWidth * i.x, this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
      }
      this._flagChildrenAsDirty(), this.fire("set:calculatedWidth", this._calculatedWidth), this.fire("resize", this._calculatedWidth, this._calculatedHeight);
    }
  }
  _setCalculatedHeight(e, t) {
    if (!(Math.abs(e - this._calculatedHeight) <= 1e-4)) {
      if (this._calculatedHeight = e, this.entity._dirtifyLocal(), t) {
        const s = this.entity.getLocalPosition(), i = this._pivot;
        this._margin.y = s.y - this._calculatedHeight * i.y, this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
      }
      this._flagChildrenAsDirty(), this.fire("set:calculatedHeight", this._calculatedHeight), this.fire("resize", this._calculatedWidth, this._calculatedHeight);
    }
  }
  _flagChildrenAsDirty() {
    const e = this.entity._children;
    for (let t = 0, s = e.length; t < s; t++)
      e[t].element && (e[t].element._anchorDirty = !0, e[t].element._sizeDirty = !0);
  }
  addModelToLayers(e) {
    this._addedModels.push(e);
    for (let t = 0; t < this.layers.length; t++) {
      const s = this.system.app.scene.layers.getLayerById(this.layers[t]);
      s && s.addMeshInstances(e.meshInstances);
    }
  }
  removeModelFromLayers(e) {
    const t = this._addedModels.indexOf(e);
    t >= 0 && this._addedModels.splice(t, 1);
    for (let s = 0; s < this.layers.length; s++) {
      const i = this.system.app.scene.layers.getLayerById(this.layers[s]);
      i && i.removeMeshInstances(e.meshInstances);
    }
  }
  getMaskOffset() {
    const e = this.system.app.frame;
    this._offsetReadAt !== e && (this._maskOffset = 0.5, this._offsetReadAt = e);
    const t = this._maskOffset;
    return this._maskOffset -= 1e-3, t;
  }
  isVisibleForCamera(e) {
    let t, s, i, n;
    if (this.maskedBy) {
      const d = this.maskedBy.element.screenCorners;
      t = Math.min(Math.min(d[0].x, d[1].x), Math.min(d[2].x, d[3].x)), s = Math.max(Math.max(d[0].x, d[1].x), Math.max(d[2].x, d[3].x)), n = Math.min(Math.min(d[0].y, d[1].y), Math.min(d[2].y, d[3].y)), i = Math.max(Math.max(d[0].y, d[1].y), Math.max(d[2].y, d[3].y));
    } else {
      const d = this.system.app.graphicsDevice.width, u = this.system.app.graphicsDevice.height, f = e._rect.z * d, m = e._rect.w * u;
      t = e._rect.x * d, s = t + f, i = (1 - e._rect.y) * u, n = i - m;
    }
    const a = this.screenCorners, o = Math.min(Math.min(a[0].x, a[1].x), Math.min(a[2].x, a[3].x)), h = Math.max(Math.max(a[0].x, a[1].x), Math.max(a[2].x, a[3].x)), l = Math.min(Math.min(a[0].y, a[1].y), Math.min(a[2].y, a[3].y)), c = Math.max(Math.max(a[0].y, a[1].y), Math.max(a[2].y, a[3].y));
    return !(h < t || o > s || l > i || c < n);
  }
  _isScreenSpace() {
    return this.screen && this.screen.screen ? this.screen.screen.screenSpace : !1;
  }
  _isScreenCulled() {
    return this.screen && this.screen.screen ? this.screen.screen.cull : !1;
  }
  _dirtyBatch() {
    if (this.batchGroupId !== -1) {
      var e;
      (e = this.system.app.batcher) == null || e.markGroupDirty(this.batchGroupId);
    }
  }
}
function Te(r) {
  Object.defineProperty(Kl.prototype, r, {
    get: function() {
      return this._text ? this._text[r] : this._image ? this._image[r] : null;
    },
    set: function(e) {
      this._text ? (this._text[r] !== e && this._dirtyBatch(), this._text[r] = e) : this._image && (this._image[r] !== e && this._dirtyBatch(), this._image[r] = e);
    }
  });
}
Te("fontSize");
Te("minFontSize");
Te("maxFontSize");
Te("maxLines");
Te("autoFitWidth");
Te("autoFitHeight");
Te("color");
Te("font");
Te("fontAsset");
Te("spacing");
Te("lineHeight");
Te("wrapLines");
Te("lines");
Te("alignment");
Te("autoWidth");
Te("autoHeight");
Te("rtlReorder");
Te("unicodeConverter");
Te("text");
Te("key");
Te("texture");
Te("textureAsset");
Te("material");
Te("materialAsset");
Te("sprite");
Te("spriteAsset");
Te("spriteFrame");
Te("pixelsPerUnit");
Te("opacity");
Te("rect");
Te("mask");
Te("outlineColor");
Te("outlineThickness");
Te("shadowColor");
Te("shadowOffset");
Te("enableMarkup");
Te("rangeStart");
Te("rangeEnd");
class gM {
  constructor() {
    this.enabled = !0;
  }
}
const qg = ["enabled"];
class yM extends Ye {
  constructor(e) {
    super(e), this.id = "element", this.ComponentType = Kl, this.DataType = gM, this.schema = qg, this._unicodeConverter = null, this._rtlReorder = null, this._defaultTexture = new ue(e.graphicsDevice, {
      width: 1,
      height: 1,
      format: ye,
      name: "element-system"
    });
    const t = this._defaultTexture.lock(), s = new Uint8Array(4);
    s[0] = 255, s[1] = 255, s[2] = 255, s[3] = 255, t.set(s), this._defaultTexture.unlock(), this.defaultImageMaterial = null, this.defaultImage9SlicedMaterial = null, this.defaultImage9TiledMaterial = null, this.defaultImageMaskMaterial = null, this.defaultImage9SlicedMaskMaterial = null, this.defaultImage9TiledMaskMaterial = null, this.defaultScreenSpaceImageMaterial = null, this.defaultScreenSpaceImage9SlicedMaterial = null, this.defaultScreenSpaceImage9TiledMaterial = null, this.defaultScreenSpaceImageMask9SlicedMaterial = null, this.defaultScreenSpaceImageMask9TiledMaterial = null, this.defaultScreenSpaceImageMaskMaterial = null, this._defaultTextMaterials = {}, this.defaultImageMaterials = [], this.on("beforeremove", this.onRemoveComponent, this);
  }
  destroy() {
    super.destroy(), this._defaultTexture.destroy();
  }
  initializeComponentData(e, t, s) {
    e._beingInitialized = !0, t.anchor !== void 0 && (t.anchor instanceof Z ? e.anchor.copy(t.anchor) : e.anchor.set(t.anchor[0], t.anchor[1], t.anchor[2], t.anchor[3])), t.pivot !== void 0 && (t.pivot instanceof q ? e.pivot.copy(t.pivot) : e.pivot.set(t.pivot[0], t.pivot[1]));
    const i = Math.abs(e.anchor.x - e.anchor.z) > 1e-3, n = Math.abs(e.anchor.y - e.anchor.w) > 1e-3;
    let a = !1, o;
    t.margin !== void 0 && (t.margin instanceof Z ? e.margin.copy(t.margin) : e._margin.set(t.margin[0], t.margin[1], t.margin[2], t.margin[3]), a = !0), t.left !== void 0 && (e._margin.x = t.left, a = !0), t.bottom !== void 0 && (e._margin.y = t.bottom, a = !0), t.right !== void 0 && (e._margin.z = t.right, a = !0), t.top !== void 0 && (e._margin.w = t.top, a = !0), a && (e.margin = e._margin);
    let h = !1;
    t.width !== void 0 && !i ? e.width = t.width : i && (h = !0), t.height !== void 0 && !n ? e.height = t.height : n && (h = !0), h && (e.anchor = e.anchor), t.enabled !== void 0 && (e.enabled = t.enabled), t.useInput !== void 0 && (e.useInput = t.useInput), t.fitMode !== void 0 && (e.fitMode = t.fitMode), e.batchGroupId = t.batchGroupId === void 0 || t.batchGroupId === null ? -1 : t.batchGroupId, t.layers && Array.isArray(t.layers) && (e.layers = t.layers.slice(0)), t.type !== void 0 && (e.type = t.type), e.type === Hd ? (t.rect !== void 0 && (e.rect = t.rect), t.color !== void 0 && (o = t.color, o instanceof z || (o = new z(t.color[0], t.color[1], t.color[2])), e.color = o), t.opacity !== void 0 && (e.opacity = t.opacity), t.textureAsset !== void 0 && (e.textureAsset = t.textureAsset), t.texture && (e.texture = t.texture), t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset), t.sprite && (e.sprite = t.sprite), t.spriteFrame !== void 0 && (e.spriteFrame = t.spriteFrame), t.pixelsPerUnit !== void 0 && t.pixelsPerUnit !== null && (e.pixelsPerUnit = t.pixelsPerUnit), t.materialAsset !== void 0 && (e.materialAsset = t.materialAsset), t.material && (e.material = t.material), t.mask !== void 0 && (e.mask = t.mask)) : e.type === ni && (t.autoWidth !== void 0 && (e.autoWidth = t.autoWidth), t.autoHeight !== void 0 && (e.autoHeight = t.autoHeight), t.rtlReorder !== void 0 && (e.rtlReorder = t.rtlReorder), t.unicodeConverter !== void 0 && (e.unicodeConverter = t.unicodeConverter), t.text !== null && t.text !== void 0 ? e.text = t.text : t.key !== null && t.key !== void 0 && (e.key = t.key), t.color !== void 0 && (o = t.color, o instanceof z || (o = new z(o[0], o[1], o[2])), e.color = o), t.opacity !== void 0 && (e.opacity = t.opacity), t.spacing !== void 0 && (e.spacing = t.spacing), t.fontSize !== void 0 && (e.fontSize = t.fontSize, t.lineHeight || (e.lineHeight = t.fontSize)), t.lineHeight !== void 0 && (e.lineHeight = t.lineHeight), t.maxLines !== void 0 && (e.maxLines = t.maxLines), t.wrapLines !== void 0 && (e.wrapLines = t.wrapLines), t.minFontSize !== void 0 && (e.minFontSize = t.minFontSize), t.maxFontSize !== void 0 && (e.maxFontSize = t.maxFontSize), t.autoFitWidth && (e.autoFitWidth = t.autoFitWidth), t.autoFitHeight && (e.autoFitHeight = t.autoFitHeight), t.fontAsset !== void 0 && (e.fontAsset = t.fontAsset), t.font !== void 0 && (e.font = t.font), t.alignment !== void 0 && (e.alignment = t.alignment), t.outlineColor !== void 0 && (e.outlineColor = t.outlineColor), t.outlineThickness !== void 0 && (e.outlineThickness = t.outlineThickness), t.shadowColor !== void 0 && (e.shadowColor = t.shadowColor), t.shadowOffset !== void 0 && (e.shadowOffset = t.shadowOffset), t.enableMarkup !== void 0 && (e.enableMarkup = t.enableMarkup));
    const l = e._parseUpToScreen();
    l.screen && e._updateScreen(l.screen), super.initializeComponentData(e, t, s), e._beingInitialized = !1, e.type === Hd && e._image._meshDirty && e._image._updateMesh(e._image.mesh);
  }
  onRemoveComponent(e, t) {
    t.onRemove();
  }
  cloneComponent(e, t) {
    const s = e.element, i = {
      enabled: s.enabled,
      width: s.width,
      height: s.height,
      anchor: s.anchor.clone(),
      pivot: s.pivot.clone(),
      margin: s.margin.clone(),
      alignment: s.alignment && s.alignment.clone() || s.alignment,
      autoWidth: s.autoWidth,
      autoHeight: s.autoHeight,
      type: s.type,
      rect: s.rect && s.rect.clone() || s.rect,
      rtlReorder: s.rtlReorder,
      unicodeConverter: s.unicodeConverter,
      materialAsset: s.materialAsset,
      material: s.material,
      color: s.color && s.color.clone() || s.color,
      opacity: s.opacity,
      textureAsset: s.textureAsset,
      texture: s.texture,
      spriteAsset: s.spriteAsset,
      sprite: s.sprite,
      spriteFrame: s.spriteFrame,
      pixelsPerUnit: s.pixelsPerUnit,
      spacing: s.spacing,
      lineHeight: s.lineHeight,
      wrapLines: s.wrapLines,
      layers: s.layers,
      fontSize: s.fontSize,
      minFontSize: s.minFontSize,
      maxFontSize: s.maxFontSize,
      autoFitWidth: s.autoFitWidth,
      autoFitHeight: s.autoFitHeight,
      maxLines: s.maxLines,
      fontAsset: s.fontAsset,
      font: s.font,
      useInput: s.useInput,
      fitMode: s.fitMode,
      batchGroupId: s.batchGroupId,
      mask: s.mask,
      outlineColor: s.outlineColor && s.outlineColor.clone() || s.outlineColor,
      outlineThickness: s.outlineThickness,
      shadowColor: s.shadowColor && s.shadowColor.clone() || s.shadowColor,
      shadowOffset: s.shadowOffset && s.shadowOffset.clone() || s.shadowOffset,
      enableMarkup: s.enableMarkup
    };
    return s.key !== void 0 && s.key !== null ? i.key = s.key : i.text = s.text, this.addComponent(t, i);
  }
  getTextElementMaterial(e, t, s) {
    const i = (e && 1) | (t && 2) | (s && 4);
    let n = this._defaultTextMaterials[i];
    if (n)
      return n;
    let a = "TextMaterial";
    return n = new Ht(), t ? (n.msdfMap = this._defaultTexture, n.msdfTextAttribute = s, n.emissive.set(1, 1, 1)) : (a = "Bitmap" + a, n.emissive.set(0.5, 0.5, 0.5), n.emissiveMap = this._defaultTexture, n.emissiveTint = !0, n.opacityMap = this._defaultTexture, n.opacityMapChannel = "a"), e && (a = "ScreenSpace" + a, n.depthTest = !1), n.name = "default" + a, n.useLighting = !1, n.useGammaTonemap = !1, n.useFog = !1, n.useSkybox = !1, n.diffuse.set(0, 0, 0), n.opacity = 0.5, n.blendType = $i, n.depthWrite = !1, n.emissiveVertexColor = !0, n.update(), this._defaultTextMaterials[i] = n, n;
  }
  _createBaseImageMaterial() {
    const e = new Ht();
    return e.diffuse.set(0, 0, 0), e.emissive.set(0.5, 0.5, 0.5), e.emissiveMap = this._defaultTexture, e.emissiveTint = !0, e.opacityMap = this._defaultTexture, e.opacityMapChannel = "a", e.opacityTint = !0, e.opacity = 0, e.useLighting = !1, e.useGammaTonemap = !1, e.useFog = !1, e.useSkybox = !1, e.blendType = $i, e.depthWrite = !1, e;
  }
  getImageElementMaterial(e, t, s, i) {
    return e ? t ? s ? (this.defaultScreenSpaceImageMask9SlicedMaterial || (this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMask9SlicedMaterial.name = "defaultScreenSpaceImageMask9SlicedMaterial", this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = ht, this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1, this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMask9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial)), this.defaultScreenSpaceImageMask9SlicedMaterial) : i ? (this.defaultScreenSpaceImageMask9TiledMaterial || (this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone(), this.defaultScreenSpaceImageMask9TiledMaterial.name = "defaultScreenSpaceImageMask9TiledMaterial", this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = it, this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = !1, this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1, this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMask9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial)), this.defaultScreenSpaceImageMask9TiledMaterial) : (this.defaultScreenSpaceImageMaskMaterial || (this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMaskMaterial.name = "defaultScreenSpaceImageMaskMaterial", this.defaultScreenSpaceImageMaskMaterial.depthTest = !1, this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1, this.defaultScreenSpaceImageMaskMaterial.redWrite = !1, this.defaultScreenSpaceImageMaskMaterial.greenWrite = !1, this.defaultScreenSpaceImageMaskMaterial.blueWrite = !1, this.defaultScreenSpaceImageMaskMaterial.alphaWrite = !1, this.defaultScreenSpaceImageMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial)), this.defaultScreenSpaceImageMaskMaterial) : s ? (this.defaultScreenSpaceImage9SlicedMaterial || (this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImage9SlicedMaterial.name = "defaultScreenSpaceImage9SlicedMaterial", this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = ht, this.defaultScreenSpaceImage9SlicedMaterial.depthTest = !1, this.defaultScreenSpaceImage9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial)), this.defaultScreenSpaceImage9SlicedMaterial) : i ? (this.defaultScreenSpaceImage9TiledMaterial || (this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImage9TiledMaterial.name = "defaultScreenSpaceImage9TiledMaterial", this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = it, this.defaultScreenSpaceImage9TiledMaterial.depthTest = !1, this.defaultScreenSpaceImage9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial)), this.defaultScreenSpaceImage9TiledMaterial) : (this.defaultScreenSpaceImageMaterial || (this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial(), this.defaultScreenSpaceImageMaterial.name = "defaultScreenSpaceImageMaterial", this.defaultScreenSpaceImageMaterial.depthTest = !1, this.defaultScreenSpaceImageMaterial.update(), this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial)), this.defaultScreenSpaceImageMaterial) : t ? s ? (this.defaultImage9SlicedMaskMaterial || (this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial(), this.defaultImage9SlicedMaskMaterial.name = "defaultImage9SlicedMaskMaterial", this.defaultImage9SlicedMaskMaterial.nineSlicedMode = ht, this.defaultImage9SlicedMaskMaterial.alphaTest = 1, this.defaultImage9SlicedMaskMaterial.redWrite = !1, this.defaultImage9SlicedMaskMaterial.greenWrite = !1, this.defaultImage9SlicedMaskMaterial.blueWrite = !1, this.defaultImage9SlicedMaskMaterial.alphaWrite = !1, this.defaultImage9SlicedMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial)), this.defaultImage9SlicedMaskMaterial) : i ? (this.defaultImage9TiledMaskMaterial || (this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial(), this.defaultImage9TiledMaskMaterial.name = "defaultImage9TiledMaskMaterial", this.defaultImage9TiledMaskMaterial.nineSlicedMode = it, this.defaultImage9TiledMaskMaterial.alphaTest = 1, this.defaultImage9TiledMaskMaterial.redWrite = !1, this.defaultImage9TiledMaskMaterial.greenWrite = !1, this.defaultImage9TiledMaskMaterial.blueWrite = !1, this.defaultImage9TiledMaskMaterial.alphaWrite = !1, this.defaultImage9TiledMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial)), this.defaultImage9TiledMaskMaterial) : (this.defaultImageMaskMaterial || (this.defaultImageMaskMaterial = this._createBaseImageMaterial(), this.defaultImageMaskMaterial.name = "defaultImageMaskMaterial", this.defaultImageMaskMaterial.alphaTest = 1, this.defaultImageMaskMaterial.redWrite = !1, this.defaultImageMaskMaterial.greenWrite = !1, this.defaultImageMaskMaterial.blueWrite = !1, this.defaultImageMaskMaterial.alphaWrite = !1, this.defaultImageMaskMaterial.update(), this.defaultImageMaterials.push(this.defaultImageMaskMaterial)), this.defaultImageMaskMaterial) : s ? (this.defaultImage9SlicedMaterial || (this.defaultImage9SlicedMaterial = this._createBaseImageMaterial(), this.defaultImage9SlicedMaterial.name = "defaultImage9SlicedMaterial", this.defaultImage9SlicedMaterial.nineSlicedMode = ht, this.defaultImage9SlicedMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial)), this.defaultImage9SlicedMaterial) : i ? (this.defaultImage9TiledMaterial || (this.defaultImage9TiledMaterial = this._createBaseImageMaterial(), this.defaultImage9TiledMaterial.name = "defaultImage9TiledMaterial", this.defaultImage9TiledMaterial.nineSlicedMode = it, this.defaultImage9TiledMaterial.update(), this.defaultImageMaterials.push(this.defaultImage9TiledMaterial)), this.defaultImage9TiledMaterial) : (this.defaultImageMaterial || (this.defaultImageMaterial = this._createBaseImageMaterial(), this.defaultImageMaterial.name = "defaultImageMaterial", this.defaultImageMaterial.update(), this.defaultImageMaterials.push(this.defaultImageMaterial)), this.defaultImageMaterial);
  }
  registerUnicodeConverter(e) {
    this._unicodeConverter = e;
  }
  registerRtlReorder(e) {
    this._rtlReorder = e;
  }
  getUnicodeConverter() {
    return this._unicodeConverter;
  }
  getRtlReorder() {
    return this._rtlReorder;
  }
}
le._buildAccessors(Kl.prototype, qg);
const ar = "free", or = "limited", hr = "locked", xM = ["angularDampingX", "angularDampingY", "angularDampingZ", "angularEquilibriumX", "angularEquilibriumY", "angularEquilibriumZ", "angularLimitsX", "angularLimitsY", "angularLimitsZ", "angularMotionX", "angularMotionY", "angularMotionZ", "angularSpringX", "angularSpringY", "angularSpringZ", "angularStiffnessX", "angularStiffnessY", "angularStiffnessZ", "breakForce", "enableCollision", "enabled", "entityA", "entityB", "linearDampingX", "linearDampingY", "linearDampingZ", "linearEquilibriumX", "linearEquilibriumY", "linearEquilibriumZ", "linearLimitsX", "linearLimitsY", "linearLimitsZ", "linearMotionX", "linearMotionY", "linearMotionZ", "linearSpringX", "linearSpringY", "linearSpringZ", "linearStiffnessX", "linearStiffnessY", "linearStiffnessZ"];
class ju extends le {
  constructor(e, t) {
    super(e, t), this._constraint = null, this._entityA = null, this._entityB = null, this._breakForce = 34e37, this._enableCollision = !0, this._linearMotionX = hr, this._linearLimitsX = new q(0, 0), this._linearSpringX = !1, this._linearStiffnessX = 0, this._linearDampingX = 1, this._linearEquilibriumX = 0, this._linearMotionY = hr, this._linearLimitsY = new q(0, 0), this._linearSpringY = !1, this._linearStiffnessY = 0, this._linearDampingY = 1, this._linearEquilibriumY = 0, this._linearMotionZ = hr, this._linearLimitsZ = new q(0, 0), this._linearSpringZ = !1, this._linearStiffnessZ = 0, this._linearDampingZ = 1, this._linearEquilibriumZ = 0, this._angularMotionX = hr, this._angularLimitsX = new q(0, 0), this._angularSpringX = !1, this._angularStiffnessX = 0, this._angularDampingX = 1, this._angularEquilibriumX = 0, this._angularMotionY = hr, this._angularLimitsY = new q(0, 0), this._angularSpringY = !1, this._angularStiffnessY = 0, this._angularDampingY = 1, this._angularEquilibriumY = 0, this._angularMotionZ = hr, this._angularLimitsZ = new q(0, 0), this._angularSpringZ = !1, this._angularEquilibriumZ = 0, this._angularDampingZ = 1, this._angularStiffnessZ = 0, this.on("set_enabled", this._onSetEnabled, this);
  }
  set entityA(e) {
    this._destroyConstraint(), this._entityA = e, this._createConstraint();
  }
  get entityA() {
    return this._entityA;
  }
  set entityB(e) {
    this._destroyConstraint(), this._entityB = e, this._createConstraint();
  }
  get entityB() {
    return this._entityB;
  }
  set breakForce(e) {
    this._constraint && this._breakForce !== e && (this._constraint.setBreakingImpulseThreshold(e), this._breakForce = e);
  }
  get breakForce() {
    return this._breakForce;
  }
  set enableCollision(e) {
    this._destroyConstraint(), this._enableCollision = e, this._createConstraint();
  }
  get enableCollision() {
    return this._enableCollision;
  }
  set angularLimitsX(e) {
    this._angularLimitsX.equals(e) || (this._angularLimitsX.copy(e), this._updateAngularLimits());
  }
  get angularLimitsX() {
    return this._angularLimitsX;
  }
  set angularMotionX(e) {
    this._angularMotionX !== e && (this._angularMotionX = e, this._updateAngularLimits());
  }
  get angularMotionX() {
    return this._angularMotionX;
  }
  set angularLimitsY(e) {
    this._angularLimitsY.equals(e) || (this._angularLimitsY.copy(e), this._updateAngularLimits());
  }
  get angularLimitsY() {
    return this._angularLimitsY;
  }
  set angularMotionY(e) {
    this._angularMotionY !== e && (this._angularMotionY = e, this._updateAngularLimits());
  }
  get angularMotionY() {
    return this._angularMotionY;
  }
  set angularLimitsZ(e) {
    this._angularLimitsZ.equals(e) || (this._angularLimitsZ.copy(e), this._updateAngularLimits());
  }
  get angularLimitsZ() {
    return this._angularLimitsZ;
  }
  set angularMotionZ(e) {
    this._angularMotionZ !== e && (this._angularMotionZ = e, this._updateAngularLimits());
  }
  get angularMotionZ() {
    return this._angularMotionZ;
  }
  set linearLimitsX(e) {
    this._linearLimitsX.equals(e) || (this._linearLimitsX.copy(e), this._updateLinearLimits());
  }
  get linearLimitsX() {
    return this._linearLimitsX;
  }
  set linearMotionX(e) {
    this._linearMotionX !== e && (this._linearMotionX = e, this._updateLinearLimits());
  }
  get linearMotionX() {
    return this._linearMotionX;
  }
  set linearLimitsY(e) {
    this._linearLimitsY.equals(e) || (this._linearLimitsY.copy(e), this._updateLinearLimits());
  }
  get linearLimitsY() {
    return this._linearLimitsY;
  }
  set linearMotionY(e) {
    this._linearMotionY !== e && (this._linearMotionY = e, this._updateLinearLimits());
  }
  get linearMotionY() {
    return this._linearMotionY;
  }
  set linearLimitsZ(e) {
    this._linearLimitsZ.equals(e) || (this._linearLimitsZ.copy(e), this._updateLinearLimits());
  }
  get linearLimitsZ() {
    return this._linearLimitsZ;
  }
  set linearMotionZ(e) {
    this._linearMotionZ !== e && (this._linearMotionZ = e, this._updateLinearLimits());
  }
  get linearMotionZ() {
    return this._linearMotionZ;
  }
  _convertTransform(e, t) {
    const s = e.getTranslation(), i = new ee();
    i.setFromMat4(e);
    const n = new Ammo.btVector3(s.x, s.y, s.z), a = new Ammo.btQuaternion(i.x, i.y, i.z, i.w);
    t.setOrigin(n), t.setRotation(a), Ammo.destroy(n), Ammo.destroy(a);
  }
  _updateAngularLimits() {
    const e = this._constraint;
    if (e) {
      let t, s, i, n, a, o;
      this._angularMotionX === or ? (t = this._angularLimitsX.x * U.DEG_TO_RAD, n = this._angularLimitsX.y * U.DEG_TO_RAD) : this._angularMotionX === ar ? (t = 1, n = 0) : t = n = 0, this._angularMotionY === or ? (s = this._angularLimitsY.x * U.DEG_TO_RAD, a = this._angularLimitsY.y * U.DEG_TO_RAD) : this._angularMotionY === ar ? (s = 1, a = 0) : s = a = 0, this._angularMotionZ === or ? (i = this._angularLimitsZ.x * U.DEG_TO_RAD, o = this._angularLimitsZ.y * U.DEG_TO_RAD) : this._angularMotionZ === ar ? (i = 1, o = 0) : i = o = 0;
      const h = new Ammo.btVector3(t, s, i);
      e.setAngularLowerLimit(h), h.setValue(n, a, o), e.setAngularUpperLimit(h), Ammo.destroy(h);
    }
  }
  _updateLinearLimits() {
    const e = this._constraint;
    if (e) {
      let t, s, i, n, a, o;
      this._linearMotionX === or ? (t = this._linearLimitsX.x, n = this._linearLimitsX.y) : this._linearMotionX === ar ? (t = 1, n = 0) : t = n = 0, this._linearMotionY === or ? (s = this._linearLimitsY.x, a = this._linearLimitsY.y) : this._linearMotionY === ar ? (s = 1, a = 0) : s = a = 0, this._linearMotionZ === or ? (i = this._linearLimitsZ.x, o = this._linearLimitsZ.y) : this._linearMotionZ === ar ? (i = 1, o = 0) : i = o = 0;
      const h = new Ammo.btVector3(t, s, i);
      e.setLinearLowerLimit(h), h.setValue(n, a, o), e.setLinearUpperLimit(h), Ammo.destroy(h);
    }
  }
  _createConstraint() {
    if (this._entityA && this._entityA.rigidbody) {
      this._destroyConstraint();
      const e = new j(), t = this._entityA.rigidbody.body;
      t.activate();
      const s = this.entity.getWorldTransform(), n = this._entityA.getWorldTransform().clone().invert();
      e.mul2(n, s);
      const a = new Ammo.btTransform();
      if (this._convertTransform(e, a), this._entityB && this._entityB.rigidbody) {
        const c = this._entityB.rigidbody.body;
        c.activate();
        const u = this._entityB.getWorldTransform().clone().invert();
        e.mul2(u, s);
        const f = new Ammo.btTransform();
        this._convertTransform(e, f), this._constraint = new Ammo.btGeneric6DofSpringConstraint(t, c, a, f, !this._enableCollision), Ammo.destroy(f);
      } else
        this._constraint = new Ammo.btGeneric6DofSpringConstraint(t, a, !this._enableCollision);
      Ammo.destroy(a);
      const o = ["X", "Y", "Z", "X", "Y", "Z"];
      for (let c = 0; c < 6; c++) {
        const d = c < 3 ? "_linear" : "_angular";
        this._constraint.enableSpring(c, this[d + "Spring" + o[c]]), this._constraint.setDamping(c, this[d + "Damping" + o[c]]), this._constraint.setEquilibriumPoint(c, this[d + "Equilibrium" + o[c]]), this._constraint.setStiffness(c, this[d + "Stiffness" + o[c]]);
      }
      this._constraint.setBreakingImpulseThreshold(this._breakForce), this._updateLinearLimits(), this._updateAngularLimits(), this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
    }
  }
  _destroyConstraint() {
    this._constraint && (this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(this._constraint), Ammo.destroy(this._constraint), this._constraint = null);
  }
  initFromData(e) {
    for (const t of xM)
      e.hasOwnProperty(t) && (e[t] instanceof q ? this["_" + t].copy(e[t]) : this["_" + t] = e[t]);
    this._createConstraint();
  }
  onEnable() {
    this._createConstraint();
  }
  onDisable() {
    this._destroyConstraint();
  }
  _onSetEnabled(e, t, s) {
  }
  _onBeforeRemove() {
    this.fire("remove");
  }
}
const vM = {
  Damping: "setDamping",
  Equilibrium: "setEquilibriumPoint",
  Spring: "enableSpring",
  Stiffness: "setStiffness"
};
["linear", "angular"].forEach((r) => {
  ["Damping", "Equilibrium", "Spring", "Stiffness"].forEach((e) => {
    ["X", "Y", "Z"].forEach((t) => {
      const s = r + e + t, i = "_" + s;
      let n = r === "linear" ? 0 : 3;
      t === "Y" && (n += 1), t === "Z" && (n += 2), Object.defineProperty(ju.prototype, s, {
        get: function() {
          return this[i];
        },
        set: function(a) {
          this[i] !== a && (this[i] = a, this._constraint[vM[e]](n, a));
        }
      });
    });
  });
});
class SM {
  constructor() {
    this.enabled = !0;
  }
}
const Xg = ["enabled"];
class bM extends Ye {
  constructor(e) {
    super(e), this.id = "joint", this.app = e, this.ComponentType = ju, this.DataType = SM, this.schema = Xg;
  }
  initializeComponentData(e, t, s) {
    e.initFromData(t);
  }
}
le._buildAccessors(ju.prototype, Xg);
class jg extends le {
  constructor(e, t) {
    super(e, t), this._minWidth = 0, this._minHeight = 0, this._maxWidth = null, this._maxHeight = null, this._fitWidthProportion = 0, this._fitHeightProportion = 0, this._excludeFromLayout = !1;
  }
  set minWidth(e) {
    e !== this._minWidth && (this._minWidth = e, this.fire("resize"));
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(e) {
    e !== this._minHeight && (this._minHeight = e, this.fire("resize"));
  }
  get minHeight() {
    return this._minHeight;
  }
  set maxWidth(e) {
    e !== this._maxWidth && (this._maxWidth = e, this.fire("resize"));
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxHeight(e) {
    e !== this._maxHeight && (this._maxHeight = e, this.fire("resize"));
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set fitWidthProportion(e) {
    e !== this._fitWidthProportion && (this._fitWidthProportion = e, this.fire("resize"));
  }
  get fitWidthProportion() {
    return this._fitWidthProportion;
  }
  set fitHeightProportion(e) {
    e !== this._fitHeightProportion && (this._fitHeightProportion = e, this.fire("resize"));
  }
  get fitHeightProportion() {
    return this._fitHeightProportion;
  }
  set excludeFromLayout(e) {
    e !== this._excludeFromLayout && (this._excludeFromLayout = e, this.fire("resize"));
  }
  get excludeFromLayout() {
    return this._excludeFromLayout;
  }
}
class wM {
  constructor() {
    this.enabled = !0;
  }
}
const $g = ["enabled"];
class TM extends Ye {
  constructor(e) {
    super(e), this.id = "layoutchild", this.ComponentType = jg, this.DataType = wM, this.schema = $g;
  }
  initializeComponentData(e, t, s) {
    t.enabled !== void 0 && (e.enabled = t.enabled), t.minWidth !== void 0 && (e.minWidth = t.minWidth), t.minHeight !== void 0 && (e.minHeight = t.minHeight), t.maxWidth !== void 0 && (e.maxWidth = t.maxWidth), t.maxHeight !== void 0 && (e.maxHeight = t.maxHeight), t.fitWidthProportion !== void 0 && (e.fitWidthProportion = t.fitWidthProportion), t.fitHeightProportion !== void 0 && (e.fitHeightProportion = t.fitHeightProportion), t.excludeFromLayout !== void 0 && (e.excludeFromLayout = t.excludeFromLayout), super.initializeComponentData(e, t, s);
  }
  cloneComponent(e, t) {
    const s = e.layoutchild;
    return this.addComponent(t, {
      enabled: s.enabled,
      minWidth: s.minWidth,
      minHeight: s.minHeight,
      maxWidth: s.maxWidth,
      maxHeight: s.maxHeight,
      fitWidthProportion: s.fitWidthProportion,
      fitHeightProportion: s.fitHeightProportion,
      excludeFromLayout: s.excludeFromLayout
    });
  }
}
le._buildAccessors(jg.prototype, $g);
const Jd = 0, CM = 1, pp = 2, AM = 3, hl = {};
hl[xe] = {
  axis: "x",
  size: "width",
  calculatedSize: "calculatedWidth",
  minSize: "minWidth",
  maxSize: "maxWidth",
  fitting: "widthFitting",
  fittingProportion: "fitWidthProportion"
};
hl[Oe] = {
  axis: "y",
  size: "height",
  calculatedSize: "calculatedHeight",
  minSize: "minHeight",
  maxSize: "maxHeight",
  fitting: "heightFitting",
  fittingProportion: "fitHeightProportion"
};
const $u = {};
$u[xe] = Oe;
$u[Oe] = xe;
const MM = {
  minWidth: 0,
  minHeight: 0,
  maxWidth: Number.POSITIVE_INFINITY,
  maxHeight: Number.POSITIVE_INFINITY,
  width: null,
  height: null,
  fitWidthProportion: 0,
  fitHeightProportion: 0
}, Yt = {
  NONE: "NONE",
  APPLY_STRETCHING: "APPLY_STRETCHING",
  APPLY_SHRINKING: "APPLY_SHRINKING"
}, Kt = new q();
function Yg(r) {
  let e;
  const t = hl[r], s = hl[$u[r]];
  function i(E, P) {
    return -P[t.size] * E.pivot[t.axis];
  }
  function n(E, P) {
    return -P[s.size] * E.pivot[s.axis];
  }
  function a(E, P) {
    return P[t.size] * (1 - E.pivot[t.axis]);
  }
  function o(E, P) {
    E = E.filter(h), e = P, Kt.x = e.containerSize.x - e.padding.x - e.padding.z, Kt.y = e.containerSize.y - e.padding.y - e.padding.w, l(E);
    const B = d(c(E)), k = f(B, u(B)), H = x(B, k);
    return y(B, k, H), S(B, k, H), C(B);
  }
  function h(E) {
    const P = E.entity.layoutchild;
    return !P || !P.enabled || !P.excludeFromLayout;
  }
  function l(E) {
    for (let P = 0; P < E.length; ++P) {
      const B = E[P], k = B.anchor;
      (k.x !== 0 || k.y !== 0 || k.z !== 0 || k.w !== 0) && (B.anchor = Z.ZERO);
    }
  }
  function c(E) {
    if (!e.wrap)
      return [E];
    const P = [[]], B = w(E);
    let k = 0;
    const H = e[t.fitting] === pp;
    for (let V = 0; V < E.length; ++V) {
      P[P.length - 1].length > 0 && (k += e.spacing[t.axis]);
      const K = B[V][t.size];
      k += K, !H && k > Kt[t.axis] && P[P.length - 1].length !== 0 && (k = K, P.push([])), P[P.length - 1].push(E[V]), H && k > Kt[t.axis] && V !== E.length - 1 && (k = 0, P.push([]));
    }
    return P;
  }
  function d(E) {
    const P = e.orientation === xe && e.reverseX || e.orientation === Oe && e.reverseY, B = e.orientation === xe && e.reverseY || e.orientation === Oe && e.reverseX;
    if (P)
      for (let k = 0; k < E.length; ++k)
        P && E[k].reverse();
    return B && E.reverse(), E;
  }
  function u(E) {
    const P = [];
    for (let B = 0; B < E.length; ++B) {
      const k = E[B], H = w(k), V = _(H, t), K = m(e[t.fitting], V, Kt[t.axis]);
      K === Yt.APPLY_STRETCHING ? p(H, V, t) : K === Yt.APPLY_SHRINKING && g(H, V, t), P.push(H);
    }
    return P;
  }
  function f(E, P) {
    const B = [], k = [];
    for (let K = 0; K < E.length; ++K) {
      const Q = E[K];
      Q.largestElement = null, Q.largestSize = {
        width: Number.NEGATIVE_INFINITY,
        height: Number.NEGATIVE_INFINITY
      };
      for (let se = 0; se < Q.length; ++se) {
        const J = P[K][se];
        J[s.size] > Q.largestSize[s.size] && (Q.largestElement = Q[se], Q.largestSize = J);
      }
      B.push(Q.largestElement), k.push(Q.largestSize);
    }
    const H = _(k, s), V = m(e[s.fitting], H, Kt[s.axis]);
    V === Yt.APPLY_STRETCHING ? p(k, H, s) : V === Yt.APPLY_SHRINKING && g(k, H, s);
    for (let K = 0; K < E.length; ++K) {
      const Q = E[K];
      for (let se = 0; se < Q.length; ++se) {
        const J = P[K][se], $ = J[s.size], Re = E.length === 1 ? Kt[s.axis] : Q.largestSize[s.size], Je = m(e[s.fitting], $, Re);
        Je === Yt.APPLY_STRETCHING ? J[s.size] = Math.min(Re, J[s.maxSize]) : Je === Yt.APPLY_SHRINKING && (J[s.size] = Math.max(Re, J[s.minSize]));
      }
    }
    return P;
  }
  function m(E, P, B) {
    switch (E) {
      case Jd:
        return Yt.NONE;
      case CM:
        return P < B ? Yt.APPLY_STRETCHING : Yt.NONE;
      case pp:
        return P >= B ? Yt.APPLY_SHRINKING : Yt.NONE;
      case AM:
        return P < B ? Yt.APPLY_STRETCHING : Yt.APPLY_SHRINKING;
      default:
        throw new Error(`Unrecognized fitting mode: ${E}`);
    }
  }
  function _(E, P) {
    const B = A(E, P.size), k = (E.length - 1) * e.spacing[P.axis];
    return B + k;
  }
  function p(E, P, B) {
    const k = I(E, B.maxSize), H = L(E, B.fittingProportion), V = X(H, k);
    let K = Kt[B.axis] - P;
    for (let Q = 0; Q < E.length; ++Q) {
      const se = k[Q], J = b(se, K, H, V), $ = E[se][B.size] + J, Re = E[se][B.maxSize], Je = Math.min($, Re);
      E[se][B.size] = Je;
      const Ke = Math.max($ - Je, 0), at = J - Ke;
      K -= at;
    }
  }
  function g(E, P, B) {
    const k = I(E, B.minSize, !0), H = L(E, B.fittingProportion), V = O(H), K = X(V, k);
    let Q = P - Kt[B.axis];
    for (let se = 0; se < E.length; ++se) {
      const J = k[se], $ = b(J, Q, V, K), Re = E[J][B.size] - $, Je = E[J][B.minSize], Ke = Math.max(Re, Je);
      E[J][B.size] = Ke;
      const at = Math.max(Ke - Re, 0), gs = $ - at;
      Q -= gs;
    }
  }
  function b(E, P, B, k) {
    const H = B[E], V = k[E];
    return Math.abs(H) < 1e-5 && Math.abs(V) < 1e-5 ? P : P * H / V;
  }
  function x(E, P) {
    const B = {};
    B[t.axis] = 0, B[s.axis] = 0, E[t.size] = Number.NEGATIVE_INFINITY;
    const k = [];
    for (let H = 0; H < E.length; ++H) {
      const V = E[H];
      if (V.length === 0) {
        k.push([]);
        continue;
      }
      const K = [], Q = P[H];
      for (let se = 0; se < V.length; ++se) {
        const J = V[se], $ = Q[se];
        B[s.axis] -= n(J, $), B[t.axis] -= i(J, $), K[se] = {}, K[se][t.axis] = B[t.axis], K[se][s.axis] = B[s.axis], B[s.axis] += n(J, $), B[t.axis] += a(J, $) + e.spacing[t.axis];
      }
      V[t.size] = B[t.axis] - e.spacing[t.axis], V[s.size] = V.largestSize[s.size], E[t.size] = Math.max(E[t.size], V[t.size]), B[t.axis] = 0, B[s.axis] += V[s.size] + e.spacing[s.axis], k.push(K);
    }
    return E[s.size] = B[s.axis] - e.spacing[s.axis], k;
  }
  function y(E, P, B) {
    const k = e.alignment[t.axis], H = e.alignment[s.axis], V = e.padding[t.axis], K = e.padding[s.axis];
    for (let Q = 0; Q < E.length; ++Q) {
      const se = E[Q], J = P[Q], $ = B[Q], Re = (Kt[t.axis] - se[t.size]) * k + V, Je = (Kt[s.axis] - E[s.size]) * H + K;
      for (let Ke = 0; Ke < se.length; ++Ke) {
        const at = (se[s.size] - J[Ke][s.size]) * e.alignment[s.axis];
        $[Ke][t.axis] += Re, $[Ke][s.axis] += Je + at;
      }
    }
  }
  function S(E, P, B) {
    for (let k = 0; k < E.length; ++k) {
      const H = E[k], V = P[k], K = B[k];
      for (let Q = 0; Q < H.length; ++Q) {
        const se = H[Q];
        se[t.calculatedSize] = V[Q][t.size], se[s.calculatedSize] = V[Q][s.size], e.orientation === xe ? se.entity.setLocalPosition(K[Q][t.axis], K[Q][s.axis], se.entity.getLocalPosition().z) : se.entity.setLocalPosition(K[Q][s.axis], K[Q][t.axis], se.entity.getLocalPosition().z);
      }
    }
  }
  function C(E) {
    const P = E.width, B = E.height, k = (Kt.x - P) * e.alignment.x + e.padding.x, H = (Kt.y - B) * e.alignment.y + e.padding.y;
    return {
      bounds: new Z(k, H, P, B)
    };
  }
  function w(E) {
    const P = [];
    for (let B = 0; B < E.length; ++B) {
      const k = E[B], H = Math.max(M(k, "minWidth"), 0), V = Math.max(M(k, "minHeight"), 0), K = Math.max(M(k, "maxWidth"), H), Q = Math.max(M(k, "maxHeight"), V), se = T(M(k, "width"), H, K), J = T(M(k, "height"), V, Q), $ = M(k, "fitWidthProportion"), Re = M(k, "fitHeightProportion");
      P.push({
        minWidth: H,
        minHeight: V,
        maxWidth: K,
        maxHeight: Q,
        width: se,
        height: J,
        fitWidthProportion: $,
        fitHeightProportion: Re
      });
    }
    return P;
  }
  function M(E, P) {
    const B = E.entity.layoutchild;
    return B && B.enabled && B[P] !== void 0 && B[P] !== null ? B[P] : E[P] !== void 0 ? E[P] : MM[P];
  }
  function T(E, P, B) {
    return Math.min(Math.max(E, P), B);
  }
  function A(E, P) {
    return E.reduce(function(B, k) {
      return B + k[P];
    }, 0);
  }
  function L(E, P) {
    const B = A(E, P), k = [], H = E.length;
    if (B === 0)
      for (let V = 0; V < H; ++V)
        k.push(1 / H);
    else
      for (let V = 0; V < H; ++V)
        k.push(E[V][P] / B);
    return k;
  }
  function O(E) {
    if (E.length === 1)
      return [1];
    const P = [], B = E.length;
    for (let k = 0; k < B; ++k)
      P.push((1 - E[k]) / (B - 1));
    return P;
  }
  function I(E, P, B) {
    return E.forEach(D), E.slice().sort(function(k, H) {
      return B ? H[P] - k[P] : k[P] - H[P];
    }).map(G);
  }
  function D(E, P) {
    E.index = P;
  }
  function G(E) {
    return E.index;
  }
  function X(E, P) {
    const B = [];
    B[P[E.length - 1]] = E[P[E.length - 1]];
    for (let k = E.length - 2; k >= 0; --k)
      B[P[k]] = B[P[k + 1]] + E[P[k]];
    return B;
  }
  return o;
}
const Yu = {};
Yu[xe] = Yg(xe);
Yu[Oe] = Yg(Oe);
class EM {
  calculateLayout(e, t) {
    const s = Yu[t.orientation];
    if (s)
      return s(e, t);
    throw new Error("Unrecognized orientation value: " + t.orientation);
  }
}
function _p(r) {
  return r.element;
}
function RM(r) {
  return r.enabled && r.element && r.element.enabled;
}
class Kg extends le {
  constructor(e, t) {
    super(e, t), this._orientation = xe, this._reverseX = !1, this._reverseY = !0, this._alignment = new q(0, 1), this._padding = new Z(), this._spacing = new q(), this._widthFitting = Jd, this._heightFitting = Jd, this._wrap = !1, this._layoutCalculator = new EM(), this._listenForReflowEvents(this.entity, "on"), this.entity.children.forEach((s) => {
      this._listenForReflowEvents(s, "on");
    }), this.entity.on("childinsert", this._onChildInsert, this), this.entity.on("childremove", this._onChildRemove, this), e.app.systems.element.on("add", this._onElementOrLayoutComponentAdd, this), e.app.systems.element.on("beforeremove", this._onElementOrLayoutComponentRemove, this), e.app.systems.layoutchild.on("add", this._onElementOrLayoutComponentAdd, this), e.app.systems.layoutchild.on("beforeremove", this._onElementOrLayoutComponentRemove, this);
  }
  set orientation(e) {
    e !== this._orientation && (this._orientation = e, this._scheduleReflow());
  }
  get orientation() {
    return this._orientation;
  }
  set reverseX(e) {
    e !== this._reverseX && (this._reverseX = e, this._scheduleReflow());
  }
  get reverseX() {
    return this._reverseX;
  }
  set reverseY(e) {
    e !== this._reverseY && (this._reverseY = e, this._scheduleReflow());
  }
  get reverseY() {
    return this._reverseY;
  }
  set alignment(e) {
    e.equals(this._alignment) || (this._alignment.copy(e), this._scheduleReflow());
  }
  get alignment() {
    return this._alignment;
  }
  set padding(e) {
    e.equals(this._padding) || (this._padding.copy(e), this._scheduleReflow());
  }
  get padding() {
    return this._padding;
  }
  set spacing(e) {
    e.equals(this._spacing) || (this._spacing.copy(e), this._scheduleReflow());
  }
  get spacing() {
    return this._spacing;
  }
  set widthFitting(e) {
    e !== this._widthFitting && (this._widthFitting = e, this._scheduleReflow());
  }
  get widthFitting() {
    return this._widthFitting;
  }
  set heightFitting(e) {
    e !== this._heightFitting && (this._heightFitting = e, this._scheduleReflow());
  }
  get heightFitting() {
    return this._heightFitting;
  }
  set wrap(e) {
    e !== this._wrap && (this._wrap = e, this._scheduleReflow());
  }
  get wrap() {
    return this._wrap;
  }
  _isSelfOrChild(e) {
    return e === this.entity || this.entity.children.indexOf(e) !== -1;
  }
  _listenForReflowEvents(e, t) {
    e.element && (e.element[t]("enableelement", this._scheduleReflow, this), e.element[t]("disableelement", this._scheduleReflow, this), e.element[t]("resize", this._scheduleReflow, this), e.element[t]("set:pivot", this._scheduleReflow, this)), e.layoutchild && (e.layoutchild[t]("set_enabled", this._scheduleReflow, this), e.layoutchild[t]("resize", this._scheduleReflow, this));
  }
  _onElementOrLayoutComponentAdd(e) {
    this._isSelfOrChild(e) && (this._listenForReflowEvents(e, "on"), this._scheduleReflow());
  }
  _onElementOrLayoutComponentRemove(e) {
    this._isSelfOrChild(e) && (this._listenForReflowEvents(e, "off"), this._scheduleReflow());
  }
  _onChildInsert(e) {
    this._listenForReflowEvents(e, "on"), this._scheduleReflow();
  }
  _onChildRemove(e) {
    this._listenForReflowEvents(e, "off"), this._scheduleReflow();
  }
  _scheduleReflow() {
    this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow && this.system.scheduleReflow(this);
  }
  reflow() {
    const e = _p(this.entity), t = this.entity.children.filter(RM).map(_p);
    if (!e || t.length === 0)
      return;
    const s = Math.max(e.calculatedWidth, 0), i = Math.max(e.calculatedHeight, 0), n = {
      orientation: this._orientation,
      reverseX: this._reverseX,
      reverseY: this._reverseY,
      alignment: this._alignment,
      padding: this._padding,
      spacing: this._spacing,
      widthFitting: this._widthFitting,
      heightFitting: this._heightFitting,
      wrap: this._wrap,
      containerSize: new q(s, i)
    };
    this._isPerformingReflow = !0;
    const a = this._layoutCalculator.calculateLayout(t, n);
    this._isPerformingReflow = !1, this.fire("reflow", a);
  }
  onEnable() {
    this._scheduleReflow();
  }
  onRemove() {
    this.entity.off("childinsert", this._onChildInsert, this), this.entity.off("childremove", this._onChildRemove, this), this._listenForReflowEvents(this.entity, "off"), this.entity.children.forEach((e) => {
      this._listenForReflowEvents(e, "off");
    }), this.system.app.systems.element.off("add", this._onElementOrLayoutComponentAdd, this), this.system.app.systems.element.off("beforeremove", this._onElementOrLayoutComponentRemove, this), this.system.app.systems.layoutchild.off("add", this._onElementOrLayoutComponentAdd, this), this.system.app.systems.layoutchild.off("beforeremove", this._onElementOrLayoutComponentRemove, this);
  }
}
class LM {
  constructor() {
    this.enabled = !0;
  }
}
const Zg = ["enabled"], PM = 100;
class IM extends Ye {
  constructor(e) {
    super(e), this.id = "layoutgroup", this.ComponentType = Kg, this.DataType = LM, this.schema = Zg, this._reflowQueue = [], this.on("beforeremove", this._onRemoveComponent, this), this.app.systems.on("postUpdate", this._onPostUpdate, this);
  }
  initializeComponentData(e, t, s) {
    t.enabled !== void 0 && (e.enabled = t.enabled), t.orientation !== void 0 && (e.orientation = t.orientation), t.reverseX !== void 0 && (e.reverseX = t.reverseX), t.reverseY !== void 0 && (e.reverseY = t.reverseY), t.alignment !== void 0 && (e.alignment = Array.isArray(t.alignment) ? new q(t.alignment) : t.alignment), t.padding !== void 0 && (e.padding = Array.isArray(t.padding) ? new Z(t.padding) : t.padding), t.spacing !== void 0 && (e.spacing = Array.isArray(t.spacing) ? new q(t.spacing) : t.spacing), t.widthFitting !== void 0 && (e.widthFitting = t.widthFitting), t.heightFitting !== void 0 && (e.heightFitting = t.heightFitting), t.wrap !== void 0 && (e.wrap = t.wrap), super.initializeComponentData(e, t, s);
  }
  cloneComponent(e, t) {
    const s = e.layoutgroup;
    return this.addComponent(t, {
      enabled: s.enabled,
      orientation: s.orientation,
      reverseX: s.reverseX,
      reverseY: s.reverseY,
      alignment: s.alignment,
      padding: s.padding,
      spacing: s.spacing,
      widthFitting: s.widthFitting,
      heightFitting: s.heightFitting,
      wrap: s.wrap
    });
  }
  scheduleReflow(e) {
    this._reflowQueue.indexOf(e) === -1 && this._reflowQueue.push(e);
  }
  _onPostUpdate() {
    this._processReflowQueue();
  }
  _processReflowQueue() {
    if (this._reflowQueue.length === 0)
      return;
    let e = 0;
    for (; this._reflowQueue.length > 0; ) {
      const t = this._reflowQueue.slice();
      this._reflowQueue.length = 0, t.sort(function(s, i) {
        return s.entity.graphDepth - i.entity.graphDepth;
      });
      for (let s = 0; s < t.length; ++s)
        t[s].reflow();
      if (++e >= PM) {
        console.warn("Max reflow iterations limit reached, bailing.");
        break;
      }
    }
  }
  _onRemoveComponent(e, t) {
    t.onRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("postUpdate", this._onPostUpdate, this);
  }
}
le._buildAccessors(Kg.prototype, Zg);
class Jg extends le {
  constructor(e, t) {
    super(e, t), this._type = "asset", this._asset = null, this._model = null, this._mapping = {}, this._castShadows = !0, this._receiveShadows = !0, this._materialAsset = null, this._material = void 0, this._castShadowsLightmap = !0, this._lightmapped = !1, this._lightmapSizeMultiplier = 1, this._isStatic = !1, this._layers = [wi], this._batchGroupId = -1, this._customAabb = null, this._area = null, this._materialEvents = null, this._clonedModel = !1, this._material = e.defaultMaterial, t.on("remove", this.onRemoveChild, this), t.on("removehierarchy", this.onRemoveChild, this), t.on("insert", this.onInsertChild, this), t.on("inserthierarchy", this.onInsertChild, this);
  }
  set meshInstances(e) {
    this._model && (this._model.meshInstances = e);
  }
  get meshInstances() {
    return this._model ? this._model.meshInstances : null;
  }
  set customAabb(e) {
    if (this._customAabb = e, this._model) {
      const t = this._model.meshInstances;
      if (t)
        for (let s = 0; s < t.length; s++)
          t[s].setCustomAabb(this._customAabb);
    }
  }
  get customAabb() {
    return this._customAabb;
  }
  set type(e) {
    if (this._type !== e)
      if (this._area = null, this._type = e, e === "asset")
        this._asset !== null ? this._bindModelAsset(this._asset) : this.model = null;
      else {
        const t = sg(this.system.app.graphicsDevice, e);
        this._area = t.area;
        const s = t.mesh, i = new bt(), n = new Ti();
        n.graph = i, n.meshInstances = [new we(s, this._material, i)], this.model = n, this._asset = null;
      }
  }
  get type() {
    return this._type;
  }
  set asset(e) {
    const t = this.system.app.assets;
    let s = e;
    if (e instanceof ce && (s = e.id), this._asset !== s) {
      if (this._asset) {
        t.off("add:" + this._asset, this._onModelAssetAdded, this);
        const i = t.get(this._asset);
        i && this._unbindModelAsset(i);
      }
      if (this._asset = s, this._asset) {
        const i = t.get(this._asset);
        i ? this._bindModelAsset(i) : (this.model = null, t.on("add:" + this._asset, this._onModelAssetAdded, this));
      } else
        this.model = null;
    }
  }
  get asset() {
    return this._asset;
  }
  set model(e) {
    if (this._model !== e && !(e && e._immutable) && (this._model && (this._model._immutable = !1, this.removeModelFromLayers(), this.entity.removeChild(this._model.getGraph()), delete this._model._entity, this._clonedModel && (this._model.destroy(), this._clonedModel = !1)), this._model = e, this._model)) {
      this._model._immutable = !0;
      const t = this._model.meshInstances;
      for (let s = 0; s < t.length; s++)
        t[s].castShadow = this._castShadows, t[s].receiveShadow = this._receiveShadows, t[s].isStatic = this._isStatic, t[s].setCustomAabb(this._customAabb);
      this.lightmapped = this._lightmapped, this.entity.addChild(this._model.graph), this.enabled && this.entity.enabled && this.addModelToLayers(), this._model._entity = this.entity, this.entity.animation && this.entity.animation.setModel(this._model), this.entity.anim && this.entity.anim.rebind(), this.type === "asset" ? this.mapping = this._mapping : this._unsetMaterialEvents();
    }
  }
  get model() {
    return this._model;
  }
  set lightmapped(e) {
    if (e !== this._lightmapped && (this._lightmapped = e, this._model)) {
      const t = this._model.meshInstances;
      for (let s = 0; s < t.length; s++)
        t[s].setLightmapped(e);
    }
  }
  get lightmapped() {
    return this._lightmapped;
  }
  set castShadows(e) {
    if (this._castShadows === e)
      return;
    const t = this._model;
    if (t) {
      const s = this.layers, i = this.system.app.scene;
      if (this._castShadows && !e)
        for (let a = 0; a < s.length; a++) {
          const o = this.system.app.scene.layers.getLayerById(this.layers[a]);
          o && o.removeShadowCasters(t.meshInstances);
        }
      const n = t.meshInstances;
      for (let a = 0; a < n.length; a++)
        n[a].castShadow = e;
      if (!this._castShadows && e)
        for (let a = 0; a < s.length; a++) {
          const o = i.layers.getLayerById(s[a]);
          o && o.addShadowCasters(t.meshInstances);
        }
    }
    this._castShadows = e;
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(e) {
    if (this._receiveShadows !== e && (this._receiveShadows = e, this._model)) {
      const t = this._model.meshInstances;
      for (let s = 0, i = t.length; s < i; s++)
        t[s].receiveShadow = e;
    }
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  set castShadowsLightmap(e) {
    this._castShadowsLightmap = e;
  }
  get castShadowsLightmap() {
    return this._castShadowsLightmap;
  }
  set lightmapSizeMultiplier(e) {
    this._lightmapSizeMultiplier = e;
  }
  get lightmapSizeMultiplier() {
    return this._lightmapSizeMultiplier;
  }
  set isStatic(e) {
    if (this._isStatic !== e && (this._isStatic = e, this._model)) {
      const t = this._model.meshInstances;
      for (let s = 0; s < t.length; s++) {
        const i = t[s];
        i.isStatic = e;
      }
    }
  }
  get isStatic() {
    return this._isStatic;
  }
  set layers(e) {
    const t = this.system.app.scene.layers;
    if (this.meshInstances)
      for (let s = 0; s < this._layers.length; s++) {
        const i = t.getLayerById(this._layers[s]);
        i && i.removeMeshInstances(this.meshInstances);
      }
    this._layers.length = 0;
    for (let s = 0; s < e.length; s++)
      this._layers[s] = e[s];
    if (!(!this.enabled || !this.entity.enabled || !this.meshInstances))
      for (let s = 0; s < this._layers.length; s++) {
        const i = t.getLayerById(this._layers[s]);
        i && i.addMeshInstances(this.meshInstances);
      }
  }
  get layers() {
    return this._layers;
  }
  set batchGroupId(e) {
    if (this._batchGroupId !== e) {
      if (this.entity.enabled && this._batchGroupId >= 0) {
        var t;
        (t = this.system.app.batcher) == null || t.remove(nt.MODEL, this.batchGroupId, this.entity);
      }
      if (this.entity.enabled && e >= 0) {
        var s;
        (s = this.system.app.batcher) == null || s.insert(nt.MODEL, e, this.entity);
      }
      e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && this.addModelToLayers(), this._batchGroupId = e;
    }
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set materialAsset(e) {
    let t = e;
    e instanceof ce && (t = e.id);
    const s = this.system.app.assets;
    if (t !== this._materialAsset) {
      if (this._materialAsset) {
        s.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
        const i = s.get(this._materialAsset);
        i && this._unbindMaterialAsset(i);
      }
      if (this._materialAsset = t, this._materialAsset) {
        const i = s.get(this._materialAsset);
        i ? this._bindMaterialAsset(i) : (this._setMaterial(this.system.defaultMaterial), s.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this));
      } else
        this._setMaterial(this.system.defaultMaterial);
    }
  }
  get materialAsset() {
    return this._materialAsset;
  }
  set material(e) {
    this._material !== e && (this.materialAsset = null, this._setMaterial(e));
  }
  get material() {
    return this._material;
  }
  set mapping(e) {
    if (this._type !== "asset" || (this._unsetMaterialEvents(), e || (e = {}), this._mapping = e, !this._model))
      return;
    const t = this._model.meshInstances, s = this.asset ? this.system.app.assets.get(this.asset) : null, i = s ? s.data.mapping : null;
    let n = null;
    for (let a = 0, o = t.length; a < o; a++)
      if (e[a] !== void 0)
        e[a] ? (n = this.system.app.assets.get(e[a]), this._loadAndSetMeshInstanceMaterial(n, t[a], a)) : t[a].material = this.system.defaultMaterial;
      else if (i)
        if (i[a] && (i[a].material || i[a].path)) {
          if (i[a].material !== void 0)
            n = this.system.app.assets.get(i[a].material);
          else if (i[a].path !== void 0) {
            const h = this._getMaterialAssetUrl(i[a].path);
            h && (n = this.system.app.assets.getByUrl(h));
          }
          this._loadAndSetMeshInstanceMaterial(n, t[a], a);
        } else
          t[a].material = this.system.defaultMaterial;
  }
  get mapping() {
    return this._mapping;
  }
  addModelToLayers() {
    const e = this.system.app.scene.layers;
    for (let t = 0; t < this._layers.length; t++) {
      const s = e.getLayerById(this._layers[t]);
      s && s.addMeshInstances(this.meshInstances);
    }
  }
  removeModelFromLayers() {
    const e = this.system.app.scene.layers;
    for (let t = 0; t < this._layers.length; t++) {
      const s = e.getLayerById(this._layers[t]);
      s && s.removeMeshInstances(this.meshInstances);
    }
  }
  onRemoveChild() {
    this._model && this.removeModelFromLayers();
  }
  onInsertChild() {
    this._model && this.enabled && this.entity.enabled && this.addModelToLayers();
  }
  onRemove() {
    this.asset = null, this.model = null, this.materialAsset = null, this._unsetMaterialEvents(), this.entity.off("remove", this.onRemoveChild, this), this.entity.off("insert", this.onInsertChild, this);
  }
  onLayersChanged(e, t) {
    this.addModelToLayers(), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    this.layers.indexOf(e.id) < 0 || e.addMeshInstances(this.meshInstances);
  }
  onLayerRemoved(e) {
    this.layers.indexOf(e.id) < 0 || e.removeMeshInstances(this.meshInstances);
  }
  _setMaterialEvent(e, t, s, i) {
    const n = t + ":" + s;
    this.system.app.assets.on(n, i, this), this._materialEvents || (this._materialEvents = []), this._materialEvents[e] || (this._materialEvents[e] = {}), this._materialEvents[e][n] = {
      id: s,
      handler: i
    };
  }
  _unsetMaterialEvents() {
    const e = this.system.app.assets, t = this._materialEvents;
    if (t) {
      for (let s = 0, i = t.length; s < i; s++) {
        if (!t[s])
          continue;
        const n = t[s];
        for (const a in n)
          e.off(a, n[a].handler, this);
      }
      this._materialEvents = null;
    }
  }
  _getAssetByIdOrPath(e) {
    let t = null;
    if (!isNaN(parseInt(e, 10)))
      t = this.system.app.assets.get(e);
    else if (this.asset) {
      const i = this._getMaterialAssetUrl(e);
      i && (t = this.system.app.assets.getByUrl(i));
    }
    return t;
  }
  _getMaterialAssetUrl(e) {
    if (!this.asset)
      return null;
    const t = this.system.app.assets.get(this.asset);
    return t ? t.getAbsoluteUrl(e) : null;
  }
  _loadAndSetMeshInstanceMaterial(e, t, s) {
    const i = this.system.app.assets;
    e && (e.resource ? (t.material = e.resource, this._setMaterialEvent(s, "remove", e.id, function() {
      t.material = this.system.defaultMaterial;
    })) : (this._setMaterialEvent(s, "load", e.id, function(n) {
      t.material = n.resource, this._setMaterialEvent(s, "remove", e.id, function() {
        t.material = this.system.defaultMaterial;
      });
    }), this.enabled && this.entity.enabled && i.load(e)));
  }
  onEnable() {
    const e = this.system.app, t = e.scene;
    t.on("set:layers", this.onLayersChanged, this), t.layers && (t.layers.on("add", this.onLayerAdded, this), t.layers.on("remove", this.onLayerRemoved, this));
    const s = this._type === "asset";
    let i;
    if (this._model ? this.addModelToLayers() : s && this._asset && (i = e.assets.get(this._asset), i && i.resource !== this._model && this._bindModelAsset(i)), this._materialAsset && (i = e.assets.get(this._materialAsset), i && i.resource !== this._material && this._bindMaterialAsset(i)), s && this._mapping)
      for (const a in this._mapping)
        this._mapping[a] && (i = this._getAssetByIdOrPath(this._mapping[a]), i && !i.resource && e.assets.load(i));
    if (this._batchGroupId >= 0) {
      var n;
      (n = e.batcher) == null || n.insert(nt.MODEL, this.batchGroupId, this.entity);
    }
  }
  onDisable() {
    const e = this.system.app, t = e.scene;
    if (t.off("set:layers", this.onLayersChanged, this), t.layers && (t.layers.off("add", this.onLayerAdded, this), t.layers.off("remove", this.onLayerRemoved, this)), this._batchGroupId >= 0) {
      var s;
      (s = e.batcher) == null || s.remove(nt.MODEL, this.batchGroupId, this.entity);
    }
    this._model && this.removeModelFromLayers();
  }
  hide() {
    if (this._model) {
      const e = this._model.meshInstances;
      for (let t = 0, s = e.length; t < s; t++)
        e[t].visible = !1;
    }
  }
  show() {
    if (this._model) {
      const e = this._model.meshInstances;
      for (let t = 0, s = e.length; t < s; t++)
        e[t].visible = !0;
    }
  }
  _bindMaterialAsset(e) {
    if (e.on("load", this._onMaterialAssetLoad, this), e.on("unload", this._onMaterialAssetUnload, this), e.on("remove", this._onMaterialAssetRemove, this), e.on("change", this._onMaterialAssetChange, this), e.resource)
      this._onMaterialAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindMaterialAsset(e) {
    e.off("load", this._onMaterialAssetLoad, this), e.off("unload", this._onMaterialAssetUnload, this), e.off("remove", this._onMaterialAssetRemove, this), e.off("change", this._onMaterialAssetChange, this);
  }
  _onMaterialAssetAdd(e) {
    this.system.app.assets.off("add:" + e.id, this._onMaterialAssetAdd, this), this._materialAsset === e.id && this._bindMaterialAsset(e);
  }
  _onMaterialAssetLoad(e) {
    this._setMaterial(e.resource);
  }
  _onMaterialAssetUnload(e) {
    this._setMaterial(this.system.defaultMaterial);
  }
  _onMaterialAssetRemove(e) {
    this._onMaterialAssetUnload(e);
  }
  _onMaterialAssetChange(e) {
  }
  _bindModelAsset(e) {
    if (this._unbindModelAsset(e), e.on("load", this._onModelAssetLoad, this), e.on("unload", this._onModelAssetUnload, this), e.on("change", this._onModelAssetChange, this), e.on("remove", this._onModelAssetRemove, this), e.resource)
      this._onModelAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindModelAsset(e) {
    e.off("load", this._onModelAssetLoad, this), e.off("unload", this._onModelAssetUnload, this), e.off("change", this._onModelAssetChange, this), e.off("remove", this._onModelAssetRemove, this);
  }
  _onModelAssetAdded(e) {
    this.system.app.assets.off("add:" + e.id, this._onModelAssetAdded, this), e.id === this._asset && this._bindModelAsset(e);
  }
  _onModelAssetLoad(e) {
    this.model = e.resource.clone(), this._clonedModel = !0;
  }
  _onModelAssetUnload(e) {
    this.model = null;
  }
  _onModelAssetChange(e, t, s, i) {
    t === "data" && (this.mapping = this._mapping);
  }
  _onModelAssetRemove(e) {
    this.model = null;
  }
  _setMaterial(e) {
    if (this._material === e)
      return;
    this._material = e;
    const t = this._model;
    if (t && this._type !== "asset") {
      const s = t.meshInstances;
      for (let i = 0, n = s.length; i < n; i++)
        s[i].material = e;
    }
  }
}
class DM {
  constructor() {
    this.enabled = !0;
  }
}
const Qg = ["enabled"];
class BM extends Ye {
  constructor(e) {
    super(e), this.id = "model", this.ComponentType = Jg, this.DataType = DM, this.schema = Qg, this.defaultMaterial = io(e.graphicsDevice), this.on("beforeremove", this.onRemove, this);
  }
  initializeComponentData(e, t, s) {
    s = ["material", "materialAsset", "asset", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "type", "mapping", "layers", "isStatic", "batchGroupId"], (t.batchGroupId === null || t.batchGroupId === void 0) && (t.batchGroupId = -1), t.layers && t.layers.length && (t.layers = t.layers.slice(0));
    for (let i = 0; i < s.length; i++)
      t.hasOwnProperty(s[i]) && (e[s[i]] = t[s[i]]);
    t.aabbCenter && t.aabbHalfExtents && (e.customAabb = new Pe(new v(t.aabbCenter), new v(t.aabbHalfExtents))), super.initializeComponentData(e, t, ["enabled"]);
  }
  cloneComponent(e, t) {
    const s = {
      type: e.model.type,
      asset: e.model.asset,
      castShadows: e.model.castShadows,
      receiveShadows: e.model.receiveShadows,
      castShadowsLightmap: e.model.castShadowsLightmap,
      lightmapped: e.model.lightmapped,
      lightmapSizeMultiplier: e.model.lightmapSizeMultiplier,
      isStatic: e.model.isStatic,
      enabled: e.model.enabled,
      layers: e.model.layers,
      batchGroupId: e.model.batchGroupId,
      mapping: Hi({}, e.model.mapping)
    };
    let i = e.model.materialAsset;
    !(i instanceof ce) && i != null && (i = this.app.assets.get(i));
    const n = e.model.material;
    (!n || n === this.defaultMaterial || !i || n === i.resource) && (s.materialAsset = i);
    const a = this.addComponent(t, s);
    if (e.model.model && e.model.type === "asset" && !e.model.asset && (a.model = e.model.model.clone(), a._clonedModel = !0), s.materialAsset || (a.material = n), e.model.model) {
      const o = e.model.model.meshInstances, h = a.model.meshInstances;
      for (let l = 0; l < o.length; l++)
        h[l].mask = o[l].mask, h[l].material = o[l].material, h[l].layer = o[l].layer, h[l].receiveShadow = o[l].receiveShadow;
    }
    return e.model.customAabb && (a.customAabb = e.model.customAabb.clone()), a;
  }
  onRemove(e, t) {
    t.onRemove();
  }
}
le._buildAccessors(Jg.prototype, Qg);
const FM = ["emitterExtents", "emitterRadius", "emitterExtentsInner", "emitterRadiusInner", "loop", "initialVelocity", "animSpeed", "normalMap", "particleNormal"], OM = ["numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "lighting", "halfLambert", "intensity", "wrap", "wrapBounds", "depthWrite", "noFog", "sort", "stretch", "alignToMotion", "preWarm", "emitterShape", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animLoop", "colorMap", "localSpace", "screenSpace", "orientation"], kM = ["scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "velocityGraph", "velocityGraph2", "localVelocityGraph", "localVelocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2"], Yo = ["colorMapAsset", "normalMapAsset", "meshAsset", "renderAsset"];
let lr;
class ey extends le {
  constructor(e, t) {
    super(e, t), this._requestedDepth = !1, this._drawOrder = 0, this.on("set_colorMapAsset", this.onSetColorMapAsset, this), this.on("set_normalMapAsset", this.onSetNormalMapAsset, this), this.on("set_meshAsset", this.onSetMeshAsset, this), this.on("set_mesh", this.onSetMesh, this), this.on("set_renderAsset", this.onSetRenderAsset, this), this.on("set_loop", this.onSetLoop, this), this.on("set_blendType", this.onSetBlendType, this), this.on("set_depthSoftening", this.onSetDepthSoftening, this), this.on("set_layers", this.onSetLayers, this), FM.forEach((s) => {
      this.on(`set_${s}`, this.onSetSimpleProperty, this);
    }), OM.forEach((s) => {
      this.on(`set_${s}`, this.onSetComplexProperty, this);
    }), kM.forEach((s) => {
      this.on(`set_${s}`, this.onSetGraphProperty, this);
    });
  }
  set drawOrder(e) {
    this._drawOrder = e, this.emitter && (this.emitter.drawOrder = e);
  }
  get drawOrder() {
    return this._drawOrder;
  }
  addMeshInstanceToLayers() {
    if (this.emitter)
      for (let e = 0; e < this.layers.length; e++) {
        const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
        t && (t.addMeshInstances([this.emitter.meshInstance]), this.emitter._layer = t);
      }
  }
  removeMeshInstanceFromLayers() {
    if (this.emitter)
      for (let e = 0; e < this.layers.length; e++) {
        const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
        t && t.removeMeshInstances([this.emitter.meshInstance]);
      }
  }
  onSetLayers(e, t, s) {
    if (this.emitter) {
      for (let i = 0; i < t.length; i++) {
        const n = this.system.app.scene.layers.getLayerById(t[i]);
        n && n.removeMeshInstances([this.emitter.meshInstance]);
      }
      if (!(!this.enabled || !this.entity.enabled))
        for (let i = 0; i < s.length; i++) {
          const n = this.system.app.scene.layers.getLayerById(s[i]);
          n && n.addMeshInstances([this.emitter.meshInstance]);
        }
    }
  }
  onLayersChanged(e, t) {
    this.addMeshInstanceToLayers(), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    !this.emitter || this.layers.indexOf(e.id) < 0 || e.addMeshInstances([this.emitter.meshInstance]);
  }
  onLayerRemoved(e) {
    !this.emitter || this.layers.indexOf(e.id) < 0 || e.removeMeshInstances([this.emitter.meshInstance]);
  }
  _bindColorMapAsset(e) {
    if (e.on("load", this._onColorMapAssetLoad, this), e.on("unload", this._onColorMapAssetUnload, this), e.on("remove", this._onColorMapAssetRemove, this), e.on("change", this._onColorMapAssetChange, this), e.resource)
      this._onColorMapAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindColorMapAsset(e) {
    e.off("load", this._onColorMapAssetLoad, this), e.off("unload", this._onColorMapAssetUnload, this), e.off("remove", this._onColorMapAssetRemove, this), e.off("change", this._onColorMapAssetChange, this);
  }
  _onColorMapAssetLoad(e) {
    this.colorMap = e.resource;
  }
  _onColorMapAssetUnload(e) {
    this.colorMap = null;
  }
  _onColorMapAssetRemove(e) {
    this._onColorMapAssetUnload(e);
  }
  _onColorMapAssetChange(e) {
  }
  onSetColorMapAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && this._unbindColorMapAsset(n);
    }
    if (s) {
      s instanceof ce && (this.data.colorMapAsset = s.id, s = s.id);
      const n = i.get(s);
      n ? this._bindColorMapAsset(n) : i.once("add:" + s, (a) => {
        this._bindColorMapAsset(a);
      });
    } else
      this.colorMap = null;
  }
  _bindNormalMapAsset(e) {
    if (e.on("load", this._onNormalMapAssetLoad, this), e.on("unload", this._onNormalMapAssetUnload, this), e.on("remove", this._onNormalMapAssetRemove, this), e.on("change", this._onNormalMapAssetChange, this), e.resource)
      this._onNormalMapAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindNormalMapAsset(e) {
    e.off("load", this._onNormalMapAssetLoad, this), e.off("unload", this._onNormalMapAssetUnload, this), e.off("remove", this._onNormalMapAssetRemove, this), e.off("change", this._onNormalMapAssetChange, this);
  }
  _onNormalMapAssetLoad(e) {
    this.normalMap = e.resource;
  }
  _onNormalMapAssetUnload(e) {
    this.normalMap = null;
  }
  _onNormalMapAssetRemove(e) {
    this._onNormalMapAssetUnload(e);
  }
  _onNormalMapAssetChange(e) {
  }
  onSetNormalMapAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && this._unbindNormalMapAsset(n);
    }
    if (s) {
      s instanceof ce && (this.data.normalMapAsset = s.id, s = s.id);
      const n = i.get(s);
      n ? this._bindNormalMapAsset(n) : i.once("add:" + s, (a) => {
        this._bindNormalMapAsset(a);
      });
    } else
      this.normalMap = null;
  }
  _bindMeshAsset(e) {
    if (e.on("load", this._onMeshAssetLoad, this), e.on("unload", this._onMeshAssetUnload, this), e.on("remove", this._onMeshAssetRemove, this), e.on("change", this._onMeshAssetChange, this), e.resource)
      this._onMeshAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindMeshAsset(e) {
    e.off("load", this._onMeshAssetLoad, this), e.off("unload", this._onMeshAssetUnload, this), e.off("remove", this._onMeshAssetRemove, this), e.off("change", this._onMeshAssetChange, this);
  }
  _onMeshAssetLoad(e) {
    this._onMeshChanged(e.resource);
  }
  _onMeshAssetUnload(e) {
    this.mesh = null;
  }
  _onMeshAssetRemove(e) {
    this._onMeshAssetUnload(e);
  }
  _onMeshAssetChange(e) {
  }
  onSetMeshAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && this._unbindMeshAsset(n);
    }
    if (s) {
      s instanceof ce && (this.data.meshAsset = s.id, s = s.id);
      const n = i.get(s);
      n && this._bindMeshAsset(n);
    } else
      this._onMeshChanged(null);
  }
  onSetMesh(e, t, s) {
    !s || s instanceof ce || typeof s == "number" ? this.meshAsset = s : this._onMeshChanged(s);
  }
  _onMeshChanged(e) {
    e && !(e instanceof _s) && (e.meshInstances[0] ? e = e.meshInstances[0].mesh : e = null), this.data.mesh = e, this.emitter && (this.emitter.mesh = e, this.emitter.resetMaterial(), this.rebuild());
  }
  onSetRenderAsset(e, t, s) {
    const i = this.system.app.assets;
    if (t) {
      const n = i.get(t);
      n && this._unbindRenderAsset(n);
    }
    if (s) {
      s instanceof ce && (this.data.renderAsset = s.id, s = s.id);
      const n = i.get(s);
      n && this._bindRenderAsset(n);
    } else
      this._onRenderChanged(null);
  }
  _bindRenderAsset(e) {
    if (e.on("load", this._onRenderAssetLoad, this), e.on("unload", this._onRenderAssetUnload, this), e.on("remove", this._onRenderAssetRemove, this), e.resource)
      this._onRenderAssetLoad(e);
    else {
      if (!this.enabled || !this.entity.enabled)
        return;
      this.system.app.assets.load(e);
    }
  }
  _unbindRenderAsset(e) {
    e.off("load", this._onRenderAssetLoad, this), e.off("unload", this._onRenderAssetUnload, this), e.off("remove", this._onRenderAssetRemove, this), e.resource && e.resource.off("set:meshes", this._onRenderSetMeshes, this);
  }
  _onRenderAssetLoad(e) {
    this._onRenderChanged(e.resource);
  }
  _onRenderAssetUnload(e) {
    this._onRenderChanged(null);
  }
  _onRenderAssetRemove(e) {
    this._onRenderAssetUnload(e);
  }
  _onRenderChanged(e) {
    if (!e) {
      this._onMeshChanged(null);
      return;
    }
    e.off("set:meshes", this._onRenderSetMeshes, this), e.on("set:meshes", this._onRenderSetMeshes, this), e.meshes && this._onRenderSetMeshes(e.meshes);
  }
  _onRenderSetMeshes(e) {
    this._onMeshChanged(e && e[0]);
  }
  onSetLoop(e, t, s) {
    this.emitter && (this.emitter[e] = s, this.emitter.resetTime());
  }
  onSetBlendType(e, t, s) {
    this.emitter && (this.emitter[e] = s, this.emitter.material.blendType = s, this.emitter.resetMaterial(), this.rebuild());
  }
  _requestDepth() {
    this._requestedDepth || (lr || (lr = this.system.app.scene.layers.getLayerById(kt)), lr && (lr.incrementCounter(), this._requestedDepth = !0));
  }
  _releaseDepth() {
    this._requestedDepth && lr && (lr.decrementCounter(), this._requestedDepth = !1);
  }
  onSetDepthSoftening(e, t, s) {
    t !== s && (s ? (this.enabled && this.entity.enabled && this._requestDepth(), this.emitter && (this.emitter[e] = s)) : (this.enabled && this.entity.enabled && this._releaseDepth(), this.emitter && (this.emitter[e] = s)), this.emitter && (this.reset(), this.emitter.resetMaterial(), this.rebuild()));
  }
  onSetSimpleProperty(e, t, s) {
    this.emitter && (this.emitter[e] = s, this.emitter.resetMaterial());
  }
  onSetComplexProperty(e, t, s) {
    this.emitter && (this.emitter[e] = s, this.emitter.resetMaterial(), this.rebuild(), this.reset());
  }
  onSetGraphProperty(e, t, s) {
    this.emitter && (this.emitter[e] = s, this.emitter.rebuildGraphs(), this.emitter.resetMaterial());
  }
  onEnable() {
    const e = this.data;
    for (let t = 0, s = Yo.length; t < s; t++) {
      let i = e[Yo[t]];
      if (i) {
        if (!(i instanceof ce))
          if (parseInt(i, 10) >= 0)
            i = this.system.app.assets.get(i);
          else
            continue;
        i && !i.resource && this.system.app.assets.load(i);
      }
    }
    if (!this.emitter) {
      let t = e.mesh;
      t instanceof _s || (t = null), this.emitter = new cA(this.system.app.graphicsDevice, {
        numParticles: e.numParticles,
        emitterExtents: e.emitterExtents,
        emitterExtentsInner: e.emitterExtentsInner,
        emitterRadius: e.emitterRadius,
        emitterRadiusInner: e.emitterRadiusInner,
        emitterShape: e.emitterShape,
        initialVelocity: e.initialVelocity,
        wrap: e.wrap,
        localSpace: e.localSpace,
        screenSpace: e.screenSpace,
        wrapBounds: e.wrapBounds,
        lifetime: e.lifetime,
        rate: e.rate,
        rate2: e.rate2,
        orientation: e.orientation,
        particleNormal: e.particleNormal,
        animTilesX: e.animTilesX,
        animTilesY: e.animTilesY,
        animStartFrame: e.animStartFrame,
        animNumFrames: e.animNumFrames,
        animNumAnimations: e.animNumAnimations,
        animIndex: e.animIndex,
        randomizeAnimIndex: e.randomizeAnimIndex,
        animSpeed: e.animSpeed,
        animLoop: e.animLoop,
        startAngle: e.startAngle,
        startAngle2: e.startAngle2,
        scaleGraph: e.scaleGraph,
        scaleGraph2: e.scaleGraph2,
        colorGraph: e.colorGraph,
        colorGraph2: e.colorGraph2,
        alphaGraph: e.alphaGraph,
        alphaGraph2: e.alphaGraph2,
        localVelocityGraph: e.localVelocityGraph,
        localVelocityGraph2: e.localVelocityGraph2,
        velocityGraph: e.velocityGraph,
        velocityGraph2: e.velocityGraph2,
        rotationSpeedGraph: e.rotationSpeedGraph,
        rotationSpeedGraph2: e.rotationSpeedGraph2,
        radialSpeedGraph: e.radialSpeedGraph,
        radialSpeedGraph2: e.radialSpeedGraph2,
        colorMap: e.colorMap,
        normalMap: e.normalMap,
        loop: e.loop,
        preWarm: e.preWarm,
        sort: e.sort,
        stretch: e.stretch,
        alignToMotion: e.alignToMotion,
        lighting: e.lighting,
        halfLambert: e.halfLambert,
        intensity: e.intensity,
        depthSoftening: e.depthSoftening,
        scene: this.system.app.scene,
        mesh: t,
        depthWrite: e.depthWrite,
        noFog: e.noFog,
        node: this.entity,
        blendType: e.blendType
      }), this.emitter.meshInstance.node = this.entity, this.emitter.drawOrder = this.drawOrder, e.autoPlay || (this.pause(), this.emitter.meshInstance.visible = !1);
    }
    this.emitter.colorMap && this.addMeshInstanceToLayers(), this.system.app.scene.on("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)), this.enabled && this.entity.enabled && e.depthSoftening && this._requestDepth();
  }
  onDisable() {
    this.system.app.scene.off("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)), this.emitter && (this.removeMeshInstanceFromLayers(), this.data.depthSoftening && this._releaseDepth(), this.emitter.camera = null);
  }
  onBeforeRemove() {
    this.enabled && (this.enabled = !1), this.emitter && (this.emitter.destroy(), this.emitter = null);
    for (let e = 0; e < Yo.length; e++) {
      const t = Yo[e];
      this.data[t] && (this[t] = null);
    }
    this.off();
  }
  reset() {
    this.emitter && this.emitter.reset();
  }
  stop() {
    this.emitter && (this.emitter.loop = !1, this.emitter.resetTime(), this.emitter.addTime(0, !0));
  }
  pause() {
    this.data.paused = !0;
  }
  unpause() {
    this.data.paused = !1;
  }
  play() {
    this.data.paused = !1, this.emitter && (this.emitter.meshInstance.visible = !0, this.emitter.loop = this.data.loop, this.emitter.resetTime());
  }
  isPlaying() {
    return this.data.paused ? !1 : this.emitter && this.emitter.loop ? !0 : Date.now() <= this.emitter.endTime;
  }
  rebuild() {
    const e = this.enabled;
    this.enabled = !1, this.emitter && (this.emitter.rebuild(), this.emitter.meshInstance.node = this.entity), this.enabled = e;
  }
}
class NM {
  constructor() {
    this.numParticles = 1, this.rate = 1, this.rate2 = null, this.startAngle = 0, this.startAngle2 = null, this.lifetime = 50, this.emitterExtents = new v(), this.emitterExtentsInner = new v(), this.emitterRadius = 0, this.emitterRadiusInner = 0, this.emitterShape = Ds, this.initialVelocity = 0, this.wrapBounds = new v(), this.localSpace = !1, this.screenSpace = !1, this.colorMap = null, this.colorMapAsset = null, this.normalMap = null, this.normalMapAsset = null, this.loop = !0, this.preWarm = !1, this.sort = 0, this.mode = $_, this.scene = null, this.lighting = !1, this.halfLambert = !1, this.intensity = 1, this.stretch = 0, this.alignToMotion = !1, this.depthSoftening = 0, this.meshAsset = null, this.mesh = null, this.depthWrite = !1, this.noFog = !1, this.orientation = fh, this.particleNormal = new v(0, 1, 0), this.animTilesX = 1, this.animTilesY = 1, this.animStartFrame = 0, this.animNumFrames = 1, this.animNumAnimations = 1, this.animIndex = 0, this.randomizeAnimIndex = !1, this.animSpeed = 1, this.animLoop = !0, this.scaleGraph = null, this.scaleGraph2 = null, this.colorGraph = null, this.colorGraph2 = null, this.alphaGraph = null, this.alphaGraph2 = null, this.localVelocityGraph = null, this.localVelocityGraph2 = null, this.velocityGraph = null, this.velocityGraph2 = null, this.rotationSpeedGraph = null, this.rotationSpeedGraph2 = null, this.radialSpeedGraph = null, this.radialSpeedGraph2 = null, this.blendType = Vt, this.enabled = !0, this.paused = !1, this.autoPlay = !0, this.layers = [wi];
  }
}
const ty = ["enabled", "autoPlay", "numParticles", "lifetime", "rate", "rate2", "startAngle", "startAngle2", "loop", "preWarm", "lighting", "halfLambert", "intensity", "depthWrite", "noFog", "depthSoftening", "sort", "blendType", "stretch", "alignToMotion", "emitterShape", "emitterExtents", "emitterExtentsInner", "emitterRadius", "emitterRadiusInner", "initialVelocity", "wrap", "wrapBounds", "localSpace", "screenSpace", "colorMapAsset", "normalMapAsset", "mesh", "meshAsset", "renderAsset", "orientation", "particleNormal", "localVelocityGraph", "localVelocityGraph2", "velocityGraph", "velocityGraph2", "rotationSpeedGraph", "rotationSpeedGraph2", "radialSpeedGraph", "radialSpeedGraph2", "scaleGraph", "scaleGraph2", "colorGraph", "colorGraph2", "alphaGraph", "alphaGraph2", "colorMap", "normalMap", "animTilesX", "animTilesY", "animStartFrame", "animNumFrames", "animNumAnimations", "animIndex", "randomizeAnimIndex", "animSpeed", "animLoop", "layers"];
class zM extends Ye {
  constructor(e) {
    super(e), this.id = "particlesystem", this.ComponentType = ey, this.DataType = NM, this.schema = ty, this.propertyTypes = {
      emitterExtents: "vec3",
      emitterExtentsInner: "vec3",
      particleNormal: "vec3",
      wrapBounds: "vec3",
      localVelocityGraph: "curveset",
      localVelocityGraph2: "curveset",
      velocityGraph: "curveset",
      velocityGraph2: "curveset",
      colorGraph: "curveset",
      colorGraph2: "curveset",
      alphaGraph: "curve",
      alphaGraph2: "curve",
      rotationSpeedGraph: "curve",
      rotationSpeedGraph2: "curve",
      radialSpeedGraph: "curve",
      radialSpeedGraph2: "curve",
      scaleGraph: "curve",
      scaleGraph2: "curve"
    }, this.on("beforeremove", this.onBeforeRemove, this), this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    const i = {};
    s = [];
    const n = this.propertyTypes;
    (t.mesh instanceof ce || typeof t.mesh == "number") && (t.meshAsset = t.mesh, delete t.mesh);
    for (const a in t) {
      if (t.hasOwnProperty(a) && (s.push(a), i[a] = t[a]), n[a] === "vec3")
        Array.isArray(i[a]) && (i[a] = new v(i[a][0], i[a][1], i[a][2]));
      else if (n[a] === "curve") {
        if (!(i[a] instanceof ms)) {
          const o = i[a].type;
          i[a] = new ms(i[a].keys), i[a].type = o;
        }
      } else if (n[a] === "curveset" && !(i[a] instanceof Wi)) {
        const o = i[a].type;
        i[a] = new Wi(i[a].keys), i[a].type = o;
      }
      i.layers && Array.isArray(i.layers) && (i.layers = i.layers.slice(0));
    }
    super.initializeComponentData(e, i, s);
  }
  cloneComponent(e, t) {
    const s = e.particlesystem.data, i = this.schema, n = {};
    for (let a = 0, o = i.length; a < o; a++) {
      const h = i[a];
      let l = s[h];
      l instanceof v || l instanceof ms || l instanceof Wi ? (l = l.clone(), n[h] = l) : h === "layers" ? n.layers = s.layers.slice(0) : l != null && (n[h] = l);
    }
    return this.addComponent(t, n);
  }
  onUpdate(e) {
    const t = this.store;
    let s;
    const i = this.app.stats.particles;
    for (const n in t)
      if (t.hasOwnProperty(n)) {
        const a = t[n], o = a.entity, h = a.data;
        if (h.enabled && o.enabled) {
          const l = o.particlesystem.emitter;
          if (!l.meshInstance.visible)
            continue;
          if (l.lighting) {
            const c = h.layers;
            let d;
            for (let u = 0; u < c.length; u++) {
              const f = this.app.scene.layers.getLayerById(c[u]);
              if (!f)
                continue;
              f._lightCube || (f._lightCube = new Float32Array(6 * 3)), d = f._lightCube;
              for (let _ = 0; _ < 6; _++)
                d[_ * 3] = this.app.scene.ambientLight.r, d[_ * 3 + 1] = this.app.scene.ambientLight.g, d[_ * 3 + 2] = this.app.scene.ambientLight.b;
              const m = f._splitLights[de];
              for (let _ = 0; _ < m.length; _++)
                for (let p = 0; p < 6; p++) {
                  const g = Math.max(l.lightCubeDir[p].dot(m[_]._direction), 0) * m[_]._intensity;
                  d[p * 3] += m[_]._color.r * g, d[p * 3 + 1] += m[_]._color.g * g, d[p * 3 + 2] += m[_]._color.b * g;
                }
            }
            l.constantLightCube.setValue(d);
          }
          if (!h.paused) {
            if (l.simTime += e, l.simTime > l.fixedTimeStep && (s = Math.floor(l.simTime / l.fixedTimeStep), l.simTime -= s * l.fixedTimeStep), s) {
              s = Math.min(s, l.maxSubSteps);
              for (let c = 0; c < s; c++)
                l.addTime(l.fixedTimeStep, !1);
              i._updatesPerFrame += s, i._frameTime += l._addTimeTime, l._addTimeTime = 0;
            }
            l.finishFrame();
          }
        }
      }
  }
  onBeforeRemove(e, t) {
    t.onBeforeRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(ey.prototype, ty);
class UM extends Nu {
  constructor(e, t) {
    super(), this.skin = e, this.skinInstance = t;
  }
}
class ds {
  static createCachedSkinInstance(e, t, s) {
    let i = ds.getCachedSkinInstance(e, t);
    return i || (i = new no(e), i.resolve(t, s), ds.addCachedSkinInstance(e, t, i)), i;
  }
  static getCachedSkinInstance(e, t) {
    let s = null;
    const i = ds._skinInstanceCache.get(t);
    if (i) {
      const n = i.find((a) => a.skin === e);
      n && (n.incRefCount(), s = n.skinInstance);
    }
    return s;
  }
  static addCachedSkinInstance(e, t, s) {
    let i = ds._skinInstanceCache.get(t);
    i || (i = [], ds._skinInstanceCache.set(t, i));
    let n = i.find((a) => a.skin === e);
    n || (n = new UM(e, s), i.push(n)), n.incRefCount();
  }
  static removeCachedSkinInstance(e) {
    if (e) {
      const t = e.rootBone;
      if (t) {
        const s = ds._skinInstanceCache.get(t);
        if (s) {
          const i = s.findIndex((n) => n.skinInstance === e);
          if (i >= 0) {
            const n = s[i];
            n.decRefCount(), n.refCount === 0 && (s.splice(i, 1), s.length || ds._skinInstanceCache.delete(t), e && (e.destroy(), n.skinInstance = null));
          }
        }
      }
    }
  }
}
ds._skinInstanceCache = /* @__PURE__ */ new Map();
class ll {
  constructor(e, t, s, i, n) {
    this.propertyName = e, this.parent = t, this._scope = n, this._registry = s, this.id = null, this.url = null, this.asset = null, this._onAssetLoad = i.load, this._onAssetAdd = i.add, this._onAssetRemove = i.remove, this._onAssetUnload = i.unload;
  }
  set id(e) {
    if (this.url)
      throw Error("Can't set id and url");
    this._unbind(), this._id = e, this.asset = this._registry.get(this._id), this._bind();
  }
  get id() {
    return this._id;
  }
  set url(e) {
    if (this.id)
      throw Error("Can't set id and url");
    this._unbind(), this._url = e, this.asset = this._registry.getByUrl(this._url), this._bind();
  }
  get url() {
    return this._url;
  }
  _bind() {
    this.id && (this._onAssetLoad && this._registry.on("load:" + this.id, this._onLoad, this), this._onAssetAdd && this._registry.once("add:" + this.id, this._onAdd, this), this._onAssetRemove && this._registry.on("remove:" + this.id, this._onRemove, this), this._onAssetUnload && this._registry.on("unload:" + this.id, this._onUnload, this)), this.url && (this._onAssetLoad && this._registry.on("load:url:" + this.url, this._onLoad, this), this._onAssetAdd && this._registry.once("add:url:" + this.url, this._onAdd, this), this._onAssetRemove && this._registry.on("remove:url:" + this.url, this._onRemove, this));
  }
  _unbind() {
    this.id && (this._onAssetLoad && this._registry.off("load:" + this.id, this._onLoad, this), this._onAssetAdd && this._registry.off("add:" + this.id, this._onAdd, this), this._onAssetRemove && this._registry.off("remove:" + this.id, this._onRemove, this), this._onAssetUnload && this._registry.off("unload:" + this.id, this._onUnload, this)), this.url && (this._onAssetLoad && this._registry.off("load:" + this.url, this._onLoad, this), this._onAssetAdd && this._registry.off("add:" + this.url, this._onAdd, this), this._onAssetRemove && this._registry.off("remove:" + this.url, this._onRemove, this));
  }
  _onLoad(e) {
    this._onAssetLoad.call(this._scope, this.propertyName, this.parent, e);
  }
  _onAdd(e) {
    this.asset = e, this._onAssetAdd.call(this._scope, this.propertyName, this.parent, e);
  }
  _onRemove(e) {
    this._onAssetRemove.call(this._scope, this.propertyName, this.parent, e), this.asset = null;
  }
  _onUnload(e) {
    this._onAssetUnload.call(this._scope, this.propertyName, this.parent, e);
  }
}
class sy extends le {
  constructor(e, t) {
    super(e, t), this._type = "asset", this._castShadows = !0, this._receiveShadows = !0, this._castShadowsLightmap = !0, this._lightmapped = !1, this._lightmapSizeMultiplier = 1, this._isStatic = !1, this._batchGroupId = -1, this._layers = [wi], this._renderStyle = Ba, this._meshInstances = [], this._customAabb = null, this._area = null, this._assetReference = [], this._materialReferences = [], this._material = void 0, this._rootBone = void 0, this._rootBone = new An(this, "rootBone"), this._rootBone.on("set:entity", this._onSetRootBone, this), this._assetReference = new ll("asset", this, e.app.assets, {
      add: this._onRenderAssetAdded,
      load: this._onRenderAssetLoad,
      remove: this._onRenderAssetRemove,
      unload: this._onRenderAssetUnload
    }, this), this._material = e.defaultMaterial, t.on("remove", this.onRemoveChild, this), t.on("removehierarchy", this.onRemoveChild, this), t.on("insert", this.onInsertChild, this), t.on("inserthierarchy", this.onInsertChild, this);
  }
  set renderStyle(e) {
    this._renderStyle !== e && (this._renderStyle = e, we._prepareRenderStyleForArray(this._meshInstances, e));
  }
  get renderStyle() {
    return this._renderStyle;
  }
  set customAabb(e) {
    this._customAabb = e;
    const t = this._meshInstances;
    if (t)
      for (let s = 0; s < t.length; s++)
        t[s].setCustomAabb(this._customAabb);
  }
  get customAabb() {
    return this._customAabb;
  }
  set type(e) {
    if (this._type !== e && (this._area = null, this._type = e, this.destroyMeshInstances(), e !== "asset")) {
      let t = this._material;
      (!t || t === this.system.defaultMaterial) && (t = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource);
      const s = sg(this.system.app.graphicsDevice, e);
      this._area = s.area, this.meshInstances = [new we(s.mesh, t || this.system.defaultMaterial, this.entity)];
    }
  }
  get type() {
    return this._type;
  }
  set meshInstances(e) {
    if (this.destroyMeshInstances(), this._meshInstances = e, this._meshInstances) {
      const t = this._meshInstances;
      for (let s = 0; s < t.length; s++)
        t[s].node || (t[s].node = this.entity), t[s].castShadow = this._castShadows, t[s].receiveShadow = this._receiveShadows, t[s].isStatic = this._isStatic, t[s].renderStyle = this._renderStyle, t[s].setLightmapped(this._lightmapped), t[s].setCustomAabb(this._customAabb);
      this.enabled && this.entity.enabled && this.addToLayers();
    }
  }
  get meshInstances() {
    return this._meshInstances;
  }
  set lightmapped(e) {
    if (e !== this._lightmapped) {
      this._lightmapped = e;
      const t = this._meshInstances;
      if (t)
        for (let s = 0; s < t.length; s++)
          t[s].setLightmapped(e);
    }
  }
  get lightmapped() {
    return this._lightmapped;
  }
  set castShadows(e) {
    if (this._castShadows !== e) {
      const t = this._meshInstances;
      if (t) {
        const s = this.layers, i = this.system.app.scene;
        if (this._castShadows && !e)
          for (let n = 0; n < s.length; n++) {
            const a = i.layers.getLayerById(this.layers[n]);
            a && a.removeShadowCasters(t);
          }
        for (let n = 0; n < t.length; n++)
          t[n].castShadow = e;
        if (!this._castShadows && e)
          for (let n = 0; n < s.length; n++) {
            const a = i.layers.getLayerById(s[n]);
            a && a.addShadowCasters(t);
          }
      }
      this._castShadows = e;
    }
  }
  get castShadows() {
    return this._castShadows;
  }
  set receiveShadows(e) {
    if (this._receiveShadows !== e) {
      this._receiveShadows = e;
      const t = this._meshInstances;
      if (t)
        for (let s = 0; s < t.length; s++)
          t[s].receiveShadow = e;
    }
  }
  get receiveShadows() {
    return this._receiveShadows;
  }
  set castShadowsLightmap(e) {
    this._castShadowsLightmap = e;
  }
  get castShadowsLightmap() {
    return this._castShadowsLightmap;
  }
  set lightmapSizeMultiplier(e) {
    this._lightmapSizeMultiplier = e;
  }
  get lightmapSizeMultiplier() {
    return this._lightmapSizeMultiplier;
  }
  set isStatic(e) {
    if (this._isStatic !== e) {
      this._isStatic = e;
      const t = this._meshInstances;
      if (t)
        for (let s = 0; s < t.length; s++)
          t[s].isStatic = e;
    }
  }
  get isStatic() {
    return this._isStatic;
  }
  set layers(e) {
    const t = this.system.app.scene.layers;
    let s;
    if (this._meshInstances)
      for (let i = 0; i < this._layers.length; i++)
        s = t.getLayerById(this._layers[i]), s && s.removeMeshInstances(this._meshInstances);
    this._layers.length = 0;
    for (let i = 0; i < e.length; i++)
      this._layers[i] = e[i];
    if (!(!this.enabled || !this.entity.enabled || !this._meshInstances))
      for (let i = 0; i < this._layers.length; i++)
        s = t.getLayerById(this._layers[i]), s && s.addMeshInstances(this._meshInstances);
  }
  get layers() {
    return this._layers;
  }
  set batchGroupId(e) {
    if (this._batchGroupId !== e) {
      if (this.entity.enabled && this._batchGroupId >= 0) {
        var t;
        (t = this.system.app.batcher) == null || t.remove(nt.RENDER, this.batchGroupId, this.entity);
      }
      if (this.entity.enabled && e >= 0) {
        var s;
        (s = this.system.app.batcher) == null || s.insert(nt.RENDER, e, this.entity);
      }
      e < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled && this.addToLayers(), this._batchGroupId = e;
    }
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set material(e) {
    if (this._material !== e && (this._material = e, this._meshInstances && this._type !== "asset"))
      for (let t = 0; t < this._meshInstances.length; t++)
        this._meshInstances[t].material = e;
  }
  get material() {
    return this._material;
  }
  set materialAssets(e = []) {
    if (this._materialReferences.length > e.length) {
      for (let t = e.length; t < this._materialReferences.length; t++)
        this._materialReferences[t].id = null;
      this._materialReferences.length = e.length;
    }
    for (let t = 0; t < e.length; t++)
      if (this._materialReferences[t] || this._materialReferences.push(new ll(t, this, this.system.app.assets, {
        add: this._onMaterialAdded,
        load: this._onMaterialLoad,
        remove: this._onMaterialRemove,
        unload: this._onMaterialUnload
      }, this)), e[t]) {
        const s = e[t] instanceof ce ? e[t].id : e[t];
        this._materialReferences[t].id !== s && (this._materialReferences[t].id = s), this._materialReferences[t].asset && this._onMaterialAdded(t, this, this._materialReferences[t].asset);
      } else
        this._materialReferences[t].id = null, this._meshInstances[t] && (this._meshInstances[t].material = this.system.defaultMaterial);
  }
  get materialAssets() {
    return this._materialReferences.map(function(e) {
      return e.id;
    });
  }
  set asset(e) {
    const t = e instanceof ce ? e.id : e;
    this._assetReference.id !== t && (this._assetReference.asset && this._assetReference.asset.resource && this._onRenderAssetRemove(), this._assetReference.id = t, this._assetReference.asset && this._onRenderAssetAdded());
  }
  get asset() {
    return this._assetReference.id;
  }
  assignAsset(e) {
    const t = e instanceof ce ? e.id : e;
    this._assetReference.id = t;
  }
  _onSetRootBone(e) {
    e && this._onRootBoneChanged();
  }
  _onRootBoneChanged() {
    this._clearSkinInstances(), this.enabled && this.entity.enabled && this._cloneSkinInstances();
  }
  destroyMeshInstances() {
    const e = this._meshInstances;
    if (e) {
      this.removeFromLayers(), this._clearSkinInstances();
      for (let t = 0; t < e.length; t++)
        e[t].destroy();
      this._meshInstances.length = 0;
    }
  }
  addToLayers() {
    const e = this.system.app.scene.layers;
    for (let t = 0; t < this._layers.length; t++) {
      const s = e.getLayerById(this._layers[t]);
      s && s.addMeshInstances(this._meshInstances);
    }
  }
  removeFromLayers() {
    if (this._meshInstances && this._meshInstances.length) {
      const e = this.system.app.scene.layers;
      for (let t = 0; t < this._layers.length; t++) {
        const s = e.getLayerById(this._layers[t]);
        s && s.removeMeshInstances(this._meshInstances);
      }
    }
  }
  onRemoveChild() {
    this.removeFromLayers();
  }
  onInsertChild() {
    this._meshInstances && this.enabled && this.entity.enabled && this.addToLayers();
  }
  onRemove() {
    this.destroyMeshInstances(), this.asset = null, this.materialAsset = null, this._assetReference.id = null;
    for (let e = 0; e < this._materialReferences.length; e++)
      this._materialReferences[e].id = null;
    this.entity.off("remove", this.onRemoveChild, this), this.entity.off("insert", this.onInsertChild, this);
  }
  onLayersChanged(e, t) {
    this.addToLayers(), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    this.layers.indexOf(e.id) < 0 || e.addMeshInstances(this._meshInstances);
  }
  onLayerRemoved(e) {
    this.layers.indexOf(e.id) < 0 || e.removeMeshInstances(this._meshInstances);
  }
  onEnable() {
    const e = this.system.app, t = e.scene;
    this._rootBone.onParentComponentEnable(), this._cloneSkinInstances(), t.on("set:layers", this.onLayersChanged, this), t.layers && (t.layers.on("add", this.onLayerAdded, this), t.layers.on("remove", this.onLayerRemoved, this));
    const s = this._type === "asset";
    this._meshInstances && this._meshInstances.length ? this.addToLayers() : s && this.asset && this._onRenderAssetAdded();
    for (let n = 0; n < this._materialReferences.length; n++)
      this._materialReferences[n].asset && this.system.app.assets.load(this._materialReferences[n].asset);
    if (this._batchGroupId >= 0) {
      var i;
      (i = e.batcher) == null || i.insert(nt.RENDER, this.batchGroupId, this.entity);
    }
  }
  onDisable() {
    const e = this.system.app, t = e.scene;
    if (t.off("set:layers", this.onLayersChanged, this), t.layers && (t.layers.off("add", this.onLayerAdded, this), t.layers.off("remove", this.onLayerRemoved, this)), this._batchGroupId >= 0) {
      var s;
      (s = e.batcher) == null || s.remove(nt.RENDER, this.batchGroupId, this.entity);
    }
    this.removeFromLayers();
  }
  hide() {
    if (this._meshInstances)
      for (let e = 0; e < this._meshInstances.length; e++)
        this._meshInstances[e].visible = !1;
  }
  show() {
    if (this._meshInstances)
      for (let e = 0; e < this._meshInstances.length; e++)
        this._meshInstances[e].visible = !0;
  }
  _onRenderAssetAdded() {
    this._assetReference.asset && (this._assetReference.asset.resource ? this._onRenderAssetLoad() : this.enabled && this.entity.enabled && this.system.app.assets.load(this._assetReference.asset));
  }
  _onRenderAssetLoad() {
    if (this.destroyMeshInstances(), this._assetReference.asset) {
      const e = this._assetReference.asset.resource;
      e.off("set:meshes", this._onSetMeshes, this), e.on("set:meshes", this._onSetMeshes, this), e.meshes && this._onSetMeshes(e.meshes);
    }
  }
  _onSetMeshes(e) {
    this._cloneMeshes(e);
  }
  _clearSkinInstances() {
    for (let e = 0; e < this._meshInstances.length; e++) {
      const t = this._meshInstances[e];
      ds.removeCachedSkinInstance(t.skinInstance), t.skinInstance = null;
    }
  }
  _cloneSkinInstances() {
    if (this._meshInstances.length && this._rootBone.entity instanceof bt)
      for (let e = 0; e < this._meshInstances.length; e++) {
        const t = this._meshInstances[e], s = t.mesh;
        s.skin && !t.skinInstance && (t.skinInstance = ds.createCachedSkinInstance(s.skin, this._rootBone.entity, this.entity));
      }
  }
  _cloneMeshes(e) {
    if (e && e.length) {
      const t = [];
      for (let s = 0; s < e.length; s++) {
        const i = e[s], n = this._materialReferences[s] && this._materialReferences[s].asset && this._materialReferences[s].asset.resource, a = new we(i, n || this.system.defaultMaterial, this.entity);
        t.push(a), i.morph && (a.morphInstance = new kn(i.morph));
      }
      this.meshInstances = t, this._cloneSkinInstances();
    }
  }
  _onRenderAssetUnload() {
    this._type === "asset" && this.destroyMeshInstances();
  }
  _onRenderAssetRemove() {
    this._assetReference.asset && this._assetReference.asset.resource && this._assetReference.asset.resource.off("set:meshes", this._onSetMeshes, this), this._onRenderAssetUnload();
  }
  _onMaterialAdded(e, t, s) {
    s.resource ? this._onMaterialLoad(e, t, s) : this.enabled && this.entity.enabled && this.system.app.assets.load(s);
  }
  _updateMainMaterial(e, t) {
    e === 0 && (this.material = t);
  }
  _onMaterialLoad(e, t, s) {
    this._meshInstances[e] && (this._meshInstances[e].material = s.resource), this._updateMainMaterial(e, s.resource);
  }
  _onMaterialRemove(e, t, s) {
    this._meshInstances[e] && (this._meshInstances[e].material = this.system.defaultMaterial), this._updateMainMaterial(e, this.system.defaultMaterial);
  }
  _onMaterialUnload(e, t, s) {
    this._meshInstances[e] && (this._meshInstances[e].material = this.system.defaultMaterial), this._updateMainMaterial(e, this.system.defaultMaterial);
  }
  resolveDuplicatedEntityReferenceProperties(e, t) {
    e.rootBone && t[e.rootBone] && (this.rootBone = t[e.rootBone]), this._clearSkinInstances();
  }
}
class VM {
  constructor() {
    this.enabled = !0, this.rootBone = null;
  }
}
const Qd = [{
  name: "rootBone",
  type: "entity"
}, "enabled"], cn = ["material", "meshInstances", "asset", "materialAssets", "castShadows", "receiveShadows", "castShadowsLightmap", "lightmapped", "lightmapSizeMultiplier", "renderStyle", "type", "layers", "isStatic", "batchGroupId"];
class GM extends Ye {
  constructor(e) {
    super(e), this.id = "render", this.ComponentType = sy, this.DataType = VM, this.schema = Qd, this.defaultMaterial = io(e.graphicsDevice), this.on("beforeremove", this.onRemove, this);
  }
  initializeComponentData(e, t, s) {
    (t.batchGroupId === null || t.batchGroupId === void 0) && (t.batchGroupId = -1), t.layers && t.layers.length && (t.layers = t.layers.slice(0));
    for (let i = 0; i < cn.length; i++)
      t.hasOwnProperty(cn[i]) && (e[cn[i]] = t[cn[i]]);
    t.aabbCenter && t.aabbHalfExtents && (e.customAabb = new Pe(new v(t.aabbCenter), new v(t.aabbHalfExtents))), super.initializeComponentData(e, t, Qd);
  }
  cloneComponent(e, t) {
    const s = {};
    for (let o = 0; o < cn.length; o++)
      s[cn[o]] = e.render[cn[o]];
    s.enabled = e.render.enabled, delete s.meshInstances;
    const i = this.addComponent(t, s), n = e.render.meshInstances, a = n.map((o) => o.mesh);
    i._onSetMeshes(a);
    for (let o = 0; o < n.length; o++)
      i.meshInstances[o].material = n[o].material;
    return e.render.customAabb && (i.customAabb = e.render.customAabb.clone()), i;
  }
  onRemove(e, t) {
    t.onRemove();
  }
}
le._buildAccessors(sy.prototype, Qd);
class zc {
  constructor(e, t) {
    this._pool = [], this._count = 0, this._constructor = e, this._resize(t);
  }
  _resize(e) {
    if (e > this._pool.length)
      for (let t = this._pool.length; t < e; t++)
        this._pool[t] = new this._constructor();
  }
  allocate() {
    return this._count >= this._pool.length && this._resize(this._pool.length * 2), this._pool[this._count++];
  }
  freeAll() {
    this._count = 0;
  }
}
let ws, Fe, ti, Ko;
const HM = new ee(), WM = new ee(), Zo = new v();
class eu extends le {
  constructor(e, t) {
    super(e, t), this._angularDamping = 0, this._angularFactor = new v(1, 1, 1), this._angularVelocity = new v(), this._body = null, this._friction = 0.5, this._group = ap, this._linearDamping = 0, this._linearFactor = new v(1, 1, 1), this._linearVelocity = new v(), this._mask = Xd, this._mass = 1, this._restitution = 0, this._rollingFriction = 0, this._simulationEnabled = !1, this._type = pa;
  }
  static onLibraryLoaded() {
    typeof Ammo < "u" && (ws = new Ammo.btTransform(), Fe = new Ammo.btVector3(), ti = new Ammo.btVector3(), Ko = new Ammo.btQuaternion());
  }
  set angularDamping(e) {
    this._angularDamping !== e && (this._angularDamping = e, this._body && this._body.setDamping(this._linearDamping, e));
  }
  get angularDamping() {
    return this._angularDamping;
  }
  set angularFactor(e) {
    this._angularFactor.equals(e) || (this._angularFactor.copy(e), this._body && this._type === Ss && (Fe.setValue(e.x, e.y, e.z), this._body.setAngularFactor(Fe)));
  }
  get angularFactor() {
    return this._angularFactor;
  }
  set angularVelocity(e) {
    this._body && this._type === Ss && (this._body.activate(), Fe.setValue(e.x, e.y, e.z), this._body.setAngularVelocity(Fe), this._angularVelocity.copy(e));
  }
  get angularVelocity() {
    if (this._body && this._type === Ss) {
      const e = this._body.getAngularVelocity();
      this._angularVelocity.set(e.x(), e.y(), e.z());
    }
    return this._angularVelocity;
  }
  set body(e) {
    this._body !== e && (this._body = e, e && this._simulationEnabled && e.activate());
  }
  get body() {
    return this._body;
  }
  set friction(e) {
    this._friction !== e && (this._friction = e, this._body && this._body.setFriction(e));
  }
  get friction() {
    return this._friction;
  }
  set group(e) {
    this._group !== e && (this._group = e, this.enabled && this.entity.enabled && (this.disableSimulation(), this.enableSimulation()));
  }
  get group() {
    return this._group;
  }
  set linearDamping(e) {
    this._linearDamping !== e && (this._linearDamping = e, this._body && this._body.setDamping(e, this._angularDamping));
  }
  get linearDamping() {
    return this._linearDamping;
  }
  set linearFactor(e) {
    this._linearFactor.equals(e) || (this._linearFactor.copy(e), this._body && this._type === Ss && (Fe.setValue(e.x, e.y, e.z), this._body.setLinearFactor(Fe)));
  }
  get linearFactor() {
    return this._linearFactor;
  }
  set linearVelocity(e) {
    this._body && this._type === Ss && (this._body.activate(), Fe.setValue(e.x, e.y, e.z), this._body.setLinearVelocity(Fe), this._linearVelocity.copy(e));
  }
  get linearVelocity() {
    if (this._body && this._type === Ss) {
      const e = this._body.getLinearVelocity();
      this._linearVelocity.set(e.x(), e.y(), e.z());
    }
    return this._linearVelocity;
  }
  set mask(e) {
    this._mask !== e && (this._mask = e, this.enabled && this.entity.enabled && (this.disableSimulation(), this.enableSimulation()));
  }
  get mask() {
    return this._mask;
  }
  set mass(e) {
    if (this._mass !== e && (this._mass = e, this._body && this._type === Ss)) {
      const t = this.enabled && this.entity.enabled;
      t && this.disableSimulation(), this._body.getCollisionShape().calculateLocalInertia(e, Fe), this._body.setMassProps(e, Fe), this._body.updateInertiaTensor(), t && this.enableSimulation();
    }
  }
  get mass() {
    return this._mass;
  }
  set restitution(e) {
    this._restitution !== e && (this._restitution = e, this._body && this._body.setRestitution(e));
  }
  get restitution() {
    return this._restitution;
  }
  set rollingFriction(e) {
    this._rollingFriction !== e && (this._rollingFriction = e, this._body && this._body.setRollingFriction(e));
  }
  get rollingFriction() {
    return this._rollingFriction;
  }
  set type(e) {
    if (this._type !== e) {
      switch (this._type = e, this.disableSimulation(), e) {
        case Ss:
          this._group = N1, this._mask = hp;
          break;
        case sr:
          this._group = z1, this._mask = hp;
          break;
        case pa:
        default:
          this._group = ap, this._mask = Xd;
          break;
      }
      this.createBody();
    }
  }
  get type() {
    return this._type;
  }
  createBody() {
    const e = this.entity;
    let t;
    if (e.collision && (t = e.collision.shape, e.trigger && (e.trigger.destroy(), delete e.trigger)), t) {
      this._body && this.system.onRemove(e, this);
      const s = this._type === Ss ? this._mass : 0;
      this._getEntityTransform(ws);
      const i = this.system.createBody(s, t, ws);
      if (i.setRestitution(this._restitution), i.setFriction(this._friction), i.setRollingFriction(this._rollingFriction), i.setDamping(this._linearDamping, this._angularDamping), this._type === Ss) {
        const n = this._linearFactor;
        Fe.setValue(n.x, n.y, n.z), i.setLinearFactor(Fe);
        const a = this._angularFactor;
        Fe.setValue(a.x, a.y, a.z), i.setAngularFactor(Fe);
      } else
        this._type === sr && (i.setCollisionFlags(i.getCollisionFlags() | k1), i.setActivationState(rp));
      i.entity = e, this.body = i, this.enabled && e.enabled && this.enableSimulation();
    }
  }
  isActive() {
    return this._body ? this._body.isActive() : !1;
  }
  activate() {
    this._body && this._body.activate();
  }
  enableSimulation() {
    const e = this.entity;
    if (e.collision && e.collision.enabled && !this._simulationEnabled) {
      const t = this._body;
      if (t) {
        switch (this.system.addBody(t, this._group, this._mask), this._type) {
          case Ss:
            this.system._dynamic.push(this), t.forceActivationState(qd), this.syncEntityToBody();
            break;
          case sr:
            this.system._kinematic.push(this), t.forceActivationState(rp);
            break;
          case pa:
            t.forceActivationState(qd), this.syncEntityToBody();
            break;
        }
        e.collision.type === "compound" && this.system._compounds.push(e.collision), t.activate(), this._simulationEnabled = !0;
      }
    }
  }
  disableSimulation() {
    const e = this._body;
    if (e && this._simulationEnabled) {
      const t = this.system;
      let s = t._compounds.indexOf(this.entity.collision);
      s > -1 && t._compounds.splice(s, 1), s = t._dynamic.indexOf(this), s > -1 && t._dynamic.splice(s, 1), s = t._kinematic.indexOf(this), s > -1 && t._kinematic.splice(s, 1), t.removeBody(e), e.forceActivationState(Ug), this._simulationEnabled = !1;
    }
  }
  applyForce(e, t, s, i, n, a) {
    const o = this._body;
    o && (o.activate(), e instanceof v ? Fe.setValue(e.x, e.y, e.z) : Fe.setValue(e, t, s), t instanceof v ? ti.setValue(t.x, t.y, t.z) : i !== void 0 ? ti.setValue(i, n, a) : ti.setValue(0, 0, 0), o.applyForce(Fe, ti));
  }
  applyTorque(e, t, s) {
    const i = this._body;
    i && (i.activate(), e instanceof v ? Fe.setValue(e.x, e.y, e.z) : Fe.setValue(e, t, s), i.applyTorque(Fe));
  }
  applyImpulse(e, t, s, i, n, a) {
    const o = this._body;
    o && (o.activate(), e instanceof v ? Fe.setValue(e.x, e.y, e.z) : Fe.setValue(e, t, s), t instanceof v ? ti.setValue(t.x, t.y, t.z) : i !== void 0 ? ti.setValue(i, n, a) : ti.setValue(0, 0, 0), o.applyImpulse(Fe, ti));
  }
  applyTorqueImpulse(e, t, s) {
    const i = this._body;
    i && (i.activate(), e instanceof v ? Fe.setValue(e.x, e.y, e.z) : Fe.setValue(e, t, s), i.applyTorqueImpulse(Fe));
  }
  isStatic() {
    return this._type === pa;
  }
  isStaticOrKinematic() {
    return this._type === pa || this._type === sr;
  }
  isKinematic() {
    return this._type === sr;
  }
  _getEntityTransform(e) {
    const t = this.entity, s = t.collision;
    if (s) {
      const i = s.getShapePosition(), n = s.getShapeRotation();
      Fe.setValue(i.x, i.y, i.z), Ko.setValue(n.x, n.y, n.z, n.w);
    } else {
      const i = t.getPosition(), n = t.getRotation();
      Fe.setValue(i.x, i.y, i.z), Ko.setValue(n.x, n.y, n.z, n.w);
    }
    e.setOrigin(Fe), e.setRotation(Ko);
  }
  syncEntityToBody() {
    const e = this._body;
    if (e) {
      if (this._getEntityTransform(ws), e.setWorldTransform(ws), this._type === sr) {
        const t = e.getMotionState();
        t && t.setWorldTransform(ws);
      }
      e.activate();
    }
  }
  _updateDynamic() {
    const e = this._body;
    if (e.isActive()) {
      const t = e.getMotionState();
      if (t) {
        const s = this.entity;
        t.getWorldTransform(ws);
        const i = ws.getOrigin(), n = ws.getRotation(), a = s.collision;
        if (a && a._hasOffset) {
          const o = a.data.linearOffset, h = a.data.angularOffset, l = WM.copy(h).invert(), c = HM.set(n.x(), n.y(), n.z(), n.w()).mul(l);
          c.transformVector(o, Zo), s.setPosition(i.x() - Zo.x, i.y() - Zo.y, i.z() - Zo.z), s.setRotation(c);
        } else
          s.setPosition(i.x(), i.y(), i.z()), s.setRotation(n.x(), n.y(), n.z(), n.w());
      }
    }
  }
  _updateKinematic() {
    const e = this._body.getMotionState();
    e && (this._getEntityTransform(ws), e.setWorldTransform(ws));
  }
  teleport(e, t, s, i, n, a) {
    e instanceof v ? this.entity.setPosition(e) : this.entity.setPosition(e, t, s), t instanceof ee ? this.entity.setRotation(t) : t instanceof v ? this.entity.setEulerAngles(t) : i !== void 0 && this.entity.setEulerAngles(i, n, a), this.syncEntityToBody();
  }
  onEnable() {
    this._body || this.createBody(), this.enableSimulation();
  }
  onDisable() {
    this.disableSimulation();
  }
}
class qM {
  constructor() {
    this.enabled = !0;
  }
}
let dn, un;
class gp {
  constructor(e, t, s) {
    this.entity = e, this.point = t, this.normal = s;
  }
}
class XM {
  constructor(e, t, s) {
    arguments.length === 0 ? (this.a = null, this.b = null, this.impulse = 0, this.localPointA = new v(), this.localPointB = new v(), this.pointA = new v(), this.pointB = new v(), this.normal = new v()) : (this.a = e, this.b = t, this.impulse = s.impulse, this.localPointA = s.localPoint, this.localPointB = s.localPointOther, this.pointA = s.point, this.pointB = s.pointOther, this.normal = s.normal);
  }
}
class jM {
  constructor(e = new v(), t = new v(), s = new v(), i = new v(), n = new v(), a = 0) {
    this.localPoint = e, this.localPointOther = t, this.point = s, this.pointOther = i, this.normal = n, this.impulse = a;
  }
}
class $M {
  constructor(e, t) {
    this.other = e, this.contacts = t;
  }
}
const iy = ["enabled"];
class YM extends Ye {
  constructor(e) {
    super(e), this.maxSubSteps = 10, this.fixedTimeStep = 1 / 60, this.gravity = new v(0, -9.81, 0), this._gravityFloat32 = new Float32Array(3), this._dynamic = [], this._kinematic = [], this._triggers = [], this._compounds = [], this.id = "rigidbody", this._stats = e.stats.frame, this.ComponentType = eu, this.DataType = qM, this.contactPointPool = null, this.contactResultPool = null, this.singleContactResultPool = null, this.schema = iy, this.collisions = {}, this.frameCollisions = {}, this.on("beforeremove", this.onBeforeRemove, this), this.on("remove", this.onRemove, this);
  }
  onLibraryLoaded() {
    if (typeof Ammo < "u") {
      if (this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration(), this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration), this.overlappingPairCache = new Ammo.btDbvtBroadphase(), this.solver = new Ammo.btSequentialImpulseConstraintSolver(), this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration), this.dynamicsWorld.setInternalTickCallback) {
        const e = Ammo.addFunction(this._checkForCollisions.bind(this), "vif");
        this.dynamicsWorld.setInternalTickCallback(e);
      }
      dn = new Ammo.btVector3(), un = new Ammo.btVector3(), eu.onLibraryLoaded(), this.contactPointPool = new zc(jM, 1), this.contactResultPool = new zc($M, 1), this.singleContactResultPool = new zc(XM, 1), this.app.systems.on("update", this.onUpdate, this);
    } else
      this.app.systems.off("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    const i = ["mass", "linearDamping", "angularDamping", "linearFactor", "angularFactor", "friction", "rollingFriction", "restitution", "type", "group", "mask"];
    for (const n of i)
      if (t.hasOwnProperty(n)) {
        const a = t[n];
        Array.isArray(a) ? e[n] = new v(a[0], a[1], a[2]) : e[n] = a;
      }
    super.initializeComponentData(e, t, ["enabled"]);
  }
  cloneComponent(e, t) {
    const s = e.rigidbody, i = {
      enabled: s.enabled,
      mass: s.mass,
      linearDamping: s.linearDamping,
      angularDamping: s.angularDamping,
      linearFactor: [s.linearFactor.x, s.linearFactor.y, s.linearFactor.z],
      angularFactor: [s.angularFactor.x, s.angularFactor.y, s.angularFactor.z],
      friction: s.friction,
      rollingFriction: s.rollingFriction,
      restitution: s.restitution,
      type: s.type,
      group: s.group,
      mask: s.mask
    };
    return this.addComponent(t, i);
  }
  onBeforeRemove(e, t) {
    t.enabled && (t.enabled = !1);
  }
  onRemove(e, t) {
    const s = t.body;
    s && (this.removeBody(s), this.destroyBody(s), t.body = null);
  }
  addBody(e, t, s) {
    t !== void 0 && s !== void 0 ? this.dynamicsWorld.addRigidBody(e, t, s) : this.dynamicsWorld.addRigidBody(e);
  }
  removeBody(e) {
    this.dynamicsWorld.removeRigidBody(e);
  }
  createBody(e, t, s) {
    const i = new Ammo.btVector3(0, 0, 0);
    e !== 0 && t.calculateLocalInertia(e, i);
    const n = new Ammo.btDefaultMotionState(s), a = new Ammo.btRigidBodyConstructionInfo(e, n, t, i), o = new Ammo.btRigidBody(a);
    return Ammo.destroy(a), Ammo.destroy(i), o;
  }
  destroyBody(e) {
    const t = e.getMotionState();
    t && Ammo.destroy(t), Ammo.destroy(e);
  }
  raycastFirst(e, t) {
    let s = null;
    dn.setValue(e.x, e.y, e.z), un.setValue(t.x, t.y, t.z);
    const i = new Ammo.ClosestRayResultCallback(dn, un);
    if (this.dynamicsWorld.rayTest(dn, un, i), i.hasHit()) {
      const n = i.get_m_collisionObject(), a = Ammo.castObject(n, Ammo.btRigidBody);
      if (a) {
        const o = i.get_m_hitPointWorld(), h = i.get_m_hitNormalWorld();
        if (s = new gp(a.entity, new v(o.x(), o.y(), o.z()), new v(h.x(), h.y(), h.z())), arguments.length > 2) {
          const l = arguments[2];
          l(s);
        }
      }
    }
    return Ammo.destroy(i), s;
  }
  raycastAll(e, t) {
    const s = [];
    dn.setValue(e.x, e.y, e.z), un.setValue(t.x, t.y, t.z);
    const i = new Ammo.AllHitsRayResultCallback(dn, un);
    if (this.dynamicsWorld.rayTest(dn, un, i), i.hasHit()) {
      const n = i.get_m_collisionObjects(), a = i.get_m_hitPointWorld(), o = i.get_m_hitNormalWorld(), h = n.size();
      for (let l = 0; l < h; l++) {
        const c = Ammo.castObject(n.at(l), Ammo.btRigidBody);
        if (c) {
          const d = a.at(l), u = o.at(l), f = new gp(c.entity, new v(d.x(), d.y(), d.z()), new v(u.x(), u.y(), u.z()));
          s.push(f);
        }
      }
    }
    return Ammo.destroy(i), s;
  }
  _storeCollision(e, t) {
    let s = !1;
    const i = e.getGuid();
    return this.collisions[i] = this.collisions[i] || {
      others: [],
      entity: e
    }, this.collisions[i].others.indexOf(t) < 0 && (this.collisions[i].others.push(t), s = !0), this.frameCollisions[i] = this.frameCollisions[i] || {
      others: [],
      entity: e
    }, this.frameCollisions[i].others.push(t), s;
  }
  _createContactPointFromAmmo(e) {
    const t = e.get_m_localPointA(), s = e.get_m_localPointB(), i = e.getPositionWorldOnA(), n = e.getPositionWorldOnB(), a = e.get_m_normalWorldOnB(), o = this.contactPointPool.allocate();
    return o.localPoint.set(t.x(), t.y(), t.z()), o.localPointOther.set(s.x(), s.y(), s.z()), o.point.set(i.x(), i.y(), i.z()), o.pointOther.set(n.x(), n.y(), n.z()), o.normal.set(a.x(), a.y(), a.z()), o.impulse = e.getAppliedImpulse(), o;
  }
  _createReverseContactPointFromAmmo(e) {
    const t = e.get_m_localPointA(), s = e.get_m_localPointB(), i = e.getPositionWorldOnA(), n = e.getPositionWorldOnB(), a = e.get_m_normalWorldOnB(), o = this.contactPointPool.allocate();
    return o.localPointOther.set(t.x(), t.y(), t.z()), o.localPoint.set(s.x(), s.y(), s.z()), o.pointOther.set(i.x(), i.y(), i.z()), o.point.set(n.x(), n.y(), n.z()), o.normal.set(a.x(), a.y(), a.z()), o.impulse = e.getAppliedImpulse(), o;
  }
  _createSingleContactResult(e, t, s) {
    const i = this.singleContactResultPool.allocate();
    return i.a = e, i.b = t, i.localPointA = s.localPoint, i.localPointB = s.localPointOther, i.pointA = s.point, i.pointB = s.pointOther, i.normal = s.normal, i.impulse = s.impulse, i;
  }
  _createContactResult(e, t) {
    const s = this.contactResultPool.allocate();
    return s.other = e, s.contacts = t, s;
  }
  _cleanOldCollisions() {
    for (const e in this.collisions)
      if (this.collisions.hasOwnProperty(e)) {
        const t = this.frameCollisions[e], s = this.collisions[e], i = s.entity, n = i.collision, a = i.rigidbody, o = s.others;
        let l = o.length;
        for (; l--; ) {
          const c = o[l];
          (!t || t.others.indexOf(c) < 0) && (o.splice(l, 1), i.trigger ? (n && n.fire("triggerleave", c), c.rigidbody && c.rigidbody.fire("triggerleave", i)) : c.trigger || (a && a.fire("collisionend", c), n && n.fire("collisionend", c)));
        }
        o.length === 0 && delete this.collisions[e];
      }
  }
  _hasContactEvent(e) {
    const t = e.collision;
    if (t && (t.hasEvent("collisionstart") || t.hasEvent("collisionend") || t.hasEvent("contact")))
      return !0;
    const s = e.rigidbody;
    return s && (s.hasEvent("collisionstart") || s.hasEvent("collisionend") || s.hasEvent("contact"));
  }
  _checkForCollisions(e, t) {
    const i = Ammo.wrapPointer(e, Ammo.btDynamicsWorld).getDispatcher(), n = i.getNumManifolds();
    this.frameCollisions = {};
    for (let a = 0; a < n; a++) {
      const o = i.getManifoldByIndexInternal(a), h = o.getBody0(), l = o.getBody1(), c = Ammo.castObject(h, Ammo.btRigidBody), d = Ammo.castObject(l, Ammo.btRigidBody), u = c.entity, f = d.entity;
      if (!u || !f)
        continue;
      const m = c.getCollisionFlags(), _ = d.getCollisionFlags(), p = o.getNumContacts(), g = [], b = [];
      let x;
      if (p > 0)
        if (m & Sa || _ & Sa) {
          const y = u.collision && (u.collision.hasEvent("triggerenter") || u.collision.hasEvent("triggerleave")), S = f.collision && (f.collision.hasEvent("triggerenter") || f.collision.hasEvent("triggerleave")), C = u.rigidbody && (u.rigidbody.hasEvent("triggerenter") || u.rigidbody.hasEvent("triggerleave")), w = f.rigidbody && (f.rigidbody.hasEvent("triggerenter") || f.rigidbody.hasEvent("triggerleave"));
          y && (x = this._storeCollision(u, f), x && !(_ & Sa) && u.collision.fire("triggerenter", f)), S && (x = this._storeCollision(f, u), x && !(m & Sa) && f.collision.fire("triggerenter", u)), C && (x || (x = this._storeCollision(f, u)), x && u.rigidbody.fire("triggerenter", f)), w && (x || (x = this._storeCollision(u, f)), x && f.rigidbody.fire("triggerenter", u));
        } else {
          const y = this._hasContactEvent(u), S = this._hasContactEvent(f), C = this.hasEvent("contact");
          if (C || y || S) {
            for (let w = 0; w < p; w++) {
              const M = o.getContactPoint(w), T = this._createContactPointFromAmmo(M);
              if (y || S) {
                g.push(T);
                const A = this._createReverseContactPointFromAmmo(M);
                b.push(A);
              }
              if (C) {
                const A = this._createSingleContactResult(u, f, T);
                this.fire("contact", A);
              }
            }
            if (y) {
              const w = this._createContactResult(f, g);
              x = this._storeCollision(u, f), u.collision && (u.collision.fire("contact", w), x && u.collision.fire("collisionstart", w)), u.rigidbody && (u.rigidbody.fire("contact", w), x && u.rigidbody.fire("collisionstart", w));
            }
            if (S) {
              const w = this._createContactResult(u, b);
              x = this._storeCollision(f, u), f.collision && (f.collision.fire("contact", w), x && f.collision.fire("collisionstart", w)), f.rigidbody && (f.rigidbody.fire("contact", w), x && f.rigidbody.fire("collisionstart", w));
            }
          }
        }
    }
    this._cleanOldCollisions(), this.contactPointPool.freeAll(), this.contactResultPool.freeAll(), this.singleContactResultPool.freeAll();
  }
  onUpdate(e) {
    let t, s;
    this._gravityFloat32[0] = this.gravity.x, this._gravityFloat32[1] = this.gravity.y, this._gravityFloat32[2] = this.gravity.z;
    const i = this.dynamicsWorld.getGravity();
    (i.x() !== this._gravityFloat32[0] || i.y() !== this._gravityFloat32[1] || i.z() !== this._gravityFloat32[2]) && (i.setValue(this.gravity.x, this.gravity.y, this.gravity.z), this.dynamicsWorld.setGravity(i));
    const n = this._triggers;
    for (t = 0, s = n.length; t < s; t++)
      n[t].updateTransform();
    const a = this._compounds;
    for (t = 0, s = a.length; t < s; t++)
      a[t]._updateCompound();
    const o = this._kinematic;
    for (t = 0, s = o.length; t < s; t++)
      o[t]._updateKinematic();
    this.dynamicsWorld.stepSimulation(e, this.maxSubSteps, this.fixedTimeStep);
    const h = this._dynamic;
    for (t = 0, s = h.length; t < s; t++)
      h[t]._updateDynamic();
    this.dynamicsWorld.setInternalTickCallback || this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), e);
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this), typeof Ammo < "u" && (Ammo.destroy(this.dynamicsWorld), Ammo.destroy(this.solver), Ammo.destroy(this.overlappingPairCache), Ammo.destroy(this.dispatcher), Ammo.destroy(this.collisionConfiguration), this.dynamicsWorld = null, this.solver = null, this.overlappingPairCache = null, this.dispatcher = null, this.collisionConfiguration = null);
  }
}
le._buildAccessors(eu.prototype, iy);
const cr = "none", ny = "blend", yp = new j();
class ry extends le {
  constructor(e, t) {
    super(e, t), this._resolution = new q(640, 320), this._referenceResolution = new q(640, 320), this._scaleMode = cr, this.scale = 1, this._scaleBlend = 0.5, this._priority = 0, this._screenSpace = !1, this.cull = this._screenSpace, this._screenMatrix = new j(), this._elements = /* @__PURE__ */ new Set(), e.app.graphicsDevice.on("resizecanvas", this._onResize, this);
  }
  syncDrawOrder() {
    this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
  }
  _recurseDrawOrderSync(e, t) {
    if (!(e instanceof oe))
      return t;
    if (e.element) {
      const n = e.element.drawOrder;
      if (e.element.drawOrder = t++, e.element._batchGroupId >= 0 && n !== e.element.drawOrder) {
        var s;
        (s = this.system.app.batcher) == null || s.markGroupDirty(e.element._batchGroupId);
      }
    }
    e.particlesystem && (e.particlesystem.drawOrder = t++);
    const i = e.children;
    for (let n = 0; n < i.length; n++)
      t = this._recurseDrawOrderSync(i[n], t);
    return t;
  }
  _processDrawOrderSync() {
    this._recurseDrawOrderSync(this.entity, 1), this.fire("syncdraworder");
  }
  _calcProjectionMatrix() {
    const e = this._resolution.x / this.scale, t = this._resolution.y / this.scale, s = 0, i = e, n = -t, a = 0, o = 1, h = -1;
    this._screenMatrix.setOrtho(s, i, n, a, o, h), this._screenSpace || (yp.setScale(0.5 * e, 0.5 * t, 1), this._screenMatrix.mul2(yp, this._screenMatrix));
  }
  _updateScale() {
    this.scale = this._calcScale(this._resolution, this.referenceResolution);
  }
  _calcScale(e, t) {
    const s = Math.log2(e.x / t.x), i = Math.log2(e.y / t.y);
    return Math.pow(2, s * (1 - this._scaleBlend) + i * this._scaleBlend);
  }
  _onResize(e, t) {
    this._screenSpace && (this._resolution.set(e, t), this.resolution = this._resolution);
  }
  _bindElement(e) {
    this._elements.add(e);
  }
  _unbindElement(e) {
    this._elements.delete(e);
  }
  onRemove() {
    this.system.app.graphicsDevice.off("resizecanvas", this._onResize, this), this.fire("remove"), this._elements.forEach((e) => e._onScreenRemove()), this._elements.clear(), this.off();
  }
  set resolution(e) {
    this._screenSpace ? this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height) : this._resolution.set(e.x, e.y), this._updateScale(), this._calcProjectionMatrix(), this.entity._dirtyLocal || this.entity._dirtifyLocal(), this.fire("set:resolution", this._resolution), this._elements.forEach((t) => t._onScreenResize(this._resolution));
  }
  get resolution() {
    return this._resolution;
  }
  set referenceResolution(e) {
    this._referenceResolution.set(e.x, e.y), this._updateScale(), this._calcProjectionMatrix(), this.entity._dirtyLocal || this.entity._dirtifyLocal(), this.fire("set:referenceresolution", this._resolution), this._elements.forEach((t) => t._onScreenResize(this._resolution));
  }
  get referenceResolution() {
    return this._scaleMode === cr ? this._resolution : this._referenceResolution;
  }
  set screenSpace(e) {
    this._screenSpace = e, this._screenSpace && this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height), this.resolution = this._resolution, this.entity._dirtyLocal || this.entity._dirtifyLocal(), this.fire("set:screenspace", this._screenSpace), this._elements.forEach((t) => t._onScreenSpaceChange());
  }
  get screenSpace() {
    return this._screenSpace;
  }
  set scaleMode(e) {
    e !== cr && e !== ny && (e = cr), !this._screenSpace && e !== cr && (e = cr), this._scaleMode = e, this.resolution = this._resolution, this.fire("set:scalemode", this._scaleMode);
  }
  get scaleMode() {
    return this._scaleMode;
  }
  set scaleBlend(e) {
    this._scaleBlend = e, this._updateScale(), this._calcProjectionMatrix(), this.entity._dirtyLocal || this.entity._dirtifyLocal(), this.fire("set:scaleblend", this._scaleBlend), this._elements.forEach((t) => t._onScreenResize(this._resolution));
  }
  get scaleBlend() {
    return this._scaleBlend;
  }
  set priority(e) {
    e > 255 && (e = 255), this._priority !== e && (this._priority = e, this.syncDrawOrder());
  }
  get priority() {
    return this._priority;
  }
}
class KM {
  constructor() {
    this.enabled = !0;
  }
}
const ay = ["enabled"];
class ZM extends Ye {
  constructor(e) {
    super(e), this.id = "screen", this.ComponentType = ry, this.DataType = KM, this.schema = ay, this.windowResolution = new q(), this._drawOrderSyncQueue = new f0(), this.app.graphicsDevice.on("resizecanvas", this._onResize, this), this.app.systems.on("update", this._onUpdate, this), this.on("beforeremove", this.onRemoveComponent, this);
  }
  initializeComponentData(e, t, s) {
    t.priority !== void 0 && (e.priority = t.priority), t.screenSpace !== void 0 && (e.screenSpace = t.screenSpace), e.cull = e.screenSpace, t.scaleMode !== void 0 && (e.scaleMode = t.scaleMode), t.scaleBlend !== void 0 && (e.scaleBlend = t.scaleBlend), t.resolution !== void 0 && (t.resolution instanceof q ? e._resolution.copy(t.resolution) : e._resolution.set(t.resolution[0], t.resolution[1]), e.resolution = e._resolution), t.referenceResolution !== void 0 && (t.referenceResolution instanceof q ? e._referenceResolution.copy(t.referenceResolution) : e._referenceResolution.set(t.referenceResolution[0], t.referenceResolution[1]), e.referenceResolution = e._referenceResolution), e.syncDrawOrder(), super.initializeComponentData(e, t, s);
  }
  destroy() {
    super.destroy(), this.app.graphicsDevice.off("resizecanvas", this._onResize, this), this.app.systems.off("update", this._onUpdate, this);
  }
  _onUpdate(e) {
    const t = this.store;
    for (const s in t)
      t[s].entity.screen.update && t[s].entity.screen.update(e);
  }
  _onResize(e, t) {
    this.windowResolution.x = e, this.windowResolution.y = t;
  }
  cloneComponent(e, t) {
    const s = e.screen;
    return this.addComponent(t, {
      enabled: s.enabled,
      screenSpace: s.screenSpace,
      scaleMode: s.scaleMode,
      resolution: s.resolution.clone(),
      referenceResolution: s.referenceResolution.clone()
    });
  }
  onRemoveComponent(e, t) {
    t.onRemove();
  }
  processDrawOrderSyncQueue() {
    const e = this._drawOrderSyncQueue.list();
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      s.callback.call(s.scope);
    }
    this._drawOrderSyncQueue.clear();
  }
  queueDrawOrderSync(e, t, s) {
    this._drawOrderSyncQueue.list().length || this.app.once("prerender", this.processDrawOrderSyncQueue, this), this._drawOrderSyncQueue.has(e) || this._drawOrderSyncQueue.push(e, {
      callback: t,
      scope: s
    });
  }
}
le._buildAccessors(ry.prototype, ay);
class oy extends le {
  constructor(e, t) {
    super(e, t), this.on("set_scripts", this.onSetScripts, this);
  }
  send(e, t) {
    const s = Array.prototype.slice.call(arguments, 2), i = this.entity.script.instances;
    let n;
    if (i && i[e] && (n = i[e].instance[t], n))
      return n.apply(i[e].instance, s);
  }
  onEnable() {
    this.data.areScriptsLoaded && !this.system.preloading && (this.data.initialized ? this.system._enableScriptComponent(this) : this.system._initializeScriptComponent(this), this.data.postInitialized || this.system._postInitializeScriptComponent(this));
  }
  onDisable() {
    this.system._disableScriptComponent(this);
  }
  onSetScripts(e, t, s) {
    if (!this.system._inTools || this.runInTools) {
      if (this._updateScriptAttributes(t, s))
        return;
      this.enabled && this.system._disableScriptComponent(this), this.system._destroyScriptComponent(this), this.data.areScriptsLoaded = !1;
      const n = s.map(function(a) {
        return a.url;
      });
      if (this._loadFromCache(n))
        return;
      this._loadScripts(n);
    }
  }
  _updateScriptAttributes(e, t) {
    let s = !0;
    if (e.length !== t.length)
      s = !1;
    else
      for (let i = 0, n = t.length; i < n; i++)
        if (e[i].url !== t[i].url) {
          s = !1;
          break;
        }
    if (s)
      for (const i in this.instances)
        this.instances.hasOwnProperty(i) && this.system._updateAccessors(this.entity, this.instances[i]);
    return s;
  }
  _loadFromCache(e) {
    const t = [], s = this.system.app._scriptPrefix || "", i = /^http(s)?:\/\//i;
    for (let n = 0, a = e.length; n < a; n++) {
      let o = e[n];
      i.test(o) || (o = me.join(s, o));
      const h = this.system.app.loader.getFromCache(o, "script");
      if (!h)
        return !1;
      t.push(h);
    }
    for (let n = 0, a = t.length; n < a; n++) {
      const o = t[n];
      if (o !== !0 && o && this.entity.script && !this.entity.script.instances[o._pcScriptName]) {
        const h = new o(this.entity);
        this.system._preRegisterInstance(this.entity, e[n], o._pcScriptName, h);
      }
    }
    return this.data && (this.data.areScriptsLoaded = !0), this.system.preloading || (this.system.onInitialize(this.entity), this.system.onPostInitialize(this.entity)), !0;
  }
  _loadScripts(e) {
    let t = e.length;
    const s = this.system.app._scriptPrefix || "";
    e.forEach((i) => {
      let n = null, a = null;
      i.toLowerCase().startsWith("http://") || i.toLowerCase().startsWith("https://") ? (a = i, n = i) : (a = i, n = me.join(s, i)), this.system.app.loader.load(n, "script", (o, h) => {
        if (t--, o)
          console.error(o);
        else if (h && this.entity.script && !this.entity.script.instances[h._pcScriptName]) {
          const l = new h(this.entity);
          this.system._preRegisterInstance(this.entity, a, h._pcScriptName, l);
        }
        t === 0 && (this.data.areScriptsLoaded = !0, this.system.preloading || (this.system.onInitialize(this.entity), this.system.onPostInitialize(this.entity)));
      });
    });
  }
}
class JM {
  constructor() {
    this.scripts = [], this.enabled = !0, this.instances = {}, this._instances = {}, this.runInTools = !1, this.attributes = {}, this.initialized = !1, this.postInitialized = !1, this.areScriptsLoaded = !1;
  }
}
const hy = ["enabled", "scripts", "instances", "runInTools"], Uc = "initialize", Vc = "postInitialize", Gc = "update", Hc = "postUpdate", Wc = "fixedUpdate", qc = "toolsUpdate", QM = "onEnable", eE = "onDisable";
class tE extends Ye {
  constructor(e) {
    super(e), this.id = "script", this.ComponentType = oy, this.DataType = JM, this.schema = hy, this.preloading = !1, this.instancesWithUpdate = [], this.instancesWithFixedUpdate = [], this.instancesWithPostUpdate = [], this.instancesWithToolsUpdate = [], this.on("beforeremove", this.onBeforeRemove, this), this.app.systems.on(Uc, this.onInitialize, this), this.app.systems.on(Vc, this.onPostInitialize, this), this.app.systems.on(Gc, this.onUpdate, this), this.app.systems.on(Wc, this.onFixedUpdate, this), this.app.systems.on(Hc, this.onPostUpdate, this), this.app.systems.on(qc, this.onToolsUpdate, this);
  }
  initializeComponentData(e, t, s) {
    s = ["runInTools", "enabled", "scripts"], t.scripts && t.scripts.length && t.scripts.forEach(function(i) {
      if (i.attributes && Array.isArray(i.attributes)) {
        const n = {};
        for (let a = 0; a < i.attributes.length; a++)
          n[i.attributes[a].name] = i.attributes[a];
        i.attributes = n;
      }
    }), super.initializeComponentData(e, t, s);
  }
  cloneComponent(e, t) {
    const s = this.store[e.getGuid()], i = {
      runInTools: s.data.runInTools,
      scripts: [],
      enabled: s.data.enabled
    }, n = s.data.scripts;
    for (let a = 0, o = n.length; a < o; a++) {
      const h = n[a].attributes;
      h && delete n[a].attributes, i.scripts.push(Hi({}, n[a])), h && (i.scripts[a].attributes = this._cloneAttributes(h), n[a].attributes = h);
    }
    return this.addComponent(t, i);
  }
  onBeforeRemove(e, t) {
    t.enabled && this._disableScriptComponent(t), this._destroyScriptComponent(t);
  }
  onInitialize(e) {
    if (this._registerInstances(e), e.enabled) {
      e.script && e.script.enabled && this._initializeScriptComponent(e.script);
      const t = e._children;
      for (let s = 0, i = t.length; s < i; s++)
        t[s] instanceof oe && this.onInitialize(t[s]);
    }
  }
  onPostInitialize(e) {
    if (e.enabled) {
      e.script && e.script.enabled && this._postInitializeScriptComponent(e.script);
      const t = e._children;
      for (let s = 0, i = t.length; s < i; s++)
        t[s] instanceof oe && this.onPostInitialize(t[s]);
    }
  }
  _callInstancesMethod(e, t) {
    const s = e.data.instances;
    for (const i in s)
      if (s.hasOwnProperty(i)) {
        const n = s[i].instance;
        n[t] && n[t]();
      }
  }
  _initializeScriptComponent(e) {
    this._callInstancesMethod(e, Uc), e.data.initialized = !0, e.enabled && e.entity.enabled && this._enableScriptComponent(e);
  }
  _enableScriptComponent(e) {
    this._callInstancesMethod(e, QM);
  }
  _disableScriptComponent(e) {
    this._callInstancesMethod(e, eE);
  }
  _destroyScriptComponent(e) {
    const t = e.data.instances;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s].instance;
        if (i.destroy && i.destroy(), i.update) {
          const n = this.instancesWithUpdate.indexOf(i);
          n >= 0 && this.instancesWithUpdate.splice(n, 1);
        }
        if (i.fixedUpdate) {
          const n = this.instancesWithFixedUpdate.indexOf(i);
          n >= 0 && this.instancesWithFixedUpdate.splice(n, 1);
        }
        if (i.postUpdate) {
          const n = this.instancesWithPostUpdate.indexOf(i);
          n >= 0 && this.instancesWithPostUpdate.splice(n, 1);
        }
        if (i.toolsUpdate) {
          const n = this.instancesWithToolsUpdate.indexOf(i);
          n >= 0 && this.instancesWithToolsUpdate.splice(n, 1);
        }
        e.instances[s].instance === e[s] && delete e[s], delete e.instances[s];
      }
  }
  _postInitializeScriptComponent(e) {
    this._callInstancesMethod(e, Vc), e.data.postInitialized = !0;
  }
  _updateInstances(e, t, s) {
    for (let i = 0, n = t.length; i < n; i++) {
      const a = t[i];
      a && a.entity && a.entity.enabled && a.entity.script.enabled && a[e](s);
    }
  }
  onUpdate(e) {
    this._updateInstances(Gc, this.instancesWithUpdate, e);
  }
  onFixedUpdate(e) {
    this._updateInstances(Wc, this.instancesWithFixedUpdate, e);
  }
  onPostUpdate(e) {
    this._updateInstances(Hc, this.instancesWithPostUpdate, e);
  }
  onToolsUpdate(e) {
    this._updateInstances(qc, this.instancesWithToolsUpdate, e);
  }
  broadcast(e, t) {
    const s = Array.prototype.slice.call(arguments, 2), i = this.store;
    for (const n in i)
      if (i.hasOwnProperty(n)) {
        const a = i[n].data;
        if (a.instances[e]) {
          const o = a.instances[e].instance[t];
          o && o.apply(a.instances[e].instance, s);
        }
      }
  }
  _preRegisterInstance(e, t, s, i) {
    if (e.script) {
      if (e.script.data._instances = e.script.data._instances || {}, e.script.data._instances[s])
        throw Error(`Script name collision '${s}'. Scripts from '${t}' and '${e.script.data._instances[s].url}' {${e.getGuid()}}`);
      e.script.data._instances[s] = {
        url: t,
        name: s,
        instance: i
      };
    }
  }
  _registerInstances(e) {
    if (e.script && e.script.data._instances) {
      e.script.instances = e.script.data._instances;
      for (const s in e.script.instances) {
        const i = e.script.instances[s], n = i.instance;
        if (mu.attach(n), n.update && this.instancesWithUpdate.push(n), n.fixedUpdate && this.instancesWithFixedUpdate.push(n), n.postUpdate && this.instancesWithPostUpdate.push(n), n.toolsUpdate && this.instancesWithToolsUpdate.push(n), e.script.scripts && this._createAccessors(e, i), e.script[s])
          throw Error(`Script with name '${s}' is already attached to Script Component`);
        e.script[s] = n;
      }
      delete e.script.data._instances;
    }
    const t = e._children;
    for (let s = 0, i = t.length; s < i; s++)
      t[s] instanceof oe && this._registerInstances(t[s]);
  }
  _cloneAttributes(e) {
    const t = {};
    for (const s in e)
      if (e.hasOwnProperty(s))
        if (e[s].type !== "entity")
          t[s] = Hi({}, e[s]);
        else {
          const i = e[s].value;
          delete e[s].value, t[s] = Hi({}, e[s]), t[s].value = i, e[s].value = i;
        }
    return t;
  }
  _createAccessors(e, t) {
    const s = e.script.scripts.length, i = t.url;
    for (let n = 0; n < s; n++) {
      const a = e.script.scripts[n];
      if (a.url === i) {
        const o = a.attributes;
        if (a.name && o) {
          for (const h in o)
            o.hasOwnProperty(h) && this._createAccessor(o[h], t);
          e.script.data.attributes[a.name] = this._cloneAttributes(o);
        }
        break;
      }
    }
  }
  _createAccessor(e, t) {
    const s = this;
    e = {
      name: e.name,
      value: e.value,
      type: e.type
    }, this._convertAttributeValue(e), Object.defineProperty(t.instance, e.name, {
      get: function() {
        return e.value;
      },
      set: function(i) {
        const n = e.value;
        e.value = i, s._convertAttributeValue(e), t.instance.fire("set", e.name, n, e.value);
      },
      configurable: !0
    });
  }
  _updateAccessors(e, t) {
    const s = e.script.scripts.length, i = t.url;
    for (let n = 0; n < s; n++) {
      const a = e.script, o = a.scripts[n];
      if (o.url === i) {
        const h = o.name, l = o.attributes;
        if (h) {
          if (l)
            for (const d in l)
              l.hasOwnProperty(d) && this._createAccessor(l[d], t);
          const c = a.data.attributes[h];
          if (c)
            for (const d in c) {
              const u = c[d];
              d in l ? l[d].value !== u.value && t.instance.onAttributeChanged && t.instance.onAttributeChanged(u.name, u.value, l[d].value) : delete t.instance[u.name];
            }
          l ? a.data.attributes[h] = this._cloneAttributes(l) : delete a.data.attributes[h];
        }
        break;
      }
    }
  }
  _convertAttributeValue(e) {
    if (e.type === "rgb" || e.type === "rgba")
      Array.isArray(e.value) && (e.value = e.value.length === 3 ? new z(e.value[0], e.value[1], e.value[2]) : new z(e.value[0], e.value[1], e.value[2], e.value[3]));
    else if (e.type === "vec2")
      Array.isArray(e.value) && (e.value = new q(e.value[0], e.value[1]));
    else if (e.type === "vec3" || e.type === "vector")
      Array.isArray(e.value) && (e.value = new v(e.value[0], e.value[1], e.value[2]));
    else if (e.type === "vec4")
      Array.isArray(e.value) && (e.value = new Z(e.value[0], e.value[1], e.value[2], e.value[3]));
    else if (e.type === "entity")
      e.value !== null && typeof e.value == "string" && (e.value = this.app.root.findByGuid(e.value));
    else if (e.type === "curve" || e.type === "colorcurve") {
      const t = e.value.keys[0] instanceof Array ? Wi : ms;
      e.value = new t(e.value.keys), e.value.type = e.value.type;
    }
  }
  destroy() {
    super.destroy(), this.app.systems.off(Uc, this.onInitialize, this), this.app.systems.off(Vc, this.onPostInitialize, this), this.app.systems.off(Gc, this.onUpdate, this), this.app.systems.off(Wc, this.onFixedUpdate, this), this.app.systems.off(Hc, this.onPostUpdate, this), this.app.systems.off(qc, this.onToolsUpdate, this);
  }
}
le._buildAccessors(oy.prototype, hy);
const Bi = new q(), xp = new v(), Ps = new od(), _a = new T0(), sE = new ee(), iE = {
  x: "y",
  y: "x"
};
class ly extends _e {
  constructor(e, t) {
    if (super(), !e || !(e instanceof Kl))
      throw new Error("Element was null or not an ElementComponent");
    if (t && t !== "x" && t !== "y")
      throw new Error("Unrecognized axis: " + t);
    this._element = e, this._app = e.system.app, this._axis = t || null, this._enabled = !0, this._dragScale = new v(), this._dragStartMousePosition = new v(), this._dragStartHandlePosition = new v(), this._deltaMousePosition = new v(), this._deltaHandlePosition = new v(), this._isDragging = !1, this._toggleLifecycleListeners("on");
  }
  _toggleLifecycleListeners(e) {
    this._element[e]("mousedown", this._onMouseDownOrTouchStart, this), this._element[e]("touchstart", this._onMouseDownOrTouchStart, this), this._element[e]("selectstart", this._onMouseDownOrTouchStart, this);
  }
  _toggleDragListeners(e) {
    const t = e === "on";
    this._hasDragListeners && t || (this._app.mouse && (this._element[e]("mousemove", this._onMove, this), this._element[e]("mouseup", this._onMouseUpOrTouchEnd, this)), lt.touch && (this._element[e]("touchmove", this._onMove, this), this._element[e]("touchend", this._onMouseUpOrTouchEnd, this), this._element[e]("touchcancel", this._onMouseUpOrTouchEnd, this)), this._element[e]("selectmove", this._onMove, this), this._element[e]("selectend", this._onMouseUpOrTouchEnd, this), this._hasDragListeners = t);
  }
  _onMouseDownOrTouchStart(e) {
    if (this._element && !this._isDragging && this.enabled) {
      this._dragCamera = e.camera, this._calculateDragScale();
      const t = this._screenToLocal(e);
      t && (this._toggleDragListeners("on"), this._isDragging = !0, this._dragStartMousePosition.copy(t), this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition()), this.fire("drag:start"));
    }
  }
  _onMouseUpOrTouchEnd() {
    this._isDragging && (this._isDragging = !1, this._toggleDragListeners("off"), this.fire("drag:end"));
  }
  _screenToLocal(e) {
    e.inputSource ? Ps.set(e.inputSource.getOrigin(), e.inputSource.getDirection()) : (this._determineInputPosition(e), this._chooseRayOriginAndDirection()), _a.point.copy(this._element.entity.getPosition()), _a.normal.copy(this._element.entity.forward).mulScalar(-1);
    const t = _a.normal.dot(Ps.direction);
    if (Math.abs(t) > 0) {
      const i = _a.point.sub(Ps.origin).dot(_a.normal) / t, n = Ps.origin.add(Ps.direction.mulScalar(i));
      return sE.copy(this._element.entity.getRotation()).invert().transformVector(n, n), n.mul(this._dragScale), n;
    }
    return null;
  }
  _determineInputPosition(e) {
    const t = this._app.graphicsDevice.maxPixelRatio;
    typeof e.x < "u" && typeof e.y < "u" ? (Bi.x = e.x * t, Bi.y = e.y * t) : e.changedTouches ? (Bi.x = e.changedTouches[0].x * t, Bi.y = e.changedTouches[0].y * t) : console.warn("Could not determine position from input event");
  }
  _chooseRayOriginAndDirection() {
    this._element.screen && this._element.screen.screen.screenSpace ? (Ps.origin.set(Bi.x, -Bi.y, 0), Ps.direction.copy(v.FORWARD)) : (xp.copy(this._dragCamera.screenToWorld(Bi.x, Bi.y, 1)), Ps.origin.copy(this._dragCamera.entity.getPosition()), Ps.direction.copy(xp).sub(Ps.origin).normalize());
  }
  _calculateDragScale() {
    let e = this._element.entity.parent;
    const t = this._element.screen && this._element.screen.screen, s = t && t.screenSpace, i = s ? t.scale : 1, n = this._dragScale;
    for (n.set(i, i, i); e && (n.mul(e.getLocalScale()), e = e.parent, !(s && e.screen)); )
      ;
    n.x = 1 / n.x, n.y = 1 / n.y, n.z = 0;
  }
  _onMove(e) {
    const {
      _element: t,
      _deltaMousePosition: s,
      _deltaHandlePosition: i,
      _axis: n
    } = this;
    if (t && this._isDragging && this.enabled && t.enabled && t.entity.enabled) {
      const a = this._screenToLocal(e);
      if (a) {
        if (s.sub2(a, this._dragStartMousePosition), i.add2(this._dragStartHandlePosition, s), n) {
          const o = t.entity.getLocalPosition(), h = iE[n];
          i[h] = o[h];
        }
        t.entity.setLocalPosition(i), this.fire("drag:move", i);
      }
    }
  }
  destroy() {
    this._toggleLifecycleListeners("off"), this._toggleDragListeners("off");
  }
  set enabled(e) {
    this._enabled = e;
  }
  get enabled() {
    return this._enabled;
  }
  get isDragging() {
    return this._isDragging;
  }
}
const nE = 0, vp = 1, rE = 2, aE = 0, oE = 1, ga = new q();
class cy extends le {
  constructor(e, t) {
    super(e, t), this._viewportReference = new An(this, "viewportEntity", {
      "element#gain": this._onViewportElementGain,
      "element#resize": this._onSetContentOrViewportSize
    }), this._contentReference = new An(this, "contentEntity", {
      "element#gain": this._onContentElementGain,
      "element#lose": this._onContentElementLose,
      "element#resize": this._onSetContentOrViewportSize
    }), this._scrollbarUpdateFlags = {}, this._scrollbarReferences = {}, this._scrollbarReferences[xe] = new An(this, "horizontalScrollbarEntity", {
      "scrollbar#set:value": this._onSetHorizontalScrollbarValue,
      "scrollbar#gain": this._onHorizontalScrollbarGain
    }), this._scrollbarReferences[Oe] = new An(this, "verticalScrollbarEntity", {
      "scrollbar#set:value": this._onSetVerticalScrollbarValue,
      "scrollbar#gain": this._onVerticalScrollbarGain
    }), this._prevContentSizes = {}, this._prevContentSizes[xe] = null, this._prevContentSizes[Oe] = null, this._scroll = new q(), this._velocity = new v(), this._dragStartPosition = new v(), this._disabledContentInput = !1, this._disabledContentInputEntities = [], this._toggleLifecycleListeners("on", e), this._toggleElementListeners("on");
  }
  _toggleLifecycleListeners(e, t) {
    this[e]("set_horizontal", this._onSetHorizontalScrollingEnabled, this), this[e]("set_vertical", this._onSetVerticalScrollingEnabled, this), t.app.systems.element[e]("add", this._onElementComponentAdd, this), t.app.systems.element[e]("beforeremove", this._onElementComponentRemove, this);
  }
  _toggleElementListeners(e) {
    if (this.entity.element) {
      if (e === "on" && this._hasElementListeners)
        return;
      this.entity.element[e]("resize", this._onSetContentOrViewportSize, this), this.entity.element[e](X_, this._onMouseWheel, this), this._hasElementListeners = e === "on";
    }
  }
  _onElementComponentAdd(e) {
    this.entity === e && this._toggleElementListeners("on");
  }
  _onElementComponentRemove(e) {
    this.entity === e && this._toggleElementListeners("off");
  }
  _onViewportElementGain() {
    this._syncAll();
  }
  _onContentElementGain() {
    this._destroyDragHelper(), this._contentDragHelper = new ly(this._contentReference.entity.element), this._contentDragHelper.on("drag:start", this._onContentDragStart, this), this._contentDragHelper.on("drag:end", this._onContentDragEnd, this), this._contentDragHelper.on("drag:move", this._onContentDragMove, this), this._prevContentSizes[xe] = null, this._prevContentSizes[Oe] = null, this._syncAll();
  }
  _onContentElementLose() {
    this._destroyDragHelper();
  }
  _onContentDragStart() {
    this._contentReference.entity && this.enabled && this.entity.enabled && this._dragStartPosition.copy(this._contentReference.entity.getLocalPosition());
  }
  _onContentDragEnd() {
    this._prevContentDragPosition = null, this._enableContentInput();
  }
  _onContentDragMove(e) {
    if (this._contentReference.entity && this.enabled && this.entity.enabled && (this._wasDragged = !0, this._setScrollFromContentPosition(e), this._setVelocityFromContentPositionDelta(e), !this._disabledContentInput)) {
      const t = e.x - this._dragStartPosition.x, s = e.y - this._dragStartPosition.y;
      (Math.abs(t) > this.dragThreshold || Math.abs(s) > this.dragThreshold) && this._disableContentInput();
    }
  }
  _onSetContentOrViewportSize() {
    this._syncAll();
  }
  _onSetHorizontalScrollbarValue(e) {
    !this._scrollbarUpdateFlags[xe] && this.enabled && this.entity.enabled && this._onSetScroll(e, null);
  }
  _onSetVerticalScrollbarValue(e) {
    !this._scrollbarUpdateFlags[Oe] && this.enabled && this.entity.enabled && this._onSetScroll(null, e);
  }
  _onSetHorizontalScrollingEnabled() {
    this._syncScrollbarEnabledState(xe);
  }
  _onSetVerticalScrollingEnabled() {
    this._syncScrollbarEnabledState(Oe);
  }
  _onHorizontalScrollbarGain() {
    this._syncScrollbarEnabledState(xe), this._syncScrollbarPosition(xe);
  }
  _onVerticalScrollbarGain() {
    this._syncScrollbarEnabledState(Oe), this._syncScrollbarPosition(Oe);
  }
  _onSetScroll(e, t, s) {
    s !== !1 && this._velocity.set(0, 0, 0);
    const i = this._updateAxis(e, "x", xe), n = this._updateAxis(t, "y", Oe);
    (i || n) && this.fire("set:scroll", this._scroll);
  }
  _updateAxis(e, t, s) {
    const i = e !== null && Math.abs(e - this._scroll[t]) > 1e-5;
    return (i || this._isDragging() || e === 0) && (this._scroll[t] = this._determineNewScrollValue(e, t, s), this._syncContentPosition(s), this._syncScrollbarPosition(s)), i;
  }
  _determineNewScrollValue(e, t, s) {
    if (!this._getScrollingEnabled(s))
      return this._scroll[t];
    switch (this.scrollMode) {
      case nE:
        return U.clamp(e, 0, this._getMaxScrollValue(s));
      case vp:
        return this._setVelocityFromOvershoot(e, t, s), e;
      case rE:
        return e;
      default:
        return console.warn("Unhandled scroll mode:" + this.scrollMode), e;
    }
  }
  _syncAll() {
    this._syncContentPosition(xe), this._syncContentPosition(Oe), this._syncScrollbarPosition(xe), this._syncScrollbarPosition(Oe), this._syncScrollbarEnabledState(xe), this._syncScrollbarEnabledState(Oe);
  }
  _syncContentPosition(e) {
    const t = this._getAxis(e), s = this._getSign(e), i = this._contentReference.entity;
    if (i) {
      const n = this._prevContentSizes[e], a = this._getContentSize(e);
      if (n !== null && Math.abs(n - a) > 1e-4) {
        const l = this._getMaxOffset(e, n), c = this._getMaxOffset(e, a);
        c === 0 ? this._scroll[t] = 1 : this._scroll[t] = U.clamp(this._scroll[t] * l / c, 0, 1);
      }
      const o = this._scroll[t] * this._getMaxOffset(e), h = i.getLocalPosition();
      h[t] = o * s, i.setLocalPosition(h), this._prevContentSizes[e] = a;
    }
  }
  _syncScrollbarPosition(e) {
    const t = this._getAxis(e), s = this._scrollbarReferences[e].entity;
    s && s.scrollbar && (this._scrollbarUpdateFlags[e] = !0, s.scrollbar.value = this._scroll[t], s.scrollbar.handleSize = this._getScrollbarHandleSize(t, e), this._scrollbarUpdateFlags[e] = !1);
  }
  _syncScrollbarEnabledState(e) {
    const t = this._scrollbarReferences[e].entity;
    if (t) {
      const s = this._getScrollingEnabled(e), i = this._getScrollbarVisibility(e);
      switch (i) {
        case aE:
          t.enabled = s;
          return;
        case oE:
          t.enabled = s && this._contentIsLargerThanViewport(e);
          return;
        default:
          console.warn("Unhandled scrollbar visibility:" + i), t.enabled = s;
      }
    }
  }
  _contentIsLargerThanViewport(e) {
    return this._getContentSize(e) > this._getViewportSize(e);
  }
  _contentPositionToScrollValue(e) {
    const t = this._getMaxOffset(xe), s = this._getMaxOffset(Oe);
    return t === 0 ? ga.x = 0 : ga.x = e.x / t, s === 0 ? ga.y = 0 : ga.y = e.y / -s, ga;
  }
  _getMaxOffset(e, t) {
    t = t === void 0 ? this._getContentSize(e) : t;
    const s = this._getViewportSize(e);
    return t < s ? -this._getViewportSize(e) : s - t;
  }
  _getMaxScrollValue(e) {
    return this._contentIsLargerThanViewport(e) ? 1 : 0;
  }
  _getScrollbarHandleSize(e, t) {
    const s = this._getViewportSize(t), i = this._getContentSize(t);
    if (Math.abs(i) < 1e-3)
      return 1;
    const n = Math.min(s / i, 1), a = this._toOvershoot(this._scroll[e], t);
    return a === 0 ? n : n / (1 + Math.abs(a));
  }
  _getViewportSize(e) {
    return this._getSize(e, this._viewportReference);
  }
  _getContentSize(e) {
    return this._getSize(e, this._contentReference);
  }
  _getSize(e, t) {
    return t.entity && t.entity.element ? t.entity.element[this._getCalculatedDimension(e)] : 0;
  }
  _getScrollingEnabled(e) {
    if (e === xe)
      return this.horizontal;
    if (e === Oe)
      return this.vertical;
  }
  _getScrollbarVisibility(e) {
    if (e === xe)
      return this.horizontalScrollbarVisibility;
    if (e === Oe)
      return this.verticalScrollbarVisibility;
  }
  _getSign(e) {
    return e === xe ? 1 : -1;
  }
  _getAxis(e) {
    return e === xe ? "x" : "y";
  }
  _getCalculatedDimension(e) {
    return e === xe ? "calculatedWidth" : "calculatedHeight";
  }
  _destroyDragHelper() {
    this._contentDragHelper && this._contentDragHelper.destroy();
  }
  onUpdate() {
    this._contentReference.entity && (this._updateVelocity(), this._syncScrollbarEnabledState(xe), this._syncScrollbarEnabledState(Oe));
  }
  _updateVelocity() {
    if (!this._isDragging()) {
      if (this.scrollMode === vp && (this._hasOvershoot("x", xe) && this._setVelocityFromOvershoot(this.scroll.x, "x", xe), this._hasOvershoot("y", Oe) && this._setVelocityFromOvershoot(this.scroll.y, "y", Oe)), Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
        const e = this._contentReference.entity.getLocalPosition();
        e.x += this._velocity.x, e.y += this._velocity.y, this._contentReference.entity.setLocalPosition(e), this._setScrollFromContentPosition(e);
      }
      this._velocity.x *= 1 - this.friction, this._velocity.y *= 1 - this.friction;
    }
  }
  _hasOvershoot(e, t) {
    return Math.abs(this._toOvershoot(this.scroll[e], t)) > 1e-3;
  }
  _toOvershoot(e, t) {
    const s = this._getMaxScrollValue(t);
    return e < 0 ? e : e > s ? e - s : 0;
  }
  _setVelocityFromOvershoot(e, t, s) {
    const n = this._toOvershoot(e, s) * this._getMaxOffset(s) * this._getSign(s);
    Math.abs(n) > 0 && (this._velocity[t] = -n / (this.bounceAmount * 50 + 1));
  }
  _setVelocityFromContentPositionDelta(e) {
    this._prevContentDragPosition ? (this._velocity.sub2(e, this._prevContentDragPosition), this._prevContentDragPosition.copy(e)) : (this._velocity.set(0, 0, 0), this._prevContentDragPosition = e.clone());
  }
  _setScrollFromContentPosition(e) {
    let t = this._contentPositionToScrollValue(e);
    this._isDragging() && (t = this._applyScrollValueTension(t)), this._onSetScroll(t.x, t.y, !1);
  }
  _applyScrollValueTension(e) {
    let s = this._getMaxScrollValue(xe), i = this._toOvershoot(e.x, xe);
    return i > 0 ? e.x = s + 1 * Math.log10(1 + i) : i < 0 && (e.x = -1 * Math.log10(1 - i)), s = this._getMaxScrollValue(Oe), i = this._toOvershoot(e.y, Oe), i > 0 ? e.y = s + 1 * Math.log10(1 + i) : i < 0 && (e.y = -1 * Math.log10(1 - i)), e;
  }
  _isDragging() {
    return this._contentDragHelper && this._contentDragHelper.isDragging;
  }
  _setScrollbarComponentsEnabled(e) {
    this._scrollbarReferences[xe].hasComponent("scrollbar") && (this._scrollbarReferences[xe].entity.scrollbar.enabled = e), this._scrollbarReferences[Oe].hasComponent("scrollbar") && (this._scrollbarReferences[Oe].entity.scrollbar.enabled = e);
  }
  _setContentDraggingEnabled(e) {
    this._contentDragHelper && (this._contentDragHelper.enabled = e);
  }
  _onMouseWheel(e) {
    if (this.useMouseWheel) {
      const t = e.event, s = t.deltaX / this._contentReference.entity.element.calculatedWidth * this.mouseWheelSensitivity.x, i = t.deltaY / this._contentReference.entity.element.calculatedHeight * this.mouseWheelSensitivity.y, n = U.clamp(this._scroll.x + s, 0, this._getMaxScrollValue(xe)), a = U.clamp(this._scroll.y + i, 0, this._getMaxScrollValue(Oe));
      this.scroll = new q(n, a);
    }
  }
  _enableContentInput() {
    for (; this._disabledContentInputEntities.length; ) {
      const e = this._disabledContentInputEntities.pop();
      e.element && (e.element.useInput = !0);
    }
    this._disabledContentInput = !1;
  }
  _disableContentInput() {
    const e = (s) => {
      s.element && s.element.useInput && (this._disabledContentInputEntities.push(s), s.element.useInput = !1);
      const i = s.children;
      for (let n = 0, a = i.length; n < a; n++)
        e(i[n]);
    }, t = this._contentReference.entity;
    if (t) {
      const s = t.children;
      for (let i = 0, n = s.length; i < n; i++)
        e(s[i]);
    }
    this._disabledContentInput = !0;
  }
  onEnable() {
    this._viewportReference.onParentComponentEnable(), this._contentReference.onParentComponentEnable(), this._scrollbarReferences[xe].onParentComponentEnable(), this._scrollbarReferences[Oe].onParentComponentEnable(), this._setScrollbarComponentsEnabled(!0), this._setContentDraggingEnabled(!0), this._syncAll();
  }
  onDisable() {
    this._setScrollbarComponentsEnabled(!1), this._setContentDraggingEnabled(!1);
  }
  onRemove() {
    this._toggleLifecycleListeners("off", this.system), this._toggleElementListeners("off"), this._destroyDragHelper();
  }
  set scroll(e) {
    this._onSetScroll(e.x, e.y);
  }
  get scroll() {
    return this._scroll;
  }
}
class hE {
  constructor() {
    this.enabled = !0;
  }
}
const tu = [{
  name: "enabled",
  type: "boolean"
}, {
  name: "horizontal",
  type: "boolean"
}, {
  name: "vertical",
  type: "boolean"
}, {
  name: "scrollMode",
  type: "number"
}, {
  name: "bounceAmount",
  type: "number"
}, {
  name: "friction",
  type: "number"
}, {
  name: "dragThreshold",
  type: "number"
}, {
  name: "useMouseWheel",
  type: "boolean"
}, {
  name: "mouseWheelSensitivity",
  type: "vec2"
}, {
  name: "horizontalScrollbarVisibility",
  type: "number"
}, {
  name: "verticalScrollbarVisibility",
  type: "number"
}, {
  name: "viewportEntity",
  type: "entity"
}, {
  name: "contentEntity",
  type: "entity"
}, {
  name: "horizontalScrollbarEntity",
  type: "entity"
}, {
  name: "verticalScrollbarEntity",
  type: "entity"
}], lE = 10;
class cE extends Ye {
  constructor(e) {
    super(e), this.id = "scrollview", this.ComponentType = cy, this.DataType = hE, this.schema = tu, this.on("beforeremove", this._onRemoveComponent, this), this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    t.dragThreshold === void 0 && (t.dragThreshold = lE), t.useMouseWheel === void 0 && (t.useMouseWheel = !0), t.mouseWheelSensitivity === void 0 && (t.mouseWheelSensitivity = new q(1, 1)), super.initializeComponentData(e, t, tu);
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t) {
      const i = t[s].entity, n = i.scrollview;
      n.enabled && i.enabled && n.onUpdate();
    }
  }
  _onRemoveComponent(e, t) {
    t.onRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(cy.prototype, tu);
class dy extends le {
  constructor(e, t) {
    super(e, t), this._handleReference = new An(this, "handleEntity", {
      "element#gain": this._onHandleElementGain,
      "element#lose": this._onHandleElementLose,
      "element#set:anchor": this._onSetHandleAlignment,
      "element#set:margin": this._onSetHandleAlignment,
      "element#set:pivot": this._onSetHandleAlignment
    }), this._toggleLifecycleListeners("on");
  }
  _toggleLifecycleListeners(e) {
    this[e]("set_value", this._onSetValue, this), this[e]("set_handleSize", this._onSetHandleSize, this), this[e]("set_orientation", this._onSetOrientation, this);
  }
  _onHandleElementGain() {
    this._destroyDragHelper(), this._handleDragHelper = new ly(this._handleReference.entity.element, this._getAxis()), this._handleDragHelper.on("drag:move", this._onHandleDrag, this), this._updateHandlePositionAndSize();
  }
  _onHandleElementLose() {
    this._destroyDragHelper();
  }
  _onHandleDrag(e) {
    this._handleReference.entity && this.enabled && this.entity.enabled && (this.value = this._handlePositionToScrollValue(e[this._getAxis()]));
  }
  _onSetValue(e, t, s) {
    Math.abs(s - t) > 1e-5 && (this.data.value = U.clamp(s, 0, 1), this._updateHandlePositionAndSize(), this.fire("set:value", this.data.value));
  }
  _onSetHandleSize(e, t, s) {
    Math.abs(s - t) > 1e-5 && (this.data.handleSize = U.clamp(s, 0, 1), this._updateHandlePositionAndSize());
  }
  _onSetHandleAlignment() {
    this._updateHandlePositionAndSize();
  }
  _onSetOrientation(e, t, s) {
    s !== t && this._handleReference.hasComponent("element") && (this._handleReference.entity.element[this._getOppositeDimension()] = 0);
  }
  _updateHandlePositionAndSize() {
    const e = this._handleReference.entity, t = e && e.element;
    if (e) {
      const s = e.getLocalPosition();
      s[this._getAxis()] = this._getHandlePosition(), this._handleReference.entity.setLocalPosition(s);
    }
    t && (t[this._getDimension()] = this._getHandleLength());
  }
  _handlePositionToScrollValue(e) {
    return e * this._getSign() / this._getUsableTrackLength();
  }
  _scrollValueToHandlePosition(e) {
    return e * this._getSign() * this._getUsableTrackLength();
  }
  _getUsableTrackLength() {
    return Math.max(this._getTrackLength() - this._getHandleLength(), 1e-3);
  }
  _getTrackLength() {
    return this.entity.element ? this.orientation === xe ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight : 0;
  }
  _getHandleLength() {
    return this._getTrackLength() * this.handleSize;
  }
  _getHandlePosition() {
    return this._scrollValueToHandlePosition(this.value);
  }
  _getSign() {
    return this.orientation === xe ? 1 : -1;
  }
  _getAxis() {
    return this.orientation === xe ? "x" : "y";
  }
  _getDimension() {
    return this.orientation === xe ? "width" : "height";
  }
  _getOppositeDimension() {
    return this.orientation === xe ? "height" : "width";
  }
  _destroyDragHelper() {
    this._handleDragHelper && this._handleDragHelper.destroy();
  }
  _setHandleDraggingEnabled(e) {
    this._handleDragHelper && (this._handleDragHelper.enabled = e);
  }
  onEnable() {
    this._handleReference.onParentComponentEnable(), this._setHandleDraggingEnabled(!0);
  }
  onDisable() {
    this._setHandleDraggingEnabled(!1);
  }
  onRemove() {
    this._destroyDragHelper(), this._toggleLifecycleListeners("off");
  }
}
class dE {
  constructor() {
    this.enabled = !0;
  }
}
const su = [{
  name: "enabled",
  type: "boolean"
}, {
  name: "orientation",
  type: "number"
}, {
  name: "value",
  type: "number"
}, {
  name: "handleSize",
  type: "number"
}, {
  name: "handleEntity",
  type: "entity"
}];
class uE extends Ye {
  constructor(e) {
    super(e), this.id = "scrollbar", this.ComponentType = dy, this.DataType = dE, this.schema = su, this.on("beforeremove", this._onRemoveComponent, this);
  }
  initializeComponentData(e, t, s) {
    super.initializeComponentData(e, t, su);
  }
  _onRemoveComponent(e, t) {
    t.onRemove();
  }
}
le._buildAccessors(dy.prototype, su);
const fE = {
  volume: 0,
  pitch: 0,
  loop: !1,
  startTime: 0,
  duration: 0,
  position: new v(),
  maxDistance: 0,
  refDistance: 0,
  rollOffFactor: 0,
  distanceModel: 0,
  onPlay: null,
  onPause: null,
  onResume: null,
  onStop: null,
  onEnd: null
};
class Xc extends _e {
  constructor(e, t = "Untitled", s = {}) {
    super(), this.name = void 0, this.instances = [], this._component = e, this._assets = e.system.app.assets, this._manager = e.system.manager, this.name = t, this._volume = s.volume !== void 0 ? U.clamp(Number(s.volume) || 0, 0, 1) : 1, this._pitch = s.pitch !== void 0 ? Math.max(0.01, Number(s.pitch) || 0) : 1, this._loop = !!(s.loop !== void 0 && s.loop), this._duration = s.duration > 0 ? s.duration : null, this._startTime = Math.max(0, Number(s.startTime) || 0), this._overlap = !!s.overlap, this._autoPlay = !!s.autoPlay, this._firstNode = null, this._lastNode = null, this._asset = s.asset, this._asset instanceof ce && (this._asset = this._asset.id), this._onInstancePlayHandler = this._onInstancePlay.bind(this), this._onInstancePauseHandler = this._onInstancePause.bind(this), this._onInstanceResumeHandler = this._onInstanceResume.bind(this), this._onInstanceStopHandler = this._onInstanceStop.bind(this), this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
  }
  play() {
    if (this.overlap || this.stop(), !this.isLoaded && !this._hasAsset())
      return;
    const e = this._createInstance();
    if (this.instances.push(e), this.isLoaded)
      e.play();
    else {
      const t = function(i) {
        const n = e._playWhenLoaded;
        e.sound = i, n && e.play();
      };
      this.off("load", t), this.once("load", t), this.load();
    }
    return e;
  }
  pause() {
    let e = !1;
    const t = this.instances;
    for (let s = 0, i = t.length; s < i; s++)
      t[s].pause() && (e = !0);
    return e;
  }
  resume() {
    let e = !1;
    const t = this.instances;
    for (let s = 0, i = t.length; s < i; s++)
      t[s].resume() && (e = !0);
    return e;
  }
  stop() {
    let e = !1;
    const t = this.instances;
    let s = t.length;
    for (; s--; )
      t[s].stop(), e = !0;
    return t.length = 0, e;
  }
  load() {
    if (!this._hasAsset())
      return;
    const e = this._assets.get(this._asset);
    if (!e) {
      this._assets.off("add:" + this._asset, this._onAssetAdd, this), this._assets.once("add:" + this._asset, this._onAssetAdd, this);
      return;
    }
    if (e.off("remove", this._onAssetRemoved, this), e.on("remove", this._onAssetRemoved, this), !e.resource) {
      e.off("load", this._onAssetLoad, this), e.once("load", this._onAssetLoad, this), this._assets.load(e);
      return;
    }
    this.fire("load", e.resource);
  }
  setExternalNodes(e, t) {
    if (!e) {
      console.error("The firstNode must have a valid AudioNode");
      return;
    }
    if (t || (t = e), this._firstNode = e, this._lastNode = t, !this._overlap) {
      const s = this.instances;
      for (let i = 0, n = s.length; i < n; i++)
        s[i].setExternalNodes(e, t);
    }
  }
  clearExternalNodes() {
    if (this._firstNode = null, this._lastNode = null, !this._overlap) {
      const e = this.instances;
      for (let t = 0, s = e.length; t < s; t++)
        e[t].clearExternalNodes();
    }
  }
  getExternalNodes() {
    return [this._firstNode, this._lastNode];
  }
  _hasAsset() {
    return this._asset != null;
  }
  _createInstance() {
    let e = null;
    const t = this._component;
    let s = null;
    if (this._hasAsset()) {
      const n = this._assets.get(this._asset);
      n && (s = n.resource);
    }
    const i = fE;
    return i.volume = this._volume * t.volume, i.pitch = this._pitch * t.pitch, i.loop = this._loop, i.startTime = this._startTime, i.duration = this._duration, i.onPlay = this._onInstancePlayHandler, i.onPause = this._onInstancePauseHandler, i.onResume = this._onInstanceResumeHandler, i.onStop = this._onInstanceStopHandler, i.onEnd = this._onInstanceEndHandler, t.positional ? (i.position.copy(t.entity.getPosition()), i.maxDistance = t.maxDistance, i.refDistance = t.refDistance, i.rollOffFactor = t.rollOffFactor, i.distanceModel = t.distanceModel, e = new fr(this._manager, s, i)) : e = new xn(this._manager, s, i), this._firstNode && e.setExternalNodes(this._firstNode, this._lastNode), e;
  }
  _onInstancePlay(e) {
    this.fire("play", e), this._component.fire("play", this, e);
  }
  _onInstancePause(e) {
    this.fire("pause", e), this._component.fire("pause", this, e);
  }
  _onInstanceResume(e) {
    this.fire("resume", e), this._component.fire("resume", this, e);
  }
  _onInstanceStop(e) {
    const t = this.instances.indexOf(e);
    t !== -1 && this.instances.splice(t, 1), this.fire("stop", e), this._component.fire("stop", this, e);
  }
  _onInstanceEnd(e) {
    const t = this.instances.indexOf(e);
    t !== -1 && this.instances.splice(t, 1), this.fire("end", e), this._component.fire("end", this, e);
  }
  _onAssetAdd(e) {
    this.load();
  }
  _onAssetLoad(e) {
    this.load();
  }
  _onAssetRemoved(e) {
    e.off("remove", this._onAssetRemoved, this), this._assets.off("add:" + e.id, this._onAssetAdd, this), this.stop();
  }
  updatePosition(e) {
    const t = this.instances;
    for (let s = 0, i = t.length; s < i; s++)
      t[s].position = e;
  }
  set asset(e) {
    const t = this._asset;
    if (t) {
      this._assets.off("add:" + t, this._onAssetAdd, this);
      const s = this._assets.get(t);
      s && s.off("remove", this._onAssetRemoved, this);
    }
    this._asset = e, this._asset instanceof ce && (this._asset = this._asset.id), this._hasAsset() && this._component.enabled && this._component.entity.enabled && this.load();
  }
  get asset() {
    return this._asset;
  }
  set autoPlay(e) {
    this._autoPlay = !!e;
  }
  get autoPlay() {
    return this._autoPlay;
  }
  set duration(e) {
    if (this._duration = Math.max(0, Number(e) || 0) || null, !this._overlap) {
      const t = this.instances;
      for (let s = 0, i = t.length; s < i; s++)
        t[s].duration = this._duration;
    }
  }
  get duration() {
    let e = 0;
    if (this._hasAsset()) {
      const t = this._assets.get(this._asset);
      e = t != null && t.resource ? t.resource.duration : 0;
    }
    return this._duration != null ? this._duration % (e || 1) : e;
  }
  get isLoaded() {
    if (this._hasAsset()) {
      const e = this._assets.get(this._asset);
      if (e)
        return !!e.resource;
    }
    return !1;
  }
  get isPaused() {
    const e = this.instances, t = e.length;
    if (t === 0)
      return !1;
    for (let s = 0; s < t; s++)
      if (!e[s].isPaused)
        return !1;
    return !0;
  }
  get isPlaying() {
    const e = this.instances;
    for (let t = 0, s = e.length; t < s; t++)
      if (e[t].isPlaying)
        return !0;
    return !1;
  }
  get isStopped() {
    const e = this.instances;
    for (let t = 0, s = e.length; t < s; t++)
      if (!e[t].isStopped)
        return !1;
    return !0;
  }
  set loop(e) {
    this._loop = !!e;
    const t = this.instances;
    for (let s = 0, i = t.length; s < i; s++)
      t[s].loop = this._loop;
  }
  get loop() {
    return this._loop;
  }
  set overlap(e) {
    this._overlap = !!e;
  }
  get overlap() {
    return this._overlap;
  }
  set pitch(e) {
    if (this._pitch = Math.max(Number(e) || 0, 0.01), !this._overlap) {
      const t = this.instances;
      for (let s = 0, i = t.length; s < i; s++)
        t[s].pitch = this.pitch * this._component.pitch;
    }
  }
  get pitch() {
    return this._pitch;
  }
  set startTime(e) {
    if (this._startTime = Math.max(0, Number(e) || 0), !this._overlap) {
      const t = this.instances;
      for (let s = 0, i = t.length; s < i; s++)
        t[s].startTime = this._startTime;
    }
  }
  get startTime() {
    return this._startTime;
  }
  set volume(e) {
    if (this._volume = U.clamp(Number(e) || 0, 0, 1), !this._overlap) {
      const t = this.instances;
      for (let s = 0, i = t.length; s < i; s++)
        t[s].volume = this._volume * this._component.volume;
    }
  }
  get volume() {
    return this._volume;
  }
}
class uy extends le {
  constructor(e, t) {
    super(e, t), this._volume = 1, this._pitch = 1, this._positional = !0, this._refDistance = 1, this._maxDistance = 1e4, this._rollOffFactor = 1, this._distanceModel = _l, this._slots = {}, this._playingBeforeDisable = {};
  }
  _updateSoundInstances(e, t, s) {
    const i = this._slots;
    for (const n in i) {
      const a = i[n];
      if (!a.overlap) {
        const o = a.instances;
        for (let h = 0, l = o.length; h < l; h++)
          o[h][e] = s ? a[e] * t : t;
      }
    }
  }
  set distanceModel(e) {
    this._distanceModel = e, this._updateSoundInstances("distanceModel", e, !1);
  }
  get distanceModel() {
    return this._distanceModel;
  }
  set maxDistance(e) {
    this._maxDistance = e, this._updateSoundInstances("maxDistance", e, !1);
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set refDistance(e) {
    this._refDistance = e, this._updateSoundInstances("refDistance", e, !1);
  }
  get refDistance() {
    return this._refDistance;
  }
  set rollOffFactor(e) {
    this._rollOffFactor = e, this._updateSoundInstances("rollOffFactor", e, !1);
  }
  get rollOffFactor() {
    return this._rollOffFactor;
  }
  set pitch(e) {
    this._pitch = e, this._updateSoundInstances("pitch", e, !0);
  }
  get pitch() {
    return this._pitch;
  }
  set volume(e) {
    this._volume = e, this._updateSoundInstances("volume", e, !0);
  }
  get volume() {
    return this._volume;
  }
  set positional(e) {
    this._positional = e;
    const t = this._slots;
    for (const s in t) {
      const i = t[s];
      if (!i.overlap) {
        const n = i.instances, a = n.length;
        for (let o = a - 1; o >= 0; o--) {
          const h = n[o].isPlaying || n[o].isSuspended, l = n[o].currentTime;
          h && n[o].stop();
          const c = i._createInstance();
          h && (c.play(), c.currentTime = l), n.push(c);
        }
      }
    }
  }
  get positional() {
    return this._positional;
  }
  set slots(e) {
    const t = this._slots;
    if (t)
      for (const i in t)
        t[i].stop();
    const s = {};
    for (const i in e)
      e[i] instanceof Xc ? s[e[i].name] = e[i] : e[i].name && (s[e[i].name] = new Xc(this, e[i].name, e[i]));
    this._slots = s, this.enabled && this.entity.enabled && this.onEnable();
  }
  get slots() {
    return this._slots;
  }
  onEnable() {
    if (this.system._inTools)
      return;
    const e = this._slots, t = this._playingBeforeDisable;
    for (const s in e) {
      const i = e[s];
      i.autoPlay && i.isStopped ? i.play() : t[s] ? i.resume() : i.isLoaded || i.load();
    }
  }
  onDisable() {
    const e = this._slots, t = {};
    for (const s in e)
      e[s].overlap || e[s].isPlaying && (e[s].pause(), t[s] = !0);
    this._playingBeforeDisable = t;
  }
  onRemove() {
    this.off();
  }
  addSlot(e, t) {
    const s = this._slots;
    if (s[e])
      return null;
    const i = new Xc(this, e, t);
    return s[e] = i, i.autoPlay && this.enabled && this.entity.enabled && i.play(), i;
  }
  removeSlot(e) {
    const t = this._slots;
    t[e] && (t[e].stop(), delete t[e]);
  }
  slot(e) {
    return this._slots[e];
  }
  play(e) {
    if (!this.enabled || !this.entity.enabled)
      return null;
    const t = this._slots[e];
    return t ? t.play() : null;
  }
  pause(e) {
    const t = this._slots;
    if (e) {
      const s = t[e];
      if (!s)
        return;
      s.pause();
    } else
      for (const s in t)
        t[s].pause();
  }
  resume(e) {
    const t = this._slots;
    if (e) {
      const s = t[e];
      if (!s)
        return;
      s.isPaused && s.resume();
    } else
      for (const s in t)
        t[s].resume();
  }
  stop(e) {
    const t = this._slots;
    if (e) {
      const s = t[e];
      if (!s)
        return;
      s.stop();
    } else
      for (const s in t)
        t[s].stop();
  }
}
class mE {
  constructor() {
    this.enabled = !0;
  }
}
const fy = ["enabled"];
class pE extends Ye {
  constructor(e) {
    super(e), this.id = "sound", this.ComponentType = uy, this.DataType = mE, this.schema = fy, this.manager = e.soundManager, this.app.systems.on("update", this.onUpdate, this), this.on("beforeremove", this.onBeforeRemove, this);
  }
  set volume(e) {
    this.manager.volume = e;
  }
  get volume() {
    return this.manager.volume;
  }
  get context() {
    return bi() ? this.manager.context : null;
  }
  initializeComponentData(e, t, s) {
    s = ["volume", "pitch", "positional", "refDistance", "maxDistance", "rollOffFactor", "distanceModel", "slots"];
    for (let i = 0; i < s.length; i++)
      t.hasOwnProperty(s[i]) && (e[s[i]] = t[s[i]]);
    super.initializeComponentData(e, t, ["enabled"]);
  }
  cloneComponent(e, t) {
    const s = e.sound, i = s.slots, n = {};
    for (const o in i) {
      const h = i[o];
      n[o] = {
        name: h.name,
        volume: h.volume,
        pitch: h.pitch,
        loop: h.loop,
        duration: h.duration,
        startTime: h.startTime,
        overlap: h.overlap,
        autoPlay: h.autoPlay,
        asset: h.asset
      };
    }
    const a = {
      distanceModel: s.distanceModel,
      enabled: s.enabled,
      maxDistance: s.maxDistance,
      pitch: s.pitch,
      positional: s.positional,
      refDistance: s.refDistance,
      rollOffFactor: s.rollOffFactor,
      slots: n,
      volume: s.volume
    };
    return this.addComponent(t, a);
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const n = t[s].entity;
        if (n.enabled) {
          const a = n.sound;
          if (a.enabled && a.positional) {
            const o = n.getPosition(), h = a.slots;
            for (const l in h)
              h[l].updatePosition(o);
          }
        }
      }
  }
  onBeforeRemove(e, t) {
    const s = t.slots;
    for (const i in s)
      s[i].overlap || s[i].stop();
    t.onRemove();
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(uy.prototype, fy);
const Sp = "simple", bp = "animated";
class jc extends _e {
  constructor(e, t) {
    super(), this._component = e, this._frame = 0, this._sprite = null, this._spriteAsset = null, this.spriteAsset = t.spriteAsset, this.name = t.name, this.fps = t.fps || 0, this.loop = t.loop || !1, this._playing = !1, this._paused = !1, this._time = 0;
  }
  get duration() {
    if (this._sprite) {
      const e = this.fps || Number.MIN_VALUE;
      return this._sprite.frameKeys.length / Math.abs(e);
    }
    return 0;
  }
  set frame(e) {
    this._setFrame(e);
    const t = this.fps || Number.MIN_VALUE;
    this._setTime(this._frame / t);
  }
  get frame() {
    return this._frame;
  }
  get isPaused() {
    return this._paused;
  }
  get isPlaying() {
    return this._playing;
  }
  set sprite(e) {
    if (this._sprite && (this._sprite.off("set:meshes", this._onSpriteMeshesChange, this), this._sprite.off("set:pixelsPerUnit", this._onSpritePpuChanged, this), this._sprite.off("set:atlas", this._onSpriteMeshesChange, this), this._sprite.atlas && this._sprite.atlas.off("set:texture", this._onSpriteMeshesChange, this)), this._sprite = e, this._sprite && (this._sprite.on("set:meshes", this._onSpriteMeshesChange, this), this._sprite.on("set:pixelsPerUnit", this._onSpritePpuChanged, this), this._sprite.on("set:atlas", this._onSpriteMeshesChange, this), this._sprite.atlas && this._sprite.atlas.on("set:texture", this._onSpriteMeshesChange, this)), this._component.currentClip === this) {
      let t;
      !e || !e.atlas ? (t = this._component._meshInstance, t && (t.deleteParameter("texture_emissiveMap"), t.deleteParameter("texture_opacityMap")), this._component._hideModel()) : (e.atlas.texture && (t = this._component._meshInstance, t && (t.setParameter("texture_emissiveMap", e.atlas.texture), t.setParameter("texture_opacityMap", e.atlas.texture)), this._component.enabled && this._component.entity.enabled && this._component._showModel()), this.time && this.fps ? this.time = this.time : this.frame = this.frame);
    }
  }
  get sprite() {
    return this._sprite;
  }
  set spriteAsset(e) {
    const t = this._component.system.app.assets;
    let s = e;
    if (e instanceof ce && (s = e.id), this._spriteAsset !== s) {
      if (this._spriteAsset) {
        const i = t.get(this._spriteAsset);
        i && this._unbindSpriteAsset(i);
      }
      if (this._spriteAsset = s, this._spriteAsset) {
        const i = t.get(this._spriteAsset);
        i ? this._bindSpriteAsset(i) : (this.sprite = null, t.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this));
      } else
        this.sprite = null;
    }
  }
  get spriteAsset() {
    return this._spriteAsset;
  }
  set time(e) {
    this._setTime(e), this._sprite ? this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps))) : this.frame = 0;
  }
  get time() {
    return this._time;
  }
  _onSpriteAssetAdded(e) {
    this._component.system.app.assets.off("add:" + e.id, this._onSpriteAssetAdded, this), this._spriteAsset === e.id && this._bindSpriteAsset(e);
  }
  _bindSpriteAsset(e) {
    e.on("load", this._onSpriteAssetLoad, this), e.on("remove", this._onSpriteAssetRemove, this), e.resource ? this._onSpriteAssetLoad(e) : this._component.system.app.assets.load(e);
  }
  _unbindSpriteAsset(e) {
    e.off("load", this._onSpriteAssetLoad, this), e.off("remove", this._onSpriteAssetRemove, this), e.resource && e.resource.atlas && this._component.system.app.assets.off("load:" + e.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
  }
  _onSpriteAssetLoad(e) {
    if (!e.resource)
      this.sprite = null;
    else if (e.resource.atlas)
      this.sprite = e.resource;
    else {
      const t = e.data.textureAtlasAsset, s = this._component.system.app.assets;
      s.off("load:" + t, this._onTextureAtlasLoad, this), s.once("load:" + t, this._onTextureAtlasLoad, this);
    }
  }
  _onTextureAtlasLoad(e) {
    const t = this._spriteAsset;
    t instanceof ce ? this._onSpriteAssetLoad(t) : this._onSpriteAssetLoad(this._component.system.app.assets.get(t));
  }
  _onSpriteAssetRemove(e) {
    this.sprite = null;
  }
  _onSpriteMeshesChange() {
    this._component.currentClip === this && this._component._showFrame(this.frame);
  }
  _onSpritePpuChanged() {
    this._component.currentClip === this && this.sprite.renderMode !== Ni && this._component._showFrame(this.frame);
  }
  _update(e) {
    if (this.fps === 0 || !this._playing || this._paused || !this._sprite)
      return;
    const t = this.fps < 0 ? -1 : 1, s = this._time + e * this._component.speed * t, i = this.duration, n = s > i || s < 0;
    this._setTime(s);
    let a = this.frame;
    this._sprite ? a = Math.floor(this._sprite.frameKeys.length * this._time / i) : a = 0, a !== this._frame && this._setFrame(a), n && (this.loop ? (this.fire("loop"), this._component.fire("loop", this)) : (this._playing = !1, this._paused = !1, this.fire("end"), this._component.fire("end", this)));
  }
  _setTime(e) {
    this._time = e;
    const t = this.duration;
    this._time < 0 ? this.loop ? this._time = this._time % t + t : this._time = 0 : this._time > t && (this.loop ? this._time %= t : this._time = t);
  }
  _setFrame(e) {
    this._sprite ? this._frame = U.clamp(e, 0, this._sprite.frameKeys.length - 1) : this._frame = e, this._component.currentClip === this && this._component._showFrame(this._frame);
  }
  _destroy() {
    this._sprite && (this.sprite = null), this._spriteAsset && (this.spriteAsset = null);
  }
  play() {
    this._playing || (this._playing = !0, this._paused = !1, this.frame = 0, this.fire("play"), this._component.fire("play", this));
  }
  pause() {
    !this._playing || this._paused || (this._paused = !0, this.fire("pause"), this._component.fire("pause", this));
  }
  resume() {
    this._paused && (this._paused = !1, this.fire("resume"), this._component.fire("resume", this));
  }
  stop() {
    this._playing && (this._playing = !1, this._paused = !1, this._time = 0, this.frame = 0, this.fire("stop"), this._component.fire("stop", this));
  }
}
const wp = "texture_emissiveMap", Tp = "texture_opacityMap", Cp = "material_emissive", Ap = "material_opacity", _E = "innerOffset", gE = "outerScale", yE = "atlasRect";
class my extends le {
  constructor(e, t) {
    super(e, t), this._type = Sp, this._material = e.defaultMaterial, this._color = new z(1, 1, 1, 1), this._colorUniform = new Float32Array(3), this._speed = 1, this._flipX = !1, this._flipY = !1, this._width = 1, this._height = 1, this._drawOrder = 0, this._layers = [wi], this._outerScale = new q(1, 1), this._outerScaleUniform = new Float32Array(2), this._innerOffset = new Z(), this._innerOffsetUniform = new Float32Array(4), this._atlasRect = new Z(), this._atlasRectUniform = new Float32Array(4), this._batchGroupId = -1, this._batchGroup = null, this._node = new bt(), this._model = new Ti(), this._model.graph = this._node, this._meshInstance = null, t.addChild(this._model.graph), this._model._entity = t, this._updateAabbFunc = this._updateAabb.bind(this), this._addedModel = !1, this._autoPlayClip = null, this._clips = {}, this._defaultClip = new jc(this, {
      name: this.entity.name,
      fps: 0,
      loop: !1,
      spriteAsset: null
    }), this._currentClip = this._defaultClip;
  }
  set type(e) {
    this._type !== e && (this._type = e, this._type === Sp ? (this.stop(), this._currentClip = this._defaultClip, this.enabled && this.entity.enabled && (this._currentClip.frame = this.frame, this._currentClip.sprite ? this._showModel() : this._hideModel())) : this._type === bp && (this.stop(), this._autoPlayClip && this._tryAutoPlay(), this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled ? this._showModel() : this._hideModel()));
  }
  get type() {
    return this._type;
  }
  set frame(e) {
    this._currentClip.frame = e;
  }
  get frame() {
    return this._currentClip.frame;
  }
  set spriteAsset(e) {
    this._defaultClip.spriteAsset = e;
  }
  get spriteAsset() {
    return this._defaultClip._spriteAsset;
  }
  set sprite(e) {
    this._currentClip.sprite = e;
  }
  get sprite() {
    return this._currentClip.sprite;
  }
  set material(e) {
    this._material = e, this._meshInstance && (this._meshInstance.material = e);
  }
  get material() {
    return this._material;
  }
  set color(e) {
    this._color.r = e.r, this._color.g = e.g, this._color.b = e.b, this._meshInstance && (this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._meshInstance.setParameter(Cp, this._colorUniform));
  }
  get color() {
    return this._color;
  }
  set opacity(e) {
    this._color.a = e, this._meshInstance && this._meshInstance.setParameter(Ap, e);
  }
  get opacity() {
    return this._color.a;
  }
  set clips(e) {
    if (!e) {
      for (const t in this._clips)
        this.removeClip(t);
      return;
    }
    for (const t in this._clips) {
      let s = !1;
      for (const i in e)
        if (e[i].name === t) {
          s = !0, this._clips[t].fps = e[i].fps, this._clips[t].loop = e[i].loop, e[i].hasOwnProperty("sprite") ? this._clips[t].sprite = e[i].sprite : e[i].hasOwnProperty("spriteAsset") && (this._clips[t].spriteAsset = e[i].spriteAsset);
          break;
        }
      s || this.removeClip(t);
    }
    for (const t in e)
      this._clips[e[t].name] || this.addClip(e[t]);
    this._autoPlayClip && this._tryAutoPlay(), (!this._currentClip || !this._currentClip.sprite) && this._hideModel();
  }
  get clips() {
    return this._clips;
  }
  get currentClip() {
    return this._currentClip;
  }
  set speed(e) {
    this._speed = e;
  }
  get speed() {
    return this._speed;
  }
  set flipX(e) {
    this._flipX !== e && (this._flipX = e, this._updateTransform());
  }
  get flipX() {
    return this._flipX;
  }
  set flipY(e) {
    this._flipY !== e && (this._flipY = e, this._updateTransform());
  }
  get flipY() {
    return this._flipY;
  }
  set width(e) {
    e !== this._width && (this._width = e, this._outerScale.x = this._width, this.sprite && (this.sprite.renderMode === it || this.sprite.renderMode === ht) && this._updateTransform());
  }
  get width() {
    return this._width;
  }
  set height(e) {
    e !== this._height && (this._height = e, this._outerScale.y = this.height, this.sprite && (this.sprite.renderMode === it || this.sprite.renderMode === ht) && this._updateTransform());
  }
  get height() {
    return this._height;
  }
  set batchGroupId(e) {
    if (this._batchGroupId === e)
      return;
    const t = this._batchGroupId;
    if (this._batchGroupId = e, this.entity.enabled && t >= 0) {
      var s;
      (s = this.system.app.batcher) == null || s.remove(nt.SPRITE, t, this.entity);
    }
    if (this.entity.enabled && e >= 0) {
      var i;
      (i = this.system.app.batcher) == null || i.insert(nt.SPRITE, e, this.entity);
    } else
      t >= 0 && this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled && this._showModel();
  }
  get batchGroupId() {
    return this._batchGroupId;
  }
  set autoPlayClip(e) {
    this._autoPlayClip = e instanceof jc ? e.name : e, this._tryAutoPlay();
  }
  get autoPlayClip() {
    return this._autoPlayClip;
  }
  set drawOrder(e) {
    this._drawOrder = e, this._meshInstance && (this._meshInstance.drawOrder = e);
  }
  get drawOrder() {
    return this._drawOrder;
  }
  set layers(e) {
    this._addedModel && this._hideModel(), this._layers = e, this._meshInstance && this.enabled && this.entity.enabled && this._showModel();
  }
  get layers() {
    return this._layers;
  }
  get aabb() {
    return this._meshInstance ? this._meshInstance.aabb : null;
  }
  onEnable() {
    const e = this.system.app, t = e.scene;
    if (t.on("set:layers", this._onLayersChanged, this), t.layers && (t.layers.on("add", this._onLayerAdded, this), t.layers.on("remove", this._onLayerRemoved, this)), this._showModel(), this._autoPlayClip && this._tryAutoPlay(), this._batchGroupId >= 0) {
      var s;
      (s = e.batcher) == null || s.insert(nt.SPRITE, this._batchGroupId, this.entity);
    }
  }
  onDisable() {
    const e = this.system.app, t = e.scene;
    if (t.off("set:layers", this._onLayersChanged, this), t.layers && (t.layers.off("add", this._onLayerAdded, this), t.layers.off("remove", this._onLayerRemoved, this)), this.stop(), this._hideModel(), this._batchGroupId >= 0) {
      var s;
      (s = e.batcher) == null || s.remove(nt.SPRITE, this._batchGroupId, this.entity);
    }
  }
  onDestroy() {
    this._currentClip = null, this._defaultClip && (this._defaultClip._destroy(), this._defaultClip = null);
    for (const e in this._clips)
      this._clips[e]._destroy();
    this._clips = null, this._hideModel(), this._model = null, this._node && (this._node.parent && this._node.parent.removeChild(this._node), this._node = null), this._meshInstance && (this._meshInstance.material = null, this._meshInstance.mesh = null, this._meshInstance = null);
  }
  _showModel() {
    if (this._addedModel || !this._meshInstance)
      return;
    const e = [this._meshInstance];
    for (let t = 0, s = this._layers.length; t < s; t++) {
      const i = this.system.app.scene.layers.getLayerById(this._layers[t]);
      i && i.addMeshInstances(e);
    }
    this._addedModel = !0;
  }
  _hideModel() {
    if (!this._addedModel || !this._meshInstance)
      return;
    const e = [this._meshInstance];
    for (let t = 0, s = this._layers.length; t < s; t++) {
      const i = this.system.app.scene.layers.getLayerById(this._layers[t]);
      i && i.removeMeshInstances(e);
    }
    this._addedModel = !1;
  }
  _showFrame(e) {
    if (!this.sprite)
      return;
    const t = this.sprite.meshes[e];
    if (!t) {
      this._meshInstance && (this._meshInstance.mesh = null, this._meshInstance.visible = !1);
      return;
    }
    let s;
    if (this.sprite.renderMode === ht ? s = this.system.default9SlicedMaterialSlicedMode : this.sprite.renderMode === it ? s = this.system.default9SlicedMaterialTiledMode : s = this.system.defaultMaterial, this._meshInstance || (this._meshInstance = new we(t, this._material, this._node), this._meshInstance.castShadow = !1, this._meshInstance.receiveShadow = !1, this._meshInstance.drawOrder = this._drawOrder, this._model.meshInstances.push(this._meshInstance), this._colorUniform[0] = this._color.r, this._colorUniform[1] = this._color.g, this._colorUniform[2] = this._color.b, this._meshInstance.setParameter(Cp, this._colorUniform), this._meshInstance.setParameter(Ap, this._color.a), this.enabled && this.entity.enabled && this._showModel()), this._meshInstance.material !== s && (this._meshInstance.material = s), this._meshInstance.mesh !== t && (this._meshInstance.mesh = t, this._meshInstance.visible = !0, this._meshInstance._aabbVer = -1), this.sprite.atlas && this.sprite.atlas.texture ? (this._meshInstance.setParameter(wp, this.sprite.atlas.texture), this._meshInstance.setParameter(Tp, this.sprite.atlas.texture)) : (this._meshInstance.deleteParameter(wp), this._meshInstance.deleteParameter(Tp)), this.sprite.atlas && (this.sprite.renderMode === ht || this.sprite.renderMode === it)) {
      this._meshInstance._updateAabbFunc = this._updateAabbFunc;
      const i = this.sprite.atlas.frames[this.sprite.frameKeys[e]];
      if (i) {
        const n = 2 / i.rect.z, a = 2 / i.rect.w;
        this._innerOffset.set(i.border.x * n, i.border.y * a, i.border.z * n, i.border.w * a);
        const o = this.sprite.atlas.texture;
        this._atlasRect.set(i.rect.x / o.width, i.rect.y / o.height, i.rect.z / o.width, i.rect.w / o.height);
      } else
        this._innerOffset.set(0, 0, 0, 0);
      this._innerOffsetUniform[0] = this._innerOffset.x, this._innerOffsetUniform[1] = this._innerOffset.y, this._innerOffsetUniform[2] = this._innerOffset.z, this._innerOffsetUniform[3] = this._innerOffset.w, this._meshInstance.setParameter(_E, this._innerOffsetUniform), this._atlasRectUniform[0] = this._atlasRect.x, this._atlasRectUniform[1] = this._atlasRect.y, this._atlasRectUniform[2] = this._atlasRect.z, this._atlasRectUniform[3] = this._atlasRect.w, this._meshInstance.setParameter(yE, this._atlasRectUniform);
    } else
      this._meshInstance._updateAabbFunc = null;
    this._updateTransform();
  }
  _updateTransform() {
    let e = this.flipX ? -1 : 1, t = this.flipY ? -1 : 1, s = 0, i = 0;
    if (this.sprite && (this.sprite.renderMode === ht || this.sprite.renderMode === it)) {
      let n = 1, a = 1;
      if (this.sprite.atlas) {
        const l = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
        l && (n = l.rect.z, a = l.rect.w, s = (0.5 - l.pivot.x) * this._width, i = (0.5 - l.pivot.y) * this._height);
      }
      const o = n / this.sprite.pixelsPerUnit, h = a / this.sprite.pixelsPerUnit;
      this._outerScale.set(Math.max(this._width, this._innerOffset.x * o), Math.max(this._height, this._innerOffset.y * h)), e *= o, t *= h, this._outerScale.x /= o, this._outerScale.y /= h, e *= U.clamp(this._width / (this._innerOffset.x * o), 1e-4, 1), t *= U.clamp(this._height / (this._innerOffset.y * h), 1e-4, 1), this._meshInstance && (this._outerScaleUniform[0] = this._outerScale.x, this._outerScaleUniform[1] = this._outerScale.y, this._meshInstance.setParameter(gE, this._outerScaleUniform));
    }
    this._node.setLocalScale(e, t, 1), this._node.setLocalPosition(s, i, 0);
  }
  _updateAabb(e) {
    return e.center.set(0, 0, 0), e.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 1e-3), e.setFromTransformedAabb(e, this._node.getWorldTransform()), e;
  }
  _tryAutoPlay() {
    if (!this._autoPlayClip || this.type !== bp)
      return;
    const e = this._clips[this._autoPlayClip];
    e && !e.isPlaying && (!this._currentClip || !this._currentClip.isPlaying) && this.enabled && this.entity.enabled && this.play(e.name);
  }
  _onLayersChanged(e, t) {
    e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this), this.enabled && this.entity.enabled && this._showModel();
  }
  _onLayerAdded(e) {
    this.layers.indexOf(e.id) < 0 || this._addedModel && this.enabled && this.entity.enabled && this._meshInstance && e.addMeshInstances([this._meshInstance]);
  }
  _onLayerRemoved(e) {
    !this._meshInstance || this.layers.indexOf(e.id) < 0 || e.removeMeshInstances([this._meshInstance]);
  }
  removeModelFromLayers() {
    for (let e = 0; e < this.layers.length; e++) {
      const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
      t && t.removeMeshInstances([this._meshInstance]);
    }
  }
  addClip(e) {
    const t = new jc(this, {
      name: e.name,
      fps: e.fps,
      loop: e.loop,
      spriteAsset: e.spriteAsset
    });
    return this._clips[e.name] = t, t.name && t.name === this._autoPlayClip && this._tryAutoPlay(), t;
  }
  removeClip(e) {
    delete this._clips[e];
  }
  clip(e) {
    return this._clips[e];
  }
  play(e) {
    const t = this._clips[e], s = this._currentClip;
    return s && s !== t && (s._playing = !1), this._currentClip = t, this._currentClip && (this._currentClip = t, this._currentClip.play()), t;
  }
  pause() {
    this._currentClip !== this._defaultClip && this._currentClip.isPlaying && this._currentClip.pause();
  }
  resume() {
    this._currentClip !== this._defaultClip && this._currentClip.isPaused && this._currentClip.resume();
  }
  stop() {
    this._currentClip !== this._defaultClip && this._currentClip.stop();
  }
}
class xE {
  constructor() {
    this.enabled = !0;
  }
}
const py = ["enabled"];
class vE extends Ye {
  constructor(e) {
    super(e), this.id = "sprite", this.ComponentType = my, this.DataType = xE, this.schema = py, this._defaultTexture = null, this._defaultMaterial = null, this._default9SlicedMaterialSlicedMode = null, this._default9SlicedMaterialTiledMode = null, this.app.systems.on("update", this.onUpdate, this), this.on("beforeremove", this.onBeforeRemove, this);
  }
  set defaultMaterial(e) {
    this._defaultMaterial = e;
  }
  get defaultMaterial() {
    if (!this._defaultMaterial) {
      const e = new ue(this.app.graphicsDevice, {
        width: 1,
        height: 1,
        format: ye,
        name: "sprite"
      }), t = new Uint8Array(e.lock());
      t[0] = t[1] = t[2] = t[3] = 255, e.unlock();
      const s = new Ht();
      s.diffuse.set(0, 0, 0), s.emissive.set(0.5, 0.5, 0.5), s.emissiveMap = e, s.emissiveTint = !0, s.opacityMap = e, s.opacityMapChannel = "a", s.opacityTint = !0, s.opacity = 0, s.useLighting = !1, s.useGammaTonemap = !1, s.useFog = !1, s.useSkybox = !1, s.blendType = $i, s.depthWrite = !1, s.pixelSnap = !1, s.cull = Ft, s.update(), this._defaultTexture = e, this._defaultMaterial = s;
    }
    return this._defaultMaterial;
  }
  set default9SlicedMaterialSlicedMode(e) {
    this._default9SlicedMaterialSlicedMode = e;
  }
  get default9SlicedMaterialSlicedMode() {
    if (!this._default9SlicedMaterialSlicedMode) {
      const e = this.defaultMaterial.clone();
      e.nineSlicedMode = ht, e.update(), this._default9SlicedMaterialSlicedMode = e;
    }
    return this._default9SlicedMaterialSlicedMode;
  }
  set default9SlicedMaterialTiledMode(e) {
    this._default9SlicedMaterialTiledMode = e;
  }
  get default9SlicedMaterialTiledMode() {
    if (!this._default9SlicedMaterialTiledMode) {
      const e = this.defaultMaterial.clone();
      e.nineSlicedMode = it, e.update(), this._default9SlicedMaterialTiledMode = e;
    }
    return this._default9SlicedMaterialTiledMode;
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this), this._defaultTexture && (this._defaultTexture.destroy(), this._defaultTexture = null);
  }
  initializeComponentData(e, t, s) {
    if (t.enabled !== void 0 && (e.enabled = t.enabled), e.type = t.type, t.layers && Array.isArray(t.layers) && (e.layers = t.layers.slice(0)), t.drawOrder !== void 0 && (e.drawOrder = t.drawOrder), t.color !== void 0 && (t.color instanceof z ? e.color.set(t.color.r, t.color.g, t.color.b, t.opacity !== void 0 ? t.opacity : 1) : e.color.set(t.color[0], t.color[1], t.color[2], t.opacity !== void 0 ? t.opacity : 1), e.color = e.color), t.opacity !== void 0 && (e.opacity = t.opacity), t.flipX !== void 0 && (e.flipX = t.flipX), t.flipY !== void 0 && (e.flipY = t.flipY), t.width !== void 0 && (e.width = t.width), t.height !== void 0 && (e.height = t.height), t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset), t.sprite && (e.sprite = t.sprite), t.frame !== void 0 && (e.frame = t.frame), t.clips)
      for (const i in t.clips)
        e.addClip(t.clips[i]);
    t.speed !== void 0 && (e.speed = t.speed), t.autoPlayClip && (e.autoPlayClip = t.autoPlayClip), e.batchGroupId = t.batchGroupId === void 0 || t.batchGroupId === null ? -1 : t.batchGroupId, super.initializeComponentData(e, t, s);
  }
  cloneComponent(e, t) {
    const s = e.sprite;
    return this.addComponent(t, {
      enabled: s.enabled,
      type: s.type,
      spriteAsset: s.spriteAsset,
      sprite: s.sprite,
      frame: s.frame,
      color: s.color.clone(),
      opacity: s.opacity,
      flipX: s.flipX,
      flipY: s.flipY,
      speed: s.speed,
      clips: s.clips,
      autoPlayClip: s.autoPlayClip,
      batchGroupId: s.batchGroupId,
      drawOrder: s.drawOrder,
      layers: s.layers.slice(0)
    });
  }
  onUpdate(e) {
    const t = this.store;
    for (const s in t)
      if (t.hasOwnProperty(s)) {
        const i = t[s];
        if (i.data.enabled && i.entity.enabled) {
          const n = i.entity.sprite;
          n._currentClip && n._currentClip._update(e);
        }
      }
  }
  onBeforeRemove(e, t) {
    t.onDestroy();
  }
}
le._buildAccessors(my.prototype, py);
class _y extends le {
  constructor(e, t) {
    super(e, t), this._oldState = !0, this._size = new v(), this.on("set_enabled", this._onSetEnabled, this);
  }
  set size(e) {
    e instanceof v ? this._size.copy(e) : e instanceof Array && e.length >= 3 && this.size.set(e[0], e[1], e[2]);
  }
  get size() {
    return this._size;
  }
  onEnable() {
    this._checkState();
  }
  onDisable() {
    this._checkState();
  }
  _onSetEnabled(e, t, s) {
    this._checkState();
  }
  _checkState() {
    const e = this.enabled && this.entity.enabled;
    e !== this._oldState && (this._oldState = e, this.fire("enable"), this.fire("state", this.enabled));
  }
  _onBeforeRemove() {
    this.fire("remove");
  }
}
class SE {
  constructor() {
    this.enabled = !0;
  }
}
const gy = ["enabled"];
class bE extends Ye {
  constructor(e) {
    super(e), this.id = "zone", this.ComponentType = _y, this.DataType = SE, this.schema = gy, this.on("beforeremove", this._onBeforeRemove, this);
  }
  initializeComponentData(e, t, s) {
    e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0, t.size && (t.size instanceof v ? e.size.copy(t.size) : t.size instanceof Array && t.size.length >= 3 && e.size.set(t.size[0], t.size[1], t.size[2]));
  }
  cloneComponent(e, t) {
    const s = {
      size: e.zone.size
    };
    return this.addComponent(t, s);
  }
  _onBeforeRemove(e, t) {
    t._onBeforeRemove();
  }
}
le._buildAccessors(_y.prototype, gy);
class wE {
  constructor(e, t) {
    this.effect = e, this.inputTarget = t, this.outputTarget = null, this.name = e.constructor.name;
  }
}
class TE {
  constructor(e, t) {
    this.app = e, this.camera = t, this.destinationRenderTarget = null, this.effects = [], this.enabled = !1, this.depthTarget = null, t.on("set:rect", this.onCameraRectChanged, this);
  }
  _allocateColorBuffer(e, t) {
    const s = this.camera.rect, i = Math.floor(s.z * this.app.graphicsDevice.width), n = Math.floor(s.w * this.app.graphicsDevice.height);
    return new ue(this.app.graphicsDevice, {
      name: t,
      format: e,
      width: i,
      height: n,
      mipmaps: !1,
      minFilter: Be,
      magFilter: Be,
      addressU: he,
      addressV: he
    });
  }
  _createOffscreenTarget(e, t) {
    const s = this.app.graphicsDevice, i = t && s.getHdrFormat(!1, !0, !1, !1) || ye, n = this.camera.entity.name + "-posteffect-" + this.effects.length, a = this._allocateColorBuffer(i, n);
    return new Dt({
      colorBuffer: a,
      depth: e,
      stencil: e && this.app.graphicsDevice.supportsStencil,
      samples: e ? s.samples : 1
    });
  }
  _resizeOffscreenTarget(e) {
    const t = e.colorBuffer.format, s = e.colorBuffer.name;
    e.destroyFrameBuffers(), e.destroyTextureBuffers(), e._colorBuffer = this._allocateColorBuffer(t, s);
  }
  _destroyOffscreenTarget(e) {
    e.destroyTextureBuffers(), e.destroy();
  }
  addEffect(e) {
    const t = this.effects, s = t.length === 0, i = this._createOffscreenTarget(s, e.hdr), n = new wE(e, i);
    t.push(n), this._sourceTarget = n.inputTarget, t.length > 1 && (t[t.length - 2].outputTarget = n.inputTarget), this._newPostEffect = e, e.needsDepthBuffer && this._requestDepthMap(), this.enable(), this._newPostEffect = void 0;
  }
  removeEffect(e) {
    let t = -1;
    for (let s = 0, i = this.effects.length; s < i; s++)
      if (this.effects[s].effect === e) {
        t = s;
        break;
      }
    t >= 0 && (t > 0 ? this.effects[t - 1].outputTarget = t + 1 < this.effects.length ? this.effects[t + 1].inputTarget : null : this.effects.length > 1 && (this.effects[1].inputTarget._depth || (this._destroyOffscreenTarget(this.effects[1].inputTarget), this.effects[1].inputTarget = this._createOffscreenTarget(!0, this.effects[1].hdr), this._sourceTarget = this.effects[1].inputTarget), this.camera.renderTarget = this.effects[1].inputTarget), this._destroyOffscreenTarget(this.effects[t].inputTarget), this.effects.splice(t, 1)), this.enabled && e.needsDepthBuffer && this._releaseDepthMap(), this.effects.length === 0 && this.disable();
  }
  _requestDepthMaps() {
    for (let e = 0, t = this.effects.length; e < t; e++) {
      const s = this.effects[e].effect;
      this._newPostEffect !== s && s.needsDepthBuffer && this._requestDepthMap();
    }
  }
  _releaseDepthMaps() {
    for (let e = 0, t = this.effects.length; e < t; e++)
      this.effects[e].effect.needsDepthBuffer && this._releaseDepthMap();
  }
  _requestDepthMap() {
    const e = this.app.scene.layers.getLayerById(kt);
    e && (e.incrementCounter(), this.camera.requestSceneDepthMap(!0));
  }
  _releaseDepthMap() {
    const e = this.app.scene.layers.getLayerById(kt);
    e && (e.decrementCounter(), this.camera.requestSceneDepthMap(!1));
  }
  destroy() {
    for (let e = 0, t = this.effects.length; e < t; e++)
      this.effects[e].inputTarget.destroy();
    this.effects.length = 0, this.disable();
  }
  enable() {
    !this.enabled && this.effects.length && (this.enabled = !0, this._requestDepthMaps(), this.app.graphicsDevice.on("resizecanvas", this._onCanvasResized, this), this.destinationRenderTarget = this.camera.renderTarget, this.camera.renderTarget = this.effects[0].inputTarget, this.camera.onPostprocessing = () => {
      if (this.enabled) {
        let e = null;
        const t = this.effects.length;
        if (t)
          for (let s = 0; s < t; s++) {
            const i = this.effects[s];
            let n = i.outputTarget;
            s === t - 1 && (e = this.camera.rect, this.destinationRenderTarget && (n = this.destinationRenderTarget)), i.effect.render(i.inputTarget, n, e);
          }
      }
    });
  }
  disable() {
    this.enabled && (this.enabled = !1, this.app.graphicsDevice.off("resizecanvas", this._onCanvasResized, this), this._releaseDepthMaps(), this._destroyOffscreenTarget(this._sourceTarget), this.camera.renderTarget = null, this.camera.onPostprocessing = null);
  }
  _onCanvasResized(e, t) {
    const s = this.camera.rect, i = this.app.graphicsDevice;
    this.camera.camera.aspectRatio = i.width * s.z / (i.height * s.w), this.resizeRenderTargets();
  }
  resizeRenderTargets() {
    const e = this.camera.rect, t = Math.floor(e.z * this.app.graphicsDevice.width), s = Math.floor(e.w * this.app.graphicsDevice.height), i = this.effects;
    for (let n = 0, a = i.length; n < a; n++) {
      const o = i[n];
      (o.inputTarget.width !== t || o.inputTarget.height !== s) && this._resizeOffscreenTarget(o.inputTarget);
    }
  }
  onCameraRectChanged(e, t, s) {
    this.enabled && this.resizeRenderTargets();
  }
}
const yy = [{
  name: "aspectRatio",
  readonly: !1
}, {
  name: "aspectRatioMode",
  readonly: !1
}, {
  name: "calculateProjection",
  readonly: !1
}, {
  name: "calculateTransform",
  readonly: !1
}, {
  name: "clearColor",
  readonly: !1
}, {
  name: "cullFaces",
  readonly: !1
}, {
  name: "farClip",
  readonly: !1
}, {
  name: "flipFaces",
  readonly: !1
}, {
  name: "fov",
  readonly: !1
}, {
  name: "frustumCulling",
  readonly: !1
}, {
  name: "horizontalFov",
  readonly: !1
}, {
  name: "nearClip",
  readonly: !1
}, {
  name: "orthoHeight",
  readonly: !1
}, {
  name: "projection",
  readonly: !1
}, {
  name: "scissorRect",
  readonly: !1
}, {
  name: "aperture",
  readonly: !1
}, {
  name: "shutter",
  readonly: !1
}, {
  name: "sensitivity",
  readonly: !1
}];
class Ku extends le {
  constructor(e, t) {
    super(e, t), this.onPostprocessing = null, this.onPreRender = null, this.onPostRender = null, this._renderSceneDepthMap = 0, this._renderSceneColorMap = 0, this._camera = new ro(), this._camera.node = t, this._priority = 0, this._disablePostEffectsLayer = Xa, this._postEffects = new TE(e.app, this), this._sceneDepthMapRequested = !1, this._sceneColorMapRequested = !1;
  }
  get camera() {
    return this._camera;
  }
  set clearColorBuffer(e) {
    this._camera.clearColorBuffer = e, this.dirtyLayerCompositionCameras();
  }
  get clearColorBuffer() {
    return this._camera.clearColorBuffer;
  }
  set clearDepthBuffer(e) {
    this._camera.clearDepthBuffer = e, this.dirtyLayerCompositionCameras();
  }
  get clearDepthBuffer() {
    return this._camera.clearDepthBuffer;
  }
  set clearStencilBuffer(e) {
    this._camera.clearStencilBuffer = e, this.dirtyLayerCompositionCameras();
  }
  get clearStencilBuffer() {
    return this._camera.clearStencilBuffer;
  }
  set disablePostEffectsLayer(e) {
    this._disablePostEffectsLayer = e, this.dirtyLayerCompositionCameras();
  }
  get disablePostEffectsLayer() {
    return this._disablePostEffectsLayer;
  }
  _enableDepthLayer(e) {
    if (this.layers.find((s) => s === kt)) {
      const s = this.system.app.scene.layers.getLayerById(kt);
      e ? s == null || s.incrementCounter() : s == null || s.decrementCounter();
    } else if (e)
      return !1;
    return !0;
  }
  requestSceneColorMap(e) {
    this._renderSceneColorMap += e ? 1 : -1, this._enableDepthLayer(e);
  }
  set renderSceneColorMap(e) {
    e && !this._sceneColorMapRequested ? (this.requestSceneColorMap(!0), this._sceneColorMapRequested = !0) : this._sceneColorMapRequested && (this.requestSceneColorMap(!1), this._sceneColorMapRequested = !1);
  }
  get renderSceneColorMap() {
    return this._renderSceneColorMap > 0;
  }
  requestSceneDepthMap(e) {
    this._renderSceneDepthMap += e ? 1 : -1, this._enableDepthLayer(e);
  }
  set renderSceneDepthMap(e) {
    e && !this._sceneDepthMapRequested ? (this.requestSceneDepthMap(!0), this._sceneDepthMapRequested = !0) : this._sceneDepthMapRequested && (this.requestSceneDepthMap(!1), this._sceneDepthMapRequested = !1);
  }
  get renderSceneDepthMap() {
    return this._renderSceneDepthMap > 0;
  }
  get frustum() {
    return this._camera.frustum;
  }
  set layers(e) {
    const t = this._camera.layers;
    for (let s = 0; s < t.length; s++) {
      const i = this.system.app.scene.layers.getLayerById(t[s]);
      i && i.removeCamera(this);
    }
    if (this._camera.layers = e, !(!this.enabled || !this.entity.enabled))
      for (let s = 0; s < e.length; s++) {
        const i = this.system.app.scene.layers.getLayerById(e[s]);
        i && i.addCamera(this);
      }
  }
  get layers() {
    return this._camera.layers;
  }
  get layersSet() {
    return this._camera.layersSet;
  }
  get postEffectsEnabled() {
    return this._postEffects.enabled;
  }
  get postEffects() {
    return this._postEffects;
  }
  set priority(e) {
    this._priority = e, this.dirtyLayerCompositionCameras();
  }
  get priority() {
    return this._priority;
  }
  get projectionMatrix() {
    return this._camera.projectionMatrix;
  }
  set aperture(e) {
    this._camera.aperture = e;
  }
  get aperture() {
    return this._camera.aperture;
  }
  set sensitivity(e) {
    this._camera.sensitivity = e;
  }
  get sensitivity() {
    return this._camera.sensitivity;
  }
  set shutter(e) {
    this._camera.shutter = e;
  }
  get shutter() {
    return this._camera.shutter;
  }
  set rect(e) {
    this._camera.rect = e, this.fire("set:rect", this._camera.rect);
  }
  get rect() {
    return this._camera.rect;
  }
  set renderTarget(e) {
    this._camera.renderTarget = e, this.dirtyLayerCompositionCameras();
  }
  get renderTarget() {
    return this._camera.renderTarget;
  }
  get viewMatrix() {
    return this._camera.viewMatrix;
  }
  dirtyLayerCompositionCameras() {
    const e = this.system.app.scene.layers;
    e._dirtyCameras = !0;
  }
  screenToWorld(e, t, s, i) {
    const n = this.system.app.graphicsDevice, a = n.clientRect.width, o = n.clientRect.height;
    return this._camera.screenToWorld(e, t, s, a, o, i);
  }
  worldToScreen(e, t) {
    const s = this.system.app.graphicsDevice, i = s.clientRect.width, n = s.clientRect.height;
    return this._camera.worldToScreen(e, i, n, t);
  }
  onAppPrerender() {
    this._camera._viewMatDirty = !0, this._camera._viewProjMatDirty = !0;
  }
  addCameraToLayers() {
    const e = this.layers;
    for (let t = 0; t < e.length; t++) {
      const s = this.system.app.scene.layers.getLayerById(e[t]);
      s && s.addCamera(this);
    }
  }
  removeCameraFromLayers() {
    const e = this.layers;
    for (let t = 0; t < e.length; t++) {
      const s = this.system.app.scene.layers.getLayerById(e[t]);
      s && s.removeCamera(this);
    }
  }
  onLayersChanged(e, t) {
    this.addCameraToLayers(), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    this.layers.indexOf(e.id) < 0 || e.addCamera(this);
  }
  onLayerRemoved(e) {
    this.layers.indexOf(e.id) < 0 || e.removeCamera(this);
  }
  onEnable() {
    const e = this.system, t = e.app.scene, s = t.layers;
    e.addCamera(this), t.on("set:layers", this.onLayersChanged, this), s && (s.on("add", this.onLayerAdded, this), s.on("remove", this.onLayerRemoved, this)), this.enabled && this.entity.enabled && this.addCameraToLayers(), this.postEffects.enable();
  }
  onDisable() {
    const e = this.system, t = e.app.scene, s = t.layers;
    this.postEffects.disable(), this.removeCameraFromLayers(), t.off("set:layers", this.onLayersChanged, this), s && (s.off("add", this.onLayerAdded, this), s.off("remove", this.onLayerRemoved, this)), e.removeCamera(this);
  }
  onRemove() {
    this.onDisable(), this.off();
  }
  calculateAspectRatio(e) {
    const t = this.system.app.graphicsDevice, s = e ? e.width : t.width, i = e ? e.height : t.height;
    return s * this.rect.z / (i * this.rect.w);
  }
  frameUpdate(e) {
    this.aspectRatioMode === ku && (this.aspectRatio = this.calculateAspectRatio(e));
  }
  startXr(e, t, s) {
    this.system.app.xr.start(this, e, t, s);
  }
  endXr(e) {
    if (!this._camera.xr) {
      e && e(new Error("Camera is not in XR"));
      return;
    }
    this._camera.xr.end(e);
  }
  copy(e) {
    yy.forEach((t) => {
      if (!t.readonly) {
        const s = t.name;
        this[s] = e[s];
      }
    }), this.clearColorBuffer = e.clearColorBuffer, this.clearDepthBuffer = e.clearDepthBuffer, this.clearStencilBuffer = e.clearStencilBuffer, this.disablePostEffectsLayer = e.disablePostEffectsLayer, this.layers = e.layers, this.priority = e.priority, this.renderTarget = e.renderTarget, this.rect = e.rect, this.aperture = e.aperture, this.sensitivity = e.sensitivity, this.shutter = e.shutter;
  }
}
yy.forEach(function(r) {
  const e = r.name, t = {};
  t.get = function() {
    return this._camera[e];
  }, r.readonly || (t.set = function(s) {
    this._camera[e] = s;
  }), Object.defineProperty(Ku.prototype, e, t);
});
class CE {
  constructor() {
    this.enabled = !0;
  }
}
const xy = ["enabled"];
class AE extends Ye {
  constructor(e) {
    super(e), this.cameras = [], this.id = "camera", this.ComponentType = Ku, this.DataType = CE, this.schema = xy, this.on("beforeremove", this.onBeforeRemove, this), this.app.on("prerender", this.onAppPrerender, this), this.app.systems.on("update", this.onUpdate, this);
  }
  initializeComponentData(e, t, s) {
    s = ["aspectRatio", "aspectRatioMode", "calculateProjection", "calculateTransform", "clearColor", "clearColorBuffer", "clearDepthBuffer", "clearStencilBuffer", "renderSceneColorMap", "renderSceneDepthMap", "cullFaces", "farClip", "flipFaces", "fov", "frustumCulling", "horizontalFov", "layers", "renderTarget", "nearClip", "orthoHeight", "projection", "priority", "rect", "scissorRect", "aperture", "shutter", "sensitivity"];
    for (let i = 0; i < s.length; i++) {
      const n = s[i];
      if (t.hasOwnProperty(n)) {
        const a = t[n];
        switch (n) {
          case "rect":
          case "scissorRect":
            Array.isArray(a) ? e[n] = new Z(a[0], a[1], a[2], a[3]) : e[n] = a;
            break;
          case "clearColor":
            Array.isArray(a) ? e[n] = new z(a[0], a[1], a[2], a[3]) : e[n] = a;
            break;
          default:
            e[n] = a;
            break;
        }
      }
    }
    super.initializeComponentData(e, t, ["enabled"]);
  }
  cloneComponent(e, t) {
    const s = e.camera;
    return this.addComponent(t, {
      aspectRatio: s.aspectRatio,
      aspectRatioMode: s.aspectRatioMode,
      calculateProjection: s.calculateProjection,
      calculateTransform: s.calculateTransform,
      clearColor: s.clearColor,
      clearColorBuffer: s.clearColorBuffer,
      clearDepthBuffer: s.clearDepthBuffer,
      clearStencilBuffer: s.clearStencilBuffer,
      renderSceneDepthMap: s.renderSceneDepthMap,
      renderSceneColorMap: s.renderSceneColorMap,
      cullFaces: s.cullFaces,
      enabled: s.enabled,
      farClip: s.farClip,
      flipFaces: s.flipFaces,
      fov: s.fov,
      frustumCulling: s.frustumCulling,
      horizontalFov: s.horizontalFov,
      layers: s.layers,
      renderTarget: s.renderTarget,
      nearClip: s.nearClip,
      orthoHeight: s.orthoHeight,
      projection: s.projection,
      priority: s.priority,
      rect: s.rect,
      scissorRect: s.scissorRect,
      aperture: s.aperture,
      sensitivity: s.sensitivity,
      shutter: s.shutter
    });
  }
  onBeforeRemove(e, t) {
    this.removeCamera(t);
  }
  onUpdate(e) {
  }
  onAppPrerender() {
    for (let e = 0, t = this.cameras.length; e < t; e++)
      this.cameras[e].onAppPrerender();
  }
  addCamera(e) {
    this.cameras.push(e), $a(this.cameras);
  }
  removeCamera(e) {
    const t = this.cameras.indexOf(e);
    t >= 0 && (this.cameras.splice(t, 1), $a(this.cameras));
  }
  destroy() {
    super.destroy(), this.app.systems.off("update", this.onUpdate, this);
  }
}
le._buildAccessors(Ku.prototype, xy);
const qr = [], vy = [];
class Sy extends le {
  constructor(e, t) {
    super(e, t), this._cookieAsset = null, this._cookieAssetId = null, this._cookieAssetAdd = !1, this._cookieMatrix = null;
  }
  addLightToLayers() {
    for (let e = 0; e < this.layers.length; e++) {
      const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
      t && t.addLight(this);
    }
  }
  removeLightFromLayers() {
    for (let e = 0; e < this.layers.length; e++) {
      const t = this.system.app.scene.layers.getLayerById(this.layers[e]);
      t && t.removeLight(this);
    }
  }
  onLayersChanged(e, t) {
    this.enabled && this.entity.enabled && this.addLightToLayers(), e.off("add", this.onLayerAdded, this), e.off("remove", this.onLayerRemoved, this), t.on("add", this.onLayerAdded, this), t.on("remove", this.onLayerRemoved, this);
  }
  onLayerAdded(e) {
    this.layers.indexOf(e.id) >= 0 && this.enabled && this.entity.enabled && e.addLight(this);
  }
  onLayerRemoved(e) {
    this.layers.indexOf(e.id) >= 0 && e.removeLight(this);
  }
  refreshProperties() {
    for (let e = 0; e < qr.length; e++) {
      const t = qr[e];
      this[t] = this[t];
    }
    this.enabled && this.entity.enabled && this.onEnable();
  }
  onCookieAssetSet() {
    let e = !1;
    this._cookieAsset.type === "cubemap" && !this._cookieAsset.loadFaces && (this._cookieAsset.loadFaces = !0, e = !0), (!this._cookieAsset.resource || e) && this.system.app.assets.load(this._cookieAsset), this._cookieAsset.resource && this.onCookieAssetLoad();
  }
  onCookieAssetAdd(e) {
    this._cookieAssetId === e.id && (this._cookieAsset = e, this.light.enabled && this.onCookieAssetSet(), this._cookieAsset.on("load", this.onCookieAssetLoad, this), this._cookieAsset.on("remove", this.onCookieAssetRemove, this));
  }
  onCookieAssetLoad() {
    !this._cookieAsset || !this._cookieAsset.resource || (this.cookie = this._cookieAsset.resource);
  }
  onCookieAssetRemove() {
    this._cookieAssetId && (this._cookieAssetAdd && (this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this), this._cookieAssetAdd = !1), this._cookieAsset && (this._cookieAsset.off("load", this.onCookieAssetLoad, this), this._cookieAsset.off("remove", this.onCookieAssetRemove, this), this._cookieAsset = null), this.cookie = null);
  }
  onEnable() {
    this.light.enabled = !0, this.system.app.scene.on("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.on("add", this.onLayerAdded, this), this.system.app.scene.layers.on("remove", this.onLayerRemoved, this)), this.enabled && this.entity.enabled && this.addLightToLayers(), this._cookieAsset && !this.cookie && this.onCookieAssetSet();
  }
  onDisable() {
    this.light.enabled = !1, this.system.app.scene.off("set:layers", this.onLayersChanged, this), this.system.app.scene.layers && (this.system.app.scene.layers.off("add", this.onLayerAdded, this), this.system.app.scene.layers.off("remove", this.onLayerRemoved, this)), this.removeLightFromLayers();
  }
  onRemove() {
    this.onDisable(), this.light.destroy(), this.cookieAsset = null;
  }
  set shadowUpdateOverrides(e) {
    this.light.shadowUpdateOverrides = e;
  }
  get shadowUpdateOverrides() {
    return this.light.shadowUpdateOverrides;
  }
}
function ge(r, e, t, s) {
  const i = Sy.prototype;
  qr.push(r), vy.push(e), Object.defineProperty(i, r, {
    get: function() {
      return this.data[r];
    },
    set: function(n) {
      const a = this.data, o = a[r];
      !s && o === n || (a[r] = n, t && t.call(this, n, o));
    },
    configurable: !0
  });
}
function ME() {
  ge("enabled", !0, function(r, e) {
    this.onSetEnabled(null, e, r);
  }), ge("light", null), ge("type", "directional", function(r, e) {
    this.system.changeType(this, e, r), this.refreshProperties();
  }), ge("color", new z(1, 1, 1), function(r, e) {
    this.light.setColor(r);
  }, !0), ge("intensity", 1, function(r, e) {
    this.light.intensity = r;
  }), ge("luminance", 0, function(r, e) {
    this.light.luminance = r;
  }), ge("shape", Mt, function(r, e) {
    this.light.shape = r;
  }), ge("castShadows", !1, function(r, e) {
    this.light.castShadows = r;
  }), ge("shadowDistance", 40, function(r, e) {
    this.light.shadowDistance = r;
  }), ge("shadowIntensity", 1, function(r, e) {
    this.light.shadowIntensity = r;
  }), ge("shadowResolution", 1024, function(r, e) {
    this.light.shadowResolution = r;
  }), ge("shadowBias", 0.05, function(r, e) {
    this.light.shadowBias = -0.01 * U.clamp(r, 0, 1);
  }), ge("numCascades", 1, function(r, e) {
    this.light.numCascades = U.clamp(Math.floor(r), 1, 4);
  }), ge("bakeNumSamples", 1, function(r, e) {
    this.light.bakeNumSamples = U.clamp(Math.floor(r), 1, 255);
  }), ge("bakeArea", 0, function(r, e) {
    this.light.bakeArea = U.clamp(r, 0, 180);
  }), ge("cascadeDistribution", 0.5, function(r, e) {
    this.light.cascadeDistribution = U.clamp(r, 0, 1);
  }), ge("normalOffsetBias", 0, function(r, e) {
    this.light.normalOffsetBias = U.clamp(r, 0, 1);
  }), ge("range", 10, function(r, e) {
    this.light.attenuationEnd = r;
  }), ge("innerConeAngle", 40, function(r, e) {
    this.light.innerConeAngle = r;
  }), ge("outerConeAngle", 45, function(r, e) {
    this.light.outerConeAngle = r;
  }), ge("falloffMode", Iu, function(r, e) {
    this.light.falloffMode = r;
  }), ge("shadowType", gt, function(r, e) {
    this.light.shadowType = r;
  }), ge("vsmBlurSize", 11, function(r, e) {
    this.light.vsmBlurSize = r;
  }), ge("vsmBlurMode", Du, function(r, e) {
    this.light.vsmBlurMode = r;
  }), ge("vsmBias", 0.01 * 0.25, function(r, e) {
    this.light.vsmBias = U.clamp(r, 0, 1);
  }), ge("cookieAsset", null, function(r, e) {
    if (!(this._cookieAssetId && (r instanceof ce && r.id === this._cookieAssetId || r === this._cookieAssetId))) {
      if (this.onCookieAssetRemove(), this._cookieAssetId = null, r instanceof ce)
        this.data.cookieAsset = r.id, this._cookieAssetId = r.id, this.onCookieAssetAdd(r);
      else if (typeof r == "number") {
        this._cookieAssetId = r;
        const t = this.system.app.assets.get(r);
        t ? this.onCookieAssetAdd(t) : (this._cookieAssetAdd = !0, this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this));
      }
    }
  }), ge("cookie", null, function(r, e) {
    this.light.cookie = r;
  }), ge("cookieIntensity", 1, function(r, e) {
    this.light.cookieIntensity = U.clamp(r, 0, 1);
  }), ge("cookieFalloff", !0, function(r, e) {
    this.light.cookieFalloff = r;
  }), ge("cookieChannel", "rgb", function(r, e) {
    this.light.cookieChannel = r;
  }), ge("cookieAngle", 0, function(r, e) {
    if (r !== 0 || this.cookieScale !== null) {
      this._cookieMatrix || (this._cookieMatrix = new Z());
      let t = 1, s = 1;
      this.cookieScale && (t = this.cookieScale.x, s = this.cookieScale.y);
      const i = Math.cos(r * U.DEG_TO_RAD), n = Math.sin(r * U.DEG_TO_RAD);
      this._cookieMatrix.set(i / t, -n / t, n / s, i / s), this.light.cookieTransform = this._cookieMatrix;
    } else
      this.light.cookieTransform = null;
  }), ge("cookieScale", null, function(r, e) {
    if (r !== null || this.cookieAngle !== 0) {
      this._cookieMatrix || (this._cookieMatrix = new Z());
      const t = r.x, s = r.y, i = Math.cos(this.cookieAngle * U.DEG_TO_RAD), n = Math.sin(this.cookieAngle * U.DEG_TO_RAD);
      this._cookieMatrix.set(i / t, -n / t, n / s, i / s), this.light.cookieTransform = this._cookieMatrix;
    } else
      this.light.cookieTransform = null;
  }, !0), ge("cookieOffset", null, function(r, e) {
    this.light.cookieOffset = r;
  }, !0), ge("shadowUpdateMode", Ou, function(r, e) {
    this.light.shadowUpdateMode = r;
  }, !0), ge("mask", 1, function(r, e) {
    this.light.mask = r;
  }), ge("affectDynamic", !0, function(r, e) {
    r ? this.light.mask |= Gs : this.light.mask &= ~Gs, this.light.layersDirty();
  }), ge("affectLightmapped", !1, function(r, e) {
    r ? (this.light.mask |= di, this.bake && (this.light.mask &= ~ui)) : (this.light.mask &= ~di, this.bake && (this.light.mask |= ui));
  }), ge("bake", !1, function(r, e) {
    r ? (this.light.mask |= ui, this.affectLightmapped && (this.light.mask &= ~di)) : (this.light.mask &= ~ui, this.affectLightmapped && (this.light.mask |= di)), this.light.layersDirty();
  }), ge("bakeDir", !0, function(r, e) {
    this.light.bakeDir = r;
  }), ge("isStatic", !1, function(r, e) {
    this.light.isStatic = r;
  }), ge("layers", [wi], function(r, e) {
    for (let t = 0; t < e.length; t++) {
      const s = this.system.app.scene.layers.getLayerById(e[t]);
      s && s.removeLight(this);
    }
    for (let t = 0; t < r.length; t++) {
      const s = this.system.app.scene.layers.getLayerById(r[t]);
      s && this.enabled && this.entity.enabled && s.addLight(this);
    }
  });
}
ME();
class EE {
  constructor() {
    const e = qr, t = vy;
    for (let s = 0; s < e.length; s++) {
      const i = t[s];
      i && i.clone ? this[e[s]] = i.clone() : this[e[s]] = i;
    }
  }
}
class RE extends Ye {
  constructor(e) {
    super(e), this.id = "light", this.ComponentType = Sy, this.DataType = EE, this.on("beforeremove", this._onRemoveComponent, this);
  }
  initializeComponentData(e, t) {
    const s = qr, i = {};
    for (let a = 0, o = s.length; a < o; a++) {
      const h = s[a];
      i[h] = t[h];
    }
    i.type || (i.type = e.data.type), e.data.type = i.type, i.layers && Array.isArray(i.layers) && (i.layers = i.layers.slice(0)), i.color && Array.isArray(i.color) && (i.color = new z(i.color[0], i.color[1], i.color[2])), i.cookieOffset && i.cookieOffset instanceof Array && (i.cookieOffset = new q(i.cookieOffset[0], i.cookieOffset[1])), i.cookieScale && i.cookieScale instanceof Array && (i.cookieScale = new q(i.cookieScale[0], i.cookieScale[1])), i.enable && (console.warn("WARNING: enable: Property is deprecated. Set enabled property instead."), i.enabled = i.enable), i.shape || (i.shape = Mt);
    const n = new Ya(this.app.graphicsDevice);
    n.type = Dd[i.type], n._node = e.entity, n._scene = this.app.scene, e.data.light = n, super.initializeComponentData(e, i, s);
  }
  _onRemoveComponent(e, t) {
    t.onRemove();
  }
  cloneComponent(e, t) {
    const s = e.light, i = [];
    let n;
    const a = qr;
    for (let o = 0; o < a.length; o++)
      n = a[o], n !== "light" && (s[n] && s[n].clone ? i[n] = s[n].clone() : i[n] = s[n]);
    return this.addComponent(t, i);
  }
  changeType(e, t, s) {
    t !== s && (e.light.type = Dd[s]);
  }
}
const LE = ["x", "y", "z", "w"], PE = [void 0, void 0, q, v, Z];
function cl(r, e, t, s) {
  switch (e.type) {
    case "boolean":
      return !!t;
    case "number":
      if (typeof t == "number")
        return t;
      if (typeof t == "string") {
        const i = parseInt(t, 10);
        return isNaN(i) ? null : i;
      } else if (typeof t == "boolean")
        return 0 + t;
      return null;
    case "json": {
      const i = {};
      if (Array.isArray(e.schema)) {
        (!t || typeof t != "object") && (t = {});
        for (let n = 0; n < e.schema.length; n++) {
          const a = e.schema[n];
          if (a.name)
            if (a.array) {
              i[a.name] = [];
              const o = Array.isArray(t[a.name]) ? t[a.name] : [];
              for (let h = 0; h < o.length; h++)
                i[a.name].push(cl(r, a, o[h]));
            } else {
              const o = t.hasOwnProperty(a.name) ? t[a.name] : a.default;
              i[a.name] = cl(r, a, o);
            }
        }
      }
      return i;
    }
    case "asset":
      return t instanceof ce ? t : typeof t == "number" ? r.assets.get(t) || null : typeof t == "string" && r.assets.get(parseInt(t, 10)) || null;
    case "entity":
      return t instanceof bt ? t : typeof t == "string" ? r.getEntityFromIndex(t) : null;
    case "rgb":
    case "rgba":
      if (t instanceof z)
        return s instanceof z ? (s.copy(t), s) : t.clone();
      if (t instanceof Array && t.length >= 3 && t.length <= 4) {
        for (let i = 0; i < t.length; i++)
          if (typeof t[i] != "number")
            return null;
        return s || (s = new z()), s.r = t[0], s.g = t[1], s.b = t[2], s.a = t.length === 3 ? 1 : t[3], s;
      } else if (typeof t == "string" && /#([0-9abcdef]{2}){3,4}/i.test(t))
        return s || (s = new z()), s.fromString(t), s;
      return null;
    case "vec2":
    case "vec3":
    case "vec4": {
      const i = parseInt(e.type.slice(3), 10), n = PE[i];
      if (t instanceof n)
        return s instanceof n ? (s.copy(t), s) : t.clone();
      if (t instanceof Array && t.length === i) {
        for (let a = 0; a < t.length; a++)
          if (typeof t[a] != "number")
            return null;
        s || (s = new n());
        for (let a = 0; a < i; a++)
          s[LE[a]] = t[a];
        return s;
      }
      return null;
    }
    case "curve":
      if (t) {
        let i;
        if (t instanceof ms || t instanceof Wi)
          i = t.clone();
        else {
          const n = t.keys[0] instanceof Array ? Wi : ms;
          i = new n(t.keys), i.type = t.type;
        }
        return i;
      }
      break;
  }
  return t;
}
class Zl {
  constructor(e) {
    this.scriptType = e, this.index = {};
  }
  add(e, t) {
    this.index[e] || Zl.reservedNames.has(e) || (this.index[e] = t, Object.defineProperty(this.scriptType.prototype, e, {
      get: function() {
        return this.__attributes[e];
      },
      set: function(s) {
        const i = "attr", n = "attr:" + e, a = this.__attributes[e];
        let o = a;
        if (a && t.type !== "json" && t.type !== "entity" && a.clone && (this._callbacks[i] || this._callbacks[n]) && (o = a.clone()), t.array) {
          if (this.__attributes[e] = [], s)
            for (let h = 0, l = s.length; h < l; h++)
              this.__attributes[e].push(cl(this.app, t, s[h], a ? a[h] : null));
        } else
          this.__attributes[e] = cl(this.app, t, s, a);
        this.fire(i, e, this.__attributes[e], o), this.fire(n, this.__attributes[e], o);
      }
    }));
  }
  remove(e) {
    return this.index[e] ? (delete this.index[e], delete this.scriptType.prototype[e], !0) : !1;
  }
  has(e) {
    return !!this.index[e];
  }
  get(e) {
    return this.index[e] || null;
  }
}
Zl.reservedNames = /* @__PURE__ */ new Set(["app", "entity", "enabled", "_enabled", "_enabledOld", "_destroyed", "__attributes", "__attributesRaw", "__scriptType", "__executionOrder", "_callbacks", "has", "get", "on", "off", "fire", "once", "hasEvent"]);
const Mp = "initialize", Ep = "postInitialize", IE = "update", DE = "postUpdate", BE = "swap";
class FE extends le {
  constructor(e, t) {
    super(e, t), this._scripts = [], this._updateList = new Ch({
      sortBy: "__executionOrder"
    }), this._postUpdateList = new Ch({
      sortBy: "__executionOrder"
    }), this._scriptsIndex = {}, this._destroyedScripts = [], this._destroyed = !1, this._scriptsData = null, this._oldState = !0, this._enabled = !0, this._beingEnabled = !1, this._isLoopingThroughScripts = !1, this._executionOrder = -1, this.on("set_enabled", this._onSetEnabled, this);
  }
  set scripts(e) {
    this._scriptsData = e;
    for (const t in e) {
      if (!e.hasOwnProperty(t))
        continue;
      const s = this._scriptsIndex[t];
      if (s) {
        if (typeof e[t].enabled == "boolean" && (s.enabled = !!e[t].enabled), typeof e[t].attributes == "object") {
          for (const i in e[t].attributes)
            if (!Zl.reservedNames.has(i)) {
              if (!s.__attributes.hasOwnProperty(i)) {
                const n = this.system.app.scripts.get(t);
                n && n.attributes.add(i, {});
              }
              s[i] = e[t].attributes[i];
            }
        }
      } else
        console.log(this.order);
    }
  }
  get scripts() {
    return this._scripts;
  }
  set enabled(e) {
    const t = this._enabled;
    this._enabled = e, this.fire("set", "enabled", t, e);
  }
  get enabled() {
    return this._enabled;
  }
  onEnable() {
    this._beingEnabled = !0, this._checkState(), this.entity._beingEnabled || this.onPostStateChange(), this._beingEnabled = !1;
  }
  onDisable() {
    this._checkState();
  }
  onPostStateChange() {
    const e = this._beginLooping();
    for (let t = 0, s = this.scripts.length; t < s; t++) {
      const i = this.scripts[t];
      i._initialized && !i._postInitialized && i.enabled && (i._postInitialized = !0, i.postInitialize && this._scriptMethod(i, Ep));
    }
    this._endLooping(e);
  }
  _beginLooping() {
    const e = this._isLoopingThroughScripts;
    return this._isLoopingThroughScripts = !0, e;
  }
  _endLooping(e) {
    this._isLoopingThroughScripts = e, this._isLoopingThroughScripts || this._removeDestroyedScripts();
  }
  _onSetEnabled(e, t, s) {
    this._beingEnabled = !0, this._checkState(), this._beingEnabled = !1;
  }
  _checkState() {
    const e = this.enabled && this.entity.enabled;
    if (e === this._oldState)
      return;
    this._oldState = e, this.fire(e ? "enable" : "disable"), this.fire("state", e), e ? this.system._addComponentToEnabled(this) : this.system._removeComponentFromEnabled(this);
    const t = this._beginLooping();
    for (let s = 0, i = this.scripts.length; s < i; s++) {
      const n = this.scripts[s];
      n.enabled = n._enabled;
    }
    this._endLooping(t);
  }
  _onBeforeRemove() {
    this.fire("remove");
    const e = this._beginLooping();
    for (let t = 0; t < this.scripts.length; t++) {
      const s = this.scripts[t];
      s && this.destroy(s.__scriptType.__name);
    }
    this._endLooping(e);
  }
  _removeDestroyedScripts() {
    const e = this._destroyedScripts.length;
    if (e) {
      for (let t = 0; t < e; t++) {
        const s = this._destroyedScripts[t];
        this._removeScriptInstance(s);
      }
      this._destroyedScripts.length = 0, this._resetExecutionOrder(0, this._scripts.length);
    }
  }
  _onInitializeAttributes() {
    for (let e = 0, t = this.scripts.length; e < t; e++)
      this.scripts[e].__initializeAttributes();
  }
  _scriptMethod(e, t, s) {
    e[t](s);
  }
  _onInitialize() {
    const e = this._scripts, t = this._beginLooping();
    for (let s = 0, i = e.length; s < i; s++) {
      const n = e[s];
      !n._initialized && n.enabled && (n._initialized = !0, n.initialize && this._scriptMethod(n, Mp));
    }
    this._endLooping(t);
  }
  _onPostInitialize() {
    this.onPostStateChange();
  }
  _onUpdate(e) {
    const t = this._updateList;
    if (!t.length)
      return;
    const s = this._beginLooping();
    for (t.loopIndex = 0; t.loopIndex < t.length; t.loopIndex++) {
      const i = t.items[t.loopIndex];
      i.enabled && this._scriptMethod(i, IE, e);
    }
    this._endLooping(s);
  }
  _onPostUpdate(e) {
    const t = this._postUpdateList;
    if (!t.length)
      return;
    const s = this._beginLooping();
    for (t.loopIndex = 0; t.loopIndex < t.length; t.loopIndex++) {
      const i = t.items[t.loopIndex];
      i.enabled && this._scriptMethod(i, DE, e);
    }
    this._endLooping(s);
  }
  _insertScriptInstance(e, t, s) {
    t === -1 ? (this._scripts.push(e), e.__executionOrder = s, e.update && this._updateList.append(e), e.postUpdate && this._postUpdateList.append(e)) : (this._scripts.splice(t, 0, e), e.__executionOrder = t, this._resetExecutionOrder(t + 1, s + 1), e.update && this._updateList.insert(e), e.postUpdate && this._postUpdateList.insert(e));
  }
  _removeScriptInstance(e) {
    const t = this._scripts.indexOf(e);
    return t === -1 || (this._scripts.splice(t, 1), e.update && this._updateList.remove(e), e.postUpdate && this._postUpdateList.remove(e)), t;
  }
  _resetExecutionOrder(e, t) {
    for (let s = e; s < t; s++)
      this._scripts[s].__executionOrder = s;
  }
  _resolveEntityScriptAttribute(e, t, s, i, n, a) {
    if (e.array) {
      const o = s.length;
      if (!o)
        return;
      const h = s.slice();
      for (let l = 0; l < o; l++) {
        const c = h[l] instanceof oe ? h[l].getGuid() : h[l];
        a[c] && (h[l] = i ? a[c].getGuid() : a[c]);
      }
      n[t] = h;
    } else {
      if (s instanceof oe)
        s = s.getGuid();
      else if (typeof s != "string")
        return;
      a[s] && (n[t] = a[s]);
    }
  }
  has(e) {
    if (typeof e == "string")
      return !!this._scriptsIndex[e];
    if (!e)
      return !1;
    const t = e, s = t.__name, i = this._scriptsIndex[s];
    return (i && i.instance) instanceof t;
  }
  get(e) {
    if (typeof e == "string") {
      const a = this._scriptsIndex[e];
      return a ? a.instance : null;
    }
    if (!e)
      return null;
    const t = e, s = t.__name, i = this._scriptsIndex[s], n = i && i.instance;
    return n instanceof t ? n : null;
  }
  create(e, t = {}) {
    const s = this;
    let i = e, n = e;
    if (typeof i == "string" ? i = this.system.app.scripts.get(i) : i && (n = i.__name), i) {
      if (!this._scriptsIndex[n] || !this._scriptsIndex[n].instance) {
        const a = new i({
          app: this.system.app,
          entity: this.entity,
          enabled: t.hasOwnProperty("enabled") ? t.enabled : !0,
          attributes: t.attributes
        }), o = this._scripts.length;
        let h = -1;
        return typeof t.ind == "number" && t.ind !== -1 && o > t.ind && (h = t.ind), this._insertScriptInstance(a, h, o), this._scriptsIndex[n] = {
          instance: a,
          onSwap: function() {
            s.swap(n);
          }
        }, this[n] = a, t.preloading || a.__initializeAttributes(), this.fire("create", n, a), this.fire("create:" + n, a), this.system.app.scripts.on("swap:" + n, this._scriptsIndex[n].onSwap), t.preloading || (a.enabled && !a._initialized && (a._initialized = !0, a.initialize && this._scriptMethod(a, Mp)), a.enabled && !a._postInitialized && (a._postInitialized = !0, a.postInitialize && this._scriptMethod(a, Ep))), a;
      }
    } else
      this._scriptsIndex[n] = {
        awaiting: !0,
        ind: this._scripts.length
      };
    return null;
  }
  destroy(e) {
    let t = e, s = e;
    typeof s == "string" ? s = this.system.app.scripts.get(s) : s && (t = s.__name);
    const i = this._scriptsIndex[t];
    if (delete this._scriptsIndex[t], !i)
      return !1;
    const n = i.instance;
    if (n && !n._destroyed)
      if (n.enabled = !1, n._destroyed = !0, this._isLoopingThroughScripts)
        this._destroyedScripts.push(n);
      else {
        const a = this._removeScriptInstance(n);
        a >= 0 && this._resetExecutionOrder(a, this._scripts.length);
      }
    return this.system.app.scripts.off("swap:" + t, i.onSwap), delete this[t], this.fire("destroy", t, n || null), this.fire("destroy:" + t, n || null), n && n.fire("destroy"), !0;
  }
  swap(e) {
    let t = e, s = e;
    typeof s == "string" ? s = this.system.app.scripts.get(s) : s && (t = s.__name);
    const i = this._scriptsIndex[t];
    if (!i || !i.instance)
      return !1;
    const n = i.instance, a = this._scripts.indexOf(n), o = new s({
      app: this.system.app,
      entity: this.entity,
      enabled: n.enabled,
      attributes: n.__attributes
    });
    return o.swap ? (o.__initializeAttributes(), this._scripts[a] = o, this._scriptsIndex[t].instance = o, this[t] = o, o.__executionOrder = a, n.update && this._updateList.remove(n), n.postUpdate && this._postUpdateList.remove(n), o.update && this._updateList.insert(o), o.postUpdate && this._postUpdateList.insert(o), this._scriptMethod(o, BE, n), this.fire("swap", t, o), this.fire("swap:" + t, o), !0) : !1;
  }
  resolveDuplicatedEntityReferenceProperties(e, t) {
    const s = this.entity.script;
    for (const i in e._scriptsIndex) {
      const n = this.system.app.scripts.get(i);
      if (!n)
        continue;
      const a = e._scriptsIndex[i];
      if (!a || !a.instance)
        continue;
      const o = s[i].__attributesRaw, h = s[i].__attributes;
      if (!o && !h)
        continue;
      const l = !!o, c = a.instance.__attributes;
      for (const d in c) {
        if (!c[d])
          continue;
        const u = n.attributes.get(d);
        if (u) {
          if (u.type === "entity")
            this._resolveEntityScriptAttribute(u, d, c[d], l, o || h, t);
          else if (u.type === "json" && Array.isArray(u.schema)) {
            const f = c[d], m = o ? o[d] : h[d];
            for (let _ = 0; _ < u.schema.length; _++) {
              const p = u.schema[_];
              if (p.type === "entity")
                if (u.array)
                  for (let g = 0; g < f.length; g++)
                    this._resolveEntityScriptAttribute(p, p.name, f[g][p.name], l, m[g], t);
                else
                  this._resolveEntityScriptAttribute(p, p.name, f[p.name], l, m, t);
            }
          }
        }
      }
    }
  }
  move(e, t) {
    const s = this._scripts.length;
    if (t >= s || t < 0)
      return !1;
    let i = e, n = e;
    typeof n != "string" ? n = e.__name : i = null;
    const a = this._scriptsIndex[n];
    if (!a || !a.instance)
      return !1;
    const o = a.instance;
    if (i && !(o instanceof i))
      return !1;
    const h = this._scripts.indexOf(o);
    return h === -1 || h === t ? !1 : (this._scripts.splice(t, 0, this._scripts.splice(h, 1)[0]), this._resetExecutionOrder(0, s), this._updateList.sort(), this._postUpdateList.sort(), this.fire("move", n, o, t, h), this.fire("move:" + n, o, t, h), !0);
  }
}
class OE {
  constructor() {
    this.enabled = !0;
  }
}
const kE = "_onInitializeAttributes", NE = "_onInitialize", zE = "_onPostInitialize", UE = "_onUpdate", VE = "_onPostUpdate";
let Jo = 0;
class GE extends Ye {
  constructor(e) {
    super(e), this.id = "script", this.ComponentType = FE, this.DataType = OE, this._components = new Ch({
      sortBy: "_executionOrder"
    }), this._enabledComponents = new Ch({
      sortBy: "_executionOrder"
    }), this.preloading = !0, this.on("beforeremove", this._onBeforeRemove, this), this.app.systems.on("initialize", this._onInitialize, this), this.app.systems.on("postInitialize", this._onPostInitialize, this), this.app.systems.on("update", this._onUpdate, this), this.app.systems.on("postUpdate", this._onPostUpdate, this);
  }
  initializeComponentData(e, t) {
    if (e._executionOrder = Jo++, this._components.append(e), Jo > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder(), e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0, e.enabled && e.entity.enabled && this._enabledComponents.append(e), t.hasOwnProperty("order") && t.hasOwnProperty("scripts")) {
      e._scriptsData = t.scripts;
      for (let s = 0; s < t.order.length; s++)
        e.create(t.order[s], {
          enabled: t.scripts[t.order[s]].enabled,
          attributes: t.scripts[t.order[s]].attributes,
          preloading: this.preloading
        });
    }
  }
  cloneComponent(e, t) {
    const s = [], i = {};
    for (let a = 0; a < e.script._scripts.length; a++) {
      const o = e.script._scripts[a], h = o.__scriptType.__name;
      s.push(h);
      const l = {};
      for (const c in o.__attributes)
        l[c] = o.__attributes[c];
      i[h] = {
        enabled: o._enabled,
        attributes: l
      };
    }
    for (const a in e.script._scriptsIndex)
      a.awaiting && s.splice(a.ind, 0, a);
    const n = {
      enabled: e.script.enabled,
      order: s,
      scripts: i
    };
    return this.addComponent(t, n);
  }
  _resetExecutionOrder() {
    Jo = 0;
    for (let e = 0, t = this._components.length; e < t; e++)
      this._components.items[e]._executionOrder = Jo++;
  }
  _callComponentMethod(e, t, s) {
    for (e.loopIndex = 0; e.loopIndex < e.length; e.loopIndex++)
      e.items[e.loopIndex][t](s);
  }
  _onInitialize() {
    this.preloading = !1, this._callComponentMethod(this._components, kE), this._callComponentMethod(this._enabledComponents, NE);
  }
  _onPostInitialize() {
    this._callComponentMethod(this._enabledComponents, zE);
  }
  _onUpdate(e) {
    this._callComponentMethod(this._enabledComponents, UE, e);
  }
  _onPostUpdate(e) {
    this._callComponentMethod(this._enabledComponents, VE, e);
  }
  _addComponentToEnabled(e) {
    this._enabledComponents.insert(e);
  }
  _removeComponentFromEnabled(e) {
    this._enabledComponents.remove(e);
  }
  _onBeforeRemove(e, t) {
    this._components.items.indexOf(t) >= 0 && t._onBeforeRemove(), this._removeComponentFromEnabled(t), this._components.remove(t);
  }
  destroy() {
    super.destroy(), this.app.systems.off("initialize", this._onInitialize, this), this.app.systems.off("postInitialize", this._onPostInitialize, this), this.app.systems.off("update", this._onUpdate, this), this.app.systems.off("postUpdate", this._onPostUpdate, this);
  }
}
class by extends _e {
  constructor() {
    super(), this._meshes = null;
  }
  set meshes(e) {
    this.decRefMeshes(), this._meshes = e, this.incRefMeshes(), this.fire("set:meshes", e);
  }
  get meshes() {
    return this._meshes;
  }
  destroy() {
    this.meshes = null;
  }
  decRefMeshes() {
    if (this._meshes) {
      const e = this._meshes.length;
      for (let t = 0; t < e; t++) {
        const s = this._meshes[t];
        s && (s.decRefCount(), s.refCount < 1 && (s.destroy(), this._meshes[t] = null));
      }
    }
  }
  incRefMeshes() {
    if (this._meshes) {
      const e = this._meshes.length;
      for (let t = 0; t < e; t++)
        this._meshes[t] && this._meshes[t].incRefCount();
    }
  }
}
function bh(r) {
  const e = this;
  if (!e.resource)
    return;
  const t = r.resource, s = t.renders && t.renders[e.data.renderIndex];
  s && (e.resource.meshes = s.resource.meshes);
}
function Rp(r) {
  const e = this;
  e.registry.off("load:" + r.id, bh, e), e.registry.on("load:" + r.id, bh, e), e.registry.off("remove:" + r.id, Lp, e), e.registry.once("remove:" + r.id, Lp, e), r.resource ? bh.call(e, r) : e.registry.load(r);
}
function Lp(r) {
  const e = this;
  e.registry.off("load:" + r.id, bh, e), e.resource && e.resource.destroy();
}
class HE {
  constructor(e) {
    this.handlerType = "render", this._registry = e.assets;
  }
  load(e, t, s) {
  }
  open(e, t) {
    return new by();
  }
  patch(e, t) {
    if (!e.data.containerAsset)
      return;
    const s = t.get(e.data.containerAsset);
    if (!s) {
      t.once("add:" + e.data.containerAsset, Rp, e);
      return;
    }
    Rp.call(e, s);
  }
}
class wy {
  constructor(e, t, s, i) {
    this._paths = e, this._input = t, this._output = s, this._interpolation = i;
  }
  get paths() {
    return this._paths;
  }
  get input() {
    return this._input;
  }
  get output() {
    return this._output;
  }
  get interpolation() {
    return this._interpolation;
  }
}
class dl {
  constructor(e, t) {
    this._components = e, this._data = t;
  }
  get components() {
    return this._components;
  }
  get data() {
    return this._data;
  }
}
class Ui {
  constructor(e, t, s, i) {
    const n = function(c, d, u) {
      const f = Ui.createAsset(t.name, c, d, u);
      return s.add(f), f;
    }, a = [];
    for (let l = 0; l < e.renders.length; ++l)
      a.push(n("render", e.renders[l], l));
    const o = [];
    for (let l = 0; l < e.materials.length; ++l)
      o.push(n("material", e.materials[l], l));
    const h = [];
    for (let l = 0; l < e.animations.length; ++l)
      h.push(n("animation", e.animations[l], l));
    this.data = e, this._model = null, this._assetName = t.name, this._assets = s, this._defaultMaterial = i, this.renders = a, this.materials = o, this.textures = e.textures, this.animations = h;
  }
  get model() {
    if (!this._model) {
      const e = Ui.createModel(this.data, this._defaultMaterial), t = Ui.createAsset(this._assetName, "model", e, 0);
      this._assets.add(t), this._model = t;
    }
    return this._model;
  }
  static createAsset(e, t, s, i) {
    const n = new ce(e + "/" + t + "/" + i, t, {
      url: ""
    });
    return n.resource = s, n.loaded = !0, n;
  }
  instantiateModelEntity(e) {
    const t = new oe();
    return t.addComponent("model", Object.assign({
      type: "asset",
      asset: this.model
    }, e)), t;
  }
  instantiateRenderEntity(e) {
    const t = this._defaultMaterial, s = [], i = function(h, l, c, d, u, f, m) {
      const _ = u[c.id], p = _ === void 0 ? t : d[_], g = new we(c, p);
      return c.morph && (g.morphInstance = new kn(c.morph)), m.hasOwnProperty("skin") && s.push({
        meshInstance: g,
        rootBone: h,
        entity: l
      }), g;
    }, n = (o, h, l) => {
      const c = new oe();
      h._cloneInternal(c), o || (o = c);
      let d = null, u = null;
      for (let _ = 0; _ < l.nodes.length; _++)
        if (l.nodes[_] === h) {
          const g = l.gltf.nodes[_];
          if (g.hasOwnProperty("mesh")) {
            const b = l.renders[g.mesh].meshes;
            u = this.renders[g.mesh];
            for (var f = 0; f < b.length; f++) {
              const x = b[f];
              if (x) {
                const y = i(o, c, x, l.materials, l.meshDefaultMaterials, l.skins, g);
                d || (d = []), d.push(y);
              }
            }
          }
          if (l.lights) {
            const b = l.lights.get(g);
            b && c.addChild(b.clone());
          }
          if (l.cameras) {
            const b = l.cameras.get(g);
            b && b.camera.system.cloneComponent(b, c);
          }
        }
      d && (c.addComponent("render", Object.assign({
        type: "asset",
        meshInstances: d,
        rootBone: o
      }, e)), c.render.assignAsset(u));
      const m = h.children;
      for (let _ = 0; _ < m.length; _++) {
        const p = n(o, m[_], l);
        c.addChild(p);
      }
      return c;
    }, a = [];
    for (const o of this.data.scenes)
      a.push(n(null, o, this.data));
    return s.forEach((o) => {
      o.meshInstance.skinInstance = ds.createCachedSkinInstance(o.meshInstance.mesh.skin, o.rootBone, o.entity);
    }), Ui.createSceneHierarchy(a, "Entity");
  }
  getMaterialVariants() {
    return this.data.variants ? Object.keys(this.data.variants) : [];
  }
  applyMaterialVariant(e, t) {
    const s = t ? this.data.variants[t] : null;
    if (s === void 0)
      return;
    const i = e.findComponents("render");
    for (let n = 0; n < i.length; n++) {
      const a = i[n];
      this._applyMaterialVariant(s, a.meshInstances);
    }
  }
  applyMaterialVariantInstances(e, t) {
    const s = t ? this.data.variants[t] : null;
    s !== void 0 && this._applyMaterialVariant(s, e);
  }
  _applyMaterialVariant(e, t) {
    t.forEach((s) => {
      if (e === null)
        s.material = this._defaultMaterial;
      else {
        const i = this.data.meshVariants[s.mesh.id];
        i && (s.material = this.data.materials[i[e]]);
      }
    });
  }
  static createSceneHierarchy(e, t) {
    let s = null;
    if (e.length === 1)
      s = e[0];
    else {
      s = new t("SceneGroup");
      for (const i of e)
        s.addChild(i);
    }
    return s;
  }
  static createModel(e, t) {
    const s = function(h, l, c, d, u, f, m) {
      const _ = e.meshDefaultMaterials[l.id], p = _ === void 0 ? t : u[_], g = new we(l, p, f);
      if (l.morph) {
        const b = new kn(l.morph);
        g.morphInstance = b, h.morphInstances.push(b);
      }
      if (m.hasOwnProperty("skin")) {
        const b = m.skin, x = c[b];
        l.skin = x;
        const y = d[b];
        g.skinInstance = y, h.skinInstances.push(y);
      }
      h.meshInstances.push(g);
    }, i = new Ti(), n = [];
    for (const o of e.skins) {
      const h = new no(o);
      h.bones = o.bones, n.push(h);
    }
    i.graph = Ui.createSceneHierarchy(e.scenes, "GraphNode");
    for (let o = 0; o < e.nodes.length; o++) {
      const h = e.nodes[o];
      if (h.root === i.graph) {
        const l = e.gltf.nodes[o];
        if (l.hasOwnProperty("mesh")) {
          const c = e.renders[l.mesh].meshes;
          for (var a = 0; a < c.length; a++) {
            const d = c[a];
            d && s(i, d, e.skins, n, e.materials, h, l);
          }
        }
      }
    }
    return i;
  }
  destroy() {
    const e = this._assets, t = function(n) {
      e.remove(n), n.unload();
    }, s = function(n) {
      n.forEach(function(a) {
        t(a);
      });
    };
    this.animations && (s(this.animations), this.animations = null), this.textures && (s(this.textures), this.textures = null), this.materials && (s(this.materials), this.materials = null), this.renders && (s(this.renders), this.renders = null), this._model && (t(this._model), this._model = null), this.data = null, this.assets = null;
  }
}
let iu = null;
const Ty = () => typeof window < "u" && window.DracoDecoderModule;
class WE {
  constructor(e) {
    this.gltf = e, this.nodes = null, this.scenes = null, this.animations = null, this.textures = null, this.materials = null, this.variants = null, this.meshVariants = null, this.meshDefaultMaterials = null, this.renders = null, this.skins = null, this.lights = null, this.cameras = null;
  }
  destroy() {
    this.renders && this.renders.forEach((e) => {
      e.meshes = null;
    });
  }
}
const Cy = function(e) {
  return /^data:.*,.*$/i.test(e);
}, qE = function(e) {
  return e.substring(e.indexOf(":") + 1, e.indexOf(";"));
}, ul = function(e) {
  switch (e) {
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
      return 4;
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
    default:
      return 3;
  }
}, Zu = function(e) {
  switch (e) {
    case 5120:
      return Nl;
    case 5121:
      return gi;
    case 5122:
      return zl;
    case 5123:
      return Bn;
    case 5124:
      return L_;
    case 5125:
      return P_;
    case 5126:
      return Ie;
    default:
      return 0;
  }
}, XE = function(e) {
  switch (e) {
    case 5120:
      return 1;
    case 5121:
      return 1;
    case 5122:
      return 2;
    case 5123:
      return 2;
    case 5124:
      return 4;
    case 5125:
      return 4;
    case 5126:
      return 4;
    default:
      return 0;
  }
}, jE = function(e) {
  switch (e) {
    case 5120:
      return Int8Array;
    case 5121:
      return Uint8Array;
    case 5122:
      return Int16Array;
    case 5123:
      return Uint16Array;
    case 5124:
      return Int32Array;
    case 5125:
      return Uint32Array;
    case 5126:
      return Float32Array;
    default:
      return null;
  }
}, fl = {
  POSITION: et,
  NORMAL: Gt,
  TANGENT: qs,
  COLOR_0: It,
  JOINTS_0: ts,
  WEIGHTS_0: Xs,
  TEXCOORD_0: rs,
  TEXCOORD_1: Zi,
  TEXCOORD_2: Pl,
  TEXCOORD_3: Il,
  TEXCOORD_4: Dl,
  TEXCOORD_5: Bl,
  TEXCOORD_6: Fl,
  TEXCOORD_7: Ol
}, $E = (r) => {
  switch (r) {
    case Nl:
      return (e) => Math.max(e / 127, -1);
    case gi:
      return (e) => e / 255;
    case zl:
      return (e) => Math.max(e / 32767, -1);
    case Bn:
      return (e) => e / 65535;
    default:
      return (e) => e;
  }
}, nu = function(e, t, s) {
  const i = $E(s), n = t.length;
  for (let a = 0; a < n; ++a)
    e[a] = i(t[a]);
  return e;
}, Jl = function r(e, t, s = !1) {
  const i = ul(e.type), n = jE(e.componentType);
  if (!n)
    return null;
  const a = t[e.bufferView];
  let o;
  if (e.sparse) {
    const h = e.sparse, l = {
      count: h.count,
      type: "SCALAR"
    }, c = r(Object.assign(l, h.indices), t, !0), d = {
      count: h.count,
      type: e.type,
      componentType: e.componentType
    }, u = r(Object.assign(d, h.values), t, !0);
    if (e.hasOwnProperty("bufferView")) {
      const f = {
        bufferView: e.bufferView,
        byteOffset: e.byteOffset,
        componentType: e.componentType,
        count: e.count,
        type: e.type
      };
      o = r(f, t, !0).slice();
    } else
      o = new n(e.count * i);
    for (let f = 0; f < h.count; ++f) {
      const m = c[f];
      for (let _ = 0; _ < i; ++_)
        o[m * i + _] = u[f * i + _];
    }
  } else if (s && a.hasOwnProperty("byteStride")) {
    const h = i * n.BYTES_PER_ELEMENT, l = new ArrayBuffer(e.count * h), c = new Uint8Array(l);
    let d = 0;
    for (let u = 0; u < e.count; ++u) {
      let f = (e.byteOffset || 0) + u * a.byteStride;
      for (let m = 0; m < h; ++m)
        c[d++] = a[f++];
    }
    o = new n(l);
  } else
    o = new n(a.buffer, a.byteOffset + (e.byteOffset || 0), e.count * i);
  return o;
}, ru = function(e, t) {
  const s = Jl(e, t, !0);
  if (s instanceof Float32Array || !e.normalized)
    return s;
  const i = new Float32Array(s.length);
  return nu(i, s, Zu(e.componentType)), i;
}, Pp = function(e) {
  let t = e.min, s = e.max;
  if (!t || !s)
    return null;
  if (e.normalized) {
    const i = Zu(e.componentType);
    t = nu([], t, i), s = nu([], s, i);
  }
  return new Pe(new v((s[0] + t[0]) * 0.5, (s[1] + t[1]) * 0.5, (s[2] + t[2]) * 0.5), new v((s[0] - t[0]) * 0.5, (s[1] - t[1]) * 0.5, (s[2] - t[2]) * 0.5));
}, YE = function(e) {
  if (!e.hasOwnProperty("mode"))
    return Es;
  switch (e.mode) {
    case 0:
      return so;
    case 1:
      return Ll;
    case 2:
      return T_;
    case 3:
      return C_;
    case 4:
      return Es;
    case 5:
      return jr;
    case 6:
      return Dn;
    default:
      return Es;
  }
}, KE = function(e) {
  const t = new Uint16Array(e);
  for (let s = 0; s < e; s++)
    t[s] = s;
  return t;
}, Ay = function(e, t) {
  const s = e[et];
  if (!s || s.components !== 3)
    return;
  let i;
  if (s.size !== s.stride) {
    const h = s.stride / Bh[s.type], l = new Ar[s.type](s.buffer, s.offset, s.count * h);
    i = new Ar[s.type](s.count * 3);
    for (let c = 0; c < s.count; ++c)
      i[c * 3 + 0] = l[c * h + 0], i[c * 3 + 1] = l[c * h + 1], i[c * 3 + 2] = l[c * h + 2];
  } else
    i = new Ar[s.type](s.buffer, s.offset, s.count * 3);
  const n = s.count;
  t || (t = KE(n));
  const a = Bv(i, t), o = new Float32Array(a.length);
  o.set(a), e[Gt] = {
    buffer: o.buffer,
    size: 12,
    offset: 0,
    stride: 12,
    count: n,
    components: 3,
    type: Ie
  };
}, ZE = function(e) {
  let t, s;
  const i = [], n = [], a = [];
  for (t = 0; t < e.format.elements.length; ++t) {
    const h = e.format.elements[t];
    if (h.name === rs || h.name === Zi)
      switch (h.dataType) {
        case Ie:
          i.push({
            offset: h.offset / 4 + 1,
            stride: h.stride / 4
          });
          break;
        case Bn:
          n.push({
            offset: h.offset / 2 + 1,
            stride: h.stride / 2
          });
          break;
        case gi:
          a.push({
            offset: h.offset + 1,
            stride: h.stride
          });
          break;
      }
  }
  const o = function(l, c, d) {
    const u = new c(e.storage);
    for (t = 0; t < l.length; ++t) {
      let f = l[t].offset;
      const m = l[t].stride;
      for (s = 0; s < e.numVertices; ++s)
        u[f] = d - u[f], f += m;
    }
  };
  i.length > 0 && o(i, Float32Array, 1), n.length > 0 && o(n, Uint16Array, 65535), a.length > 0 && o(a, Uint8Array, 255);
}, JE = function(e) {
  const t = function(n) {
    const a = [];
    for (let o = 0; o < n._levels.length; ++o) {
      let h = [];
      if (n.cubemap)
        for (let l = 0; l < 6; ++l)
          h.push(n._levels[o][l]);
      else
        h = n._levels[o];
      a.push(h);
    }
    return a;
  }, s = new ue(e.device, e);
  return s._levels = t(e), s;
}, QE = function(e) {
  const t = new ce(e.name + "_clone", e.type, e.file, e.data, e.options);
  return t.loaded = !0, t.resource = JE(e.resource), e.registry.add(t), t;
}, My = function(e, t, s) {
  const i = t[et];
  if (!i)
    return null;
  const n = i.count, a = [];
  for (const y in t)
    t.hasOwnProperty(y) && a.push({
      semantic: y,
      components: t[y].components,
      type: t[y].type,
      normalize: !!t[y].normalize
    });
  const o = [et, Gt, qs, It, ts, Xs, rs, Zi];
  a.sort(function(y, S) {
    const C = o.indexOf(y.semantic), w = o.indexOf(S.semantic);
    return C < w ? -1 : w < C ? 1 : 0;
  });
  let h, l, c, d, u, f;
  const m = new Ot(e, a);
  let _ = !0;
  for (h = 0; h < m.elements.length; ++h)
    if (u = m.elements[h], d = t[u.name], f = d.offset - i.offset, d.buffer !== i.buffer || d.stride !== u.stride || d.size !== u.size || f !== u.offset) {
      _ = !1;
      break;
    }
  const p = new yi(e, m, n, ns), g = p.lock(), b = new Uint32Array(g);
  let x;
  if (_)
    x = new Uint32Array(i.buffer, i.offset, n * p.format.size / 4), b.set(x);
  else {
    let y, S;
    for (h = 0; h < p.format.elements.length; ++h) {
      u = p.format.elements[h], y = u.stride / 4, d = t[u.name], S = d.stride / 4, x = new Uint32Array(d.buffer, d.offset, (d.count - 1) * S + (d.size + 3) / 4);
      let C = 0, w = u.offset / 4;
      const M = Math.floor((d.size + 3) / 4);
      for (l = 0; l < n; ++l) {
        for (c = 0; c < M; ++c)
          b[w + c] = x[C + c];
        C += S, w += y;
      }
    }
  }
  return s && ZE(p), p.unlock(), p;
}, eR = function(e, t, s, i, n, a, o) {
  const h = {}, l = [];
  for (const u in t)
    t.hasOwnProperty(u) && fl.hasOwnProperty(u) && (h[u] = t[u], l.push(u + ":" + t[u]));
  l.sort();
  const c = l.join();
  let d = o[c];
  if (!d) {
    const u = {};
    for (const f in h) {
      const m = i[t[f]], _ = Jl(m, n), p = n[m.bufferView], g = fl[f], b = ul(m.type) * XE(m.componentType), x = p.hasOwnProperty("byteStride") ? p.byteStride : b;
      u[g] = {
        buffer: _.buffer,
        size: b,
        offset: _.byteOffset,
        stride: x,
        count: m.count,
        components: ul(m.type),
        type: Zu(m.componentType),
        normalize: m.normalized
      };
    }
    u.hasOwnProperty(Gt) || Ay(u, s), d = My(e, u, a), o[c] = d;
  }
  return d;
}, tR = function(e, t, s, i, n, a, o) {
  const h = t.num_points(), l = function(f, m) {
    const _ = i.GetAttributeByUniqueId(t, f), p = h * _.num_components(), g = _.data_type();
    let b, x, y, S;
    switch (g) {
      case n.DT_UINT8:
        S = gi, y = 1, b = n._malloc(p * y), i.GetAttributeDataArrayForAllPoints(t, _, n.DT_UINT8, p * y, b), x = new Uint8Array(n.HEAPU8.buffer, b, p).slice();
        break;
      case n.DT_UINT16:
        S = Bn, y = 2, b = n._malloc(p * y), i.GetAttributeDataArrayForAllPoints(t, _, n.DT_UINT16, p * y, b), x = new Uint16Array(n.HEAPU16.buffer, b, p).slice();
        break;
      case n.DT_FLOAT32:
      default:
        S = Ie, y = 4, b = n._malloc(p * y), i.GetAttributeDataArrayForAllPoints(t, _, n.DT_FLOAT32, p * y, b), x = new Float32Array(n.HEAPF32.buffer, b, p).slice();
        break;
    }
    return n._free(b), {
      values: x,
      numComponents: _.num_components(),
      componentSizeInBytes: y,
      storageType: S,
      normalized: m === It && (S === gi || S === Bn) ? !0 : _.normalized()
    };
  }, c = {}, d = s.attributes;
  for (const u in d)
    if (d.hasOwnProperty(u) && fl.hasOwnProperty(u)) {
      const f = fl[u], m = l(d[u], f), _ = m.numComponents * m.componentSizeInBytes;
      c[f] = {
        values: m.values,
        buffer: m.values.buffer,
        size: _,
        offset: 0,
        stride: _,
        count: h,
        components: m.numComponents,
        type: m.storageType,
        normalize: m.normalized
      };
    }
  return c.hasOwnProperty(Gt) || Ay(c, a), My(e, c, o);
}, sR = function(e, t, s, i, n, a) {
  let o, h, l;
  const c = t.joints, d = c.length, u = [];
  if (t.hasOwnProperty("inverseBindMatrices")) {
    const p = t.inverseBindMatrices, g = Jl(s[p], i, !0), b = [];
    for (o = 0; o < d; o++) {
      for (h = 0; h < 16; h++)
        b[h] = g[o * 16 + h];
      l = new j(), l.set(b), u.push(l);
    }
  } else
    for (o = 0; o < d; o++)
      l = new j(), u.push(l);
  const f = [];
  for (o = 0; o < d; o++)
    f[o] = n[c[o]].name;
  const m = f.join("#");
  let _ = a.get(m);
  return _ || (_ = new yg(e, u, f), a.set(m, _)), _;
}, Qo = new j(), dr = new v(), iR = function(e, t, s, i, n, a, o, h, l, c) {
  const d = [];
  return t.primitives.forEach(function(u) {
    let f, m, _, p = null, g = !0;
    if (u.hasOwnProperty("extensions")) {
      const x = u.extensions;
      if (x.hasOwnProperty("KHR_draco_mesh_compression")) {
        const y = iu || Ty();
        if (y) {
          const S = x.KHR_draco_mesh_compression;
          if (S.hasOwnProperty("attributes")) {
            const C = i[S.bufferView], w = new y.DecoderBuffer();
            w.Init(C, C.length);
            const M = new y.Decoder(), T = M.GetEncodedGeometryType(w);
            let A, L;
            switch (T) {
              case y.POINT_CLOUD:
                f = so, A = new y.PointCloud(), L = M.DecodeBufferToPointCloud(w, A);
                break;
              case y.TRIANGULAR_MESH:
                f = Es, A = new y.Mesh(), L = M.DecodeBufferToMesh(w, A);
                break;
              case y.INVALID_GEOMETRY_TYPE:
            }
            if (!L || !L.ok() || A.ptr === 0) {
              n("Failed to decode draco compressed asset: " + (L ? L.error_msg() : "Mesh asset - invalid draco compressed geometry type: " + T));
              return;
            }
            const O = A.num_faces();
            if (T === y.TRIANGULAR_MESH) {
              const I = A.num_points() > 65535;
              _ = O * 3;
              const D = _ * (I ? 4 : 2), G = y._malloc(D);
              I ? (M.GetTrianglesUInt32Array(A, D, G), p = new Uint32Array(y.HEAPU32.buffer, G, _).slice()) : (M.GetTrianglesUInt16Array(A, D, G), p = new Uint16Array(y.HEAPU16.buffer, G, _).slice()), y._free(G);
            }
            m = tR(e, A, S, M, y, p, a), y.destroy(A), y.destroy(M), y.destroy(w), g = !1;
          }
        }
      }
    }
    m || (p = u.hasOwnProperty("indices") ? Jl(s[u.indices], i, !0) : null, m = eR(e, u.attributes, p, s, i, a, o), f = YE(u));
    let b = null;
    if (m) {
      if (b = new _s(e), b.vertexBuffer = m, b.primitive[0].type = f, b.primitive[0].base = 0, b.primitive[0].indexed = p !== null, p !== null) {
        let y;
        p instanceof Uint8Array ? y = v_ : p instanceof Uint16Array ? y = pi : y = Pn, y === Pn && !e.extUintElement && (y = pi, p = new Uint16Array(p));
        const S = new ji(e, y, p.length, ns, p);
        b.indexBuffer[0] = S, b.primitive[0].count = p.length;
      } else
        b.primitive[0].count = m.numVertices;
      if (u.hasOwnProperty("extensions") && u.extensions.hasOwnProperty("KHR_materials_variants")) {
        const y = u.extensions.KHR_materials_variants, S = {};
        y.mappings.forEach((C) => {
          C.variants.forEach((w) => {
            S[w] = C.material;
          });
        }), h[b.id] = S;
      }
      l[b.id] = u.material;
      let x = s[u.attributes.POSITION];
      if (b.aabb = Pp(x), g && u.hasOwnProperty("targets")) {
        const y = [];
        u.targets.forEach(function(S, C) {
          const w = {};
          S.hasOwnProperty("POSITION") && (x = s[S.POSITION], w.deltaPositions = ru(x, i), w.deltaPositionsType = Ie, w.aabb = Pp(x)), S.hasOwnProperty("NORMAL") && (x = s[S.NORMAL], w.deltaNormals = ru(x, i), w.deltaNormalsType = Ie), t.hasOwnProperty("extras") && t.extras.hasOwnProperty("targetNames") ? w.name = t.extras.targetNames[C] : w.name = C.toString(10), t.hasOwnProperty("weights") && (w.defaultWeight = t.weights[C]), w.preserveData = c.morphPreserveData, y.push(new $l(w));
        }), b.morph = new _g(y, e);
      }
    }
    d.push(b);
  }), d;
}, yt = function(e, t, s) {
  var i;
  let n;
  const a = e.texCoord;
  if (a)
    for (n = 0; n < s.length; ++n)
      t[s[n] + "MapUv"] = a;
  const o = [0, 0], h = [1, 1], l = (i = e.extensions) == null ? void 0 : i.KHR_texture_transform;
  if (l) {
    const c = l.offset || o, d = l.scale || h, u = l.rotation ? -l.rotation * U.RAD_TO_DEG : 0, f = new q(d[0], d[1]), m = new q(c[0], 1 - d[1] - c[1]);
    for (n = 0; n < s.length; ++n)
      t[`${s[n]}MapTiling`] = f, t[`${s[n]}MapOffset`] = m, t[`${s[n]}MapRotation`] = u;
  }
}, nR = function(e, t, s) {
  let i, n;
  if (e.hasOwnProperty("diffuseFactor") ? (i = e.diffuseFactor, t.diffuse.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2)), t.opacity = i[3]) : (t.diffuse.set(1, 1, 1), t.opacity = 1), e.hasOwnProperty("diffuseTexture")) {
    const a = e.diffuseTexture;
    n = s[a.index], t.diffuseMap = n, t.diffuseMapChannel = "rgb", t.opacityMap = n, t.opacityMapChannel = "a", yt(a, t, ["diffuse", "opacity"]);
  }
  if (t.useMetalness = !1, e.hasOwnProperty("specularFactor") ? (i = e.specularFactor, t.specular.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2))) : t.specular.set(1, 1, 1), e.hasOwnProperty("glossinessFactor") ? t.gloss = e.glossinessFactor : t.gloss = 1, e.hasOwnProperty("specularGlossinessTexture")) {
    const a = e.specularGlossinessTexture;
    t.specularEncoding = "srgb", t.specularMap = t.glossMap = s[a.index], t.specularMapChannel = "rgb", t.glossMapChannel = "a", yt(a, t, ["gloss", "metalness"]);
  }
}, rR = function(e, t, s) {
  if (e.hasOwnProperty("clearcoatFactor") ? t.clearCoat = e.clearcoatFactor * 0.25 : t.clearCoat = 0, e.hasOwnProperty("clearcoatTexture")) {
    const i = e.clearcoatTexture;
    t.clearCoatMap = s[i.index], t.clearCoatMapChannel = "r", yt(i, t, ["clearCoat"]);
  }
  if (e.hasOwnProperty("clearcoatRoughnessFactor") ? t.clearCoatGloss = e.clearcoatRoughnessFactor : t.clearCoatGloss = 0, e.hasOwnProperty("clearcoatRoughnessTexture")) {
    const i = e.clearcoatRoughnessTexture;
    t.clearCoatGlossMap = s[i.index], t.clearCoatGlossMapChannel = "g", yt(i, t, ["clearCoatGloss"]);
  }
  if (e.hasOwnProperty("clearcoatNormalTexture")) {
    const i = e.clearcoatNormalTexture;
    t.clearCoatNormalMap = s[i.index], yt(i, t, ["clearCoatNormal"]), i.hasOwnProperty("scale") && (t.clearCoatBumpiness = i.scale);
  }
  t.clearCoatGlossInvert = !0;
}, aR = function(e, t, s) {
  t.useLighting = !1, t.emissive.copy(t.diffuse), t.emissiveTint = t.diffuseTint, t.emissiveMap = t.diffuseMap, t.emissiveMapUv = t.diffuseMapUv, t.emissiveMapTiling.copy(t.diffuseMapTiling), t.emissiveMapOffset.copy(t.diffuseMapOffset), t.emissiveMapRotation = t.diffuseMapRotation, t.emissiveMapChannel = t.diffuseMapChannel, t.emissiveVertexColor = t.diffuseVertexColor, t.emissiveVertexColorChannel = t.diffuseVertexColorChannel, t.diffuse.set(0, 0, 0), t.diffuseTint = !1, t.diffuseMap = null, t.diffuseVertexColor = !1;
}, oR = function(e, t, s) {
  if (t.useMetalnessSpecularColor = !0, e.hasOwnProperty("specularColorTexture") && (t.specularEncoding = "srgb", t.specularMap = s[e.specularColorTexture.index], t.specularMapChannel = "rgb", yt(e.specularColorTexture, t, ["specular"])), e.hasOwnProperty("specularColorFactor")) {
    const i = e.specularColorFactor;
    t.specular.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2));
  } else
    t.specular.set(1, 1, 1);
  e.hasOwnProperty("specularFactor") ? t.specularityFactor = e.specularFactor : t.specularityFactor = 1, e.hasOwnProperty("specularTexture") && (t.specularityFactorMapChannel = "a", t.specularityFactorMap = s[e.specularTexture.index], yt(e.specularTexture, t, ["specularityFactor"]));
}, hR = function(e, t, s) {
  e.hasOwnProperty("ior") && (t.refractionIndex = 1 / e.ior);
}, lR = function(e, t, s) {
  t.blendType = Vt, t.useDynamicRefraction = !0, e.hasOwnProperty("transmissionFactor") && (t.refraction = e.transmissionFactor), e.hasOwnProperty("transmissionTexture") && (t.refractionMapChannel = "r", t.refractionMap = s[e.transmissionTexture.index], yt(e.transmissionTexture, t, ["refraction"]));
}, cR = function(e, t, s) {
  if (t.useSheen = !0, e.hasOwnProperty("sheenColorFactor")) {
    const i = e.sheenColorFactor;
    t.sheen.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2));
  } else
    t.sheen.set(1, 1, 1);
  e.hasOwnProperty("sheenColorTexture") && (t.sheenMap = s[e.sheenColorTexture.index], t.sheenEncoding = "srgb", yt(e.sheenColorTexture, t, ["sheen"])), e.hasOwnProperty("sheenRoughnessFactor") ? t.sheenGloss = e.sheenRoughnessFactor : t.sheenGloss = 0, e.hasOwnProperty("sheenRoughnessTexture") && (t.sheenGlossMap = s[e.sheenRoughnessTexture.index], t.sheenGlossMapChannel = "a", yt(e.sheenRoughnessTexture, t, ["sheenGloss"])), t.sheenGlossInvert = !0;
}, dR = function(e, t, s) {
  if (t.blendType = Vt, t.useDynamicRefraction = !0, e.hasOwnProperty("thicknessFactor") && (t.thickness = e.thicknessFactor), e.hasOwnProperty("thicknessTexture") && (t.thicknessMap = s[e.thicknessTexture.index], t.thicknessMapChannel = "g", yt(e.thicknessTexture, t, ["thickness"])), e.hasOwnProperty("attenuationDistance") && (t.attenuationDistance = e.attenuationDistance), e.hasOwnProperty("attenuationColor")) {
    const i = e.attenuationColor;
    t.attenuation.set(Math.pow(i[0], 1 / 2.2), Math.pow(i[1], 1 / 2.2), Math.pow(i[2], 1 / 2.2));
  }
}, uR = function(e, t, s) {
  e.hasOwnProperty("emissiveStrength") && (t.emissiveIntensity = e.emissiveStrength);
}, fR = function(e, t, s) {
  t.useIridescence = !0, e.hasOwnProperty("iridescenceFactor") && (t.iridescence = e.iridescenceFactor), e.hasOwnProperty("iridescenceTexture") && (t.iridescenceMapChannel = "r", t.iridescenceMap = s[e.iridescenceTexture.index], yt(e.iridescenceTexture, t, ["iridescence"])), e.hasOwnProperty("iridescenceIor") && (t.iridescenceRefractionIndex = e.iridescenceIor), e.hasOwnProperty("iridescenceThicknessMinimum") && (t.iridescenceThicknessMin = e.iridescenceThicknessMinimum), e.hasOwnProperty("iridescenceThicknessMaximum") && (t.iridescenceThicknessMax = e.iridescenceThicknessMaximum), e.hasOwnProperty("iridescenceThicknessTexture") && (t.iridescenceThicknessMapChannel = "g", t.iridescenceThicknessMap = s[e.iridescenceThicknessTexture.index], yt(e.iridescenceThicknessTexture, t, ["iridescenceThickness"]));
}, Ey = function(e, t, s) {
  const i = new Ht();
  i.occludeSpecular = ja, i.diffuseTint = !0, i.diffuseVertexColor = !0, i.specularTint = !0, i.specularVertexColor = !0, e.hasOwnProperty("name") && (i.name = e.name);
  let n, a;
  if (e.hasOwnProperty("pbrMetallicRoughness")) {
    const h = e.pbrMetallicRoughness;
    if (h.hasOwnProperty("baseColorFactor") ? (n = h.baseColorFactor, i.diffuse.set(Math.pow(n[0], 1 / 2.2), Math.pow(n[1], 1 / 2.2), Math.pow(n[2], 1 / 2.2)), i.opacity = n[3]) : (i.diffuse.set(1, 1, 1), i.opacity = 1), h.hasOwnProperty("baseColorTexture")) {
      const l = h.baseColorTexture;
      a = t[l.index], i.diffuseMap = a, i.diffuseMapChannel = "rgb", i.opacityMap = a, i.opacityMapChannel = "a", yt(l, i, ["diffuse", "opacity"]);
    }
    if (i.useMetalness = !0, i.specular.set(1, 1, 1), h.hasOwnProperty("metallicFactor") ? i.metalness = h.metallicFactor : i.metalness = 1, h.hasOwnProperty("roughnessFactor") ? i.gloss = h.roughnessFactor : i.gloss = 1, i.glossInvert = !0, h.hasOwnProperty("metallicRoughnessTexture")) {
      const l = h.metallicRoughnessTexture;
      i.metalnessMap = i.glossMap = t[l.index], i.metalnessMapChannel = "b", i.glossMapChannel = "g", yt(l, i, ["gloss", "metalness"]);
    }
  }
  if (e.hasOwnProperty("normalTexture")) {
    const h = e.normalTexture;
    i.normalMap = t[h.index], yt(h, i, ["normal"]), h.hasOwnProperty("scale") && (i.bumpiness = h.scale);
  }
  if (e.hasOwnProperty("occlusionTexture")) {
    const h = e.occlusionTexture;
    i.aoMap = t[h.index], i.aoMapChannel = "r", yt(h, i, ["ao"]);
  }
  if (e.hasOwnProperty("emissiveFactor") ? (n = e.emissiveFactor, i.emissive.set(Math.pow(n[0], 1 / 2.2), Math.pow(n[1], 1 / 2.2), Math.pow(n[2], 1 / 2.2)), i.emissiveTint = !0) : (i.emissive.set(0, 0, 0), i.emissiveTint = !1), e.hasOwnProperty("emissiveTexture")) {
    const h = e.emissiveTexture;
    i.emissiveMap = t[h.index], yt(h, i, ["emissive"]);
  }
  if (e.hasOwnProperty("alphaMode"))
    switch (e.alphaMode) {
      case "MASK":
        i.blendType = ss, e.hasOwnProperty("alphaCutoff") ? i.alphaTest = e.alphaCutoff : i.alphaTest = 0.5;
        break;
      case "BLEND":
        i.blendType = Vt, i.depthWrite = !1;
        break;
      default:
      case "OPAQUE":
        i.blendType = ss;
        break;
    }
  else
    i.blendType = ss;
  e.hasOwnProperty("doubleSided") ? (i.twoSidedLighting = e.doubleSided, i.cull = e.doubleSided ? Ft : Br) : (i.twoSidedLighting = !1, i.cull = Br);
  const o = {
    KHR_materials_clearcoat: rR,
    KHR_materials_emissive_strength: uR,
    KHR_materials_ior: hR,
    KHR_materials_iridescence: fR,
    KHR_materials_pbrSpecularGlossiness: nR,
    KHR_materials_sheen: cR,
    KHR_materials_specular: oR,
    KHR_materials_transmission: lR,
    KHR_materials_unlit: aR,
    KHR_materials_volume: dR
  };
  if (e.hasOwnProperty("extensions"))
    for (const h in e.extensions) {
      const l = o[h];
      l !== void 0 && l(e.extensions[h], i, t);
    }
  return i.update(), i;
}, mR = function(e, t, s, i, n, a, o) {
  const h = function(L) {
    return new dl(ul(L.type), ru(L, i));
  }, l = {
    STEP: Ag,
    LINEAR: kd,
    CUBICSPLINE: Nd
  }, c = {}, d = {}, u = {};
  let f = 1, m;
  for (m = 0; m < e.samplers.length; ++m) {
    const A = e.samplers[m];
    c.hasOwnProperty(A.input) || (c[A.input] = h(s[A.input])), d.hasOwnProperty(A.output) || (d[A.output] = h(s[A.output]));
    const L = A.hasOwnProperty("interpolation") && l.hasOwnProperty(A.interpolation) ? l[A.interpolation] : kd, O = {
      paths: [],
      input: A.input,
      output: A.output,
      interpolation: L
    };
    u[m] = O;
  }
  const _ = [], p = {
    translation: "localPosition",
    rotation: "localRotation",
    scale: "localScale"
  }, g = (A) => {
    const L = [];
    for (; A; )
      L.unshift(A.name), A = A.parent;
    return L;
  }, b = (A, L) => {
    if (a && a[A.mesh]) {
      const O = a[A.mesh];
      if (O.hasOwnProperty("extras") && O.extras.hasOwnProperty("targetNames") && O.extras.targetNames[L])
        return `name.${O.extras.targetNames[L]}`;
    }
    return L;
  }, x = (A, L, O) => {
    const I = d[A.output];
    if (!I)
      return;
    const D = I.data, G = D.length / c[A.input].data.length, X = D.length / G;
    for (let E = 0; E < G; E++) {
      const P = new Float32Array(X);
      for (let H = 0; H < X; H++)
        P[H] = D[H * G + E];
      const B = new dl(1, P);
      d[-f] = B;
      const k = {
        paths: [{
          entityPath: O,
          component: "graph",
          propertyPath: [`weight.${b(L, E)}`]
        }],
        input: A.input,
        output: -f,
        interpolation: A.interpolation
      };
      f++, u[`morphCurve-${m}-${E}`] = k;
    }
  };
  for (m = 0; m < e.channels.length; ++m) {
    const A = e.channels[m], L = A.target, O = u[A.sampler], I = n[L.node], D = o[L.node], G = g(I);
    L.path.startsWith("weights") ? (x(O, D, G), u[A.sampler].morphCurve = !0) : O.paths.push({
      entityPath: G,
      component: "graph",
      propertyPath: [p[L.path]]
    });
  }
  const y = [], S = [], C = [];
  for (const A in c)
    y.push(c[A]), c[A] = y.length - 1;
  for (const A in d)
    S.push(d[A]), d[A] = S.length - 1;
  for (const A in u) {
    const L = u[A];
    L.morphCurve || (C.push(new wy(L.paths, c[L.input], d[L.output], L.interpolation)), L.paths.length > 0 && L.paths[0].propertyPath[0] === "localRotation" && L.interpolation !== Nd && _.push(C[C.length - 1].output));
  }
  _.sort();
  let w = null, M;
  for (m = 0; m < _.length; ++m) {
    const A = _[m];
    if (m === 0 || A !== w) {
      if (M = S[A], M.components === 4) {
        const L = M.data, O = L.length - 4;
        for (let I = 0; I < O; I += 4)
          L[I + 0] * L[I + 4] + L[I + 1] * L[I + 5] + L[I + 2] * L[I + 6] + L[I + 3] * L[I + 7] < 0 && (L[I + 4] *= -1, L[I + 5] *= -1, L[I + 6] *= -1, L[I + 7] *= -1);
      }
      w = A;
    }
  }
  let T = 0;
  for (m = 0; m < y.length; m++)
    M = y[m]._data, T = Math.max(T, M.length === 0 ? 0 : M[M.length - 1]);
  return new Yl(e.hasOwnProperty("name") ? e.name : "animation_" + t, T, y, S, C);
}, pR = function(e, t) {
  const s = new bt();
  if (e.hasOwnProperty("name") && e.name.length > 0 ? s.name = e.name : s.name = "node_" + t, e.hasOwnProperty("matrix") && (Qo.data.set(e.matrix), Qo.getTranslation(dr), s.setLocalPosition(dr), Qo.getEulerAngles(dr), s.setLocalEulerAngles(dr), Qo.getScale(dr), s.setLocalScale(dr)), e.hasOwnProperty("rotation")) {
    const i = e.rotation;
    s.setLocalRotation(i[0], i[1], i[2], i[3]);
  }
  if (e.hasOwnProperty("translation")) {
    const i = e.translation;
    s.setLocalPosition(i[0], i[1], i[2]);
  }
  if (e.hasOwnProperty("scale")) {
    const i = e.scale;
    s.setLocalScale(i[0], i[1], i[2]);
  }
  return s;
}, _R = function(e, t) {
  const s = e.type === "orthographic" ? Mr : Bs, i = s === Mr ? e.orthographic : e.perspective, n = {
    enabled: !1,
    projection: s,
    nearClip: i.znear,
    aspectRatioMode: ku
  };
  i.zfar && (n.farClip = i.zfar), s === Mr ? (n.orthoHeight = 0.5 * i.ymag, i.ymag && (n.aspectRatioMode = Ld, n.aspectRatio = i.xmag / i.ymag)) : (n.fov = i.yfov * U.RAD_TO_DEG, i.aspectRatio && (n.aspectRatioMode = Ld, n.aspectRatio = i.aspectRatio));
  const a = new oe(e.name);
  return a.addComponent("camera", n), a;
}, gR = function(e, t) {
  const s = {
    enabled: !1,
    type: e.type === "point" ? "omni" : e.type,
    color: e.hasOwnProperty("color") ? new z(e.color) : z.WHITE,
    range: e.hasOwnProperty("range") ? e.range : 9999,
    falloffMode: uv,
    intensity: e.hasOwnProperty("intensity") ? U.clamp(e.intensity, 0, 2) : 1
  };
  e.hasOwnProperty("spot") && (s.innerConeAngle = e.spot.hasOwnProperty("innerConeAngle") ? e.spot.innerConeAngle * U.RAD_TO_DEG : 0, s.outerConeAngle = e.spot.hasOwnProperty("outerConeAngle") ? e.spot.outerConeAngle * U.RAD_TO_DEG : Math.PI / 4), e.hasOwnProperty("intensity") && (s.luminance = e.intensity * Ya.getLightUnitConversion(Dd[s.type], s.outerConeAngle, s.innerConeAngle));
  const i = new oe(t.name);
  return i.rotateLocal(90, 0, 0), i.addComponent("light", s), i;
}, yR = function(e, t, s, i) {
  if (!t.hasOwnProperty("skins") || t.skins.length === 0)
    return [];
  const n = /* @__PURE__ */ new Map();
  return t.skins.map(function(a) {
    return sR(e, a, t.accessors, i, s, n);
  });
}, xR = function(e, t, s, i, n, a, o, h) {
  if (!t.hasOwnProperty("meshes") || t.meshes.length === 0 || !t.hasOwnProperty("accessors") || t.accessors.length === 0 || !t.hasOwnProperty("bufferViews") || t.bufferViews.length === 0)
    return [];
  if (h.skipMeshes)
    return [];
  const l = {};
  return t.meshes.map(function(c) {
    return iR(e, c, t.accessors, s, i, n, l, a, o, h);
  });
}, vR = function(e, t, s, i) {
  if (!e.hasOwnProperty("materials") || e.materials.length === 0)
    return [];
  const n = s && s.material && s.material.preprocess, a = s && s.material && s.material.process || Ey, o = s && s.material && s.material.postprocess;
  return e.materials.map(function(h) {
    n && n(h);
    const l = a(h, t, i);
    return o && o(h, l), l;
  });
}, SR = function(e) {
  if (!e.hasOwnProperty("extensions") || !e.extensions.hasOwnProperty("KHR_materials_variants"))
    return null;
  const t = e.extensions.KHR_materials_variants.variants, s = {};
  for (let i = 0; i < t.length; i++)
    s[t[i].name] = i;
  return s;
}, bR = function(e, t, s, i) {
  if (!e.hasOwnProperty("animations") || e.animations.length === 0)
    return [];
  const n = i && i.animation && i.animation.preprocess, a = i && i.animation && i.animation.postprocess;
  return e.animations.map(function(o, h) {
    n && n(o);
    const l = mR(o, h, e.accessors, s, t, e.meshes, e.nodes);
    return a && a(o, l), l;
  });
}, wR = function(e, t) {
  if (!e.hasOwnProperty("nodes") || e.nodes.length === 0)
    return [];
  const s = t && t.node && t.node.preprocess, i = t && t.node && t.node.process || pR, n = t && t.node && t.node.postprocess, a = e.nodes.map(function(o, h) {
    s && s(o);
    const l = i(o, h);
    return n && n(o, l), l;
  });
  for (let o = 0; o < e.nodes.length; ++o) {
    const h = e.nodes[o];
    if (h.hasOwnProperty("children")) {
      const l = a[o], c = {};
      for (let d = 0; d < h.children.length; ++d) {
        const u = a[h.children[d]];
        u.parent || (c.hasOwnProperty(u.name) ? u.name += c[u.name]++ : c[u.name] = 1, l.addChild(u));
      }
    }
  }
  return a;
}, TR = function(e, t) {
  var s;
  const i = [], n = e.scenes.length;
  if (n === 1 && ((s = e.scenes[0].nodes) == null ? void 0 : s.length) === 1) {
    const a = e.scenes[0].nodes[0];
    i.push(t[a]);
  } else
    for (let a = 0; a < n; a++) {
      const o = e.scenes[a];
      if (o.nodes) {
        const h = new bt(o.name);
        for (let l = 0; l < o.nodes.length; l++) {
          const c = t[o.nodes[l]];
          h.addChild(c);
        }
        i.push(h);
      }
    }
  return i;
}, CR = function(e, t, s) {
  let i = null;
  if (e.hasOwnProperty("nodes") && e.hasOwnProperty("cameras") && e.cameras.length > 0) {
    const n = s && s.camera && s.camera.preprocess, a = s && s.camera && s.camera.process || _R, o = s && s.camera && s.camera.postprocess;
    e.nodes.forEach(function(h, l) {
      if (h.hasOwnProperty("camera")) {
        const c = e.cameras[h.camera];
        if (c) {
          n && n(c);
          const d = a(c, t[l]);
          o && o(c, d), d && (i || (i = /* @__PURE__ */ new Map()), i.set(h, d));
        }
      }
    });
  }
  return i;
}, AR = function(e, t, s) {
  let i = null;
  if (e.hasOwnProperty("nodes") && e.hasOwnProperty("extensions") && e.extensions.hasOwnProperty("KHR_lights_punctual") && e.extensions.KHR_lights_punctual.hasOwnProperty("lights")) {
    const n = e.extensions.KHR_lights_punctual.lights;
    if (n.length) {
      const a = s && s.light && s.light.preprocess, o = s && s.light && s.light.process || gR, h = s && s.light && s.light.postprocess;
      e.nodes.forEach(function(l, c) {
        if (l.hasOwnProperty("extensions") && l.extensions.hasOwnProperty("KHR_lights_punctual") && l.extensions.KHR_lights_punctual.hasOwnProperty("light")) {
          const d = l.extensions.KHR_lights_punctual.light, u = n[d];
          if (u) {
            a && a(u);
            const f = o(u, t[c]);
            h && h(u, f), f && (i || (i = /* @__PURE__ */ new Map()), i.set(l, f));
          }
        }
      });
    }
  }
  return i;
}, MR = function(e, t, s) {
  e.nodes.forEach((i) => {
    i.hasOwnProperty("mesh") && i.hasOwnProperty("skin") && t[i.mesh].meshes.forEach((a) => {
      a.skin = s[i.skin];
    });
  });
}, Ip = function(e, t, s, i, n, a) {
  const o = n && n.global && n.global.preprocess, h = n && n.global && n.global.postprocess;
  o && o(t);
  const l = t.asset && t.asset.generator === "PlayCanvas", c = wR(t, n), d = TR(t, c), u = AR(t, c, n), f = CR(t, c, n), m = bR(t, c, s, n), _ = vR(t, i.map(function(w) {
    return w.resource;
  }), n, l), p = SR(t), g = {}, b = {}, x = xR(e, t, s, a, l, g, b, n), y = yR(e, t, c, s), S = [];
  for (let w = 0; w < x.length; w++)
    S[w] = new by(), S[w].meshes = x[w];
  MR(t, S, y);
  const C = new WE(t);
  C.nodes = c, C.scenes = d, C.animations = m, C.textures = i, C.materials = _, C.variants = p, C.meshVariants = g, C.meshDefaultMaterials = b, C.renders = S, C.skins = y, C.lights = u, C.cameras = f, h && h(t, C), a(null, C);
}, ER = function(e, t) {
  const s = function(a, o) {
    switch (a) {
      case 9728:
        return Be;
      case 9729:
        return rt;
      case 9984:
        return yl;
      case 9985:
        return vl;
      case 9986:
        return xl;
      case 9987:
        return Ln;
      default:
        return o;
    }
  }, i = function(a, o) {
    switch (a) {
      case 33071:
        return he;
      case 33648:
        return _u;
      case 10497:
        return xt;
      default:
        return o;
    }
  };
  e && (t = t || {}, e.minFilter = s(t.minFilter, Ln), e.magFilter = s(t.magFilter, rt), e.addressU = i(t.wrapS, xt), e.addressV = i(t.wrapT, xt));
};
let RR = 0;
const LR = function(e, t, s, i, n, a, o) {
  const h = a && a.image && a.image.preprocess, l = a && a.image && a.image.processAsync || function(m, _) {
    _(null, null);
  }, c = a && a.image && a.image.postprocess, d = function(_) {
    c && c(e, _), o(null, _);
  }, u = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/basis": "basis",
    "image/ktx": "ktx",
    "image/ktx2": "ktx2",
    "image/vnd-ms.dds": "dds"
  }, f = function(_, p, g, b) {
    const x = (e.name || "gltf-texture") + "-" + RR++, y = {
      url: _ || x
    };
    if (p && (y.contents = p.slice(0).buffer), g) {
      const C = u[g];
      C && (y.filename = y.url + "." + C);
    }
    const S = new ce(x, "texture", y, null, b);
    S.on("load", d), S.on("error", o), n.add(S), n.load(S);
  };
  h && h(e), l(e, function(m, _) {
    m ? o(m) : _ ? d(_) : e.hasOwnProperty("uri") ? Cy(e.uri) ? f(e.uri, null, qE(e.uri), null) : f(me.join(i, e.uri), null, null, {
      crossOrigin: "anonymous"
    }) : e.hasOwnProperty("bufferView") && e.hasOwnProperty("mimeType") ? f(null, s[e.bufferView], e.mimeType, null) : o("Invalid image found in gltf (neither uri or bufferView found). index=" + t);
  });
}, PR = function(e, t, s, i, n, a) {
  if (!e.hasOwnProperty("images") || e.images.length === 0 || !e.hasOwnProperty("textures") || e.textures.length === 0) {
    a(null, []);
    return;
  }
  const o = n && n.texture && n.texture.preprocess, h = n && n.texture && n.texture.processAsync || function(m, _, p) {
    p(null, null);
  }, l = n && n.texture && n.texture.postprocess, c = [], d = [];
  let u = e.textures.length;
  const f = function(_, p) {
    if (d[p] || (d[p] = []), d[p].push(_), --u === 0) {
      const g = [];
      d.forEach(function(b, x) {
        b.forEach(function(y, S) {
          const C = S === 0 ? c[x] : QE(c[x]);
          ER(C.resource, (e.samplers || [])[e.textures[y].sampler]), g[y] = C, l && l(e.textures[y], C);
        });
      }), a(null, g);
    }
  };
  for (let m = 0; m < e.textures.length; ++m) {
    const _ = e.textures[m];
    o && o(_), h(_, e.images, function(p, g, b, x) {
      if (b)
        a(b);
      else {
        if (x == null) {
          var y, S;
          x = g == null || (y = g.extensions) == null || (S = y.KHR_texture_basisu) == null ? void 0 : S.source, x === void 0 && (x = g.source);
        }
        if (c[x])
          f(p, x);
        else {
          const C = e.images[x];
          LR(C, p, t, s, i, n, function(w, M) {
            w ? a(w) : (c[x] = M, f(p, x));
          });
        }
      }
    }.bind(null, m, _));
  }
}, IR = function(e, t, s, i, n) {
  const a = [];
  if (!e.buffers || e.buffers.length === 0) {
    n(null, a);
    return;
  }
  const o = i && i.buffer && i.buffer.preprocess, h = i && i.buffer && i.buffer.processAsync || function(u, f) {
    f(null, null);
  }, l = i && i.buffer && i.buffer.postprocess;
  let c = e.buffers.length;
  const d = function(f, m) {
    a[f] = m, l && l(e.buffers[f], m), --c === 0 && n(null, a);
  };
  for (let u = 0; u < e.buffers.length; ++u) {
    const f = e.buffers[u];
    o && o(f), h(f, function(m, _, p, g) {
      if (p)
        n(p);
      else if (g)
        d(m, new Uint8Array(g));
      else if (_.hasOwnProperty("uri"))
        if (Cy(_.uri)) {
          const b = atob(_.uri.split(",")[1]), x = new Uint8Array(b.length);
          for (let y = 0; y < b.length; y++)
            x[y] = b.charCodeAt(y);
          d(m, x);
        } else
          $e.get(me.join(s, _.uri), {
            cache: !0,
            responseType: "arraybuffer",
            retry: !1
          }, function(b, x, y) {
            x ? n(x) : d(b, new Uint8Array(y));
          }.bind(null, m));
      else
        d(m, t);
    }.bind(null, u, f));
  }
}, Dp = function(e, t) {
  const i = JSON.parse(function(o) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(o);
    let h = "";
    for (let l = 0; l < o.length; l++)
      h += String.fromCharCode(o[l]);
    return decodeURIComponent(escape(h));
  }(e));
  if (i.asset && i.asset.version && parseFloat(i.asset.version) < 2) {
    t(`Invalid gltf version. Expected version 2.0 or above but found version '${i.asset.version}'.`);
    return;
  }
  const n = (i == null ? void 0 : i.extensionsRequired) || [];
  !iu && !Ty() && n.indexOf("KHR_draco_mesh_compression") !== -1 ? p0.getInstance("DracoDecoderModule", (a) => {
    iu = a, t(null, i);
  }) : t(null, i);
}, DR = function(e, t) {
  const s = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength), i = s.getUint32(0, !0), n = s.getUint32(4, !0), a = s.getUint32(8, !0);
  if (i !== 1179937895) {
    t("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + i.toString(16));
    return;
  }
  if (n !== 2) {
    t("Invalid version number found in glb header. Expected 2, found " + n);
    return;
  }
  if (a <= 0 || a > s.byteLength) {
    t("Invalid length found in glb header. Found " + a);
    return;
  }
  const o = [];
  let h = 12;
  for (; h < a; ) {
    const l = s.getUint32(h, !0);
    if (h + l + 8 > s.byteLength)
      throw new Error("Invalid chunk length found in glb. Found " + l);
    const c = s.getUint32(h + 4, !0), d = new Uint8Array(s.buffer, s.byteOffset + h + 8, l);
    o.push({
      length: l,
      type: c,
      data: d
    }), h += l + 8;
  }
  if (o.length !== 1 && o.length !== 2) {
    t("Invalid number of chunks found in glb file.");
    return;
  }
  if (o[0].type !== 1313821514) {
    t("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + o[0].type.toString(16));
    return;
  }
  if (o.length > 1 && o[1].type !== 5130562) {
    t("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + o[1].type.toString(16));
    return;
  }
  t(null, {
    gltfChunk: o[0].data,
    binaryChunk: o.length === 2 ? o[1].data : null
  });
}, Bp = function(e, t, s) {
  const i = () => {
    const n = new Uint8Array(t);
    return n[0] === 103 && n[1] === 108 && n[2] === 84 && n[3] === 70;
  };
  e && e.toLowerCase().endsWith(".glb") || i() ? DR(t, s) : s(null, {
    gltfChunk: t,
    binaryChunk: null
  });
}, Fp = function(e, t, s, i) {
  const n = [], a = s && s.bufferView && s.bufferView.preprocess, o = s && s.bufferView && s.bufferView.processAsync || function(d, u, f) {
    f(null, null);
  }, h = s && s.bufferView && s.bufferView.postprocess;
  let l = e.bufferViews ? e.bufferViews.length : 0;
  if (!l) {
    i(null, null);
    return;
  }
  const c = function(u, f) {
    const m = e.bufferViews[u];
    m.hasOwnProperty("byteStride") && (f.byteStride = m.byteStride), n[u] = f, h && h(m, f), --l === 0 && i(null, n);
  };
  for (let d = 0; d < e.bufferViews.length; ++d) {
    const u = e.bufferViews[d];
    a && a(u), o(u, t, function(f, m, _, p) {
      if (_)
        i(_);
      else if (p)
        c(f, p);
      else {
        const g = t[m.buffer], b = new Uint8Array(g.buffer, g.byteOffset + (m.byteOffset || 0), m.byteLength);
        c(f, b);
      }
    }.bind(null, d, u));
  }
};
class co {
  static parseAsync(e, t, s, i, n, a, o) {
    Bp(e, s, function(h, l) {
      if (h) {
        o(h);
        return;
      }
      Dp(l.gltfChunk, function(c, d) {
        if (c) {
          o(c);
          return;
        }
        IR(d, l.binaryChunk, t, a, function(u, f) {
          if (u) {
            o(u);
            return;
          }
          Fp(d, f, a, function(m, _) {
            if (m) {
              o(m);
              return;
            }
            PR(d, _, t, n, a, function(p, g) {
              if (p) {
                o(p);
                return;
              }
              Ip(i, d, _, g, a, o);
            });
          });
        });
      });
    });
  }
  static parse(e, t, s, i) {
    let n = null;
    return i = i || {}, Bp(e, t, function(a, o) {
      a ? console.error(a) : Dp(o.gltfChunk, function(h, l) {
        h ? console.error(h) : Fp(l, [o.binaryChunk], i, function(c, d) {
          c ? console.error(c) : Ip(s, l, d, [], i, function(u, f) {
            u ? console.error(u) : n = f;
          });
        });
      });
    }), n;
  }
  constructor(e, t, s) {
    this._device = e, this._assets = t, this._defaultMaterial = Ey({
      name: "defaultGlbMaterial"
    }, []), this.maxRetries = s;
  }
  _getUrlWithoutParams(e) {
    return e.indexOf("?") >= 0 ? e.split("?")[0] : e;
  }
  load(e, t, s) {
    ce.fetchArrayBuffer(e.load, (i, n) => {
      i ? t(i) : co.parseAsync(this._getUrlWithoutParams(e.original), me.extractPath(e.load), n, this._device, s.registry, s.options, (a, o) => {
        a ? t(a) : t(null, new Ui(o, s, this._assets, this._defaultMaterial));
      });
    }, s, this.maxRetries);
  }
  open(e, t, s) {
    return t;
  }
  patch(e, t) {
  }
}
class BR {
  constructor(e) {
    this.handlerType = "animation", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    (e.load.startsWith("blob:") || e.load.startsWith("data:")) && (me.getExtension(e.original).toLowerCase() === ".glb" ? s.responseType = ve.ResponseType.ARRAY_BUFFER : s.responseType = ve.ResponseType.JSON), $e.get(e.load, s, function(i, n) {
      i ? t(`Error loading animation resource: ${e.original} [${i}]`) : t(null, n);
    });
  }
  open(e, t, s) {
    if (me.getExtension(e).toLowerCase() === ".glb") {
      const n = co.parse("filename.glb", t, null);
      if (n) {
        var i;
        const a = n.animations;
        if (s != null && (i = s.data) != null && i.events)
          for (let o = 0; o < a.length; o++)
            a[o].events = new Pg(Object.values(s.data.events));
        return n.destroy(), a;
      }
      return null;
    }
    return this["_parseAnimationV" + t.animation.version](t);
  }
  patch(e, t) {
  }
  _parseAnimationV3(e) {
    const t = e.animation, s = new Vm();
    s.name = t.name, s.duration = t.duration;
    for (let i = 0; i < t.nodes.length; i++) {
      const n = new Um(), a = t.nodes[i];
      n._name = a.name;
      for (let o = 0; o < a.keys.length; o++) {
        const h = a.keys[o], l = h.time, c = h.pos, d = h.rot, u = h.scale, f = new v(c[0], c[1], c[2]), m = new ee().setFromEulerAngles(d[0], d[1], d[2]), _ = new v(u[0], u[1], u[2]), p = new zm(l, f, m, _);
        n._keys.push(p);
      }
      s.addNode(n);
    }
    return s;
  }
  _parseAnimationV4(e) {
    const t = e.animation, s = new Vm();
    s.name = t.name, s.duration = t.duration;
    for (let i = 0; i < t.nodes.length; i++) {
      const n = new Um(), a = t.nodes[i];
      n._name = a.name;
      const o = a.defaults.p, h = a.defaults.r, l = a.defaults.s;
      for (let c = 0; c < a.keys.length; c++) {
        const d = a.keys[c], u = d.t, f = o || d.p, m = h || d.r, _ = l || d.s, p = new v(f[0], f[1], f[2]), g = new ee().setFromEulerAngles(m[0], m[1], m[2]), b = new v(_[0], _[1], _[2]), x = new zm(u, p, g, b);
        n._keys.push(x);
      }
      s.addNode(n);
    }
    return s;
  }
}
class FR {
  constructor(e) {
    this.handlerType = "animclip", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    e.load.startsWith("blob:") && (s.responseType = ve.ResponseType.JSON), $e.get(e.load, s, function(i, n) {
      i ? t(`Error loading animation clip resource: ${e.original} [${i}]`) : t(null, n);
    });
  }
  open(e, t) {
    const s = t.name, i = t.duration, n = t.inputs.map(function(h) {
      return new dl(1, h);
    }), a = t.outputs.map(function(h) {
      return new dl(h.components, h.data);
    }), o = t.curves.map(function(h) {
      return new wy([h.path], h.inputIndex, h.outputIndex, h.interpolation);
    });
    return new Yl(s, i, n, a, o);
  }
  patch(e, t) {
  }
}
class OR {
  constructor(e) {
    this.handlerType = "animstategraph", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    e.load.startsWith("blob:") && (s.responseType = ve.ResponseType.JSON), $e.get(e.load, s, function(i, n) {
      i ? t(`Error loading animation state graph resource: ${e.original} [${i}]`) : t(null, n);
    });
  }
  open(e, t) {
    return new xh(t);
  }
  patch(e, t) {
  }
}
const $c = function() {
  if (typeof window > "u")
    return !1;
  const r = window.navigator.userAgent, e = r.indexOf("MSIE ");
  if (e > 0)
    return parseInt(r.substring(e + 5, r.indexOf(".", e)), 10);
  if (r.indexOf("Trident/") > 0) {
    const s = r.indexOf("rv:");
    return parseInt(r.substring(s + 3, r.indexOf(".", s)), 10);
  }
  return !1;
}(), kR = [".ogg", ".mp3", ".wav", ".mp4a", ".m4a", ".mp4", ".aac", ".opus"];
class NR {
  constructor(e) {
    this.handlerType = "audio", this.manager = e.soundManager, this.maxRetries = 0;
  }
  _isSupported(e) {
    const t = me.getExtension(e);
    return kR.indexOf(t) > -1;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = function(a) {
      t(null, new sv(a));
    }, i = function(a) {
      let o = "Error loading audio url: " + e.original;
      a && (o += ": " + (a.message || a)), console.warn(o), t(o);
    };
    if (this._createSound) {
      if (!this._isSupported(e.original)) {
        i(`Audio format for ${e.original} not supported`);
        return;
      }
      this._createSound(e.load, s, i);
    } else
      i(null);
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
  _createSound(e, t, s) {
    if (bi()) {
      const i = this.manager;
      if (!i.context) {
        s("Audio manager has no audio context");
        return;
      }
      const n = {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      };
      (e.startsWith("blob:") || e.startsWith("data:")) && (n.responseType = ve.ResponseType.ARRAY_BUFFER), $e.get(e, n, function(a, o) {
        if (a) {
          s(a);
          return;
        }
        i.context.decodeAudioData(o, t, s);
      });
    } else {
      let i = null;
      try {
        i = new Audio();
      } catch {
        s("No support for Audio element");
        return;
      }
      $c && document.body.appendChild(i);
      const n = function a() {
        i.removeEventListener("canplaythrough", a), $c && document.body.removeChild(i), t(i);
      };
      i.onerror = function() {
        i.onerror = null, $c && document.body.removeChild(i), s();
      }, i.addEventListener("canplaythrough", n), i.src = e;
    }
  }
}
class zR {
  constructor(e) {
    this.handlerType = "binary", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      responseType: ve.ResponseType.ARRAY_BUFFER,
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(`Error loading binary resource: ${e.original} [${s}]`) : t(null, i);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
class UR {
  constructor(e) {
    this.handlerType = "container", this.glbParser = new co(e.graphicsDevice, e.assets, 0), this.parsers = {};
  }
  set maxRetries(e) {
    this.glbParser.maxRetries = e;
    for (const t in this.parsers)
      this.parsers.hasOwnProperty(t) && (this.parsers[t].maxRetries = e);
  }
  get maxRetries() {
    return this.glbParser.maxRetries;
  }
  _getUrlWithoutParams(e) {
    return e.indexOf("?") >= 0 ? e.split("?")[0] : e;
  }
  _getParser(e) {
    const t = e ? me.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".", "") : null;
    return this.parsers[t] || this.glbParser;
  }
  load(e, t, s) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), this._getParser(e.original).load(e, t, s);
  }
  open(e, t, s) {
    return this._getParser(e).open(e, t, s);
  }
  patch(e, t) {
  }
}
class VR {
  constructor(e) {
    this.handlerType = "css", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(`Error loading css resource: ${e.original} [${s}]`) : t(null, i);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
class GR {
  constructor(e) {
    this.handlerType = "cubemap", this._device = e.graphicsDevice, this._registry = e.assets, this._loader = e.loader;
  }
  load(e, t, s) {
    this.loadAssets(s, t);
  }
  open(e, t, s) {
    return s ? s.resource : null;
  }
  patch(e, t) {
    this.loadAssets(e, function(s, i) {
      s && (t.fire("error", e), t.fire("error:" + e.id, s, e), e.fire("error", e));
    });
  }
  getAssetIds(e) {
    const t = [];
    if (t[0] = e.file, (e.loadFaces || !e.file) && e.data && e.data.textures)
      for (let s = 0; s < 6; ++s)
        t[s + 1] = e.data.textures[s];
    else
      t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = null;
    return t;
  }
  compareAssetIds(e, t) {
    return e && t ? parseInt(e, 10) === e || typeof e == "string" ? e === t : e.url === t.url : e !== null == (t !== null);
  }
  update(e, t, s) {
    const i = e.data || {}, n = e._handlerState.assets, a = e._resources;
    let o, h, l;
    const c = [null, null, null, null, null, null, null], d = function() {
      return i.hasOwnProperty("type") ? i.type : i.hasOwnProperty("rgbm") ? i.rgbm ? _i : Rs : null;
    };
    if (!e.loaded || s[0] !== n[0]) {
      if (s[0])
        for (o = s[0].resource, l = 0; l < 6; ++l)
          c[l + 1] = new ue(this._device, {
            name: e.name + "_prelitCubemap" + (o.width >> l),
            cubemap: !0,
            type: d() || o.type,
            width: o.width >> l,
            height: o.height >> l,
            format: o.format,
            levels: [o._levels[l]],
            fixCubemapSeams: !0,
            addressU: he,
            addressV: he,
            mipmaps: l === 0
          });
    } else
      c[1] = a[1] || null, c[2] = a[2] || null, c[3] = a[3] || null, c[4] = a[4] || null, c[5] = a[5] || null, c[6] = a[6] || null;
    const u = s.slice(1);
    if (!e.loaded || !this.cmpArrays(u, n.slice(1))) {
      if (u.indexOf(null) === -1) {
        const f = u.map(function(g) {
          return g.resource;
        }), m = [];
        for (h = 0; h < f[0]._levels.length; ++h)
          m.push(f.map(function(g) {
            return g._levels[h];
          }));
        const _ = f[0].format, p = new ue(this._device, {
          name: e.name + "_faces",
          cubemap: !0,
          type: d() || f[0].type,
          width: f[0].width,
          height: f[0].height,
          format: _ === Si ? ye : _,
          levels: m,
          minFilter: i.hasOwnProperty("minFilter") ? i.minFilter : f[0].minFilter,
          magFilter: i.hasOwnProperty("magFilter") ? i.magFilter : f[0].magFilter,
          anisotropy: i.hasOwnProperty("anisotropy") ? i.anisotropy : 1,
          addressU: he,
          addressV: he,
          fixCubemapSeams: !!s[0]
        });
        c[0] = p;
      }
    } else
      c[0] = a[0] || null;
    if (!this.cmpArrays(c, a))
      for (e.resources = c, e._handlerState.assetIds = t, e._handlerState.assets = s, l = 0; l < a.length; ++l)
        a[l] !== null && c.indexOf(a[l]) === -1 && a[l].destroy();
    for (l = 0; l < n.length; ++l)
      n[l] !== null && s.indexOf(n[l]) === -1 && n[l].unload();
  }
  cmpArrays(e, t) {
    if (e.length !== t.length)
      return !1;
    for (let s = 0; s < e.length; ++s)
      if (e[s] !== t[s])
        return !1;
    return !0;
  }
  resolveId(e) {
    const t = parseInt(e, 10);
    return t === e || t.toString() === e ? t : e;
  }
  loadAssets(e, t) {
    e.hasOwnProperty("_handlerState") || (e._handlerState = {
      assetIds: [null, null, null, null, null, null, null],
      assets: [null, null, null, null, null, null, null]
    });
    const s = this, i = s.getAssetIds(e), n = [null, null, null, null, null, null, null], a = e._handlerState.assetIds, o = e._handlerState.assets, h = s._registry;
    let l = 7;
    const c = function(_, p) {
      n[_] = p, l--, l === 0 && (s.update(e, i, n), t(null, e.resources));
    }, d = function(_, p, g) {
      t(p);
    }, u = function(_, p) {
      p.loaded ? c(_, p) : (h.once("load:" + p.id, c.bind(s, _)), h.once("error:" + p.id, d.bind(s, _)), p.loading || h.load(p));
    };
    let f;
    for (let m = 0; m < 7; ++m) {
      const _ = this.resolveId(i[m]);
      if (!_)
        c(m, null);
      else if (s.compareAssetIds(_, a[m]))
        c(m, o[m]);
      else if (parseInt(_, 10) === _)
        f = h.get(_), f ? u(m, f) : setTimeout(function(p, g) {
          const b = h.get(g);
          b ? u(p, b) : d(p, "failed to find dependent cubemap asset=" + g);
        }.bind(null, m, _));
      else {
        const p = typeof _ == "string" ? {
          url: _,
          filename: _
        } : _;
        f = new ce(e.name + "_part_" + m, "texture", p), h.add(f), h.once("load:" + f.id, c.bind(s, m)), h.once("error:" + f.id, d.bind(s, m)), h.load(f);
      }
    }
  }
}
class HR {
  constructor() {
    this.handlerType = "folder";
  }
  load(e, t) {
    t(null, null);
  }
  open(e, t) {
    return t;
  }
}
class Op {
  constructor(e, t) {
    this.type = t && t.type || ol, this.em = 1, this.textures = e, this.intensity = 0, this._data = null, this.data = t;
  }
  set data(e) {
    if (this._data = e, !!e && (this._data.intensity !== void 0 && (this.intensity = this._data.intensity), this._data.info || (this._data.info = {}), (!this._data.version || this._data.version < 2) && (this._data.info.maps = [{
      width: this._data.info.width,
      height: this._data.info.height
    }], this._data.chars)))
      for (const t in this._data.chars)
        this._data.chars[t].map = 0;
  }
  get data() {
    return this._data;
  }
}
function Yc(r) {
  return r.version < 3 && (r.version < 2 && (r.info.maps = r.info.maps || [{
    width: r.info.width,
    height: r.info.height
  }]), r.chars = Object.keys(r.chars || {}).reduce(function(e, t) {
    const s = r.chars[t], i = s.letter !== void 0 ? s.letter : dh.fromCodePoint(t);
    return r.version < 2 && (s.map = s.map || 0), e[i] = s, e;
  }, {}), r.version = 3), r;
}
class WR {
  constructor(e) {
    this.handlerType = "font", this._loader = e.loader, this.maxRetries = 0;
  }
  load(e, t, s) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const i = this;
    me.getExtension(e.original) === ".json" ? $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(n, a) {
      if (n)
        t(`Error loading font resource: ${e.original} [${n}]`);
      else {
        const o = Yc(a);
        i._loadTextures(e.load.replace(".json", ".png"), o, function(h, l) {
          if (h)
            return t(h);
          t(null, {
            data: o,
            textures: l
          });
        });
      }
    }) : (s && s.data && (s.data = Yc(s.data)), this._loadTextures(e.load, s && s.data, t));
  }
  _loadTextures(e, t, s) {
    const i = t.info.maps.length;
    let n = 0, a = null;
    const o = new Array(i), h = this._loader, l = function(d) {
      const u = function(m, _) {
        if (!a) {
          if (m)
            return a = m, s(m);
          _.upload(), o[d] = _, n++, n === i && s(null, o);
        }
      };
      d === 0 ? h.load(e, "texture", u) : h.load(e.replace(".png", d + ".png"), "texture", u);
    };
    for (let c = 0; c < i; c++)
      l(c);
  }
  open(e, t, s) {
    let i;
    return t.textures ? i = new Op(t.textures, t.data) : i = new Op(t, null), i;
  }
  patch(e, t) {
    const s = e.resource;
    !s.data && e.data ? s.data = e.data : !e.data && s.data && (e.data = s.data), e.data && (e.data = Yc(e.data));
  }
}
const au = {
  setCompressedPRS: function(r, e, t) {
    const s = t.singleVecs;
    let i, n;
    const a = e.___1;
    a || (i = t.tripleVecs, n = e.___2);
    let o = a ? a[0] : i[n];
    r.setLocalPosition(s[o], s[o + 1], s[o + 2]), o = a ? a[1] : i[n + 1], r.setLocalEulerAngles(s[o], s[o + 1], s[o + 2]), o = a ? a[2] : i[n + 2], r.setLocalScale(s[o], s[o + 1], s[o + 2]);
  },
  oneCharToKey: function(r, e) {
    const t = r.charCodeAt(0) - e.fieldFirstCode;
    return e.fieldArray[t];
  },
  multCharToKey: function(r, e) {
    let t = 0;
    for (let s = 0; s < r.length; s++)
      t = t * e.fieldCodeBase + r.charCodeAt(s) - e.fieldFirstCode;
    return e.fieldArray[t];
  }
};
class ml {
  constructor(e, t) {
    this._node = e, this._data = t;
  }
  run() {
    const e = Object.prototype.toString.call(this._node);
    return e === "[object Object]" ? this._handleMap() : e === "[object Array]" ? this._handleArray() : this._result = this._node, this._result;
  }
  _handleMap() {
    this._result = {}, Object.keys(this._node).forEach(this._handleKey, this);
  }
  _handleKey(e) {
    let t = e;
    const s = e.length;
    s === 1 ? t = au.oneCharToKey(e, this._data) : s === 2 && (t = au.multCharToKey(e, this._data)), this._result[t] = new ml(this._node[e], this._data).run();
  }
  _handleArray() {
    this._result = [], this._node.forEach(this._handleArElt, this);
  }
  _handleArElt(e) {
    const t = new ml(e, this._data).run();
    this._result.push(t);
  }
}
class Ju {
  constructor(e, t) {
    this._app = e, this._isTemplate = t;
  }
  parse(e) {
    const t = {};
    let s = null;
    const i = e.compressedFormat;
    i && !e.entDecompressed && (e.entDecompressed = !0, e.entities = new ml(e.entities, i).run());
    for (const n in e.entities) {
      const a = e.entities[n], o = this._createEntity(a, i);
      t[n] = o, a.parent === null && (s = o);
    }
    for (const n in e.entities) {
      const a = t[n], o = e.entities[n].children, h = o.length;
      for (let l = 0; l < h; l++) {
        const c = t[o[l]];
        c && a.addChild(c);
      }
    }
    return this._openComponentData(s, e.entities), s;
  }
  _createEntity(e, t) {
    const s = new oe(e.name, this._app);
    if (s.setGuid(e.resource_id), this._setPosRotScale(s, e, t), s._enabled = e.enabled !== void 0 ? e.enabled : !0, this._isTemplate ? s._template = !0 : s._enabledInHierarchy = s._enabled, s.template = e.template, e.tags)
      for (let i = 0; i < e.tags.length; i++)
        s.tags.add(e.tags[i]);
    return e.labels && e.labels.forEach(function(i) {
      s.addLabel(i);
    }), s;
  }
  _setPosRotScale(e, t, s) {
    if (s)
      au.setCompressedPRS(e, t, s);
    else {
      const i = t.position, n = t.rotation, a = t.scale;
      e.setLocalPosition(i[0], i[1], i[2]), e.setLocalEulerAngles(n[0], n[1], n[2]), e.setLocalScale(a[0], a[1], a[2]);
    }
  }
  _openComponentData(e, t) {
    const s = this._app.systems.list;
    let i = s.length;
    const n = t[e.getGuid()];
    for (let o = 0; o < i; o++) {
      const h = s[o], l = n.components[h.id];
      l && h.addComponent(e, l);
    }
    i = n.children.length;
    const a = e._children;
    for (let o = 0; o < i; o++)
      a[o] && (a[o] = this._openComponentData(a[o], t));
    return e;
  }
}
const Ry = {
  load: function(r, e, t) {
    typeof r == "string" && (r = {
      load: r,
      original: r
    }), $e.get(r.load, {
      retry: e > 0,
      maxRetries: e
    }, function(s, i) {
      if (!s)
        t(s, i);
      else {
        let n = "Error while loading scene JSON " + r.original;
        s.message ? (n += ": " + s.message, s.stack && (n += `
` + s.stack)) : n += ": " + s, t(n);
      }
    });
  }
};
class qR {
  constructor(e) {
    this.handlerType = "hierarchy", this._app = e, this.maxRetries = 0;
  }
  load(e, t) {
    Ry.load(e, this.maxRetries, t);
  }
  open(e, t) {
    this._app.systems.script.preloading = !0;
    const i = new Ju(this._app, !1).parse(t);
    return this._app.systems.script.preloading = !1, i;
  }
}
class XR {
  constructor(e) {
    this.handlerType = "html", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(`Error loading html resource: ${e.original} [${s}]`) : t(null, i);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
class jR {
  constructor(e) {
    this.handlerType = "json", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    e.load.startsWith("blob:") && (s.responseType = ve.ResponseType.JSON), $e.get(e.load, s, function(i, n) {
      i ? t(`Error loading JSON resource: ${e.original} [${i}]`) : t(null, n);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
class $R {
  constructor() {
    this.removeInvalid = !0, this.valid = !0, this.enumValidators = {
      occludeSpecular: this._createEnumValidator([Tv, ja, Ad]),
      cull: this._createEnumValidator([Ft, Br, Mh, x_]),
      blendType: this._createEnumValidator([nv, Oh, Vt, ss, $i, kh, Nh, Sd, bd, wd, Td]),
      depthFunc: this._createEnumValidator([M0, gu, Eh, Sl, E0, R0, L0, Mn]),
      shadingModel: this._createEnumValidator([Hs, Wl])
    };
  }
  setInvalid(e, t) {
    this.valid = !1, this.removeInvalid && delete t[e];
  }
  validate(e) {
    const t = Wr, s = LC, i = e.mappingFormat === "path";
    for (const n in e) {
      const a = t[n];
      if (!a) {
        s[n] ? delete e[n] : this.valid = !1;
        continue;
      }
      if (a.startsWith("enum")) {
        const o = a.split(":")[1];
        this.enumValidators[o] && (this.enumValidators[o](e[n]) || this.setInvalid(n, e));
      } else if (a === "number")
        typeof e[n] != "number" && this.setInvalid(n, e);
      else if (a === "boolean")
        typeof e[n] != "boolean" && this.setInvalid(n, e);
      else if (a === "string")
        typeof e[n] != "string" && this.setInvalid(n, e);
      else if (a === "vec2")
        e[n] instanceof Array && e[n].length === 2 || this.setInvalid(n, e);
      else if (a === "rgb")
        e[n] instanceof Array && e[n].length === 3 || this.setInvalid(n, e);
      else if (a === "texture")
        i ? typeof e[n] == "string" || e[n] === null || e[n] instanceof ue || this.setInvalid(n, e) : typeof e[n] == "number" || e[n] === null || e[n] instanceof ue || this.setInvalid(n, e);
      else if (a === "boundingbox")
        e[n].center && e[n].center instanceof Array && e[n].center.length === 3 || this.setInvalid(n, e), e[n].halfExtents && e[n].halfExtents instanceof Array && e[n].halfExtents.length === 3 || this.setInvalid(n, e);
      else if (a === "cubemap")
        typeof e[n] == "number" || e[n] === null || e[n] === void 0 || e[n] instanceof ue && e[n].cubemap || this.setInvalid(n, e);
      else if (a === "chunks") {
        const o = Object.keys(e[n]);
        for (let h = 0; h < o.length; h++)
          typeof e[n][o[h]] != "string" && this.setInvalid(o[h], e[n]);
      } else
        console.error("Unknown material type: " + a);
    }
    return e.validated = !0, this.valid;
  }
  _createEnumValidator(e) {
    return function(t) {
      return e.indexOf(t) >= 0;
    };
  }
}
class YR {
  constructor() {
    this._validator = null;
  }
  parse(e) {
    const t = this.migrate(e), s = this._validate(t), i = new Ht();
    return this.initialize(i, s), i;
  }
  initialize(e, t) {
    t.validated || (t = this._validate(t)), t.chunks && (e.chunks = On({}, t.chunks));
    for (const s in t) {
      const i = Wr[s], n = t[s];
      if (i === "vec2")
        e[s] = new q(n[0], n[1]);
      else if (i === "rgb")
        e[s] = new z(n[0], n[1], n[2]);
      else if (i === "texture")
        n instanceof ue ? e[s] = n : e[s] instanceof ue && typeof n == "number" && n > 0 || (e[s] = null);
      else if (i === "cubemap")
        n instanceof ue ? e[s] = n : e[s] instanceof ue && typeof n == "number" && n > 0 || (e[s] = null), s === "cubeMap" && !n && (e.prefilteredCubemaps = null);
      else if (i === "boundingbox") {
        const a = new v(n.center[0], n.center[1], n.center[2]), o = new v(n.halfExtents[0], n.halfExtents[1], n.halfExtents[2]);
        e[s] = new Pe(a, o);
      } else
        e[s] = t[s];
    }
    e.update();
  }
  migrate(e) {
    e.shadingModel === void 0 && (e.shader === "blinn" ? e.shadingModel = Wl : e.shadingModel = Hs), e.shader && delete e.shader, e.mapping_format && (e.mappingFormat = e.mapping_format, delete e.mapping_format);
    let t;
    const s = [["bumpMapFactor", "bumpiness"], ["aoUvSet", "aoMapUv"], ["aoMapVertexColor", "aoVertexColor"], ["diffuseMapVertexColor", "diffuseVertexColor"], ["emissiveMapVertexColor", "emissiveVertexColor"], ["specularMapVertexColor", "specularVertexColor"], ["metalnessMapVertexColor", "metalnessVertexColor"], ["opacityMapVertexColor", "opacityVertexColor"], ["glossMapVertexColor", "glossVertexColor"], ["lightMapVertexColor", "lightVertexColor"], ["diffuseMapTint", "diffuseTint"], ["specularMapTint", "specularTint"], ["emissiveMapTint", "emissiveTint"], ["metalnessMapTint", "metalnessTint"], ["clearCoatGlossiness", "clearCoatGloss"]];
    for (t = 0; t < s.length; t++) {
      const n = s[t][0], a = s[t][1];
      e[n] !== void 0 && e[a] === void 0 && (e[a] = e[n], delete e[n]);
    }
    const i = ["fresnelFactor", "shadowSampleType"];
    for (t = 0; t < i.length; t++) {
      const n = i[t];
      e.hasOwnProperty(n) && delete e[n];
    }
    return e;
  }
  _validate(e) {
    return e.validated || (this._validator || (this._validator = new $R()), this._validator.validate(e)), e;
  }
}
const KR = {
  aoMap: "white",
  diffuseMap: "gray",
  specularMap: "gray",
  specularityFactorMap: "white",
  metalnessMap: "black",
  glossMap: "gray",
  sheenMap: "black",
  sheenGlossinessMap: "gray",
  clearCoatMap: "black",
  clearCoatGlossMap: "gray",
  clearCoatNormalMap: "normal",
  refractionMap: "white",
  emissiveMap: "gray",
  normalMap: "normal",
  heightMap: "gray",
  opacityMap: "gray",
  sphereMap: "gray",
  lightMap: "white"
};
class ZR {
  constructor(e) {
    this.handlerType = "material", this._assets = e.assets, this._device = e.graphicsDevice, this._placeholderTextures = null, this._parser = new YR(), this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t && t(`Error loading material: ${e.original} [${s}]`) : t && (i._engine = !0, t(null, i));
    });
  }
  open(e, t) {
    const s = this._parser.parse(t);
    return t._engine && (s._data = t, delete t._engine), s;
  }
  _createPlaceholders() {
    this._placeholderTextures = {};
    const e = {
      white: [255, 255, 255, 255],
      gray: [128, 128, 128, 255],
      black: [0, 0, 0, 255],
      normal: [128, 128, 255, 255]
    };
    for (const t in e) {
      if (!e.hasOwnProperty(t))
        continue;
      this._placeholderTextures[t] = new ue(this._device, {
        width: 2,
        height: 2,
        format: ye,
        name: "material_placeholder"
      });
      const s = this._placeholderTextures[t].lock();
      for (let i = 0; i < 4; i++)
        for (let n = 0; n < 4; n++)
          s[i * 4 + n] = e[t][n];
      this._placeholderTextures[t].unlock();
    }
  }
  patch(e, t) {
    e.resource._data && (e._data = e.resource._data, delete e.resource._data), e.data.name = e.name, e.resource.name = e.name, this._bindAndAssignAssets(e, t), e.off("unload", this._onAssetUnload, this), e.on("unload", this._onAssetUnload, this);
  }
  _onAssetUnload(e) {
    delete e.data.parameters, delete e.data.chunks, delete e.data.name;
  }
  _assignTexture(e, t, s) {
    t.resource[e] = s;
  }
  _getPlaceholderTexture(e) {
    this._placeholderTextures || this._createPlaceholders();
    const t = KR[e];
    return this._placeholderTextures[t];
  }
  _assignPlaceholderTexture(e, t) {
    t.resource[e] = this._getPlaceholderTexture(e);
  }
  _onTextureLoad(e, t, s) {
    this._assignTexture(e, t, s.resource), t.resource.update();
  }
  _onTextureAdd(e, t, s) {
    this._assets.load(s);
  }
  _onTextureRemoveOrUnload(e, t, s) {
    const i = t.resource;
    i && t.resource[e] === s.resource && (this._assignPlaceholderTexture(e, t), i.update());
  }
  _assignCubemap(e, t, s) {
    t.resource[e] = s[0], e === "cubeMap" && (t.resource.prefilteredCubemaps = s.slice(1));
  }
  _onCubemapLoad(e, t, s) {
    this._assignCubemap(e, t, s.resources), this._parser.initialize(t.resource, t.data);
  }
  _onCubemapAdd(e, t, s) {
    t.data.shadingModel === Hs && (t.loadFaces = !0), this._assets.load(s);
  }
  _onCubemapRemoveOrUnload(e, t, s) {
    const i = t.resource;
    t.data.prefilteredCubeMap128 === s.resources[1] && (this._assignCubemap(e, t, [null, null, null, null, null, null, null]), i.update());
  }
  _bindAndAssignAssets(e, t) {
    const s = this._parser.migrate(e.data), i = e.resource, n = s.mappingFormat === "path", a = Xl;
    let o, h, l;
    for (o = 0; o < a.length; o++) {
      h = a[o], l = i._assetReferences[h];
      const d = s[h], u = i[h], f = u === this._getPlaceholderTexture(h), m = s.validated;
      d && (!u || !m || f) ? (l || (l = new ll(h, e, t, {
        load: this._onTextureLoad,
        add: this._onTextureAdd,
        remove: this._onTextureRemoveOrUnload,
        unload: this._onTextureRemoveOrUnload
      }, this), i._assetReferences[h] = l), n ? l.url = e.getAbsoluteUrl(d) : l.id = d, l.asset && (l.asset.resource ? this._assignTexture(h, e, l.asset.resource) : this._assignPlaceholderTexture(h, e), t.load(l.asset))) : l && (n ? l.url = null : l.id = null);
    }
    const c = Wu;
    for (o = 0; o < c.length; o++)
      h = c[o], l = i._assetReferences[h], s[h] && !e.data.prefilteredCubeMap128 && (l || (l = new ll(h, e, t, {
        load: this._onCubemapLoad,
        add: this._onCubemapAdd,
        remove: this._onCubemapRemoveOrUnload,
        unload: this._onCubemapRemoveOrUnload
      }, this), i._assetReferences[h] = l), n ? l.url = s[h] : l.id = s[h], l.asset && (l.asset.loaded && this._assignCubemap(h, e, l.asset.resources), t.load(l.asset)));
    this._parser.initialize(i, s);
  }
}
class JR {
  constructor(e, t) {
    this._device = e, this._defaultMaterial = t;
  }
  parse(e) {
    const t = co.parse("filename.glb", e, this._device);
    if (t) {
      const s = Ui.createModel(t, this._defaultMaterial);
      return t.destroy(), s;
    }
    return null;
  }
}
class QR {
  constructor() {
    this.index = 0, this.boneIndices = [0, 0, 0, 0];
  }
}
class eL {
  constructor() {
    this.partition = 0, this.vertexStart = 0, this.vertexCount = 0, this.indexStart = 0, this.indexCount = 0, this.boneIndices = [], this.vertices = [], this.indices = [], this.indexMap = {}, this.originalMesh = null;
  }
  addVertex(e, t, s) {
    let i = -1;
    if (this.indexMap[t] !== void 0)
      i = this.indexMap[t], this.indices.push(i);
    else {
      for (let n = 0; n < 4; n++) {
        if (s.blendWeight.data[t * 4 + n] === 0)
          continue;
        const a = s.blendIndices.data[e.index * 4 + n];
        e.boneIndices[n] = this.getBoneRemap(a);
      }
      i = this.vertices.length, this.indices.push(i), this.vertices.push(e), this.indexMap[t] = i;
    }
  }
  addPrimitive(e, t, s, i) {
    const n = [];
    let a = 0;
    const o = e.length;
    for (let h = 0; h < o; h++) {
      const c = e[h].index;
      for (let d = 0; d < 4; d++)
        if (s.blendWeight.data[c * 4 + d] > 0) {
          const u = s.blendIndices.data[c * 4 + d];
          let f = !0;
          for (let m = 0; m < a; m++)
            if (n[m] === u) {
              f = !1;
              break;
            }
          if (f) {
            n[a] = u;
            const m = this.getBoneRemap(u);
            a += m === -1 ? 1 : 0;
          }
        }
    }
    if (this.boneIndices.length + a > i)
      return !1;
    for (let h = 0; h < a; h++)
      this.boneIndices.push(n[h]);
    for (let h = 0; h < o; h++)
      this.addVertex(e[h], t[h], s);
    return !0;
  }
  getBoneRemap(e) {
    for (let t = 0; t < this.boneIndices.length; t++)
      if (this.boneIndices[t] === e)
        return t;
    return -1;
  }
}
function tL(r) {
  const e = r.vertices, t = r.skins, s = r.meshes, i = r.meshInstances;
  for (let n = 0; n < s.length; n++)
    s[n].vertices = e[s[n].vertices], s[n].skin !== void 0 && (s[n].skin = t[s[n].skin]);
  for (let n = 0; n < i.length; n++)
    i[n].mesh = s[i[n].mesh];
}
function sL(r) {
  const e = r.vertices, t = r.skins, s = r.meshes, i = r.meshInstances;
  for (let n = 0; n < s.length; n++)
    s[n].vertices = e.indexOf(s[n].vertices), s[n].skin !== void 0 && (s[n].skin = t.indexOf(s[n].skin));
  for (let n = 0; n < i.length; n++)
    i[n].mesh = s.indexOf(i[n].mesh);
}
function iL(r, e, t) {
  let s, i, n, a;
  tL(r);
  const o = r.vertices, h = r.skins;
  let l;
  const c = r.meshes, d = r.meshInstances, u = function(m) {
    const _ = new QR();
    return _.index = m, _;
  };
  for (s = h.length - 1; s >= 0; s--)
    if (h[s].boneNames.length > t) {
      const f = h.splice(s, 1)[0], m = [];
      for (i = 0; i < c.length; i++)
        c[i].skin === f && m.push(c[i]);
      for (i = 0; i < m.length; i++)
        a = c.indexOf(m[i]), a !== -1 && c.splice(a, 1);
      if (m.length === 0)
        throw new Error("partitionSkin: There should be at least one mesh that references a skin");
      const _ = m[0].vertices;
      for (i = 1; i < m.length; i++)
        if (m[i].vertices !== _)
          throw new Error("partitionSkin: All meshes that share a skin should also share the same vertex buffer");
      let p;
      const g = [], b = [], x = [];
      let y = 0;
      for (i = 0; i < m.length; i++) {
        l = m[i];
        const I = l.indices;
        for (let D = l.base; D < l.base + l.count; ) {
          a = I[D++], b[0] = u(a), x[0] = a, a = I[D++], b[1] = u(a), x[1] = a, a = I[D++], b[2] = u(a), x[2] = a;
          let G = !1;
          for (let X = y; X < g.length; X++)
            if (p = g[X], p.addPrimitive(b, x, _, t)) {
              G = !0;
              break;
            }
          G || (p = new eL(), p.originalMesh = l, p.addPrimitive(b, x, _, t), g.push(p));
        }
        y = g.length;
      }
      const S = [], C = [];
      for (i = 0; i < g.length; i++)
        if (p = g[i], p.vertices.length && p.indices.length) {
          const I = S.length, D = p.vertices.length, G = C.length, X = p.indices.length;
          p.partition = i, p.vertexStart = I, p.vertexCount = D, p.indexStart = G, p.indexCount = X;
          let E, P;
          for (E = 0, P = I; E < D; )
            S[P++] = p.vertices[E++];
          for (E = 0, P = G; E < X; )
            C[P++] = p.indices[E++] + I;
        }
      const w = [];
      for (i = 0; i < g.length; i++) {
        p = g[i];
        const I = [], D = [];
        for (n = 0; n < p.boneIndices.length; n++)
          I.push(f.inverseBindMatrices[p.boneIndices[n]]), D.push(f.boneNames[p.boneIndices[n]]);
        const G = {
          inverseBindMatrices: I,
          boneNames: D
        };
        w.push(G), h.push(G);
      }
      let M, T, A, L;
      const O = {};
      for (T in _)
        O[T] = {
          components: _[T].components,
          data: [],
          type: _[T].type
        };
      for (T in _)
        if (T === "blendIndices") {
          const I = O[T].data;
          for (i = 0; i < S.length; i++) {
            const D = S[i].boneIndices;
            I.push(D[0], D[1], D[2], D[3]);
          }
        } else
          for (M = _[T], A = M.data, L = M.components, i = 0; i < S.length; i++)
            for (a = S[i].index, n = 0; n < L; n++)
              O[T].data.push(A[a * L + n]);
      for (o[o.indexOf(_)] = O, i = 0; i < g.length; i++)
        for (p = g[i], l = {
          aabb: {
            min: [0, 0, 0],
            max: [0, 0, 0]
          },
          vertices: O,
          skin: w[i],
          indices: C.splice(0, p.indexCount),
          type: "triangles",
          base: 0,
          count: p.indexCount
        }, c.push(l), n = d.length - 1; n >= 0; n--)
          d[n].mesh === p.originalMesh && (d.push({
            mesh: l,
            node: d[n].node
          }), e && e.push({
            material: e[n].material,
            path: e[n].path
          }));
      for (i = 0; i < g.length; i++)
        for (p = g[i], n = d.length - 1; n >= 0; n--)
          d[n].mesh === p.originalMesh && (d.splice(n, 1), e && e.splice(n, 1));
    }
  sL(r);
}
const nL = {
  points: so,
  lines: Ll,
  lineloop: T_,
  linestrip: C_,
  triangles: Es,
  trianglestrip: jr,
  trianglefan: Dn
}, rL = {
  int8: Nl,
  uint8: gi,
  int16: zl,
  uint16: Bn,
  int32: L_,
  uint32: P_,
  float32: Ie
};
class aL {
  constructor(e, t) {
    this._device = e, this._defaultMaterial = t;
  }
  parse(e) {
    const t = e.model;
    if (!t || t.version <= 1)
      return null;
    const s = this._parseNodes(e), i = this._parseSkins(e, s), n = this._parseVertexBuffers(e), a = this._parseIndexBuffers(e, n), o = this._parseMorphs(e, s, n), h = this._parseMeshes(e, i.skins, o.morphs, n, a.buffer, a.data), l = this._parseMeshInstances(e, s, h, i.skins, i.instances, o.morphs, o.instances), c = new Ti();
    return c.graph = s[0], c.meshInstances = l, c.skinInstances = i.instances, c.morphInstances = o.instances, c.getGraph().syncHierarchy(), c;
  }
  _parseNodes(e) {
    const t = e.model, s = [];
    let i;
    for (i = 0; i < t.nodes.length; i++) {
      const n = t.nodes[i], a = new bt(n.name);
      a.setLocalPosition(n.position[0], n.position[1], n.position[2]), a.setLocalEulerAngles(n.rotation[0], n.rotation[1], n.rotation[2]), a.setLocalScale(n.scale[0], n.scale[1], n.scale[2]), a.scaleCompensation = !!n.scaleCompensation, s.push(a);
    }
    for (i = 1; i < t.parents.length; i++)
      s[t.parents[i]].addChild(s[i]);
    return s;
  }
  _parseSkins(e, t) {
    const s = e.model, i = [], n = [];
    let a, o;
    if (!this._device.supportsBoneTextures && s.skins.length > 0) {
      const h = this._device.getBoneLimit();
      iL(s, null, h);
    }
    for (a = 0; a < s.skins.length; a++) {
      const h = s.skins[a], l = [];
      for (o = 0; o < h.inverseBindMatrices.length; o++) {
        const f = h.inverseBindMatrices[o];
        l[o] = new j().set(f);
      }
      const c = new yg(this._device, l, h.boneNames);
      i.push(c);
      const d = new no(c), u = [];
      for (o = 0; o < c.boneNames.length; o++) {
        const f = c.boneNames[o], m = t[0].findByName(f);
        u.push(m);
      }
      d.bones = u, n.push(d);
    }
    return {
      skins: i,
      instances: n
    };
  }
  _getMorphVertexCount(e, t, s) {
    for (let i = 0; i < e.meshes.length; i++) {
      const n = e.meshes[i];
      if (n.morph === t)
        return s[n.vertices].numVertices;
    }
  }
  _parseMorphs(e, t, s) {
    const i = e.model, n = [], a = [];
    let o, h, l, c, d, u;
    if (i.morphs) {
      const f = function(_, p, g) {
        const b = new Float32Array(g * 3);
        for (let x = 0; x < p.length; x++) {
          const y = p[x] * 3;
          b[y] = _[x * 3], b[y + 1] = _[x * 3 + 1], b[y + 2] = _[x * 3 + 2];
        }
        return b;
      };
      for (o = 0; o < i.morphs.length; o++) {
        for (c = i.morphs[o].targets, u = [], l = this._getMorphVertexCount(i, o, s), h = 0; h < c.length; h++) {
          const p = c[h].aabb, g = p.min, b = p.max, x = new Pe(new v((b[0] + g[0]) * 0.5, (b[1] + g[1]) * 0.5, (b[2] + g[2]) * 0.5), new v((b[0] - g[0]) * 0.5, (b[1] - g[1]) * 0.5, (b[2] - g[2]) * 0.5)), y = c[h].indices;
          let S = c[h].deltaPositions, C = c[h].deltaNormals;
          y && (S = f(S, y, l), C = f(C, y, l)), d = new $l({
            deltaPositions: S,
            deltaNormals: C,
            name: c[h].name,
            aabb: x
          }), u.push(d);
        }
        const m = new _g(u, this._device);
        n.push(m);
        const _ = new kn(m);
        a.push(_);
      }
    }
    return {
      morphs: n,
      instances: a
    };
  }
  _parseVertexBuffers(e) {
    const t = e.model, s = [], i = {
      position: et,
      normal: Gt,
      tangent: qs,
      blendWeight: Xs,
      blendIndices: ts,
      color: It,
      texCoord0: rs,
      texCoord1: Zi,
      texCoord2: Pl,
      texCoord3: Il,
      texCoord4: Dl,
      texCoord5: Bl,
      texCoord6: Fl,
      texCoord7: Ol
    };
    for (let n = 0; n < t.vertices.length; n++) {
      const a = t.vertices[n], o = [];
      for (const u in a) {
        const f = a[u];
        o.push({
          semantic: i[u],
          components: f.components,
          type: rL[f.type],
          normalize: i[u] === It
        });
      }
      const h = new Ot(this._device, o), l = a.position.data.length / a.position.components, c = new yi(this._device, h, l), d = new Da(c);
      for (let u = 0; u < l; u++) {
        for (const f in a) {
          const m = a[f];
          switch (m.components) {
            case 1:
              d.element[i[f]].set(m.data[u]);
              break;
            case 2:
              d.element[i[f]].set(m.data[u * 2], 1 - m.data[u * 2 + 1]);
              break;
            case 3:
              d.element[i[f]].set(m.data[u * 3], m.data[u * 3 + 1], m.data[u * 3 + 2]);
              break;
            case 4:
              d.element[i[f]].set(m.data[u * 4], m.data[u * 4 + 1], m.data[u * 4 + 2], m.data[u * 4 + 3]);
              break;
          }
        }
        d.next();
      }
      d.end(), s.push(c);
    }
    return s;
  }
  _parseIndexBuffers(e, t) {
    const s = e.model;
    let i = null, n = null, a, o = 0;
    for (a = 0; a < s.meshes.length; a++) {
      const l = s.meshes[a];
      l.indices !== void 0 && (o += l.indices.length);
    }
    let h = 0;
    for (a = 0; a < t.length; a++)
      h = Math.max(h, t[a].numVertices);
    return o > 0 && (h > 65535 && this._device.extUintElement ? (i = new ji(this._device, Pn, o), n = new Uint32Array(i.lock())) : (i = new ji(this._device, pi, o), n = new Uint16Array(i.lock()))), {
      buffer: i,
      data: n
    };
  }
  _parseMeshes(e, t, s, i, n, a) {
    const o = e.model, h = [];
    let l = 0;
    for (let c = 0; c < o.meshes.length; c++) {
      const d = o.meshes[c], u = d.aabb, f = u.min, m = u.max, _ = new Pe(new v((m[0] + f[0]) * 0.5, (m[1] + f[1]) * 0.5, (m[2] + f[2]) * 0.5), new v((m[0] - f[0]) * 0.5, (m[1] - f[1]) * 0.5, (m[2] - f[2]) * 0.5)), p = d.indices !== void 0, g = new _s(this._device);
      g.vertexBuffer = i[d.vertices], g.indexBuffer[0] = p ? n : null, g.primitive[0].type = nL[d.type], g.primitive[0].base = p ? d.base + l : d.base, g.primitive[0].count = d.count, g.primitive[0].indexed = p, g.skin = d.skin !== void 0 ? t[d.skin] : null, g.morph = d.morph !== void 0 ? s[d.morph] : null, g.aabb = _, p && (a.set(d.indices, l), l += d.indices.length), h.push(g);
    }
    return n !== null && n.unlock(), h;
  }
  _parseMeshInstances(e, t, s, i, n, a, o) {
    const h = e.model, l = [];
    let c;
    for (c = 0; c < h.meshInstances.length; c++) {
      const d = h.meshInstances[c], u = t[d.node], f = s[d.mesh], m = new we(f, this._defaultMaterial, u);
      if (f.skin) {
        const _ = i.indexOf(f.skin);
        m.skinInstance = n[_];
      }
      if (f.morph) {
        const _ = a.indexOf(f.morph);
        m.morphInstance = o[_];
      }
      l.push(m);
    }
    return l;
  }
}
class oL {
  constructor(e) {
    this.handlerType = "model", this._device = e.graphicsDevice, this._parsers = [], this._defaultMaterial = io(this._device), this.maxRetries = 0, this.addParser(new aL(this._device, this._defaultMaterial), function(t, s) {
      return me.getExtension(t) === ".json";
    }), this.addParser(new JR(this._device, this._defaultMaterial), function(t, s) {
      return me.getExtension(t) === ".glb";
    });
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    (e.load.startsWith("blob:") || e.load.startsWith("data:")) && (me.getExtension(e.original).toLowerCase() === ".glb" ? s.responseType = ve.ResponseType.ARRAY_BUFFER : s.responseType = ve.ResponseType.JSON), $e.get(e.load, s, function(i, n) {
      t && (i ? t(`Error loading model: ${e.original} [${i}]`) : t(null, n));
    });
  }
  open(e, t) {
    for (let s = 0; s < this._parsers.length; s++) {
      const i = this._parsers[s];
      if (i.decider(e, t))
        return i.parser.parse(t);
    }
    return null;
  }
  patch(e, t) {
    if (!e.resource)
      return;
    const s = e.data, i = this;
    e.resource.meshInstances.forEach(function(n, a) {
      if (s.mapping) {
        const o = function d(u) {
          u.resource ? n.material = u.resource : (u.once("load", d), t.load(u)), u.once("remove", function(f) {
            n.material === f.resource && (n.material = i._defaultMaterial);
          });
        };
        if (!s.mapping[a]) {
          n.material = i._defaultMaterial;
          return;
        }
        const h = s.mapping[a].material, l = s.mapping[a].path;
        let c;
        if (h !== void 0)
          h ? (c = t.get(h), c ? o(c) : t.once("add:" + h, o)) : n.material = i._defaultMaterial;
        else if (l) {
          const d = e.getAbsoluteUrl(s.mapping[a].path);
          c = t.getByUrl(d), c ? o(c) : t.once("add:url:" + d, o);
        }
      }
    });
  }
  addParser(e, t) {
    this._parsers.push({
      parser: e,
      decider: t
    });
  }
}
class hL {
  constructor(e) {
    this.handlerType = "scene", this._app = e, this.maxRetries = 0;
  }
  load(e, t) {
    Ry.load(e, this.maxRetries, t);
  }
  open(e, t) {
    this._app.systems.script.preloading = !0;
    const i = new Ju(this._app, !1).parse(t), n = this._app.scene;
    return n.root = i, this._app.applySceneSettings(t.settings), this._app.systems.script.preloading = !1, n;
  }
  patch(e, t) {
  }
}
class lL {
  constructor(e) {
    this.handlerType = "script", this._app = e, this._scripts = {}, this._cache = {};
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = this;
    fs.app = this._app, this._loadScript(e.load, (i, n, a) => {
      if (i)
        t(i);
      else if (fs.legacy) {
        let o = null;
        Cs._types.length && (o = Cs._types.pop()), o ? this._scripts[n] = o : o = null, t(null, o, a);
      } else {
        const o = {};
        for (let h = 0; h < Cs._types.length; h++)
          o[Cs._types[h].name] = Cs._types[h];
        Cs._types.length = 0, t(null, o, a), delete s._loader._cache[n + "script"];
      }
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
  _loadScript(e, t) {
    const s = document.head, i = document.createElement("script");
    this._cache[e] = i, i.async = !1, i.addEventListener("error", function(a) {
      t(`Script: ${a.target.src} failed to load`);
    }, !1);
    let n = !1;
    i.onload = i.onreadystatechange = function() {
      !n && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") && (n = !0, t(null, e, i));
    }, i.src = e, s.appendChild(i);
  }
}
class cL {
  constructor(e) {
    this.handlerType = "shader", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(`Error loading shader resource: ${e.original} [${s}]`) : t(null, i);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
function Kc(r) {
  const e = this;
  e.resource && (e.resource.atlas = r.resource);
}
function Zc(r) {
  this.registry.load(r);
}
class dL {
  constructor(e) {
    this.handlerType = "sprite", this._assets = e.assets, this._device = e.graphicsDevice, this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), me.getExtension(e.original) === ".json" && $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(s) : t(null, i);
    });
  }
  open(e, t) {
    const s = new yA(this._device);
    return e && (s.__data = t), s;
  }
  patch(e, t) {
    const s = e.resource;
    if (s.__data && (e.data.pixelsPerUnit = s.__data.pixelsPerUnit, e.data.renderMode = s.__data.renderMode, e.data.frameKeys = s.__data.frameKeys, s.__data.textureAtlasAsset)) {
      const i = t.getByUrl(s.__data.textureAtlasAsset);
      i ? e.data.textureAtlasAsset = i.id : console.warn("Could not find textureatlas with url: " + s.__data.textureAtlasAsset);
    }
    s.startUpdate(), s.renderMode = e.data.renderMode, s.pixelsPerUnit = e.data.pixelsPerUnit, s.frameKeys = e.data.frameKeys, this._updateAtlas(e), s.endUpdate(), e.off("change", this._onAssetChange, this), e.on("change", this._onAssetChange, this);
  }
  _updateAtlas(e) {
    const t = e.resource;
    if (!e.data.textureAtlasAsset) {
      t.atlas = null;
      return;
    }
    this._assets.off("load:" + e.data.textureAtlasAsset, Kc, e), this._assets.on("load:" + e.data.textureAtlasAsset, Kc, e);
    const s = this._assets.get(e.data.textureAtlasAsset);
    s && s.resource ? t.atlas = s.resource : s ? this._assets.load(s) : (this._assets.off("add:" + e.data.textureAtlasAsset, Zc, e), this._assets.on("add:" + e.data.textureAtlasAsset, Zc, e));
  }
  _onAssetChange(e, t, s, i) {
    t === "data" && s && s.textureAtlasAsset && i && s.textureAtlasAsset !== i.textureAtlasAsset && (this._assets.off("load:" + i.textureAtlasAsset, Kc, e), this._assets.off("add:" + i.textureAtlasAsset, Zc, e));
  }
}
class uL {
  constructor(e, t) {
    this._app = e, this._data = t, this._templateRoot = null;
  }
  instantiate() {
    return this._templateRoot || this._parseTemplate(), this._templateRoot.clone();
  }
  _parseTemplate() {
    const e = new Ju(this._app, !0);
    this._templateRoot = e.parse(this._data);
  }
}
class fL {
  constructor(e) {
    this.handlerType = "template", this._app = e, this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    $e.get(e.load, s, function(i, n) {
      i ? t("Error requesting template: " + e.original) : t(i, n);
    });
  }
  open(e, t) {
    return new uL(this._app, t);
  }
}
class mL {
  constructor(e) {
    this.handlerType = "text", this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), $e.get(e.load, {
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    }, function(s, i) {
      s ? t(`Error loading text resource: ${e.original} [${s}]`) : t(null, i);
    });
  }
  open(e, t) {
    return t;
  }
  patch(e, t) {
  }
}
const eh = {
  repeat: xt,
  clamp: he,
  mirror: _u
}, th = {
  nearest: Be,
  linear: rt,
  nearest_mip_nearest: yl,
  linear_mip_nearest: vl,
  nearest_mip_linear: xl,
  linear_mip_linear: Ln
}, pL = /^data\.frames\.(\d+)$/;
class _L {
  constructor(e) {
    this.handlerType = "textureatlas", this._loader = e.loader, this.maxRetries = 0;
  }
  load(e, t) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    });
    const s = this, i = this._loader.getHandler("texture");
    if (me.getExtension(e.original) === ".json")
      $e.get(e.load, {
        retry: this.maxRetries > 0,
        maxRetries: this.maxRetries
      }, function(n, a) {
        if (n)
          t(n);
        else {
          const o = e.original.replace(".json", ".png");
          s._loader.load(o, "texture", function(h, l) {
            h ? t(h) : t(null, {
              data: a,
              texture: l
            });
          });
        }
      });
    else
      return i.load(e, t);
  }
  open(e, t) {
    const s = new xA();
    if (t.texture && t.data)
      s.texture = t.texture, s.__data = t.data;
    else {
      const n = this._loader.getHandler("texture").open(e, t);
      if (!n)
        return null;
      s.texture = n;
    }
    return s;
  }
  patch(e, t) {
    if (!e.resource)
      return;
    e.resource.__data && (e.resource.__data.minfilter !== void 0 && (e.data.minfilter = e.resource.__data.minfilter), e.resource.__data.magfilter !== void 0 && (e.data.magfilter = e.resource.__data.magfilter), e.resource.__data.addressu !== void 0 && (e.data.addressu = e.resource.__data.addressu), e.resource.__data.addressv !== void 0 && (e.data.addressv = e.resource.__data.addressv), e.resource.__data.mipmaps !== void 0 && (e.data.mipmaps = e.resource.__data.mipmaps), e.resource.__data.anisotropy !== void 0 && (e.data.anisotropy = e.resource.__data.anisotropy), e.resource.__data.rgbm !== void 0 && (e.data.rgbm = !!e.resource.__data.rgbm), e.data.frames = e.resource.__data.frames, delete e.resource.__data);
    const s = e.resource.texture;
    if (s && (s.name = e.name, e.data.hasOwnProperty("minfilter") && s.minFilter !== th[e.data.minfilter] && (s.minFilter = th[e.data.minfilter]), e.data.hasOwnProperty("magfilter") && s.magFilter !== th[e.data.magfilter] && (s.magFilter = th[e.data.magfilter]), e.data.hasOwnProperty("addressu") && s.addressU !== eh[e.data.addressu] && (s.addressU = eh[e.data.addressu]), e.data.hasOwnProperty("addressv") && s.addressV !== eh[e.data.addressv] && (s.addressV = eh[e.data.addressv]), e.data.hasOwnProperty("mipmaps") && s.mipmaps !== e.data.mipmaps && (s.mipmaps = e.data.mipmaps), e.data.hasOwnProperty("anisotropy") && s.anisotropy !== e.data.anisotropy && (s.anisotropy = e.data.anisotropy), e.data.hasOwnProperty("rgbm"))) {
      const n = e.data.rgbm ? _i : Rs;
      s.type !== n && (s.type = n);
    }
    e.resource.texture = s;
    const i = {};
    for (const n in e.data.frames) {
      const a = e.data.frames[n];
      i[n] = {
        rect: new Z(a.rect),
        pivot: new q(a.pivot),
        border: new Z(a.border)
      };
    }
    e.resource.frames = i, e.off("change", this._onAssetChange, this), e.on("change", this._onAssetChange, this);
  }
  _onAssetChange(e, t, s) {
    let i;
    if (t === "data" || t === "data.frames") {
      const n = {};
      for (const a in s.frames)
        i = s.frames[a], n[a] = {
          rect: new Z(i.rect),
          pivot: new q(i.pivot),
          border: new Z(i.border)
        };
      e.resource.frames = n;
    } else {
      const n = t.match(pL);
      if (n) {
        const a = n[1];
        s ? (e.resource.frames[a] ? (i = e.resource.frames[a], i.rect.set(s.rect[0], s.rect[1], s.rect[2], s.rect[3]), i.pivot.set(s.pivot[0], s.pivot[1]), i.border.set(s.border[0], s.border[1], s.border[2], s.border[3])) : e.resource.frames[a] = {
          rect: new Z(s.rect),
          pivot: new q(s.pivot),
          border: new Z(s.border)
        }, e.resource.fire("set:frame", a, e.resource.frames[a])) : e.resource.frames[a] && (delete e.resource.frames[a], e.resource.fire("remove:frame", a));
      }
    }
  }
}
function gL() {
  const r = {
    cTFETC1: 0,
    cTFETC2: 1,
    cTFBC1: 2,
    cTFBC3: 3,
    cTFPVRTC1_4_RGB: 8,
    cTFPVRTC1_4_RGBA: 9,
    cTFASTC_4x4: 10,
    cTFATC_RGB: 11,
    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
    cTFRGBA32: 13,
    cTFRGB565: 14,
    cTFRGBA4444: 16
  }, e = {
    astc: r.cTFASTC_4x4,
    dxt: r.cTFBC1,
    etc1: r.cTFETC1,
    etc2: r.cTFETC1,
    pvr: r.cTFPVRTC1_4_RGB,
    atc: r.cTFATC_RGB,
    none: r.cTFRGB565
  }, t = {
    astc: r.cTFASTC_4x4,
    dxt: r.cTFBC3,
    etc1: r.cTFRGBA4444,
    etc2: r.cTFETC2,
    pvr: r.cTFPVRTC1_4_RGBA,
    atc: r.cTFATC_RGBA_INTERPOLATED_ALPHA,
    none: r.cTFRGBA4444
  }, s = {
    ETC1: 21,
    ETC2_RGB: 22,
    ETC2_RGBA: 23,
    DXT1: 8,
    DXT5: 10,
    PVRTC_4BPP_RGB_1: 26,
    PVRTC_4BPP_RGBA_1: 27,
    ASTC_4x4: 28,
    ATC_RGB: 29,
    ATC_RGBA: 30,
    R8_G8_B8_A8: 7,
    R5_G6_B5: 3,
    R4_G4_B4_A4: 5
  }, i = (y, S) => {
    switch (y) {
      case r.cTFETC1:
        return S.formats.etc1 ? s.ETC1 : s.ETC2_RGB;
      case r.cTFETC2:
        return s.ETC2_RGBA;
      case r.cTFBC1:
        return s.DXT1;
      case r.cTFBC3:
        return s.DXT5;
      case r.cTFPVRTC1_4_RGB:
        return s.PVRTC_4BPP_RGB_1;
      case r.cTFPVRTC1_4_RGBA:
        return s.PVRTC_4BPP_RGBA_1;
      case r.cTFASTC_4x4:
        return s.ASTC_4x4;
      case r.cTFATC_RGB:
        return s.ATC_RGB;
      case r.cTFATC_RGBA_INTERPOLATED_ALPHA:
        return s.ATC_RGBA;
      case r.cTFRGBA32:
        return s.R8_G8_B8_A8;
      case r.cTFRGB565:
        return s.R5_G6_B5;
      case r.cTFRGBA4444:
        return s.R4_G4_B4_A4;
    }
  }, n = (y) => {
    const S = function(w, M) {
      const T = w * 0.00784313725490196 - 1, A = M * (2 / 255) - 1, L = Math.sqrt(1 - Math.min(1, T * T + A * A));
      return Math.max(0, Math.min(255, Math.floor((L + 1) * 0.5 * 255)));
    };
    for (let C = 0; C < y.length; C += 4) {
      const w = y[C + 3], M = y[C + 1];
      y[C + 0] = w, y[C + 2] = S(w, M), y[C + 3] = 255;
    }
    return y;
  }, a = (y) => {
    const S = new Uint16Array(y.length / 4);
    for (let C = 0; C < y.length; C += 4) {
      const w = y[C + 0], M = y[C + 1], T = y[C + 2];
      S[C / 4] = (w & 248) << 8 | (M & 252) << 3 | T >> 3;
    }
    return S;
  }, o = (y, S) => (y & y - 1) === 0 && (S & S - 1) === 0, h = () => typeof performance < "u" ? performance.now() : 0;
  let l, c, d;
  const u = (y, S, C) => {
    if (C) {
      if (y.formats.astc)
        return "astc";
    } else if (S) {
      if (y.formats.etc2)
        return "etc2";
    } else if (y.formats.etc1 || y.formats.etc2)
      return "etc1";
    return ((M) => {
      for (let T = 0; T < M.length; ++T) {
        const A = M[T];
        if (y.formats[A])
          return A;
      }
      return "none";
    })(S ? d : c);
  }, f = (y, S, C, w) => {
    switch (C) {
      case r.cTFETC1:
      case r.cTFETC2:
        return !0;
      case r.cTFBC1:
      case r.cTFBC3:
        return (y & 3) === 0 && (S & 3) === 0;
      case r.cTFPVRTC1_4_RGB:
      case r.cTFPVRTC1_4_RGBA:
        return o(y, S) && (y === S || w);
      case r.cTFASTC_4x4:
        return !0;
      case r.cTFATC_RGB:
      case r.cTFATC_RGBA_INTERPOLATED_ALPHA:
        return !0;
    }
  }, m = (y, S, C) => {
    if (!l.KTX2File)
      throw new Error("Basis transcoder module does not include support for KTX2.");
    const w = h(), M = new l.KTX2File(new Uint8Array(S)), T = M.getWidth(), A = M.getHeight(), L = M.getLevels(), O = !!M.getHasAlpha(), I = M.isUASTC && M.isUASTC();
    if (!T || !A || !L)
      throw M.close(), M.delete(), new Error(`Invalid image dimensions url=${y} width=${T} height=${A} levels=${L}`);
    const D = u(C.deviceDetails, O, I), G = !!C.isGGGR && D === "pvr";
    let X;
    if (G ? X = r.cTFRGBA32 : (X = O ? t[D] : e[D], f(T, A, X, C.deviceDetails.webgl2) || (X = O ? r.cTFRGBA32 : r.cTFRGB565)), !M.startTranscoding())
      throw M.close(), M.delete(), new Error("Failed to start transcoding url=" + y);
    let E;
    const P = [];
    for (let B = 0; B < L; ++B) {
      const k = M.getImageTranscodedSizeInBytes(B, 0, 0, X), H = new Uint8Array(k);
      if (!M.transcodeImage(H, B, 0, 0, X, 0, -1, -1))
        throw M.close(), M.delete(), new Error("Failed to transcode image url=" + y);
      const V = X === r.cTFRGB565 || X === r.cTFRGBA4444;
      P.push(V ? new Uint16Array(H.buffer) : H);
    }
    if (M.close(), M.delete(), G)
      for (X = r.cTFRGB565, E = 0; E < P.length; ++E)
        P[E] = a(n(P[E]));
    return {
      format: i(X, C.deviceDetails),
      width: T,
      height: A,
      levels: P,
      cubemap: !1,
      transcodeTime: h() - w,
      url: y,
      unswizzledGGGR: G
    };
  }, _ = (y, S, C) => {
    const w = h(), M = new l.BasisFile(new Uint8Array(S)), T = M.getImageWidth(0, 0), A = M.getImageHeight(0, 0), L = M.getNumImages(), O = M.getNumLevels(0), I = !!M.getHasAlpha(), D = M.isUASTC && M.isUASTC();
    if (!T || !A || !L || !O)
      throw M.close(), M.delete(), new Error(`Invalid image dimensions url=${y} width=${T} height=${A} images=${L} levels=${O}`);
    const G = u(C.deviceDetails, I, D), X = !!C.isGGGR && G === "pvr";
    let E;
    if (X ? E = r.cTFRGBA32 : (E = I ? t[G] : e[G], f(T, A, E, C.deviceDetails.webgl2) || (E = I ? r.cTFRGBA32 : r.cTFRGB565)), !M.startTranscoding())
      throw M.close(), M.delete(), new Error("Failed to start transcoding url=" + y);
    let P;
    const B = [];
    for (let k = 0; k < O; ++k) {
      const H = M.getImageTranscodedSizeInBytes(0, k, E), V = new Uint8Array(H);
      if (!M.transcodeImage(V, 0, k, E, 0, 0))
        throw M.close(), M.delete(), new Error("Failed to transcode image url=" + y);
      const K = E === r.cTFRGB565 || E === r.cTFRGBA4444;
      B.push(K ? new Uint16Array(V.buffer) : V);
    }
    if (M.close(), M.delete(), X)
      for (E = r.cTFRGB565, P = 0; P < B.length; ++P)
        B[P] = a(n(B[P]));
    return {
      format: i(E, C.deviceDetails),
      width: T,
      height: A,
      levels: B,
      cubemap: !1,
      transcodeTime: h() - w,
      url: y,
      unswizzledGGGR: X
    };
  }, p = (y, S, C) => C.isKTX2 ? m(y, S, C) : _(y, S, C), g = (y, S, C) => {
    try {
      const w = p(y, S, C);
      w.levels = w.levels.map((M) => M.buffer), self.postMessage({
        url: y,
        data: w
      }, w.levels);
    } catch (w) {
      self.postMessage({
        url: y,
        err: w
      }, null);
    }
  }, b = (y, S) => {
    const C = (w, M) => (WebAssembly.instantiate(y.module, w).then((T) => {
      M(T);
    }).catch((T) => {
      console.error("instantiate failed + " + T);
    }), {});
    self.BASIS(y.module ? {
      instantiateWasm: C
    } : null).then((w) => {
      w.initializeBasis(), l = w, c = y.rgbPriority, d = y.rgbaPriority, S(null);
    });
  }, x = [];
  self.onmessage = (y) => {
    const S = y.data;
    switch (S.type) {
      case "init":
        b(S.config, () => {
          for (let C = 0; C < x.length; ++C)
            g(x[C].url, x[C].data, x[C].options);
          x.length = 0;
        });
        break;
      case "transcode":
        l ? g(S.url, S.data, S.options) : x.push(S);
        break;
    }
  };
}
const yL = (r) => ({
  astc: !!r.extCompressedTextureASTC,
  atc: !!r.extCompressedTextureATC,
  dxt: !!r.extCompressedTextureS3TC,
  etc1: !!r.extCompressedTextureETC1,
  etc2: !!r.extCompressedTextureETC,
  pvr: !!r.extCompressedTexturePVRTC
}), xL = (r, e) => {
  const t = (a) => {
    const o = ["/* basis */", a, "", "(" + gL.toString() + `)()

`].join(`
`);
    return new Blob([o], {
      type: "application/javascript"
    });
  }, s = () => {
    try {
      if (typeof WebAssembly == "object" && typeof WebAssembly.instantiate == "function") {
        const a = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
        if (a instanceof WebAssembly.Module)
          return new WebAssembly.Instance(a) instanceof WebAssembly.Instance;
      }
    } catch {
    }
    return !1;
  }, i = (a, o) => {
    e(null, {
      workerUrl: URL.createObjectURL(t(a)),
      module: o,
      rgbPriority: r.rgbPriority,
      rgbaPriority: r.rgbaPriority
    });
  }, n = {
    cache: !0,
    responseType: "text",
    retry: r.maxRetries > 0,
    maxRetries: r.maxRetries
  };
  if (r.glueUrl && r.wasmUrl && s()) {
    let a = null, o = null;
    $e.get(r.glueUrl, n, (c, d) => {
      c ? e(c) : o ? i(d, o) : a = d;
    });
    const h = fetch(r.wasmUrl), l = () => {
      h.then((c) => c.arrayBuffer()).then((c) => WebAssembly.compile(c)).then((c) => {
        a ? i(a, c) : o = c;
      }).catch((c) => {
        e(c, null);
      });
    };
    WebAssembly.compileStreaming ? WebAssembly.compileStreaming(h).then((c) => {
      a ? i(a, c) : o = c;
    }).catch((c) => {
      l();
    }) : l();
  } else
    $e.get(r.fallbackUrl, n, (a, o) => {
      a ? e(a, null) : i(o, null);
    });
};
class vL {
  constructor() {
    this.callbacks = {}, this.queue = [], this.clients = [];
  }
  enqueueJob(e, t, s, i) {
    if (this.callbacks.hasOwnProperty(e))
      this.callbacks[e].push(s);
    else {
      this.callbacks[e] = [s];
      const n = {
        url: e,
        data: t,
        options: i
      };
      this.clients.length > 0 ? this.clients.shift().run(n) : this.queue.push(n);
    }
  }
  enqueueClient(e) {
    this.queue.length > 0 ? e.run(this.queue.shift()) : this.clients.push(e);
  }
  handleResponse(e, t, s) {
    const i = this.callbacks[e];
    if (t)
      for (let n = 0; n < i.length; ++n)
        i[n](t);
    else {
      s.format === Tl || s.format === Cl ? s.levels = s.levels.map(function(n) {
        return new Uint16Array(n);
      }) : s.levels = s.levels.map(function(n) {
        return new Uint8Array(n);
      });
      for (let n = 0; n < i.length; ++n)
        i[n](null, s);
    }
    delete this.callbacks[e];
  }
}
class SL {
  constructor(e, t, s) {
    this.queue = e, this.worker = new Worker(t.workerUrl), this.worker.addEventListener("message", (i) => {
      const n = i.data;
      this.queue.handleResponse(n.url, n.err, n.data), this.eager || this.queue.enqueueClient(this);
    }), this.worker.postMessage({
      type: "init",
      config: t
    }), this.eager = s;
  }
  run(e) {
    const t = [];
    e.data instanceof ArrayBuffer && t.push(e.data), this.worker.postMessage({
      type: "transcode",
      url: e.url,
      format: e.format,
      data: e.data,
      options: e.options
    }, t), this.eager && this.queue.enqueueClient(this);
  }
}
const bL = 1, wL = ["etc1", "etc2", "astc", "dxt", "pvr", "atc"], TL = ["astc", "dxt", "etc2", "pvr", "atc"], CL = 5, ou = new vL();
let kp = null, hu = !1;
function AL(r) {
  if (!hu) {
    if (!r)
      r = kp || {};
    else if (r.lazyInit) {
      kp = r;
      return;
    }
    if (!r.glueUrl || !r.wasmUrl || !r.fallbackUrl) {
      const t = ((window.config ? window.config.wasmModules : window.PRELOAD_MODULES) || []).find(function(s) {
        return s.moduleName === "BASIS";
      });
      if (t) {
        const s = window.ASSET_PREFIX || "";
        r.glueUrl || (r.glueUrl = s + t.glueUrl), r.wasmUrl || (r.wasmUrl = s + t.wasmUrl), r.fallbackUrl || (r.fallbackUrl = s + t.fallbackUrl);
      }
    }
    if (r.glueUrl || r.wasmUrl || r.fallbackUrl) {
      hu = !0;
      const e = Math.max(1, Math.min(16, r.numWorkers || bL)), t = r.numWorkers === 1 || (r.hasOwnProperty("eagerWorkers") ? r.eagerWorkers : !0);
      r.rgbPriority = r.rgbPriority || wL, r.rgbaPriority = r.rgbaPriority || TL, r.maxRetries = r.hasOwnProperty("maxRetries") ? r.maxRetries : CL, xL(r, (s, i) => {
        if (s)
          console.error(`failed to initialize basis worker: ${s}`);
        else
          for (let n = 0; n < e; ++n)
            ou.enqueueClient(new SL(ou, i, t));
      });
    }
  }
}
let Jc = null;
function Ly(r, e, t, s, i) {
  return AL(), Jc || (Jc = {
    webgl2: r.webgl2,
    formats: yL(r)
  }), ou.enqueueJob(e, t, s, {
    deviceDetails: Jc,
    isGGGR: !!(i != null && i.isGGGR),
    isKTX2: !!(i != null && i.isKTX2)
  }), hu;
}
class ML {
  constructor(e, t) {
    this.device = t, this.maxRetries = 0;
  }
  load(e, t, s) {
    const i = this.device, n = (a) => {
      var o, h, l;
      Ly(i, e.load, a, t, {
        isGGGR: ((s == null || (o = s.file) == null || (h = o.variants) == null || (l = h.basis) == null ? void 0 : l.opt) & 8) !== 0
      }) || t(`Basis module not found. Asset '${s.name}' basis texture variant will not be loaded.`);
    };
    ce.fetchArrayBuffer(e.load, (a, o) => {
      a ? t(a) : n(o);
    }, s, this.maxRetries);
  }
  open(e, t, s) {
    const i = new ue(s, {
      name: e,
      addressU: t.cubemap ? he : xt,
      addressV: t.cubemap ? he : xt,
      width: t.width,
      height: t.height,
      format: t.format,
      cubemap: t.cubemap,
      levels: t.levels
    });
    return i.upload(), i;
  }
}
class EL {
  constructor(e, t) {
    this.crossOrigin = e.prefix ? "anonymous" : null, this.maxRetries = 0, this.device = t;
  }
  load(e, t, s) {
    var i;
    const n = !!(s != null && (i = s.file) != null && i.contents);
    if (n) {
      if (this.device.supportsImageBitmap) {
        this._loadImageBitmapFromData(s.file.contents, t);
        return;
      }
      e = {
        load: URL.createObjectURL(new Blob([s.file.contents])),
        original: e.original
      };
    }
    const a = (h, l) => {
      n && URL.revokeObjectURL(e.load), t(h, l);
    };
    let o;
    s && s.options && s.options.hasOwnProperty("crossOrigin") ? o = s.options.crossOrigin : nl.test(e.load) && (o = this.crossOrigin), this.device.supportsImageBitmap ? this._loadImageBitmap(e.load, e.original, o, a) : this._loadImage(e.load, e.original, o, a);
  }
  open(e, t, s) {
    const i = me.getExtension(e).toLowerCase(), n = i === ".jpg" || i === ".jpeg" ? Si : ye, a = new ue(s, {
      name: e,
      width: t.width,
      height: t.height,
      format: n
    });
    return a.setSource(t), a;
  }
  _loadImage(e, t, s, i) {
    const n = new Image();
    s && (n.crossOrigin = s);
    let a = 0;
    const o = this.maxRetries;
    let h;
    n.onload = function() {
      i(null, n);
    }, n.onerror = function() {
      if (!h)
        if (o > 0 && ++a <= o) {
          const l = Math.pow(2, a) * 100;
          console.log(`Error loading Texture from: '${t}' - Retrying in ${l}ms...`);
          const d = e.indexOf("?") >= 0 ? "&" : "?";
          h = setTimeout(function() {
            n.src = e + d + "retry=" + Date.now(), h = null;
          }, l);
        } else
          i(`Error loading Texture from: '${t}'`);
    }, n.src = e;
  }
  _loadImageBitmap(e, t, s, i) {
    const n = {
      cache: !0,
      responseType: "blob",
      retry: this.maxRetries > 0,
      maxRetries: this.maxRetries
    };
    $e.get(e, n, function(a, o) {
      a ? i(a) : createImageBitmap(o, {
        premultiplyAlpha: "none"
      }).then((h) => i(null, h)).catch((h) => i(h));
    });
  }
  _loadImageBitmapFromData(e, t) {
    createImageBitmap(new Blob([e]), {
      premultiplyAlpha: "none"
    }).then((s) => t(null, s)).catch((s) => t(s));
  }
}
const Qc = [1481919403, 3140563232, 169478669], RL = {
  33776: Fr,
  33778: Rh,
  33779: In,
  36196: to,
  37492: bu,
  37496: wu,
  35840: El,
  35841: Ga,
  35842: Rl,
  35843: Ha,
  32849: Si,
  32856: ye,
  35905: vu,
  35907: Su,
  35898: Ml,
  34843: za,
  34842: Pt
};
function LL(r, e, t, s) {
  return r === Ml ? new Uint32Array(e, t, s / 4) : new Uint8Array(e, t, s);
}
class PL {
  constructor(e) {
    this.maxRetries = 0;
  }
  load(e, t, s) {
    ce.fetchArrayBuffer(e.load, t, s, this.maxRetries);
  }
  open(e, t, s) {
    const i = this.parse(t);
    if (!i)
      return null;
    const n = new ue(s, {
      name: e,
      addressU: i.cubemap ? he : xt,
      addressV: i.cubemap ? he : xt,
      width: i.width,
      height: i.height,
      format: i.format,
      cubemap: i.cubemap,
      levels: i.levels
    });
    return n.upload(), n;
  }
  parse(e) {
    const t = new Uint32Array(e);
    if (Qc[0] !== t[0] || Qc[1] !== t[1] || Qc[2] !== t[2])
      return null;
    const s = {
      endianness: t[3],
      glType: t[4],
      glTypeSize: t[5],
      glFormat: t[6],
      glInternalFormat: t[7],
      glBaseInternalFormat: t[8],
      pixelWidth: t[9],
      pixelHeight: t[10],
      pixelDepth: t[11],
      numberOfArrayElements: t[12],
      numberOfFaces: t[13],
      numberOfMipmapLevels: t[14],
      bytesOfKeyValueData: t[15]
    };
    if (s.pixelDepth > 1 || s.numberOfArrayElements !== 0)
      return null;
    const i = RL[s.glInternalFormat];
    if (i === void 0)
      return null;
    let n = 16 + s.bytesOfKeyValueData / 4;
    const a = s.numberOfFaces > 1, o = [];
    for (let h = 0; h < (s.numberOfMipmapLevels || 1); h++) {
      const l = t[n++];
      a && o.push([]);
      const c = a ? o[h] : o;
      for (let d = 0; d < (a ? 6 : 1); ++d)
        c.push(LL(i, e, n * 4, l)), n += l + 3 >> 2;
    }
    return {
      format: i,
      width: s.pixelWidth,
      height: s.pixelHeight,
      levels: o,
      cubemap: a
    };
  }
}
const IL = {
  KHR_DF_MODEL_ETC1S: 163,
  KHR_DF_MODEL_UASTC: 166
};
class DL {
  constructor(e, t) {
    this.maxRetries = 0, this.device = t;
  }
  load(e, t, s) {
    ce.fetchArrayBuffer(e.load, (i, n) => {
      i ? t(i, n) : this.parse(n, e, t, s);
    }, s, this.maxRetries);
  }
  open(e, t, s) {
    const i = new ue(s, {
      name: e,
      addressU: t.cubemap ? he : xt,
      addressV: t.cubemap ? he : xt,
      width: t.width,
      height: t.height,
      format: t.format,
      cubemap: t.cubemap,
      levels: t.levels
    });
    return i.upload(), i;
  }
  parse(e, t, s, i) {
    const n = new p_(e), a = [n.readU32be(), n.readU32be(), n.readU32be()];
    if (a[0] !== 2873840728 || a[1] !== 540160187 || a[2] !== 218765834)
      return null;
    const o = {
      vkFormat: n.readU32(),
      typeSize: n.readU32(),
      pixelWidth: n.readU32(),
      pixelHeight: n.readU32(),
      pixelDepth: n.readU32(),
      layerCount: n.readU32(),
      faceCount: n.readU32(),
      levelCount: n.readU32(),
      supercompressionScheme: n.readU32()
    }, h = {
      dfdByteOffset: n.readU32(),
      dfdByteLength: n.readU32(),
      kvdByteOffset: n.readU32(),
      kvdByteLength: n.readU32(),
      sgdByteOffset: n.readU64(),
      sgdByteLength: n.readU64()
    }, l = [];
    for (let _ = 0; _ < Math.max(1, o.levelCount); ++_)
      l.push({
        byteOffset: n.readU64(),
        byteLength: n.readU64(),
        uncompressedByteLength: n.readU64()
      });
    if (n.readU32() !== h.kvdByteOffset - h.dfdByteOffset)
      return null;
    n.skip(8);
    const d = n.readU8();
    if (n.skip(h.dfdByteLength - 9), n.skip(h.kvdByteLength), o.supercompressionScheme === 1 || d === IL.KHR_DF_MODEL_UASTC) {
      var u, f, m;
      Ly(this.device, t.load, e, s, {
        isGGGR: ((i == null || (u = i.file) == null || (f = u.variants) == null || (m = f.basis) == null ? void 0 : m.opt) & 8) !== 0,
        isKTX2: !0
      }) || s('Basis module not found. Asset "' + i.name + '" basis texture variant will not be loaded.');
    } else
      s("unsupported KTX2 pixel format");
  }
}
class BL {
  constructor(e) {
    this.maxRetries = 0;
  }
  load(e, t, s) {
    ce.fetchArrayBuffer(e.load, t, s, this.maxRetries);
  }
  open(e, t, s) {
    const i = new Uint32Array(t, 0, 32), n = i[4], a = i[3], o = Math.max(i[7], 1), h = i[20] === 4, l = i[21], c = i[22], d = i[28] === 65024, u = 827611204, f = 894720068, m = 113, _ = 116, p = 826496069, g = 825438800, b = 825504336, x = 825439312, y = 825504848;
    let S = !1, C = !1, w = !1, M = !1, T = null, A = 1, L;
    if (h ? l === u ? (T = Fr, S = !0) : l === f ? (T = In, S = !0) : l === m ? (T = Pt, A = 2) : l === _ ? (T = vt, A = 4) : l === p ? (T = to, S = !0, C = !0) : l === g || l === b ? (T = l === g ? Ga : Ha, S = !0, w = !0) : (l === x || l === y) && (T = l === x ? El : Rl, S = !0, M = !0) : c === 32 && (T = ye), !T)
      return L = new ue(s, {
        width: 4,
        height: 4,
        format: Si,
        name: "dds-legacy-empty"
      }), L;
    L = new ue(s, {
      name: e,
      addressU: d ? he : xt,
      addressV: d ? he : xt,
      width: n,
      height: a,
      format: T,
      cubemap: d,
      mipmaps: o > 1
    });
    let O = 128;
    const I = d ? 6 : 1;
    let D;
    const G = 4, X = 4, E = l === u ? 8 : 16;
    let P, B, k;
    for (let H = 0; H < I; H++) {
      let V = n, K = a;
      for (let Q = 0; Q < o; Q++) {
        S ? C ? D = Math.floor((V + 3) / 4) * Math.floor((K + 3) / 4) * 8 : w ? D = Math.max(V, 16) * Math.max(K, 8) / 4 : M ? D = Math.max(V, 8) * Math.max(K, 8) / 2 : (P = Math.floor((V + G - 1) / G), B = Math.floor((K + X - 1) / X), k = P * B, D = k * E) : D = V * K * 4;
        const se = T === vt ? new Float32Array(t, O, D) : T === Pt ? new Uint16Array(t, O, D) : new Uint8Array(t, O, D);
        d ? (L._levels[Q] || (L._levels[Q] = []), L._levels[Q][H] = se) : L._levels[Q] = se, O += D * A, V = Math.max(V * 0.5, 1), K = Math.max(K * 0.5, 1);
      }
    }
    return L.upload(), L;
  }
}
class FL {
  constructor(e) {
    this.maxRetries = 0;
  }
  load(e, t, s) {
    ce.fetchArrayBuffer(e.load, t, s, this.maxRetries);
  }
  open(e, t, s) {
    const i = this.parse(t);
    if (!i)
      return null;
    const n = new ue(s, {
      name: e,
      addressU: xt,
      addressV: he,
      minFilter: Be,
      magFilter: Be,
      width: i.width,
      height: i.height,
      levels: i.levels,
      format: ye,
      type: Cu,
      mipmaps: !1
    });
    return n.upload(), n;
  }
  parse(e) {
    const t = new p_(e);
    if (!t.readLine().startsWith("#?RADIANCE"))
      return null;
    const i = {};
    for (; ; ) {
      const l = t.readLine();
      if (l.length === 0)
        break;
      {
        const c = l.split("=");
        c.length === 2 && (i[c[0]] = c[1]);
      }
    }
    if (!i.hasOwnProperty("FORMAT"))
      return null;
    const n = t.readLine().split(" ");
    if (n.length !== 4)
      return null;
    const a = parseInt(n[1], 10), o = parseInt(n[3], 10), h = this._readPixels(t, o, a, n[0] === "-Y");
    return h ? {
      width: o,
      height: a,
      levels: [h]
    } : null;
  }
  _readPixels(e, t, s, i) {
    if (t < 8 || t > 32767)
      return this._readPixelsFlat(e, t, s);
    const n = [0, 0, 0, 0];
    if (e.readArray(n), n[0] !== 2 || n[1] !== 2 || n[2] & 128)
      return e.skip(-4), this._readPixelsFlat(e, t, s);
    const a = new ArrayBuffer(t * s * 4), o = new Uint8Array(a);
    let h = i ? 0 : t * 4 * (s - 1), l, c, d, u, f, m;
    for (c = 0; c < s; ++c) {
      if (c && e.readArray(n), (n[2] << 8) + n[3] !== t)
        return null;
      for (u = 0; u < 4; ++u)
        for (l = 0; l < t; )
          if (f = e.readU8(), f > 128) {
            if (f -= 128, l + f > t)
              return null;
            for (m = e.readU8(), d = 0; d < f; ++d)
              o[h + u + 4 * l++] = m;
          } else {
            if (f === 0 || l + f > t)
              return null;
            for (d = 0; d < f; ++d)
              o[h + u + 4 * l++] = e.readU8();
          }
      h += t * 4 * (i ? 1 : -1);
    }
    return o;
  }
  _readPixelsFlat(e, t, s) {
    return e.remainingBytes === t * s * 4 ? new Uint8Array(e.arraybuffer, e.offset) : null;
  }
}
const Np = {
  repeat: xt,
  clamp: he,
  mirror: _u
}, zp = {
  nearest: Be,
  linear: rt,
  nearest_mip_nearest: yl,
  linear_mip_nearest: vl,
  nearest_mip_linear: xl,
  linear_mip_linear: Ln
}, OL = {
  default: Rs,
  rgbm: _i,
  rgbe: Cu,
  rgbp: R_,
  swizzleGGGR: kl
}, kL = function(e) {
  const t = Math.log2(Math.max(e._width, e._height)) + 1, s = function(a) {
    return a instanceof HTMLCanvasElement || a instanceof HTMLImageElement || a instanceof HTMLVideoElement;
  };
  if (!(e._format === ye || e._format === vt) || e._volume || e._compressed || e._levels.length === 1 || e._levels.length === t || s(e._cubemap ? e._levels[0][0] : e._levels[0]))
    return;
  const i = function(a, o, h) {
    const l = Math.max(1, a >> 1), c = Math.max(1, o >> 1), d = new h.constructor(l * c * 4), u = Math.floor(a / l), f = Math.floor(o / c), m = u * f;
    for (let _ = 0; _ < c; ++_)
      for (let p = 0; p < l; ++p)
        for (let g = 0; g < 4; ++g) {
          let b = 0;
          for (let x = 0; x < f; ++x)
            for (let y = 0; y < u; ++y)
              b += h[(p * u + y + (_ * f + x) * a) * 4 + g];
          d[(p + _ * l) * 4 + g] = b / m;
        }
    return d;
  };
  for (let n = e._levels.length; n < t; ++n) {
    const a = Math.max(1, e._width >> n - 1), o = Math.max(1, e._height >> n - 1);
    if (e._cubemap) {
      const h = [];
      for (let l = 0; l < 6; ++l)
        h.push(i(a, o, e._levels[n - 1][l]));
      e._levels.push(h);
    } else
      e._levels.push(i(a, o, e._levels[n - 1]));
  }
  e._levelsUpdated = e._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0];
};
class NL {
  constructor(e) {
    this.handlerType = "texture";
    const t = e.assets, s = e.graphicsDevice;
    this._device = s, this._assets = t, this._loader = e.loader, this.imgParser = new EL(t, s), this.parsers = {
      dds: new BL(t),
      ktx: new PL(t),
      ktx2: new DL(t, s),
      basis: new ML(t, s),
      hdr: new FL(t)
    };
  }
  set crossOrigin(e) {
    this.imgParser.crossOrigin = e;
  }
  get crossOrigin() {
    return this.imgParser.crossOrigin;
  }
  set maxRetries(e) {
    this.imgParser.maxRetries = e;
    for (const t in this.parsers)
      this.parsers.hasOwnProperty(t) && (this.parsers[t].maxRetries = e);
  }
  get maxRetries() {
    return this.imgParser.maxRetries;
  }
  _getUrlWithoutParams(e) {
    return e.indexOf("?") >= 0 ? e.split("?")[0] : e;
  }
  _getParser(e) {
    const t = me.getExtension(this._getUrlWithoutParams(e)).toLowerCase().replace(".", "");
    return this.parsers[t] || this.imgParser;
  }
  load(e, t, s) {
    typeof e == "string" && (e = {
      load: e,
      original: e
    }), this._getParser(e.original).load(e, t, s);
  }
  open(e, t, s) {
    if (!e)
      return;
    let i = this._getParser(e).open(e, t, this._device);
    return i === null ? i = new ue(this._device, {
      width: 4,
      height: 4,
      format: Si
    }) : (kL(i), t.unswizzledGGGR && (s.file.variants.basis.opt &= -9)), i;
  }
  patch(e, t) {
    const s = e.resource;
    if (!s)
      return;
    e.name && e.name.length > 0 && (s.name = e.name);
    const i = e.data;
    i.hasOwnProperty("minfilter") && (s.minFilter = zp[i.minfilter]), i.hasOwnProperty("magfilter") && (s.magFilter = zp[i.magfilter]), s.cubemap || (i.hasOwnProperty("addressu") && (s.addressU = Np[i.addressu]), i.hasOwnProperty("addressv") && (s.addressV = Np[i.addressv])), i.hasOwnProperty("mipmaps") && (s.mipmaps = i.mipmaps), i.hasOwnProperty("anisotropy") && (s.anisotropy = i.anisotropy), i.hasOwnProperty("flipY") && (s.flipY = !!i.flipY), i.hasOwnProperty("type") ? s.type = OL[i.type] : i.hasOwnProperty("rgbm") && i.rgbm ? s.type = _i : e.file && e.file.opt & 8 && (s.type = kl);
  }
}
const zL = "inline", Oa = "immersive-vr", Ir = "immersive-ar", UL = "viewer", VL = "local-floor", Qu = "left", GL = "right", Py = "cpu-optimized", HL = "gpu-optimized", WL = "luminance-alpha";
class qL extends _e {
  constructor(e) {
    super(), this._manager = void 0, this._available = !1, this._depthInfoCpu = null, this._depthInfoGpu = null, this._usage = null, this._dataFormat = null, this._matrixDirty = !1, this._matrix = new j(), this._emptyBuffer = new Uint8Array(32), this._depthBuffer = null, this._texture = void 0, this._manager = e, this._texture = new ue(this._manager.app.graphicsDevice, {
      format: wl,
      mipmaps: !1,
      addressU: he,
      addressV: he,
      minFilter: rt,
      magFilter: rt,
      name: "XRDepthSensing"
    }), this.supported && (this._manager.on("start", this._onSessionStart, this), this._manager.on("end", this._onSessionEnd, this));
  }
  destroy() {
    this._texture.destroy(), this._texture = null;
  }
  _onSessionStart() {
    const e = this._manager.session;
    try {
      this._usage = e.depthUsage, this._dataFormat = e.depthDataFormat;
    } catch (t) {
      this._usage = null, this._dataFormat = null, this._available = !1, this.fire("error", t);
    }
  }
  _onSessionEnd() {
    this._depthInfoCpu = null, this._depthInfoGpu = null, this._usage = null, this._dataFormat = null, this._available && (this._available = !1, this.fire("unavailable")), this._depthBuffer = null, this._texture._width = 4, this._texture._height = 4, this._texture._levels[0] = this._emptyBuffer, this._texture.upload();
  }
  _updateTexture() {
    const e = this._depthInfoCpu || this._depthInfoGpu;
    if (e) {
      let t = !1;
      if ((e.width !== this._texture.width || e.height !== this._texture.height) && (this._texture._width = e.width, this._texture._height = e.height, this._matrixDirty = !0, t = !0), this._depthInfoCpu) {
        const s = this._depthInfoCpu.data;
        this._depthBuffer = new Uint8Array(s), this._texture._levels[0] = this._depthBuffer, this._texture.upload();
      } else
        this._depthInfoGpu && (this._texture._levels[0] = this._depthInfoGpu.texture, this._texture.upload());
      t && this.fire("resize", e.width, e.height);
    } else
      this._depthBuffer && (this._depthBuffer = null, this._texture._width = 4, this._texture._height = 4, this._texture._levels[0] = this._emptyBuffer, this._texture.upload());
  }
  update(e, t) {
    if (!this._usage)
      return;
    let s = null, i = null;
    if (this._usage === Py && t ? s = e.getDepthInformation(t) : this._usage === HL && t && (i = e.getDepthInformation(t)), (this._depthInfoCpu && !s || !this._depthInfoCpu && s || this.depthInfoGpu && !i || !this._depthInfoGpu && i) && (this._matrixDirty = !0), this._depthInfoCpu = s, this._depthInfoGpu = i, this._updateTexture(), this._matrixDirty) {
      this._matrixDirty = !1;
      const n = this._depthInfoCpu || this._depthInfoGpu;
      n ? this._matrix.data.set(n.normDepthBufferFromNormView.matrix) : this._matrix.setIdentity();
    }
    (this._depthInfoCpu || this._depthInfoGpu) && !this._available ? (this._available = !0, this.fire("available")) : !this._depthInfoCpu && !this._depthInfoGpu && this._available && (this._available = !1, this.fire("unavailable"));
  }
  getDepth(e, t) {
    return this._depthInfoCpu ? this._depthInfoCpu.getDepthInMeters(e, t) : null;
  }
  get supported() {
    return lt.browser && !!window.XRDepthInformation;
  }
  get available() {
    return this._available;
  }
  get usage() {
    return this._usage;
  }
  get dataFormat() {
    return this._dataFormat;
  }
  get width() {
    const e = this._depthInfoCpu || this._depthInfoGpu;
    return e && e.width || 0;
  }
  get height() {
    const e = this._depthInfoCpu || this._depthInfoGpu;
    return e && e.height || 0;
  }
  get texture() {
    return this._texture;
  }
  get uvMatrix() {
    return this._matrix;
  }
  get rawValueToMeters() {
    const e = this._depthInfoCpu || this._depthInfoGpu;
    return e && e.rawValueToMeters || 0;
  }
}
class XL {
  constructor(e) {
    this._manager = void 0, this._supported = lt.browser && !!window.XRDOMOverlayState, this._root = null, this._manager = e;
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
  }
  get state() {
    return !this._supported || !this._manager.active || !this._manager._session.domOverlayState ? null : this._manager._session.domOverlayState.type;
  }
  set root(e) {
    !this._supported || this._manager.active || (this._root = e);
  }
  get root() {
    return this._root;
  }
}
const Up = [], Vp = [];
class jL extends _e {
  constructor(e, t, s) {
    super(), this.manager = void 0, this._xrHitTestSource = void 0, this._transient = void 0, this.manager = e, this._xrHitTestSource = t, this._transient = s;
  }
  remove() {
    if (!this._xrHitTestSource)
      return;
    const e = this.manager.hitTest.sources, t = e.indexOf(this);
    t !== -1 && e.splice(t, 1), this.onStop();
  }
  onStop() {
    this._xrHitTestSource.cancel(), this._xrHitTestSource = null, this.fire("remove"), this.manager.hitTest.fire("remove", this);
  }
  update(e) {
    if (this._transient) {
      const t = e.getHitTestResultsForTransientInput(this._xrHitTestSource);
      for (let s = 0; s < t.length; s++) {
        const i = t[s];
        let n;
        i.inputSource && (n = this.manager.input._getByInputSource(i.inputSource)), this.updateHitResults(i.results, n);
      }
    } else
      this.updateHitResults(e.getHitTestResults(this._xrHitTestSource));
  }
  updateHitResults(e, t) {
    for (let s = 0; s < e.length; s++) {
      const i = e[s].getPose(this.manager._referenceSpace);
      let n = Up.pop();
      n || (n = new v()), n.copy(i.transform.position);
      let a = Vp.pop();
      a || (a = new ee()), a.copy(i.transform.orientation), this.fire("result", n, a, t), this.manager.hitTest.fire("result", this, n, a, t), Up.push(n), Vp.push(a);
    }
  }
}
class $L extends _e {
  constructor(e) {
    super(), this.manager = void 0, this._supported = lt.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource), this._session = null, this.sources = [], this.manager = e, this._supported && (this.manager.on("start", this._onSessionStart, this), this.manager.on("end", this._onSessionEnd, this));
  }
  _onSessionStart() {
    this.manager.type === Ir && (this._session = this.manager.session);
  }
  _onSessionEnd() {
    if (this._session) {
      this._session = null;
      for (let e = 0; e < this.sources.length; e++)
        this.sources[e].onStop();
      this.sources = [];
    }
  }
  isAvailable(e, t) {
    let s;
    return this._supported || (s = new Error("XR HitTest is not supported")), this._session || (s = new Error("XR Session is not started (1)")), this.manager.type !== Ir && (s = new Error("XR HitTest is available only for AR")), s ? (e && e(s), t && t.fire("error", s), !1) : !0;
  }
  start(e = {}) {
    if (!this.isAvailable(e.callback, this))
      return;
    !e.profile && !e.spaceType && (e.spaceType = UL);
    let t;
    const s = e.offsetRay;
    if (s) {
      const n = new DOMPoint(s.origin.x, s.origin.y, s.origin.z, 1), a = new DOMPoint(s.direction.x, s.direction.y, s.direction.z, 0);
      t = new XRRay(n, a);
    }
    const i = e.callback;
    e.spaceType ? this._session.requestReferenceSpace(e.spaceType).then((n) => {
      if (!this._session) {
        const a = new Error("XR Session is not started (2)");
        i && i(a), this.fire("error", a);
        return;
      }
      this._session.requestHitTestSource({
        space: n,
        entityTypes: e.entityTypes || void 0,
        offsetRay: t
      }).then((a) => {
        this._onHitTestSource(a, !1, i);
      }).catch((a) => {
        i && i(a), this.fire("error", a);
      });
    }).catch((n) => {
      i && i(n), this.fire("error", n);
    }) : this._session.requestHitTestSourceForTransientInput({
      profile: e.profile,
      entityTypes: e.entityTypes || void 0,
      offsetRay: t
    }).then((n) => {
      this._onHitTestSource(n, !0, i);
    }).catch((n) => {
      i && i(n), this.fire("error", n);
    });
  }
  _onHitTestSource(e, t, s) {
    if (!this._session) {
      e.cancel();
      const n = new Error("XR Session is not started (3)");
      s && s(n), this.fire("error", n);
      return;
    }
    const i = new jL(this.manager, e, t);
    this.sources.push(i), s && s(null, i), this.fire("add", i);
  }
  update(e) {
    for (let t = 0; t < this.sources.length; t++)
      this.sources[t].update(e);
  }
  get supported() {
    return this._supported;
  }
}
class YL extends _e {
  constructor(e, t) {
    super(), this._image = void 0, this._width = void 0, this._bitmap = null, this._measuredWidth = 0, this._trackable = !1, this._tracking = !1, this._emulated = !1, this._pose = null, this._position = new v(), this._rotation = new ee(), this._image = e, this._width = t;
  }
  get image() {
    return this._image;
  }
  set width(e) {
    this._width = e;
  }
  get width() {
    return this._width;
  }
  get trackable() {
    return this._trackable;
  }
  get tracking() {
    return this._tracking;
  }
  get emulated() {
    return this._emulated;
  }
  prepare() {
    return this._bitmap ? {
      image: this._bitmap,
      widthInMeters: this._width
    } : createImageBitmap(this._image).then((e) => (this._bitmap = e, {
      image: this._bitmap,
      widthInMeters: this._width
    }));
  }
  destroy() {
    this._image = null, this._pose = null, this._bitmap && (this._bitmap.close(), this._bitmap = null);
  }
  getPosition() {
    return this._pose && this._position.copy(this._pose.transform.position), this._position;
  }
  getRotation() {
    return this._pose && this._rotation.copy(this._pose.transform.orientation), this._rotation;
  }
}
class KL extends _e {
  constructor(e) {
    super(), this._manager = void 0, this._supported = lt.browser && !!window.XRImageTrackingResult, this._available = !1, this._images = [], this._manager = e, this._supported && (this._manager.on("start", this._onSessionStart, this), this._manager.on("end", this._onSessionEnd, this));
  }
  add(e, t) {
    if (!this._supported || this._manager.active)
      return null;
    const s = new YL(e, t);
    return this._images.push(s), s;
  }
  remove(e) {
    if (this._manager.active)
      return;
    const t = this._images.indexOf(e);
    t !== -1 && (e.destroy(), this._images.splice(t, 1));
  }
  _onSessionStart() {
    this._manager.session.getTrackedImageScores().then((e) => {
      this._available = !0;
      for (let t = 0; t < e.length; t++)
        this._images[t]._trackable = e[t] === "trackable";
    }).catch((e) => {
      this._available = !1, this.fire("error", e);
    });
  }
  _onSessionEnd() {
    this._available = !1;
    for (let e = 0; e < this._images.length; e++) {
      const t = this._images[e];
      t._pose = null, t._measuredWidth = 0, t._tracking && (t._tracking = !1, t.fire("untracked"));
    }
  }
  prepareImages(e) {
    this._images.length ? Promise.all(this._images.map(function(t) {
      return t.prepare();
    })).then(function(t) {
      e(null, t);
    }).catch(function(t) {
      e(t, null);
    }) : e(null, null);
  }
  update(e) {
    if (!this._available)
      return;
    const t = e.getImageTrackingResults(), s = {};
    for (let i = 0; i < t.length; i++) {
      s[t[i].index] = t[i];
      const n = this._images[t[i].index];
      n._emulated = t[i].trackingState === "emulated", n._measuredWidth = t[i].measuredWidthInMeters, n._pose = e.getPose(t[i].imageSpace, this._manager._referenceSpace);
    }
    for (let i = 0; i < this._images.length; i++)
      this._images[i]._tracking && !s[i] ? (this._images[i]._tracking = !1, this._images[i].fire("untracked")) : !this._images[i]._tracking && s[i] && (this._images[i]._tracking = !0, this._images[i].fire("tracked"));
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get images() {
    return this._images;
  }
}
class ZL {
  constructor(e, t) {
    this._index = void 0, this._hand = void 0, this._joints = [], this._tip = null, this._index = e, this._hand = t, this._hand._fingers.push(this);
  }
  get index() {
    return this._index;
  }
  get hand() {
    return this._hand;
  }
  get joints() {
    return this._joints;
  }
  get tip() {
    return this._tip;
  }
}
const Gp = lt.browser && window.XRHand ? ["thumb-tip", "index-finger-tip", "middle-finger-tip", "ring-finger-tip", "pinky-finger-tip"] : [], Iy = {};
for (let r = 0; r < Gp.length; r++)
  Iy[Gp[r]] = !0;
class Hp {
  constructor(e, t, s, i = null) {
    this._index = void 0, this._id = void 0, this._hand = void 0, this._finger = void 0, this._wrist = void 0, this._tip = void 0, this._radius = null, this._localTransform = new j(), this._worldTransform = new j(), this._localPosition = new v(), this._localRotation = new ee(), this._position = new v(), this._rotation = new ee(), this._dirtyLocal = !0, this._index = e, this._id = t, this._hand = s, this._finger = i, this._wrist = t === "wrist", this._tip = this._finger && !!Iy[t];
  }
  update(e) {
    this._dirtyLocal = !0, this._radius = e.radius, this._localPosition.copy(e.transform.position), this._localRotation.copy(e.transform.orientation);
  }
  _updateTransforms() {
    this._dirtyLocal && (this._dirtyLocal = !1, this._localTransform.setTRS(this._localPosition, this._localRotation, v.ONE));
    const t = this._hand._manager.camera.parent;
    t ? this._worldTransform.mul2(t.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform);
  }
  getPosition() {
    return this._updateTransforms(), this._worldTransform.getTranslation(this._position), this._position;
  }
  getRotation() {
    return this._updateTransforms(), this._rotation.setFromMat4(this._worldTransform), this._rotation;
  }
  get index() {
    return this._index;
  }
  get hand() {
    return this._hand;
  }
  get finger() {
    return this._finger;
  }
  get wrist() {
    return this._wrist;
  }
  get tip() {
    return this._tip;
  }
  get radius() {
    return this._radius || 5e-3;
  }
}
let wh = [];
const fn = new v(), sh = new v(), Wp = new v();
lt.browser && window.XRHand && (wh = [["thumb-metacarpal", "thumb-phalanx-proximal", "thumb-phalanx-distal", "thumb-tip"], ["index-finger-metacarpal", "index-finger-phalanx-proximal", "index-finger-phalanx-intermediate", "index-finger-phalanx-distal", "index-finger-tip"], ["middle-finger-metacarpal", "middle-finger-phalanx-proximal", "middle-finger-phalanx-intermediate", "middle-finger-phalanx-distal", "middle-finger-tip"], ["ring-finger-metacarpal", "ring-finger-phalanx-proximal", "ring-finger-phalanx-intermediate", "ring-finger-phalanx-distal", "ring-finger-tip"], ["pinky-finger-metacarpal", "pinky-finger-phalanx-proximal", "pinky-finger-phalanx-intermediate", "pinky-finger-phalanx-distal", "pinky-finger-tip"]]);
class JL extends _e {
  constructor(e) {
    super(), this._manager = void 0, this._inputSource = void 0, this._tracking = !1, this._fingers = [], this._joints = [], this._jointsById = {}, this._tips = [], this._wrist = null;
    const t = e._xrInputSource.hand;
    if (this._manager = e._manager, this._inputSource = e, t.get("wrist")) {
      const s = new Hp(0, "wrist", this, null);
      this._wrist = s, this._joints.push(s), this._jointsById.wrist = s;
    }
    for (let s = 0; s < wh.length; s++) {
      const i = new ZL(s, this);
      for (let n = 0; n < wh[s].length; n++) {
        const a = wh[s][n];
        if (!t.get(a))
          continue;
        const o = new Hp(n, a, this, i);
        this._joints.push(o), this._jointsById[a] = o, o.tip && (this._tips.push(o), i._tip = o), i._joints.push(o);
      }
    }
  }
  update(e) {
    const t = this._inputSource._xrInputSource;
    for (let c = 0; c < this._joints.length; c++) {
      const d = this._joints[c], u = t.hand.get(d._id);
      if (u) {
        let f;
        if (e.session.visibilityState !== "hidden" && (f = e.getJointPose(u, this._manager._referenceSpace)), f)
          d.update(f), d.wrist && !this._tracking && (this._tracking = !0, this.fire("tracking"));
        else if (d.wrist) {
          this._tracking && (this._tracking = !1, this.fire("trackinglost"));
          break;
        }
      }
    }
    const s = this._jointsById["thumb-metacarpal"], i = this._jointsById["thumb-tip"], n = this._jointsById["index-finger-phalanx-proximal"], a = this._jointsById["index-finger-tip"], o = this._jointsById["ring-finger-phalanx-proximal"], h = this._jointsById["pinky-finger-phalanx-proximal"];
    if (s && i && n && a && o && h) {
      this._inputSource._dirtyRay = !0, this._inputSource._rayLocal.origin.lerp(i._localPosition, a._localPosition, 0.5);
      let c = s, d = h;
      if (this._inputSource.handedness === Qu) {
        const u = c;
        c = d, d = u;
      }
      fn.sub2(c._localPosition, this._wrist._localPosition), sh.sub2(d._localPosition, this._wrist._localPosition), Wp.cross(fn, sh).normalize(), fn.lerp(n._localPosition, o._localPosition, 0.5), fn.sub(this._wrist._localPosition).normalize(), this._inputSource._rayLocal.direction.lerp(Wp, fn, 0.5).normalize();
    }
    this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4) ? this._inputSource._squeezing || (this._inputSource._squeezing = !0, this._inputSource.fire("squeezestart"), this._manager.input.fire("squeezestart", this._inputSource)) : this._inputSource._squeezing && (this._inputSource._squeezing = !1, this._inputSource.fire("squeeze"), this._manager.input.fire("squeeze", this._inputSource), this._inputSource.fire("squeezeend"), this._manager.input.fire("squeezeend", this._inputSource));
  }
  _fingerIsClosed(e) {
    const t = this._fingers[e];
    return fn.sub2(t.joints[0]._localPosition, t.joints[1]._localPosition).normalize(), sh.sub2(t.joints[2]._localPosition, t.joints[3]._localPosition).normalize(), fn.dot(sh) < -0.8;
  }
  getJointById(e) {
    return this._jointsById[e] || null;
  }
  get fingers() {
    return this._fingers;
  }
  get joints() {
    return this._joints;
  }
  get tips() {
    return this._tips;
  }
  get wrist() {
    return this._wrist;
  }
  get tracking() {
    return this._tracking;
  }
}
const qp = new ee();
let QL = 0;
class eP extends _e {
  constructor(e, t) {
    super(), this._id = void 0, this._manager = void 0, this._xrInputSource = void 0, this._ray = new od(), this._rayLocal = new od(), this._grip = !1, this._hand = null, this._localTransform = null, this._worldTransform = null, this._position = new v(), this._rotation = new ee(), this._localPosition = null, this._localRotation = null, this._dirtyLocal = !0, this._dirtyRay = !1, this._selecting = !1, this._squeezing = !1, this._elementInput = !0, this._elementEntity = null, this._hitTestSources = [], this._id = ++QL, this._manager = e, this._xrInputSource = t, t.hand && (this._hand = new JL(this));
  }
  get id() {
    return this._id;
  }
  get inputSource() {
    return this._xrInputSource;
  }
  get targetRayMode() {
    return this._xrInputSource.targetRayMode;
  }
  get handedness() {
    return this._xrInputSource.handedness;
  }
  get profiles() {
    return this._xrInputSource.profiles;
  }
  get grip() {
    return this._grip;
  }
  get hand() {
    return this._hand;
  }
  get gamepad() {
    return this._xrInputSource.gamepad || null;
  }
  get selecting() {
    return this._selecting;
  }
  get squeezing() {
    return this._squeezing;
  }
  set elementInput(e) {
    this._elementInput !== e && (this._elementInput = e, this._elementInput || (this._elementEntity = null));
  }
  get elementInput() {
    return this._elementInput;
  }
  get elementEntity() {
    return this._elementEntity;
  }
  get hitTestSources() {
    return this._hitTestSources;
  }
  update(e) {
    if (this._hand)
      this._hand.update(e);
    else {
      if (this._xrInputSource.gripSpace) {
        const s = e.getPose(this._xrInputSource.gripSpace, this._manager._referenceSpace);
        s && (this._grip || (this._grip = !0, this._localTransform = new j(), this._worldTransform = new j(), this._localPosition = new v(), this._localRotation = new ee()), this._dirtyLocal = !0, this._localPosition.copy(s.transform.position), this._localRotation.copy(s.transform.orientation));
      }
      const t = e.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
      t && (this._dirtyRay = !0, this._rayLocal.origin.copy(t.transform.position), this._rayLocal.direction.set(0, 0, -1), qp.copy(t.transform.orientation), qp.transformVector(this._rayLocal.direction, this._rayLocal.direction));
    }
  }
  _updateTransforms() {
    this._dirtyLocal && (this._dirtyLocal = !1, this._localTransform.setTRS(this._localPosition, this._localRotation, v.ONE));
    const e = this._manager.camera.parent;
    e ? this._worldTransform.mul2(e.getWorldTransform(), this._localTransform) : this._worldTransform.copy(this._localTransform);
  }
  _updateRayTransforms() {
    const e = this._dirtyRay;
    if (this._dirtyRay = !1, this._manager.camera.parent) {
      const s = this._manager.camera.parent.getWorldTransform();
      s.getTranslation(this._position), this._rotation.setFromMat4(s), this._rotation.transformVector(this._rayLocal.origin, this._ray.origin), this._ray.origin.add(this._position), this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
    } else
      e && (this._ray.origin.copy(this._rayLocal.origin), this._ray.direction.copy(this._rayLocal.direction));
  }
  getPosition() {
    return this._position ? (this._updateTransforms(), this._worldTransform.getTranslation(this._position), this._position) : null;
  }
  getLocalPosition() {
    return this._localPosition;
  }
  getRotation() {
    return this._rotation ? (this._updateTransforms(), this._rotation.setFromMat4(this._worldTransform), this._rotation) : null;
  }
  getLocalRotation() {
    return this._localRotation;
  }
  getOrigin() {
    return this._updateRayTransforms(), this._ray.origin;
  }
  getDirection() {
    return this._updateRayTransforms(), this._ray.direction;
  }
  hitTestStart(e = {}) {
    e.profile = this._xrInputSource.profiles[0];
    const t = e.callback;
    e.callback = (s, i) => {
      i && this.onHitTestSourceAdd(i), t && t(s, i);
    }, this._manager.hitTest.start(e);
  }
  onHitTestSourceAdd(e) {
    this._hitTestSources.push(e), this.fire("hittest:add", e), e.on("result", function(t, s, i) {
      i === this && this.fire("hittest:result", e, t, s);
    }, this), e.once("remove", function() {
      this.onHitTestSourceRemove(e), this.fire("hittest:remove", e);
    }, this);
  }
  onHitTestSourceRemove(e) {
    const t = this._hitTestSources.indexOf(e);
    t !== -1 && this._hitTestSources.splice(t, 1);
  }
}
class tP extends _e {
  constructor(e) {
    super(), this.manager = void 0, this._inputSources = [], this._onInputSourcesChangeEvt = void 0, this.manager = e, this._onInputSourcesChangeEvt = (t) => {
      this._onInputSourcesChange(t);
    }, this.manager.on("start", this._onSessionStart, this), this.manager.on("end", this._onSessionEnd, this);
  }
  _onSessionStart() {
    const e = this.manager.session;
    e.addEventListener("inputsourceschange", this._onInputSourcesChangeEvt), e.addEventListener("select", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i.fire("select", s), this.fire("select", i, s);
    }), e.addEventListener("selectstart", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i._selecting = !0, i.fire("selectstart", s), this.fire("selectstart", i, s);
    }), e.addEventListener("selectend", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i._selecting = !1, i.fire("selectend", s), this.fire("selectend", i, s);
    }), e.addEventListener("squeeze", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i.fire("squeeze", s), this.fire("squeeze", i, s);
    }), e.addEventListener("squeezestart", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i._squeezing = !0, i.fire("squeezestart", s), this.fire("squeezestart", i, s);
    }), e.addEventListener("squeezeend", (s) => {
      const i = this._getByInputSource(s.inputSource);
      i.update(s.frame), i._squeezing = !1, i.fire("squeezeend", s), this.fire("squeezeend", i, s);
    });
    const t = e.inputSources;
    for (let s = 0; s < t.length; s++)
      this._addInputSource(t[s]);
  }
  _onSessionEnd() {
    let e = this._inputSources.length;
    for (; e--; ) {
      const s = this._inputSources[e];
      this._inputSources.splice(e, 1), s.fire("remove"), this.fire("remove", s);
    }
    this.manager.session.removeEventListener("inputsourceschange", this._onInputSourcesChangeEvt);
  }
  _onInputSourcesChange(e) {
    for (let t = 0; t < e.removed.length; t++)
      this._removeInputSource(e.removed[t]);
    for (let t = 0; t < e.added.length; t++)
      this._addInputSource(e.added[t]);
  }
  _getByInputSource(e) {
    for (let t = 0; t < this._inputSources.length; t++)
      if (this._inputSources[t].inputSource === e)
        return this._inputSources[t];
    return null;
  }
  _addInputSource(e) {
    if (this._getByInputSource(e))
      return;
    const t = new eP(this.manager, e);
    this._inputSources.push(t), this.fire("add", t);
  }
  _removeInputSource(e) {
    for (let t = 0; t < this._inputSources.length; t++) {
      if (this._inputSources[t].inputSource !== e)
        continue;
      const s = this._inputSources[t];
      this._inputSources.splice(t, 1);
      let i = s.hitTestSources.length;
      for (; i--; )
        s.hitTestSources[i].remove();
      s.fire("remove"), this.fire("remove", s);
      return;
    }
  }
  update(e) {
    for (let t = 0; t < this._inputSources.length; t++)
      this._inputSources[t].update(e);
  }
  get inputSources() {
    return this._inputSources;
  }
}
const ur = new v(), Xp = new v(), ed = new j(), jp = new j();
class sP extends _e {
  constructor(e) {
    super(), this._manager = void 0, this._supported = !1, this._available = !1, this._lightProbeRequested = !1, this._lightProbe = null, this._intensity = 0, this._rotation = new ee(), this._color = new z(), this._sphericalHarmonics = new Float32Array(27), this._manager = e, this._manager.on("start", this._onSessionStart, this), this._manager.on("end", this._onSessionEnd, this);
  }
  _onSessionStart() {
    this._manager.session.requestLightProbe && (this._supported = !0);
  }
  _onSessionEnd() {
    this._supported = !1, this._available = !1, this._lightProbeRequested = !1, this._lightProbe = null;
  }
  start() {
    let e;
    if (this._manager.session || (e = new Error("XR session is not running")), !e && this._manager.type !== Ir && (e = new Error("XR session type is not AR")), !e && !this._supported && (e = new Error("light-estimation is not supported")), (!e && this._lightProbe || this._lightProbeRequested) && (e = new Error("light estimation is already requested")), e) {
      this.fire("error", e);
      return;
    }
    this._lightProbeRequested = !0, this._manager.session.requestLightProbe().then((t) => {
      const s = this._lightProbeRequested;
      this._lightProbeRequested = !1, this._manager.active ? s && (this._lightProbe = t) : this.fire("error", new Error("XR session is not active"));
    }).catch((t) => {
      this._lightProbeRequested = !1, this.fire("error", t);
    });
  }
  end() {
    this._lightProbeRequested = !1, this._lightProbe = null, this._available = !1;
  }
  update(e) {
    if (!this._lightProbe)
      return;
    const t = e.getLightEstimate(this._lightProbe);
    if (!t)
      return;
    this._available || (this._available = !0, this.fire("available"));
    const s = t.primaryLightIntensity;
    this._intensity = Math.max(1, Math.max(s.x, Math.max(s.y, s.z))), ur.copy(s).mulScalar(1 / this._intensity), this._color.set(ur.x, ur.y, ur.z), ur.set(0, 0, 0), Xp.copy(t.primaryLightDirection), ed.setLookAt(Xp, ur, v.UP), jp.setFromAxisAngle(v.RIGHT, 90), ed.mul(jp), this._rotation.setFromMat4(ed), this._sphericalHarmonics.set(t.sphericalHarmonicsCoefficients);
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get intensity() {
    return this._available ? this._intensity : null;
  }
  get color() {
    return this._available ? this._color : null;
  }
  get rotation() {
    return this._available ? this._rotation : null;
  }
  get sphericalHarmonics() {
    return this._available ? this._sphericalHarmonics : null;
  }
}
let iP = 0;
class nP extends _e {
  constructor(e, t) {
    super(), this._id = void 0, this._planeDetection = void 0, this._xrPlane = void 0, this._lastChangedTime = void 0, this._orientation = void 0, this._position = new v(), this._rotation = new ee(), this._id = ++iP, this._planeDetection = e, this._xrPlane = t, this._lastChangedTime = t.lastChangedTime, this._orientation = t.orientation;
  }
  destroy() {
    this.fire("remove");
  }
  update(e) {
    const t = this._planeDetection._manager, s = e.getPose(this._xrPlane.planeSpace, t._referenceSpace);
    s && (this._position.copy(s.transform.position), this._rotation.copy(s.transform.orientation)), this._lastChangedTime !== this._xrPlane.lastChangedTime && (this._lastChangedTime = this._xrPlane.lastChangedTime, this.fire("change"));
  }
  getPosition() {
    return this._position;
  }
  getRotation() {
    return this._rotation;
  }
  get id() {
    return this._id;
  }
  get orientation() {
    return this._orientation;
  }
  get points() {
    return this._xrPlane.polygon;
  }
}
class rP extends _e {
  constructor(e) {
    super(), this._manager = void 0, this._supported = lt.browser && !!window.XRPlane, this._available = !1, this._planesIndex = /* @__PURE__ */ new Map(), this._planes = null, this._manager = e, this._supported && this._manager.on("end", this._onSessionEnd, this);
  }
  _onSessionEnd() {
    if (this._planes)
      for (let e = 0; e < this._planes.length; e++)
        this._planes[e].destroy();
    this._planesIndex.clear(), this._planes = null, this._available && (this._available = !1, this.fire("unavailable"));
  }
  update(e) {
    let t;
    if (this._available)
      t = e.detectedPlanes;
    else
      try {
        t = e.detectedPlanes, this._planes = [], this._available = !0, this.fire("available");
      } catch {
        return;
      }
    for (const [s, i] of this._planesIndex)
      t.has(s) || (this._planesIndex.delete(s), this._planes.splice(this._planes.indexOf(i), 1), i.destroy(), this.fire("remove", i));
    for (const s of t) {
      let i = this._planesIndex.get(s);
      i ? i.update(e) : (i = new nP(this, s), this._planesIndex.set(s, i), this._planes.push(i), i.update(e), this.fire("add", i));
    }
  }
  get supported() {
    return this._supported;
  }
  get available() {
    return this._available;
  }
  get planes() {
    return this._planes;
  }
}
class aP extends _e {
  constructor(e) {
    super(), this.app = void 0, this._supported = lt.browser && !!navigator.xr, this._available = {}, this._type = null, this._spaceType = null, this._session = null, this._baseLayer = null, this._referenceSpace = null, this.depthSensing = void 0, this.domOverlay = void 0, this.hitTest = void 0, this.imageTracking = void 0, this.planeDetection = void 0, this.input = void 0, this.lightEstimation = void 0, this._camera = null, this.views = [], this.viewsPool = [], this._localPosition = new v(), this._localRotation = new ee(), this._depthNear = 0.1, this._depthFar = 1e3, this._width = 0, this._height = 0, this.app = e, this._available[zL] = !1, this._available[Oa] = !1, this._available[Ir] = !1, this.depthSensing = new qL(this), this.domOverlay = new XL(this), this.hitTest = new $L(this), this.imageTracking = new KL(this), this.planeDetection = new rP(this), this.input = new tP(this), this.lightEstimation = new sP(this), this._supported && (navigator.xr.addEventListener("devicechange", () => {
      this._deviceAvailabilityCheck();
    }), this._deviceAvailabilityCheck());
  }
  destroy() {
    this.depthSensing.destroy(), this.depthSensing = null;
  }
  start(e, t, s, i) {
    let n = i;
    if (typeof i == "object" && (n = i.callback), !this._available[t]) {
      n && n(new Error("XR is not available"));
      return;
    }
    if (this._session) {
      n && n(new Error("XR session is already started"));
      return;
    }
    this._camera = e, this._camera.camera.xr = this, this._type = t, this._spaceType = s, this._setClipPlanes(e.nearClip, e.farClip);
    const a = {
      requiredFeatures: [s],
      optionalFeatures: []
    };
    if (t === Ir) {
      if (a.optionalFeatures.push("light-estimation"), a.optionalFeatures.push("hit-test"), i && (i.imageTracking && this.imageTracking.supported && a.optionalFeatures.push("image-tracking"), i.planeDetection && a.optionalFeatures.push("plane-detection")), this.domOverlay.supported && this.domOverlay.root && (a.optionalFeatures.push("dom-overlay"), a.domOverlay = {
        root: this.domOverlay.root
      }), i && i.depthSensing && this.depthSensing.supported) {
        a.optionalFeatures.push("depth-sensing");
        const o = [Py], h = [WL];
        if (i.depthSensing.usagePreference) {
          const l = o.indexOf(i.depthSensing.usagePreference);
          l !== -1 && o.splice(l, 1), o.unshift(i.depthSensing.usagePreference);
        }
        if (i.depthSensing.dataFormatPreference) {
          const l = h.indexOf(i.depthSensing.dataFormatPreference);
          l !== -1 && h.splice(l, 1), h.unshift(i.depthSensing.dataFormatPreference);
        }
        a.depthSensing = {
          usagePreference: o,
          dataFormatPreference: h
        };
      }
    } else
      t === Oa && a.optionalFeatures.push("hand-tracking");
    i && i.optionalFeatures && (a.optionalFeatures = a.optionalFeatures.concat(i.optionalFeatures)), this.imageTracking.supported && this.imageTracking.images.length ? this.imageTracking.prepareImages((o, h) => {
      if (o) {
        n && n(o), this.fire("error", o);
        return;
      }
      h !== null && (a.trackedImages = h), this._onStartOptionsReady(t, s, a, n);
    }) : this._onStartOptionsReady(t, s, a, n);
  }
  _onStartOptionsReady(e, t, s, i) {
    navigator.xr.requestSession(e, s).then((n) => {
      this._onSessionStart(n, t, i);
    }).catch((n) => {
      this._camera.camera.xr = null, this._camera = null, this._type = null, this._spaceType = null, i && i(n), this.fire("error", n);
    });
  }
  end(e) {
    if (!this._session) {
      e && e(new Error("XR Session is not initialized"));
      return;
    }
    e && this.once("end", e), this._session.end();
  }
  isAvailable(e) {
    return this._available[e];
  }
  _deviceAvailabilityCheck() {
    for (const e in this._available)
      this._sessionSupportCheck(e);
  }
  _sessionSupportCheck(e) {
    navigator.xr.isSessionSupported(e).then((t) => {
      this._available[e] !== t && (this._available[e] = t, this.fire("available", e, t), this.fire("available:" + e, t));
    }).catch((t) => {
      this.fire("error", t);
    });
  }
  _onSessionStart(e, t, s) {
    let i = !1;
    this._session = e;
    const n = () => {
      this.fire("visibility:change", e.visibilityState);
    }, a = () => {
      this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
    }, o = () => {
      this._camera && (this._camera.off("set_nearClip", a), this._camera.off("set_farClip", a), this._camera.camera.xr = null, this._camera = null), e.removeEventListener("end", o), e.removeEventListener("visibilitychange", n), i || this.fire("end"), this._session = null, this._referenceSpace = null, this.views = [], this._width = 0, this._height = 0, this._type = null, this._spaceType = null, this.app.tick();
    };
    e.addEventListener("end", o), e.addEventListener("visibilitychange", n), this._camera.on("set_nearClip", a), this._camera.on("set_farClip", a);
    const h = this.app.graphicsDevice.maxPixelRatio / window.devicePixelRatio;
    this._baseLayer = new XRWebGLLayer(e, this.app.graphicsDevice.gl, {
      alpha: !0,
      depth: !0,
      stencil: !0,
      framebufferScaleFactor: h
    }), e.updateRenderState({
      baseLayer: this._baseLayer,
      depthNear: this._depthNear,
      depthFar: this._depthFar
    }), e.requestReferenceSpace(t).then((l) => {
      this._referenceSpace = l, this.app.tick(), s && s(null), this.fire("start");
    }).catch((l) => {
      i = !0, e.end(), s && s(l), this.fire("error", l);
    });
  }
  _setClipPlanes(e, t) {
    this._depthNear === e && this._depthFar === t || (this._depthNear = e, this._depthFar = t, this._session && this._session.updateRenderState({
      depthNear: this._depthNear,
      depthFar: this._depthFar
    }));
  }
  update(e) {
    if (!this._session)
      return !1;
    const t = e.session.renderState.baseLayer.framebufferWidth, s = e.session.renderState.baseLayer.framebufferHeight;
    (this._width !== t || this._height !== s) && (this._width = t, this._height = s, this.app.graphicsDevice.setResolution(t, s));
    const i = e.getViewerPose(this._referenceSpace);
    if (!i)
      return !1;
    const n = this.views.length, a = i.views.length;
    if (a > this.views.length)
      for (let c = 0; c <= a - this.views.length; c++) {
        let d = this.viewsPool.pop();
        d || (d = {
          viewport: new Z(),
          projMat: new j(),
          viewMat: new j(),
          viewOffMat: new j(),
          viewInvMat: new j(),
          viewInvOffMat: new j(),
          projViewOffMat: new j(),
          viewMat3: new is(),
          position: new Float32Array(3),
          rotation: new ee()
        }), this.views.push(d);
      }
    else if (a <= this.views.length)
      for (let c = 0; c < this.views.length - a; c++)
        this.viewsPool.push(this.views.pop());
    const o = i.transform.position, h = i.transform.orientation;
    this._localPosition.set(o.x, o.y, o.z), this._localRotation.set(h.x, h.y, h.z, h.w);
    const l = e.session.renderState.baseLayer;
    for (let c = 0; c < i.views.length; c++) {
      const d = i.views[c], u = this.views[c], f = l.getViewport(d);
      u.viewport.x = f.x, u.viewport.y = f.y, u.viewport.z = f.width, u.viewport.w = f.height, u.projMat.set(d.projectionMatrix), u.viewMat.set(d.transform.inverse.matrix), u.viewInvMat.set(d.transform.matrix);
    }
    if (n === 0 && this.views.length > 0) {
      const c = new j(), d = this.views[0];
      c.copy(d.projMat);
      const u = c.data, f = 2 * Math.atan(1 / u[5]) * 180 / Math.PI, m = u[5] / u[0], _ = u[14] / (u[10] + 1), p = u[14] / (u[10] - 1), g = !1;
      this._camera.camera.setXrProperties({
        aspectRatio: m,
        farClip: _,
        fov: f,
        horizontalFov: g,
        nearClip: p
      });
    }
    return this._camera.camera._node.setLocalPosition(this._localPosition), this._camera.camera._node.setLocalRotation(this._localRotation), this.input.update(e), this._type === Ir && (this.hitTest.supported && this.hitTest.update(e), this.lightEstimation.supported && this.lightEstimation.update(e), this.depthSensing.supported && this.depthSensing.update(e, i && i.views[0]), this.imageTracking.supported && this.imageTracking.update(e), this.planeDetection.supported && this.planeDetection.update(e)), this.fire("update", e), !0;
  }
  get supported() {
    return this._supported;
  }
  get active() {
    return !!this._session;
  }
  get type() {
    return this._type;
  }
  get spaceType() {
    return this._spaceType;
  }
  get session() {
    return this._session;
  }
  get camera() {
    return this._camera ? this._camera.entity : null;
  }
  get visibilityState() {
    return this._session ? this._session.visibilityState : null;
  }
}
class oP extends Pr {
  constructor(e, t = {}) {
    super(e);
    const s = new YA();
    s.graphicsDevice = this.createDevice(e, t), this.addComponentSystems(s), this.addResourceHandles(s), s.elementInput = t.elementInput, s.keyboard = t.keyboard, s.mouse = t.mouse, s.touch = t.touch, s.gamepads = t.gamepads, s.scriptPrefix = t.scriptPrefix, s.assetPrefix = t.assetPrefix, s.scriptsOrder = t.scriptsOrder, s.soundManager = new tv(), s.lightmapper = t1, s.batchManager = PT, s.xr = aP, this.init(s);
  }
  createDevice(e, t) {
    return t.graphicsDeviceOptions || (t.graphicsDeviceOptions = {}), lt.browser && navigator.xr && (t.graphicsDeviceOptions.xrCompatible = !0), t.graphicsDeviceOptions.alpha = t.graphicsDeviceOptions.alpha || !1, new Dx(e, t.graphicsDeviceOptions);
  }
  addComponentSystems(e) {
    e.componentSystems = [YM, $1, bM, S1, M1, BM, GM, AE, RE, fs.legacy ? tE : GE, P1, pE, R1, zM, ZM, yM, F1, cE, uE, vE, IM, TM, bE];
  }
  addResourceHandles(e) {
    e.resourceHandlers = [HE, BR, FR, OR, oL, ZR, NL, mL, jR, NR, lL, hL, GR, XR, VR, cL, qR, HR, WR, zR, _L, dL, fL, UR];
  }
}
class $p extends _e {
  constructor(e, t) {
    super(), this._assets = /* @__PURE__ */ new Set(), this._loadingAssets = /* @__PURE__ */ new Set(), this._waitingAssets = /* @__PURE__ */ new Set(), this._registry = t, this._loading = !1, this._loaded = !1, this._failed = [], e.forEach((s) => {
      if (s instanceof ce)
        s.registry || (s.registry = t), this._assets.add(s);
      else {
        const i = t.get(s);
        i ? this._assets.add(i) : this._waitForAsset(s);
      }
    });
  }
  destroy() {
    const e = this;
    this._registry.off("load", this._onLoad), this._registry.off("error", this._onError), this._waitingAssets.forEach(function(t) {
      e._registry.off("add:" + t, this._onAddAsset);
    }), this.off("progress"), this.off("load");
  }
  _assetHasDependencies(e) {
    var t;
    return e.type === "model" && ((t = e.file) == null ? void 0 : t.url) && e.file.url && e.file.url.match(/.json$/g);
  }
  load(e, t) {
    if (this._loading)
      return;
    this._loading = !0, this._callback = e, this._scope = t, this._registry.on("load", this._onLoad, this), this._registry.on("error", this._onError, this);
    let s = !1;
    this._assets.forEach((i) => {
      i.loaded || (s = !0, this._assetHasDependencies(i) && this._registry.loadFromUrl(i.file.url, i.type, (n, a) => {
        if (n) {
          this._onError(n, i);
          return;
        }
        this._onLoad(i);
      }), this._loadingAssets.add(i), this._registry.add(i));
    }), this._loadingAssets.forEach((i) => {
      this._assetHasDependencies(i) || this._registry.load(i);
    }), !s && this._waitingAssets.size === 0 && this._loadingComplete();
  }
  ready(e, t = this) {
    this._loaded ? e.call(t, Array.from(this._assets)) : this.once("load", function(s) {
      e.call(t, s);
    });
  }
  _loadingComplete() {
    this._loaded || (this._loaded = !0, this._registry.off("load", this._onLoad, this), this._registry.off("error", this._onError, this), this._failed.length ? (this._callback && this._callback.call(this._scope, "Failed to load some assets", this._failed), this.fire("error", this._failed)) : (this._callback && this._callback.call(this._scope), this.fire("load", Array.from(this._assets))));
  }
  _onLoad(e) {
    this._loadingAssets.has(e) && (this.fire("progress", e), this._loadingAssets.delete(e)), this._loadingAssets.size === 0 && setTimeout(() => {
      this._loadingComplete(this._failed);
    }, 0);
  }
  _onError(e, t) {
    this._loadingAssets.has(t) && (this._failed.push(t), this._loadingAssets.delete(t)), this._loadingAssets.size === 0 && setTimeout(() => {
      this._loadingComplete(this._failed);
    }, 0);
  }
  _onAddAsset(e) {
    this._waitingAssets.delete(e), this._assets.add(e), e.loaded || (this._loadingAssets.add(e), this._registry.load(e));
  }
  _waitForAsset(e) {
    this._waitingAssets.add(e), this._registry.once("add:" + e, this._onAddAsset, this);
  }
}
class ze {
  /**
   * The Logger's constructor should always be private to prevent direct
   * construction calls with the `new` operator.
   */
  constructor() {
    this.debug = !1;
  }
  /**
   * The static method that controls the access to the Logger instance.
   *
   * This implementation let you subclass the Logger class while keeping
   * just one instance of each subclass around.
   */
  static get Instance() {
    return ze.instance || (ze.instance = new ze()), ze.instance;
  }
  setDebug(e) {
    this.debug = e;
  }
  log(e, ...t) {
    this.debug && (t.length ? console.log(`[FIK]${e}`, ...t) : console.log(`[FIK]${e}`));
  }
  warn(e, ...t) {
    this.debug && (t.length ? console.warn(`[FIK]${e}`, ...t) : console.warn(`[FIK]${e}`));
  }
  error(e, ...t) {
    this.debug && (t.length ? console.error(`[FIK]${e}`, ...t) : console.error(`[FIK]${e}`));
  }
}
var Y = /* @__PURE__ */ ((r) => (r.Spine = "Spine", r.Head = "Head", r.RightArm = "RightArm", r.LeftArm = "LeftArm", r.RightLeg = "RightLeg", r.LeftLeg = "LeftLeg", r))(Y || {});
let F = class {
  static createRootBone(e = new R(0, 0, 0), t = re, s = 1e-4) {
    return new Cr(
      e,
      new R(
        e.x + t.x * s,
        e.y + t.y * s,
        e.z + t.z * s
      )
    );
  }
  static applyApproximatelyEqualsTolerance(e) {
    return e >= 0 ? e + Le.DefaultApproximatelyEqualsTolerance : e - Le.DefaultApproximatelyEqualsTolerance;
  }
};
var ka = {
  Linear: {
    None: function(r) {
      return r;
    }
  },
  Quadratic: {
    In: function(r) {
      return r * r;
    },
    Out: function(r) {
      return r * (2 - r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
    }
  },
  Cubic: {
    In: function(r) {
      return r * r * r;
    },
    Out: function(r) {
      return --r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
    }
  },
  Quartic: {
    In: function(r) {
      return r * r * r * r;
    },
    Out: function(r) {
      return 1 - --r * r * r * r;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
    }
  },
  Quintic: {
    In: function(r) {
      return r * r * r * r * r;
    },
    Out: function(r) {
      return --r * r * r * r * r + 1;
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
    }
  },
  Sinusoidal: {
    In: function(r) {
      return 1 - Math.cos(r * Math.PI / 2);
    },
    Out: function(r) {
      return Math.sin(r * Math.PI / 2);
    },
    InOut: function(r) {
      return 0.5 * (1 - Math.cos(Math.PI * r));
    }
  },
  Exponential: {
    In: function(r) {
      return r === 0 ? 0 : Math.pow(1024, r - 1);
    },
    Out: function(r) {
      return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
    }
  },
  Circular: {
    In: function(r) {
      return 1 - Math.sqrt(1 - r * r);
    },
    Out: function(r) {
      return Math.sqrt(1 - --r * r);
    },
    InOut: function(r) {
      return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
    }
  },
  Elastic: {
    In: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : -Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI);
    },
    Out: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : Math.pow(2, -10 * r) * Math.sin((r - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(r) {
      return r === 0 ? 0 : r === 1 ? 1 : (r *= 2, r < 1 ? -0.5 * Math.pow(2, 10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (r - 1)) * Math.sin((r - 1.1) * 5 * Math.PI) + 1);
    }
  },
  Back: {
    In: function(r) {
      var e = 1.70158;
      return r * r * ((e + 1) * r - e);
    },
    Out: function(r) {
      var e = 1.70158;
      return --r * r * ((e + 1) * r + e) + 1;
    },
    InOut: function(r) {
      var e = 2.5949095;
      return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
    }
  },
  Bounce: {
    In: function(r) {
      return 1 - ka.Bounce.Out(1 - r);
    },
    Out: function(r) {
      return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
    },
    InOut: function(r) {
      return r < 0.5 ? ka.Bounce.In(r * 2) * 0.5 : ka.Bounce.Out(r * 2 - 1) * 0.5 + 0.5;
    }
  }
}, wa;
typeof self > "u" && typeof process < "u" && process.hrtime ? wa = function() {
  var r = process.hrtime();
  return r[0] * 1e3 + r[1] / 1e6;
} : typeof self < "u" && self.performance !== void 0 && self.performance.now !== void 0 ? wa = self.performance.now.bind(self.performance) : Date.now !== void 0 ? wa = Date.now : wa = function() {
  return new Date().getTime();
};
var gr = wa, hP = (
  /** @class */
  function() {
    function r() {
      this._tweens = {}, this._tweensAddedDuringUpdate = {};
    }
    return r.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(t) {
        return e._tweens[t];
      });
    }, r.prototype.removeAll = function() {
      this._tweens = {};
    }, r.prototype.add = function(e) {
      this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e;
    }, r.prototype.remove = function(e) {
      delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()];
    }, r.prototype.update = function(e, t) {
      e === void 0 && (e = gr()), t === void 0 && (t = !1);
      var s = Object.keys(this._tweens);
      if (s.length === 0)
        return !1;
      for (; s.length > 0; ) {
        this._tweensAddedDuringUpdate = {};
        for (var i = 0; i < s.length; i++) {
          var n = this._tweens[s[i]], a = !t;
          n && n.update(e, a) === !1 && !t && delete this._tweens[s[i]];
        }
        s = Object.keys(this._tweensAddedDuringUpdate);
      }
      return !0;
    }, r;
  }()
), Ta = {
  Linear: function(r, e) {
    var t = r.length - 1, s = t * e, i = Math.floor(s), n = Ta.Utils.Linear;
    return e < 0 ? n(r[0], r[1], s) : e > 1 ? n(r[t], r[t - 1], t - s) : n(r[i], r[i + 1 > t ? t : i + 1], s - i);
  },
  Bezier: function(r, e) {
    for (var t = 0, s = r.length - 1, i = Math.pow, n = Ta.Utils.Bernstein, a = 0; a <= s; a++)
      t += i(1 - e, s - a) * i(e, a) * r[a] * n(s, a);
    return t;
  },
  CatmullRom: function(r, e) {
    var t = r.length - 1, s = t * e, i = Math.floor(s), n = Ta.Utils.CatmullRom;
    return r[0] === r[t] ? (e < 0 && (i = Math.floor(s = t * (1 + e))), n(r[(i - 1 + t) % t], r[i], r[(i + 1) % t], r[(i + 2) % t], s - i)) : e < 0 ? r[0] - (n(r[0], r[0], r[1], r[1], -s) - r[0]) : e > 1 ? r[t] - (n(r[t], r[t], r[t - 1], r[t - 1], s - t) - r[t]) : n(r[i ? i - 1 : 0], r[i], r[t < i + 1 ? t : i + 1], r[t < i + 2 ? t : i + 2], s - i);
  },
  Utils: {
    Linear: function(r, e, t) {
      return (e - r) * t + r;
    },
    Bernstein: function(r, e) {
      var t = Ta.Utils.Factorial;
      return t(r) / t(e) / t(r - e);
    },
    Factorial: function() {
      var r = [1];
      return function(e) {
        var t = 1;
        if (r[e])
          return r[e];
        for (var s = e; s > 1; s--)
          t *= s;
        return r[e] = t, t;
      };
    }(),
    CatmullRom: function(r, e, t, s, i) {
      var n = (t - r) * 0.5, a = (s - e) * 0.5, o = i * i, h = i * o;
      return (2 * e - 2 * t + n + a) * h + (-3 * e + 3 * t - 2 * n - a) * o + n * i + e;
    }
  }
}, Dy = (
  /** @class */
  function() {
    function r() {
    }
    return r.nextId = function() {
      return r._nextId++;
    }, r._nextId = 0, r;
  }()
), By = new hP(), lP = (
  /** @class */
  function() {
    function r(e, t) {
      t === void 0 && (t = By), this._object = e, this._group = t, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = ka.Linear.None, this._interpolationFunction = Ta.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._id = Dy.nextId(), this._isChainStopped = !1, this._goToEnd = !1;
    }
    return r.prototype.getId = function() {
      return this._id;
    }, r.prototype.isPlaying = function() {
      return this._isPlaying;
    }, r.prototype.isPaused = function() {
      return this._isPaused;
    }, r.prototype.to = function(e, t) {
      return this._valuesEnd = Object.create(e), t !== void 0 && (this._duration = t), this;
    }, r.prototype.duration = function(e) {
      return this._duration = e, this;
    }, r.prototype.start = function(e) {
      if (this._isPlaying)
        return this;
      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var t in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(t), this._valuesStart[t] = this._valuesStartRepeat[t];
      }
      return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e !== void 0 ? typeof e == "string" ? gr() + parseFloat(e) : e : gr(), this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat), this;
    }, r.prototype._setupProperties = function(e, t, s, i) {
      for (var n in s) {
        var a = e[n], o = Array.isArray(a), h = o ? "array" : typeof a, l = !o && Array.isArray(s[n]);
        if (!(h === "undefined" || h === "function")) {
          if (l) {
            var c = s[n];
            if (c.length === 0)
              continue;
            c = c.map(this._handleRelativeValue.bind(this, a)), s[n] = [a].concat(c);
          }
          if ((h === "object" || o) && a && !l) {
            t[n] = o ? [] : {};
            for (var d in a)
              t[n][d] = a[d];
            i[n] = o ? [] : {}, this._setupProperties(a, t[n], s[n], i[n]);
          } else
            typeof t[n] > "u" && (t[n] = a), o || (t[n] *= 1), l ? i[n] = s[n].slice().reverse() : i[n] = t[n] || 0;
        }
      }
    }, r.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, r.prototype.end = function() {
      return this._goToEnd = !0, this.update(1 / 0), this;
    }, r.prototype.pause = function(e) {
      return e === void 0 && (e = gr()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this._group && this._group.remove(this), this);
    }, r.prototype.resume = function(e) {
      return e === void 0 && (e = gr()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);
    }, r.prototype.stopChainedTweens = function() {
      for (var e = 0, t = this._chainedTweens.length; e < t; e++)
        this._chainedTweens[e].stop();
      return this;
    }, r.prototype.group = function(e) {
      return this._group = e, this;
    }, r.prototype.delay = function(e) {
      return this._delayTime = e, this;
    }, r.prototype.repeat = function(e) {
      return this._initialRepeat = e, this._repeat = e, this;
    }, r.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, r.prototype.yoyo = function(e) {
      return this._yoyo = e, this;
    }, r.prototype.easing = function(e) {
      return this._easingFunction = e, this;
    }, r.prototype.interpolation = function(e) {
      return this._interpolationFunction = e, this;
    }, r.prototype.chain = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      return this._chainedTweens = e, this;
    }, r.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, r.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, r.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, r.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, r.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, r.prototype.update = function(e, t) {
      if (e === void 0 && (e = gr()), t === void 0 && (t = !0), this._isPaused)
        return !0;
      var s, i, n = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (e > n)
          return !1;
        t && this.start(e);
      }
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), i = (e - this._startTime) / this._duration, i = this._duration === 0 || i > 1 ? 1 : i;
      var a = this._easingFunction(i);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, a), this._onUpdateCallback && this._onUpdateCallback(this._object, i), i === 1)
        if (this._repeat > 0) {
          isFinite(this._repeat) && this._repeat--;
          for (s in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var o = 0, h = this._chainedTweens.length; o < h; o++)
            this._chainedTweens[o].start(this._startTime + this._duration);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, r.prototype._updateProperties = function(e, t, s, i) {
      for (var n in s)
        if (t[n] !== void 0) {
          var a = t[n] || 0, o = s[n], h = Array.isArray(e[n]), l = Array.isArray(o), c = !h && l;
          c ? e[n] = this._interpolationFunction(o, i) : typeof o == "object" && o ? this._updateProperties(e[n], a, o, i) : (o = this._handleRelativeValue(a, o), typeof o == "number" && (e[n] = a + (o - a) * i));
        }
    }, r.prototype._handleRelativeValue = function(e, t) {
      return typeof t != "string" ? t : t.charAt(0) === "+" || t.charAt(0) === "-" ? e + parseFloat(t) : parseFloat(t);
    }, r.prototype._swapEndStartRepeatValues = function(e) {
      var t = this._valuesStartRepeat[e], s = this._valuesEnd[e];
      typeof s == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(s) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = t;
    }, r;
  }()
);
Dy.nextId;
var Ws = By;
Ws.getAll.bind(Ws);
Ws.removeAll.bind(Ws);
Ws.add.bind(Ws);
Ws.remove.bind(Ws);
Ws.update.bind(Ws);
class cP {
  constructor(e, t) {
    this.id = e, this.entity = t;
  }
  getPosition() {
    const e = this.entity.getPosition();
    return new R(e.x, e.y, e.z);
  }
  getLocalPosition() {
    const e = this.entity.getLocalPosition();
    return new R(e.x, e.y, e.z);
  }
  getRotation() {
    return this.entity.getRotation();
  }
  getLocalRotation() {
    return this.entity.getLocalRotation();
  }
  setPosition(e) {
    this.entity.setPosition(e.x, e.y, e.z);
  }
  setRotation(e) {
    this.entity.setRotation(e.x, e.y, e.z, e.w);
  }
}
class js {
  constructor() {
    this.boneEntityCacheMap = /* @__PURE__ */ new Map(), this.targetCacheMap = /* @__PURE__ */ new Map(), this.needToSolve = !0, this.renderForwardLine = !1, this.renderIKBone = !0;
  }
  setRenderer(e) {
    this.renderer = e;
  }
  setRenderIKBone(e) {
    this.renderIKBone = e;
  }
  addTarget(e, t = new R(
    Number.MAX_VALUE,
    Number.MAX_VALUE,
    Number.MAX_VALUE
  )) {
    var i;
    const s = this.targetCacheMap.get(e);
    if (s)
      s.entity.setPosition(t.x, t.y, t.z);
    else {
      const n = (i = this.renderer) == null ? void 0 : i.addTarget(e);
      if (n) {
        n.setPosition(t.x, t.y, t.z);
        const a = new cP(e, n);
        this.targetCacheMap.set(a.id, a), this.renderIKBone || (n.enabled = !1);
      }
    }
  }
  getTarget(e) {
    return this.targetCacheMap.get(e);
  }
  randomMoveTarget(e, t = new R(2, 2, 2), s = new R(-2, -2, -2), i = () => {
  }) {
    const n = be.randRangeFloat(s.x, t.x), a = be.randRangeFloat(s.y, t.y), o = be.randRangeFloat(s.z, t.z), h = this.getTarget(e);
    h && new lP(h.getPosition()).to(
      {
        x: n,
        y: a,
        z: o
      },
      1e3
    ).easing(ka.Quadratic.Out).onUpdate(() => {
      this.solveIK(), this.render(), i.call(this, h.getPosition());
    }).onComplete(() => {
      this.randomMoveTarget(e, t, s, i);
    }).start();
  }
  setNeedToSolve(e) {
    this.needToSolve = e;
  }
  solveIK() {
    if (this.needToSolve) {
      const e = /* @__PURE__ */ new Map(), t = this.renderer.getAvatarScale();
      this.targetCacheMap.forEach((s, i) => {
        var o, h, l, c;
        const n = s.getLocalPosition(), a = s.getPosition();
        switch (i) {
          case Y.RightArm:
            (o = this.renderer) == null || o.setTextInputSourceRightPos(
              `${a.x.toFixed(4)},${a.y.toFixed(
                4
              )},${a.z.toFixed(4)}`
            ), (h = this.renderer) == null || h.setTextTargetRightPos(
              `${(n.x * t).toFixed(4)},${(n.y * t).toFixed(4)},${(n.z * t).toFixed(4)}`
            );
            break;
          case Y.LeftArm:
            (l = this.renderer) == null || l.setTextInputSourceLeftPos(
              `${a.x.toFixed(4)},${a.y.toFixed(
                4
              )},${a.z.toFixed(4)}`
            ), (c = this.renderer) == null || c.setTextTargetLeftPos(
              `${(n.x * t).toFixed(4)},${(n.y * t).toFixed(4)},${(n.z * t).toFixed(4)}`
            );
            break;
        }
        this.renderer.setLocalTargetWithLocalPos(
          s.entity.name,
          new v(
            n.x * t,
            n.y * t,
            n.z * t
          )
        ), e.set(
          s.id,
          new R(
            n.x * t,
            n.y * t,
            n.z * t
          )
        );
      }), this.solveForTargets(e);
    }
    this.needToSolve = !1;
  }
  getBoneFromCache(e, t) {
    var s;
    return (s = this.boneEntityCacheMap.get(e)) == null ? void 0 : s.get(t);
  }
  setBoneToCache(e, t, s) {
    let i = this.boneEntityCacheMap.get(e);
    i || (i = /* @__PURE__ */ new Map(), this.boneEntityCacheMap.set(e, i)), i.set(t, s);
  }
  addBoneEntity(e, t = "") {
    if (!this.renderer)
      throw new Error("renderer is undefined");
    const s = e.getColor();
    return this.renderer.addBone(
      e.length(),
      new z(s.r, s.g, s.b),
      t
    );
  }
  render() {
    const e = this.getSolver();
    if (!e)
      return;
    const t = e.getNumChains();
    for (let s = 0; s < t; s++) {
      const i = e.getChain(s), n = i.getNumBones();
      for (let a = 0; a < n; a++) {
        const o = i.getBone(a), h = this.getBoneFromCache(
          i.getName(),
          a
        );
        let l;
        if (h)
          l = h;
        else {
          const _ = `${i.getName()}_${a}`;
          o.setName(_), l = this.addBoneEntity(o, _), this.setBoneToCache(i.getName(), a, l);
        }
        this.renderIKBone || (l.enabled = !1);
        const c = o.getStartLocation(), d = o.getEndLocation();
        l.setLocalPosition(
          c.x,
          c.y,
          c.z
        );
        const u = o.getJoint();
        u.getJointType() == Ce.BALL ? new R(0, 0, 0) : u.getHingeRotationAxis();
        const f = new v(
          d.x,
          d.y,
          d.z
        );
        let m = l.up;
        switch (u.getJointType()) {
          case Ce.BALL:
          case Ce.GLOBAL_HINGE:
          case Ce.LOCAL_HINGE:
            switch (o.getName()) {
              case "RightLeg_1":
              case "RightLeg_2":
              case "RightLeg_3":
                m = new v(1, 0, 0);
                break;
              case "LeftLeg_2":
              case "LeftLeg_3":
                m = new v(1, 0, 0);
                break;
            }
            l.lookAt(f, m);
            break;
        }
        this.renderForwardLine && this.renderIKBone && this.renderEntityForwardLine(l);
      }
    }
  }
  renderEntityForwardLine(e) {
    if (!this.renderer)
      throw new Error("renderer is undefined");
    const t = e.getLocalPosition(), s = e.forward;
    this.renderer.drawLine(
      new v(t.x, t.y, t.z),
      new v(t.x + s.x, t.y + s.y, t.z + s.z),
      new z(0, 0, 1, 1)
    );
    const i = e.up;
    this.renderer.drawLine(
      new v(t.x, t.y, t.z),
      new v(t.x + i.x, t.y + i.y, t.z + i.z),
      new z(0, 1, 0, 1)
    );
    const n = e.right;
    this.renderer.drawLine(
      new v(t.x, t.y, t.z),
      new v(t.x + n.x, t.y + n.y, t.z + n.z),
      new z(1, 0, 0, 1)
    );
  }
  getSolver() {
    throw new Error("Method not implemented.");
  }
  solveForTargets(e) {
    throw new Error("Method not implemented.");
  }
  run() {
    throw new Error("Method not implemented.");
  }
  update() {
    throw new Error("Method not implemented.");
  }
}
class Fy extends js {
  constructor() {
    super(), this.solver = new St();
  }
  getSolver() {
    return this.solver;
  }
  update() {
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St();
    const e = new Le("default"), t = F.createRootBone();
    e.addBone(t), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), this.solver.addChain(e);
    const s = "default";
    this.addTarget(s, new R(0.01, 3, 0)), this.randomMoveTarget(s), this.solveIK(), this.render();
  }
}
var fe = /* @__PURE__ */ ((r) => (r.Hips = "1", r.Spine = "2", r.Chest = "3", r.UpperChest = "4", r.Neck = "5", r.Head = "6", r.RightEye = "7", r.LeftEye = "8", r.RightShoulder = "9", r.RightUpperArm = "10", r.RightLowerArm = "11", r.RightHand = "12", r.RightMiddle1 = "13", r.LeftShoulder = "14", r.LeftUpperArm = "15", r.LeftLowerArm = "16", r.LeftHand = "17", r.LeftMiddle1 = "18", r.RightHip = "19", r.RightUpperLeg = "20", r.RightLowerLeg = "21", r.RightFoot = "22", r.RightToeBase = "23", r.LeftHip = "24", r.LeftUpperLeg = "25", r.LeftLowerLeg = "26", r.LeftFoot = "27", r.LeftToeBase = "28", r))(fe || {});
class W {
  static set(e, t) {
    this.partMap.set(e, t);
  }
  static get Hips() {
    return this.partMap.get(
      "1"
      /* Hips */
    );
  }
  static get Spine() {
    return this.partMap.get(
      "2"
      /* Spine */
    );
  }
  static get UpperChest() {
    return this.partMap.get(
      "4"
      /* UpperChest */
    );
  }
  static get Chest() {
    return this.partMap.get(
      "3"
      /* Chest */
    );
  }
  static get Neck() {
    return this.partMap.get(
      "5"
      /* Neck */
    );
  }
  static get Head() {
    return this.partMap.get(
      "6"
      /* Head */
    );
  }
  static get RightEye() {
    return this.partMap.get(
      "7"
      /* RightEye */
    );
  }
  static get LeftEye() {
    return this.partMap.get(
      "8"
      /* LeftEye */
    );
  }
  static get RightShoulder() {
    return this.partMap.get(
      "9"
      /* RightShoulder */
    );
  }
  static get RightUpperArm() {
    return this.partMap.get(
      "10"
      /* RightUpperArm */
    );
  }
  static get RightLowerArm() {
    return this.partMap.get(
      "11"
      /* RightLowerArm */
    );
  }
  static get RightHand() {
    return this.partMap.get(
      "12"
      /* RightHand */
    );
  }
  static get RightMiddle1() {
    return this.partMap.get(
      "13"
      /* RightMiddle1 */
    );
  }
  static get LeftShoulder() {
    return this.partMap.get(
      "14"
      /* LeftShoulder */
    );
  }
  static get LeftUpperArm() {
    return this.partMap.get(
      "15"
      /* LeftUpperArm */
    );
  }
  static get LeftLowerArm() {
    return this.partMap.get(
      "16"
      /* LeftLowerArm */
    );
  }
  static get LeftHand() {
    return this.partMap.get(
      "17"
      /* LeftHand */
    );
  }
  static get LeftMiddle1() {
    return this.partMap.get(
      "18"
      /* LeftMiddle1 */
    );
  }
  static get RightHip() {
    return this.partMap.get(
      "19"
      /* RightHip */
    );
  }
  static get RightUpperLeg() {
    return this.partMap.get(
      "20"
      /* RightUpperLeg */
    );
  }
  static get RightLowerLeg() {
    return this.partMap.get(
      "21"
      /* RightLowerLeg */
    );
  }
  static get RightFoot() {
    return this.partMap.get(
      "22"
      /* RightFoot */
    );
  }
  static get RightToeBase() {
    return this.partMap.get(
      "23"
      /* RightToeBase */
    );
  }
  static get LeftHip() {
    return this.partMap.get(
      "24"
      /* LeftHip */
    );
  }
  static get LeftUpperLeg() {
    return this.partMap.get(
      "25"
      /* LeftUpperLeg */
    );
  }
  static get LeftLowerLeg() {
    return this.partMap.get(
      "26"
      /* LeftLowerLeg */
    );
  }
  static get LeftFoot() {
    return this.partMap.get(
      "27"
      /* LeftFoot */
    );
  }
  static get LeftToeBase() {
    return this.partMap.get(
      "28"
      /* LeftToeBase */
    );
  }
}
W.partMap = /* @__PURE__ */ new Map([
  ["1", "J_Bip_C_Hips"],
  ["2", "J_Bip_C_Spine"],
  ["4", "J_Bip_C_UpperChest"],
  ["3", "J_Bip_C_Chest"],
  ["5", "J_Bip_C_Neck"],
  ["6", "J_Bip_C_Head"],
  ["7", "J_Adj_R_FaceEye"],
  ["8", "J_Adj_L_FaceEye"],
  ["9", "J_Bip_R_Shoulder"],
  ["10", "J_Bip_R_UpperArm"],
  ["11", "J_Bip_R_LowerArm"],
  ["12", "J_Bip_R_Hand"],
  ["13", "J_Bip_R_Middle1"],
  ["14", "J_Bip_L_Shoulder"],
  ["15", "J_Bip_L_UpperArm"],
  ["16", "J_Bip_L_LowerArm"],
  ["17", "J_Bip_L_Hand"],
  ["18", "J_Bip_L_Middle1"],
  ["19", "J_Bip_R_Hip"],
  ["20", "J_Bip_R_UpperLeg"],
  ["21", "J_Bip_R_LowerLeg"],
  ["22", "J_Bip_R_Foot"],
  ["23", "J_Bip_R_ToeBase"],
  ["24", "J_Bip_L_Hip"],
  ["25", "J_Bip_L_UpperLeg"],
  ["26", "J_Bip_L_LowerLeg"],
  ["27", "J_Bip_L_Foot"],
  ["28", "J_Bip_L_ToeBase"]
]);
var lu = function(r, e) {
  return lu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var i in s)
      Object.prototype.hasOwnProperty.call(s, i) && (t[i] = s[i]);
  }, lu(r, e);
};
function ef(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  lu(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function dP(r, e, t, s) {
  function i(n) {
    return n instanceof t ? n : new t(function(a) {
      a(n);
    });
  }
  return new (t || (t = Promise))(function(n, a) {
    function o(c) {
      try {
        l(s.next(c));
      } catch (d) {
        a(d);
      }
    }
    function h(c) {
      try {
        l(s.throw(c));
      } catch (d) {
        a(d);
      }
    }
    function l(c) {
      c.done ? n(c.value) : i(c.value).then(o, h);
    }
    l((s = s.apply(r, e || [])).next());
  });
}
function Oy(r, e) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, s, i, n, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(l) {
    return function(c) {
      return h([l, c]);
    };
  }
  function h(l) {
    if (s)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, l[0] && (t = 0)), t; )
      try {
        if (s = 1, i && (n = l[0] & 2 ? i.return : l[0] ? i.throw || ((n = i.return) && n.call(i), 0) : i.next) && !(n = n.call(i, l[1])).done)
          return n;
        switch (i = 0, n && (l = [l[0] & 2, n.value]), l[0]) {
          case 0:
          case 1:
            n = l;
            break;
          case 4:
            return t.label++, { value: l[1], done: !1 };
          case 5:
            t.label++, i = l[1], l = [0];
            continue;
          case 7:
            l = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (l[0] === 6 || l[0] === 2)) {
              t = 0;
              continue;
            }
            if (l[0] === 3 && (!n || l[1] > n[0] && l[1] < n[3])) {
              t.label = l[1];
              break;
            }
            if (l[0] === 6 && t.label < n[1]) {
              t.label = n[1], n = l;
              break;
            }
            if (n && t.label < n[2]) {
              t.label = n[2], t.ops.push(l);
              break;
            }
            n[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        l = e.call(r, t);
      } catch (c) {
        l = [6, c], i = 0;
      } finally {
        s = n = 0;
      }
    if (l[0] & 5)
      throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function Za(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], s = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && s >= r.length && (r = void 0), { value: r && r[s++], done: !r };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Xr(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var s = t.call(r), i, n = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = s.next()).done; )
      n.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = s.return) && t.call(s);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return n;
}
function Ja(r, e, t) {
  if (t || arguments.length === 2)
    for (var s = 0, i = e.length, n; s < i; s++)
      (n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]);
  return r.concat(n || Array.prototype.slice.call(e));
}
function Dr(r) {
  return this instanceof Dr ? (this.v = r, this) : new Dr(r);
}
function uP(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var s = t.apply(r, e || []), i, n = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(u) {
    s[u] && (i[u] = function(f) {
      return new Promise(function(m, _) {
        n.push([u, f, m, _]) > 1 || o(u, f);
      });
    });
  }
  function o(u, f) {
    try {
      h(s[u](f));
    } catch (m) {
      d(n[0][3], m);
    }
  }
  function h(u) {
    u.value instanceof Dr ? Promise.resolve(u.value.v).then(l, c) : d(n[0][2], u);
  }
  function l(u) {
    o("next", u);
  }
  function c(u) {
    o("throw", u);
  }
  function d(u, f) {
    u(f), n.shift(), n.length && o(n[0][0], n[0][1]);
  }
}
function fP(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Za == "function" ? Za(r) : r[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function s(n) {
    t[n] = r[n] && function(a) {
      return new Promise(function(o, h) {
        a = r[n](a), i(o, h, a.done, a.value);
      });
    };
  }
  function i(n, a, o, h) {
    Promise.resolve(h).then(function(l) {
      n({ value: l, done: o });
    }, a);
  }
}
function je(r) {
  return typeof r == "function";
}
function mP(r) {
  var e = function(s) {
    Error.call(s), s.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var td = mP(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(s, i) {
      return i + 1 + ") " + s.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function Yp(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var tf = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, s, i, n;
    if (!this.closed) {
      this.closed = !0;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var o = Za(a), h = o.next(); !h.done; h = o.next()) {
              var l = h.value;
              l.remove(this);
            }
          } catch (_) {
            e = { error: _ };
          } finally {
            try {
              h && !h.done && (t = o.return) && t.call(o);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          a.remove(this);
      var c = this.initialTeardown;
      if (je(c))
        try {
          c();
        } catch (_) {
          n = _ instanceof td ? _.errors : [_];
        }
      var d = this._finalizers;
      if (d) {
        this._finalizers = null;
        try {
          for (var u = Za(d), f = u.next(); !f.done; f = u.next()) {
            var m = f.value;
            try {
              Kp(m);
            } catch (_) {
              n = n ?? [], _ instanceof td ? n = Ja(Ja([], Xr(n)), Xr(_.errors)) : n.push(_);
            }
          }
        } catch (_) {
          s = { error: _ };
        } finally {
          try {
            f && !f.done && (i = u.return) && i.call(u);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
      if (n)
        throw new td(n);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        Kp(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && Yp(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && Yp(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = !0, e;
  }(), r;
}();
tf.EMPTY;
function ky(r) {
  return r instanceof tf || r && "closed" in r && je(r.remove) && je(r.add) && je(r.unsubscribe);
}
function Kp(r) {
  je(r) ? r() : r.unsubscribe();
}
var Ny = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, cu = {
  setTimeout: function(r, e) {
    for (var t = [], s = 2; s < arguments.length; s++)
      t[s - 2] = arguments[s];
    var i = cu.delegate;
    return i != null && i.setTimeout ? i.setTimeout.apply(i, Ja([r, e], Xr(t))) : setTimeout.apply(void 0, Ja([r, e], Xr(t)));
  },
  clearTimeout: function(r) {
    var e = cu.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(r);
  },
  delegate: void 0
};
function zy(r) {
  cu.setTimeout(function() {
    throw r;
  });
}
function Zp() {
}
function pP(r) {
  r();
}
var sf = function(r) {
  ef(e, r);
  function e(t) {
    var s = r.call(this) || this;
    return s.isStopped = !1, t ? (s.destination = t, ky(t) && t.add(s)) : s.destination = xP, s;
  }
  return e.create = function(t, s, i) {
    return new du(t, s, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = !0, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(tf), _P = Function.prototype.bind;
function sd(r, e) {
  return _P.call(r, e);
}
var gP = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (s) {
        ih(s);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (s) {
        ih(s);
      }
    else
      ih(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        ih(t);
      }
  }, r;
}(), du = function(r) {
  ef(e, r);
  function e(t, s, i) {
    var n = r.call(this) || this, a;
    if (je(t) || !t)
      a = {
        next: t ?? void 0,
        error: s ?? void 0,
        complete: i ?? void 0
      };
    else {
      var o;
      n && Ny.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = function() {
        return n.unsubscribe();
      }, a = {
        next: t.next && sd(t.next, o),
        error: t.error && sd(t.error, o),
        complete: t.complete && sd(t.complete, o)
      }) : a = t;
    }
    return n.destination = new gP(a), n;
  }
  return e;
}(sf);
function ih(r) {
  zy(r);
}
function yP(r) {
  throw r;
}
var xP = {
  closed: !0,
  next: Zp,
  error: yP,
  complete: Zp
}, nf = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function vP(r) {
  return r;
}
function SP(r) {
  return r.length === 0 ? vP : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(s, i) {
      return i(s);
    }, t);
  };
}
var Hn = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, s) {
    var i = this, n = wP(e) ? e : new du(e, t, s);
    return pP(function() {
      var a = i, o = a.operator, h = a.source;
      n.add(o ? o.call(n, h) : h ? i._subscribe(n) : i._trySubscribe(n));
    }), n;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var s = this;
    return t = Jp(t), new t(function(i, n) {
      var a = new du({
        next: function(o) {
          try {
            e(o);
          } catch (h) {
            n(h), a.unsubscribe();
          }
        },
        error: n,
        complete: i
      });
      s.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[nf] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return SP(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = Jp(e), new e(function(s, i) {
      var n;
      t.subscribe(function(a) {
        return n = a;
      }, function(a) {
        return i(a);
      }, function() {
        return s(n);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function Jp(r) {
  var e;
  return (e = r ?? Ny.Promise) !== null && e !== void 0 ? e : Promise;
}
function bP(r) {
  return r && je(r.next) && je(r.error) && je(r.complete);
}
function wP(r) {
  return r && r instanceof sf || bP(r) && ky(r);
}
function TP(r) {
  return je(r == null ? void 0 : r.lift);
}
function Uy(r) {
  return function(e) {
    if (TP(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (s) {
          this.error(s);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function uu(r, e, t, s, i) {
  return new CP(r, e, t, s, i);
}
var CP = function(r) {
  ef(e, r);
  function e(t, s, i, n, a, o) {
    var h = r.call(this, t) || this;
    return h.onFinalize = a, h.shouldUnsubscribe = o, h._next = s ? function(l) {
      try {
        s(l);
      } catch (c) {
        t.error(c);
      }
    } : r.prototype._next, h._error = n ? function(l) {
      try {
        n(l);
      } catch (c) {
        t.error(c);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, h._complete = i ? function() {
      try {
        i();
      } catch (l) {
        t.error(l);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, h;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var s = this.closed;
      r.prototype.unsubscribe.call(this), !s && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(sf), Vy = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function AP(r) {
  return je(r == null ? void 0 : r.then);
}
function MP(r) {
  return je(r[nf]);
}
function EP(r) {
  return Symbol.asyncIterator && je(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function RP(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function LP() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var PP = LP();
function IP(r) {
  return je(r == null ? void 0 : r[PP]);
}
function DP(r) {
  return uP(this, arguments, function() {
    var t, s, i, n;
    return Oy(this, function(a) {
      switch (a.label) {
        case 0:
          t = r.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, Dr(t.read())];
        case 3:
          return s = a.sent(), i = s.value, n = s.done, n ? [4, Dr(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, Dr(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function BP(r) {
  return je(r == null ? void 0 : r.getReader);
}
function rf(r) {
  if (r instanceof Hn)
    return r;
  if (r != null) {
    if (MP(r))
      return FP(r);
    if (Vy(r))
      return OP(r);
    if (AP(r))
      return kP(r);
    if (EP(r))
      return Gy(r);
    if (IP(r))
      return NP(r);
    if (BP(r))
      return zP(r);
  }
  throw RP(r);
}
function FP(r) {
  return new Hn(function(e) {
    var t = r[nf]();
    if (je(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function OP(r) {
  return new Hn(function(e) {
    for (var t = 0; t < r.length && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  });
}
function kP(r) {
  return new Hn(function(e) {
    r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, zy);
  });
}
function NP(r) {
  return new Hn(function(e) {
    var t, s;
    try {
      for (var i = Za(r), n = i.next(); !n.done; n = i.next()) {
        var a = n.value;
        if (e.next(a), e.closed)
          return;
      }
    } catch (o) {
      t = { error: o };
    } finally {
      try {
        n && !n.done && (s = i.return) && s.call(i);
      } finally {
        if (t)
          throw t.error;
      }
    }
    e.complete();
  });
}
function Gy(r) {
  return new Hn(function(e) {
    UP(r, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function zP(r) {
  return Gy(DP(r));
}
function UP(r, e) {
  var t, s, i, n;
  return dP(this, void 0, void 0, function() {
    var a, o;
    return Oy(this, function(h) {
      switch (h.label) {
        case 0:
          h.trys.push([0, 5, 6, 11]), t = fP(r), h.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (s = h.sent(), !!s.done)
            return [3, 4];
          if (a = s.value, e.next(a), e.closed)
            return [2];
          h.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = h.sent(), i = { error: o }, [3, 11];
        case 6:
          return h.trys.push([6, , 9, 10]), s && !s.done && (n = t.return) ? [4, n.call(t)] : [3, 8];
        case 7:
          h.sent(), h.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function VP(r, e, t, s, i) {
  s === void 0 && (s = 0), i === void 0 && (i = !1);
  var n = e.schedule(function() {
    t(), i ? r.add(this.schedule(null, s)) : this.unsubscribe();
  }, s);
  if (r.add(n), !i)
    return n;
}
function Hy(r, e) {
  return Uy(function(t, s) {
    var i = 0;
    t.subscribe(uu(s, function(n) {
      s.next(r.call(e, n, i++));
    }));
  });
}
var GP = Array.isArray;
function HP(r, e) {
  return GP(e) ? r.apply(void 0, Ja([], Xr(e))) : r(e);
}
function WP(r) {
  return Hy(function(e) {
    return HP(r, e);
  });
}
function qP(r, e, t, s, i, n, a, o) {
  var h = [], l = 0, c = 0, d = !1, u = function() {
    d && !h.length && !l && e.complete();
  }, f = function(_) {
    return l < s ? m(_) : h.push(_);
  }, m = function(_) {
    n && e.next(_), l++;
    var p = !1;
    rf(t(_, c++)).subscribe(uu(e, function(g) {
      i == null || i(g), n ? f(g) : e.next(g);
    }, function() {
      p = !0;
    }, void 0, function() {
      if (p)
        try {
          l--;
          for (var g = function() {
            var b = h.shift();
            a ? VP(e, a, function() {
              return m(b);
            }) : m(b);
          }; h.length && l < s; )
            g();
          u();
        } catch (b) {
          e.error(b);
        }
    }));
  };
  return r.subscribe(uu(e, f, function() {
    d = !0, u();
  })), function() {
    o == null || o();
  };
}
function Wy(r, e, t) {
  return t === void 0 && (t = 1 / 0), je(e) ? Wy(function(s, i) {
    return Hy(function(n, a) {
      return e(s, n, i, a);
    })(rf(r(s, i)));
  }, t) : (typeof e == "number" && (t = e), Uy(function(s, i) {
    return qP(s, i, r, t);
  }));
}
var XP = ["addListener", "removeListener"], jP = ["addEventListener", "removeEventListener"], $P = ["on", "off"];
function mi(r, e, t, s) {
  if (je(t) && (s = t, t = void 0), s)
    return mi(r, e, t).pipe(WP(s));
  var i = Xr(ZP(r) ? jP.map(function(o) {
    return function(h) {
      return r[o](e, h, t);
    };
  }) : YP(r) ? XP.map(Qp(r, e)) : KP(r) ? $P.map(Qp(r, e)) : [], 2), n = i[0], a = i[1];
  if (!n && Vy(r))
    return Wy(function(o) {
      return mi(o, e, t);
    })(rf(r));
  if (!n)
    throw new TypeError("Invalid event target");
  return new Hn(function(o) {
    var h = function() {
      for (var l = [], c = 0; c < arguments.length; c++)
        l[c] = arguments[c];
      return o.next(1 < l.length ? l : l[0]);
    };
    return n(h), function() {
      return a(h);
    };
  });
}
function Qp(r, e) {
  return function(t) {
    return function(s) {
      return r[t](e, s);
    };
  };
}
function YP(r) {
  return je(r.addListener) && je(r.removeListener);
}
function KP(r) {
  return je(r.on) && je(r.off);
}
function ZP(r) {
  return je(r.addEventListener) && je(r.removeEventListener);
}
class qy {
  constructor(e = void 0, t = void 0, s = !0) {
    this.xrInputSources = new Array(), this.xrStartCallback = () => {
    }, this.updateCallbacks = new Array(), this.isLocalDemo = !0, this.isRunning = !0, e && (this.app = e, this.app.on("update", (i) => {
      this.isRunning && (this.updateCallbacks.forEach((n) => {
        n(i);
      }), this.drawBaseLines());
    }), this.registerXRInputEvent()), t && (this.rootEntity = t), this.isLocalDemo = s;
  }
  async init() {
    if (this.app) {
      console.warn("PlayCanvas application is already initial");
      return;
    }
    this.initApplication(), await this.loadAssets(), await this.loadFontAssets(), this.initXRCamera(), this.initCamera(), this.initLight(), this.initPlane(), this.initHUD(), this.initTextHMDPos(), this.initTextHMDRotation(), this.initTextInputSourceLeftPos(), this.initTextTargetLeftPos(), this.initTextInputSourceRightPos(), this.initTextTargetRightPos(), this.initTextAvatarForward(), this.runApplication(), this.drawBaseLines(), mi(document, "touchend").subscribe((e) => {
      this.startXR();
    }), mi(document, "click").subscribe((e) => {
      this.startXR();
    }), mi(document, "keyup").subscribe((e) => {
      e.key === "`" && this.startXR();
    });
  }
  stop() {
    this.isRunning = !1;
  }
  resume() {
    this.isRunning = !0;
  }
  initApplication() {
    var t;
    const e = document.getElementById("canvas");
    this.app = new oP(e, {
      graphicsDeviceOptions: {
        antialias: !0,
        alpha: !1,
        preserveDrawingBuffer: !1,
        preferWebGl2: !0,
        powerPreference: "high-performance",
        xrCompatible: !0
      },
      mouse: new Jx(document.body)
    }), this.app.setCanvasFillMode(xg), this.app.setCanvasResolution(Fd), this.isLocalDemo, this.rootEntity || (this.rootEntity = new oe("avatarRoot"), (t = this.app) == null || t.root.addChild(this.rootEntity)), this.app.on("update", (s) => {
      this.isRunning && (this.updateCallbacks.forEach((i) => {
        i(s);
      }), this.drawBaseLines());
    });
  }
  async loadAssets() {
    var s;
    const e = [];
    this.isLocalDemo;
    const t = new $p(
      e,
      (s = this.app) == null ? void 0 : s.assets
    );
    return new Promise((i, n) => {
      t.load(() => {
        i();
      });
    });
  }
  async loadFontAssets() {
    var s;
    const e = [];
    e.forEach((i) => {
      var a, o;
      const n = (o = (a = this.app) == null ? void 0 : a.assets.find(
        `${i.name}.json`
      )) == null ? void 0 : o.resource;
      n ? i.data = n : ze.Instance.error(
        `Font Loading: You did'nt loaded ${i.name} json file`
      );
    });
    const t = new $p(
      e,
      (s = this.app) == null ? void 0 : s.assets
    );
    return new Promise((i, n) => {
      t.load(() => {
        i();
      });
    });
  }
  initCamera() {
    var e, t, s;
    this.camera = new oe("camera"), this.camera.addComponent("camera", {
      clearColor: new z(0.5, 0.6, 0.9),
      nearClip: 0.1,
      farClip: 1e3
      // fov: 55,
    }), this.camera.addComponent("script"), (e = this.camera.script) == null || e.create("orbitCamera", {
      attributes: {
        inertiaFactor: 0.2
      }
    }), (t = this.camera.script) == null || t.create("mouseInput", {
      attributes: {}
    }), this.camera.setPosition(0, 8, 16), (s = this.app) == null || s.root.addChild(this.camera);
  }
  initXRCamera() {
    var e;
    this.xrCamera = new oe("xrCamera"), this.xrCamera.addComponent("camera", {
      clearColor: new z(0.5, 0.6, 0.9),
      nearClip: 1e-3,
      farClip: 1e3
      // fov: 55,
    }), this.xrCamera.setPosition(0, 0, 0), this.xrCameraRoot = new oe("xrCamera"), this.xrCameraRoot.addChild(this.xrCamera), this.rootEntity ? this.rootEntity.addChild(this.xrCameraRoot) : (e = this.app) == null || e.root.addChild(this.xrCameraRoot);
  }
  initHUD() {
    var e;
    this.hud = new oe("HUD"), this.hud.addComponent("screen", {
      screenSpace: !0,
      referenceResolution: new q(1280, 720),
      scaleBlend: 0.5,
      scaleMode: ny
    }), (e = this.app) == null || e.root.addChild(this.hud), this.hud.setPosition(0, 4, 0);
  }
  initTextHMDPos() {
    var e, t;
    this.textHMDPos = new oe("HMDPos"), this.textHMDPos.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#FF0000"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), (t = this.hud) == null || t.addChild(this.textHMDPos);
  }
  initTextHMDRotation() {
    var e, t;
    this.textHMDRotation = new oe("HMDRotation"), this.textHMDRotation.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#00FF00"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textHMDRotation.setLocalPosition(0, 32, 0), (t = this.hud) == null || t.addChild(this.textHMDRotation);
  }
  initTextInputSourceLeftPos() {
    var e, t;
    this.textInputSourceLeftPos = new oe("InputSourceLeftPos"), this.textInputSourceLeftPos.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#FFFF00"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textInputSourceLeftPos.setLocalPosition(-128, 128, 0), (t = this.hud) == null || t.addChild(this.textInputSourceLeftPos);
  }
  initTextTargetLeftPos() {
    var e, t;
    this.textTargetLeftPos = new oe("TargetLeftPos"), this.textTargetLeftPos.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#FFFF00"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textTargetLeftPos.setLocalPosition(-128, 160, 0), (t = this.hud) == null || t.addChild(this.textTargetLeftPos);
  }
  initTextInputSourceRightPos() {
    var e, t;
    this.textInputSourceRightPos = new oe("InputSourceRightPos"), this.textInputSourceRightPos.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#FFFF00"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textInputSourceRightPos.setLocalPosition(128, 128, 0), (t = this.hud) == null || t.addChild(this.textInputSourceRightPos);
  }
  initTextTargetRightPos() {
    var e, t;
    this.textTargetRightPos = new oe("TargetRightPos"), this.textTargetRightPos.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#FFFF00"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textTargetRightPos.setLocalPosition(128, 160, 0), (t = this.hud) == null || t.addChild(this.textTargetRightPos);
  }
  initTextAvatarForward() {
    var e, t;
    this.textAvatarForward = new oe("AvatarForward"), this.textAvatarForward.addComponent("element", {
      anchor: [0.5, 0.5, 0.5, 0.5],
      pivot: [0.5, 0.5],
      fontSize: 24,
      autoWidth: !0,
      autoHeight: !0,
      type: ni,
      color: new z().fromString("#0000FF"),
      alignment: [0.5, 0.5],
      useInput: !0,
      text: "0,0,0",
      fontAsset: (e = this.app) == null ? void 0 : e.assets.find("RobotoMedium")
    }), this.textAvatarForward.setLocalPosition(0, 64, 0), (t = this.hud) == null || t.addChild(this.textAvatarForward);
  }
  initLight() {
    var t;
    const e = new oe("light");
    e.addComponent("light"), e.setEulerAngles(45, 0, 0), (t = this.app) == null || t.root.addChild(e);
  }
  initPlane() {
    var t;
    const e = new oe("plane");
    e.addComponent("render", {
      type: "plane",
      receiveShadows: !0,
      renderStyle: Rt
    }), e.setLocalScale(10, 1, 10), (t = this.app) == null || t.root.addChild(e);
  }
  drawBaseLines() {
    this.drawLine(
      new v(-100, 0, 0),
      new v(100, 0, 0),
      new z(1, 0, 0, 0.2)
    ), this.drawLine(
      new v(0, -100, 0),
      new v(0, 100, 0),
      new z(0, 1, 0, 0.2)
    ), this.drawLine(
      new v(0, 0, -100),
      new v(0, 0, 100),
      new z(0, 0, 1, 0.2)
    );
  }
  runApplication() {
    var e;
    (e = this.app) == null || e.start();
  }
  addUpdateCallback(e = () => {
  }) {
    this.updateCallbacks.push(e);
  }
  addBone(e, t, s = "") {
    var f, m;
    const i = new oe(`${s}_joint`), n = (f = this.app) == null ? void 0 : f.graphicsDevice, a = wn(n, {
      radius: 0.02
    }), o = new Tn();
    o.color = z.RED;
    const h = new we(a, o);
    i.addComponent("render", {
      meshInstances: [h],
      renderStyle: Rt
    });
    const l = new oe(`${s}_bone`), c = Uu(n, {
      baseRadius: 0.02,
      peakRadius: 5e-3,
      height: e,
      capSegments: 5
    });
    let d = new Ht();
    d.emissive = t, d.update();
    const u = new we(c, d);
    return l.addComponent("render", {
      meshInstances: [u],
      renderStyle: Rt
    }), l.rotate(-90, 0, 0), l.translate(0, 0, -e * 0.5), i.addChild(l), this.rootEntity ? this.rootEntity.addChild(i) : (m = this.app) == null || m.root.addChild(i), i;
  }
  addTarget(e = "target") {
    var o, h;
    const t = new oe(e), s = (o = this.app) == null ? void 0 : o.graphicsDevice, i = wn(s, {
      radius: 0.02
    }), n = new Tn();
    n.color = z.YELLOW;
    const a = new we(i, n);
    return t.addComponent("render", {
      meshInstances: [a],
      renderStyle: Rt
    }), (h = this.app) == null || h.root.addChild(t), t;
  }
  drawLine(e, t, s, i = !0) {
    var n;
    (n = this.app) == null || n.drawLine(e, t, s, i);
  }
  getXRInputSources() {
    return this.xrInputSources;
  }
  addXRStartCallback(e) {
    this.xrStartCallback = e;
  }
  isInXR() {
    return this.app ? this.app.xr.active : !1;
  }
  xrInputAddCallback(e) {
    this.xrInputSources.push(e);
  }
  registerXRInputEvent() {
    var e;
    (e = this.app) != null && e.xr.isAvailable(Oa) && (this.app.xr.input.on("add", this.xrInputAddCallback, this), this.app.xr.on("end", () => {
      var t;
      (t = this.app) == null || t.xr.input.off("add", this.xrInputAddCallback, this), this.xrInputSources = [];
    }));
  }
  startXR() {
    var e, t, s, i;
    (e = this.app) != null && e.xr.isAvailable(Oa) && !((t = this.app) != null && t.xr.active) && this.isLocalDemo && (this.registerXRInputEvent(), this.app.xr.on("start", () => {
      this.xrCamera && this.xrCamera.camera && (this.xrCamera.camera.rect = new Z(0, 0, 1, 1)), this.camera && this.camera.camera && (this.camera.camera.rect = new Z(0, 0, 1, 0)), this.xrCamera && this.xrStartCallback.call(this, this.xrCamera);
    }), this.app.xr.on("end", () => {
      this.xrCamera && this.xrCamera.camera && (this.xrCamera.camera.rect = new Z(0, 0, 1, 0)), this.camera && this.camera.camera && (this.camera.camera.rect = new Z(0, 0, 1, 1));
    }), this.app.xr.on("update", () => {
      if (this.xrCamera && this.xrCamera.camera) {
        const n = this.xrCamera.getPosition();
        this.textHMDPos && this.textHMDPos.element && this.textHMDPos.element.text && this.isLocalDemo && (this.textHMDPos.element.text = `${n.x.toFixed(
          4
        )}, ${n.y.toFixed(4)}, ${n.z.toFixed(4)}`);
      }
      this.xrInputSources.forEach((n) => {
        if (n) {
          const a = n.getPosition();
          n.handedness === Qu ? this.textInputSourceLeftPos && this.textInputSourceLeftPos.element && this.textInputSourceLeftPos.element.text && (this.textInputSourceLeftPos.element.text = `${a.x.toFixed(
            4
          )},${a.y.toFixed(4)},${a.z.toFixed(4)}`) : this.textInputSourceRightPos && this.textInputSourceRightPos.element && this.textInputSourceRightPos.element.text && (this.textInputSourceRightPos.element.text = `${a.x.toFixed(
            4
          )},${a.y.toFixed(4)},${a.z.toFixed(4)}`);
        }
      });
    }), (i = (s = this.xrCamera) == null ? void 0 : s.camera) == null || i.startXr(Oa, VL, {
      callback: (n) => {
        ze.Instance.error("startXr callback err:", n);
      }
    }));
  }
  getXRCameraPos() {
    var e;
    return (e = this.xrCamera) == null ? void 0 : e.getPosition();
  }
  setTextInputSourceLeftPos(e) {
    this.isLocalDemo && this.textInputSourceLeftPos && this.textInputSourceLeftPos.element && this.textInputSourceLeftPos.element.text && this.isLocalDemo && (this.textInputSourceLeftPos.element.text = e);
  }
  setTextTargetLeftPos(e) {
    this.isLocalDemo && this.textTargetLeftPos && this.textTargetLeftPos.element && this.textTargetLeftPos.element.text && this.isLocalDemo && (this.textTargetLeftPos.element.text = e);
  }
  setTextInputSourceRightPos(e) {
    this.isLocalDemo && this.textInputSourceRightPos && this.textInputSourceRightPos.element && this.textInputSourceRightPos.element.text && this.isLocalDemo && (this.textInputSourceRightPos.element.text = e);
  }
  setTextTargetRightPos(e) {
    this.isLocalDemo && this.textTargetRightPos && this.textTargetRightPos.element && this.textTargetRightPos.element.text && this.isLocalDemo && (this.textTargetRightPos.element.text = e);
  }
  setXRCamera(e) {
    this.xrCamera = e;
  }
}
class JP extends qy {
  constructor(e = void 0, t = void 0, s = void 0, i = !0) {
    super(e, t, i), this.isRenderForwardLines = !1, this.boneLengthMap = /* @__PURE__ */ new Map(), this.scale = 1, this.localTargetMap = /* @__PURE__ */ new Map(), this.scaleAvatarWithHDMCallback = new Array(), this.fitXRCameraToAvatarHeadCallback = new Array(), this.avatarEntity = s;
  }
  async init() {
    var e, t, s;
    await super.init(), this.avatarEntity || (this.avatarEntity = this.addAvatar()), this.ikBoneRootEntity || (this.ikBoneRootEntity = new oe("ikBoneRootEntity"), this.rootEntity ? this.rootEntity.addChild(this.ikBoneRootEntity) : (e = this.app) == null || e.root.addChild(this.ikBoneRootEntity)), this.isLocalDemo && ((t = this.app) == null || t.xr.once("update", () => {
      this.fitXRCameraToAvatarHead();
    }), (s = this.app) == null || s.xr.on("update", (i) => {
      var n, a, o, h;
      if (i) {
        const l = i.getViewerPose((n = this.app) == null ? void 0 : n.xr._referenceSpace), c = l.transform.position, d = l.transform.orientation;
        if ((a = this.avatarEntity) == null || a.setLocalPosition(
          c.x,
          this.avatarEntity.getLocalPosition().y,
          c.z
        ), this.textHMDRotation && this.textHMDRotation.element && this.textHMDRotation.element.text && this.isLocalDemo && (this.textHMDRotation.element.text = `${d.x.toFixed(
          4
        )}, ${d.y.toFixed(4)}, ${d.z.toFixed(
          4
        )}, ${d.w.toFixed(4)}`), (o = this.avatarEntity) == null || o.setLocalRotation(0, d.y, 0, 1), this.textAvatarForward && this.textAvatarForward.element && this.textAvatarForward.element.text && this.isLocalDemo) {
          const u = (h = this.avatarEntity) == null ? void 0 : h.forward;
          this.textAvatarForward.element.text = `${u == null ? void 0 : u.x.toFixed(
            4
          )}, ${u == null ? void 0 : u.y.toFixed(4)}, ${u == null ? void 0 : u.z.toFixed(4)}`;
        }
      }
    }));
  }
  addAvatar() {
    var t, s;
    const e = (t = this.app) == null ? void 0 : t.assets.find("avatar");
    if (e) {
      const i = e.resource.instantiateRenderEntity();
      return i.setLocalPosition(0, 0, 0.2), ze.Instance.log("addAvatar:", i), this.rootEntity ? this.rootEntity.addChild(i) : (s = this.app) == null || s.root.addChild(i), i;
    }
  }
  getAvatarEntity() {
    return this.avatarEntity;
  }
  getAvatarHipsPosition() {
    var t;
    const e = (t = this.avatarEntity) == null ? void 0 : t.findByName(W.Hips);
    if (e)
      return e == null ? void 0 : e.getPosition();
  }
  addBone(e, t, s = "") {
    var f, m;
    const i = new oe(`${s}_joint`), n = (f = this.app) == null ? void 0 : f.graphicsDevice, a = wn(n, {
      radius: 0.02
    }), o = new Tn();
    o.color = z.RED;
    const h = new we(a, o);
    i.addComponent("render", {
      meshInstances: [h],
      renderStyle: Rt
    });
    const l = new oe(`${s}_bone`), c = Uu(n, {
      baseRadius: 0.02,
      peakRadius: 5e-3,
      height: e,
      capSegments: 5
    });
    let d = new Ht();
    d.emissive = t, d.update();
    const u = new we(c, d);
    return l.addComponent("render", {
      meshInstances: [u],
      renderStyle: Rt
    }), l.rotate(-90, 0, 0), l.translate(0, 0, -e * 0.5), i.addChild(l), (m = this.ikBoneRootEntity) == null || m.addChild(i), i;
  }
  addTarget(e = "target") {
    var o, h;
    const t = new oe(e), s = (o = this.app) == null ? void 0 : o.graphicsDevice, i = wn(s, {
      radius: 0.02
    }), n = new Tn();
    n.color = z.YELLOW;
    const a = new we(i, n);
    return t.addComponent("render", {
      meshInstances: [a],
      renderStyle: Rt
    }), (h = this.avatarEntity) == null || h.addChild(t), this.addLocalTarget(e), t;
  }
  addLocalTarget(e = "target") {
    var o, h;
    const t = new oe(e), s = (o = this.app) == null ? void 0 : o.graphicsDevice, i = wn(s, {
      radius: 0.02
    }), n = new Tn();
    n.color = z.BLUE;
    const a = new we(i, n);
    t.addComponent("render", {
      meshInstances: [a],
      renderStyle: Rt
    }), (h = this.ikBoneRootEntity) == null || h.addChild(t), this.localTargetMap.set(e, t);
  }
  addLocalForwardPoint() {
    var a, o;
    const e = new oe("forward-point"), t = (a = this.app) == null ? void 0 : a.graphicsDevice, s = wn(t, {
      radius: 0.02
    }), i = new Tn();
    i.color = z.BLUE;
    const n = new we(s, i);
    e.addComponent("render", {
      meshInstances: [n],
      renderStyle: Rt
    }), e.setLocalPosition(0, 1.6, -1), (o = this.avatarEntity) == null || o.addChild(e);
  }
  setLocalTargetWithLocalPos(e, t) {
    const s = this.localTargetMap.get(e);
    s && s.setLocalPosition(t);
  }
  update() {
    this.isRenderForwardLines && this.avatarEntity && this.renderAvatarForwardLines(this.avatarEntity);
  }
  renderAvatarForwardLines(e) {
    this.renderAvatarRightArmForwardLines(e), this.renderAvatarLeftArmForwardLines(e), this.renderAvatarRightLegForwardLines(e), this.renderAvatarLeftLegForwardLines(e);
  }
  renderAvatarForwardLine(e, t) {
    this.drawLine(
      new v(e.x, e.y, e.z),
      new v(e.x + t.x, e.y + t.y, e.z + t.z),
      new z(1, 0, 0, 1)
    );
  }
  renderAvatarLeftArmForwardLines(e) {
    const t = e.findByName(
      W.LeftUpperArm
    ), s = e.findByName(
      W.LeftLowerArm
    ), i = e.findByName(W.LeftHand);
    if (t) {
      const n = t.getLocalPosition(), a = t.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (s) {
      const n = s.getLocalPosition(), a = s.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (i) {
      const n = i.getLocalPosition(), a = i.forward;
      this.renderAvatarForwardLine(n, a);
    }
  }
  renderAvatarRightArmForwardLines(e) {
    const t = e.findByName(
      W.RightUpperArm
    ), s = e.findByName(
      W.RightLowerArm
    ), i = e.findByName(W.RightHand);
    if (t) {
      const n = t.getLocalPosition(), a = t.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (s) {
      const n = s.getLocalPosition(), a = s.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (i) {
      const n = i.getLocalPosition(), a = i.forward;
      this.renderAvatarForwardLine(n, a);
    }
  }
  renderAvatarLeftLegForwardLines(e) {
    const t = e.findByName(
      W.LeftUpperLeg
    ), s = e.findByName(
      W.LeftLowerLeg
    ), i = e.findByName(W.LeftFoot);
    if (t) {
      const n = t.getLocalPosition(), a = t.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (s) {
      const n = s.getLocalPosition(), a = s.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (i) {
      const n = i.getLocalPosition(), a = i.forward;
      this.renderAvatarForwardLine(n, a);
    }
  }
  renderAvatarRightLegForwardLines(e) {
    const t = e.findByName(
      W.RightUpperLeg
    ), s = e.findByName(
      W.RightLowerLeg
    ), i = e.findByName(W.RightFoot);
    if (t) {
      const n = t.getLocalPosition(), a = t.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (s) {
      const n = s.getLocalPosition(), a = s.forward;
      this.renderAvatarForwardLine(n, a);
    }
    if (i) {
      const n = i.getLocalPosition(), a = i.forward;
      this.renderAvatarForwardLine(n, a);
    }
  }
  calculateBoneLenth() {
    const e = this.calculateBoneLengthNeck(), t = this.calculateBoneLengthHipsToSpine(), s = this.calculateBoneLengthSpine(), i = this.calculateBoneLengthChest(), n = this.calculateBoneLengthUpperChest(), a = this.calculateBoneLengthRightShoulder(), o = this.calculateBoneLengthRightUpperArm(), h = this.calculateBoneLengthRightLowerArm(), l = this.calculateBoneLengthRightHand(), c = this.calculateBoneLengthLeftShoulder(), d = this.calculateBoneLengthLeftUpperArm(), u = this.calculateBoneLengthLeftLowerArm(), f = this.calculateBoneLengthLeftHand(), m = this.calculateBoneLengthRightHip(), _ = this.calculateBoneLengthRightUpperLeg(), p = this.calculateBoneLengthRightLowerLeg(), g = this.calculateBoneLengthRightFoot(), b = this.calculateBoneLengthLeftHip(), x = this.calculateBoneLengthLeftUpperLeg(), y = this.calculateBoneLengthLeftLowerLeg(), S = this.calculateBoneLengthLeftFoot();
    return this.boneLengthMap.set(fe.Neck, e), this.boneLengthMap.set(fe.Hips, t), this.boneLengthMap.set(fe.Spine, s), this.boneLengthMap.set(fe.Chest, i), this.boneLengthMap.set(fe.UpperChest, n), this.boneLengthMap.set(fe.RightShoulder, a), this.boneLengthMap.set(fe.RightUpperArm, o), this.boneLengthMap.set(fe.RightLowerArm, h), this.boneLengthMap.set(fe.RightHand, l), this.boneLengthMap.set(fe.LeftShoulder, c), this.boneLengthMap.set(fe.LeftUpperArm, d), this.boneLengthMap.set(fe.LeftLowerArm, u), this.boneLengthMap.set(fe.LeftHand, f), this.boneLengthMap.set(fe.RightHip, m), this.boneLengthMap.set(fe.RightUpperLeg, _), this.boneLengthMap.set(fe.RightLowerLeg, p), this.boneLengthMap.set(fe.RightFoot, g), this.boneLengthMap.set(fe.LeftHip, b), this.boneLengthMap.set(fe.LeftUpperLeg, x), this.boneLengthMap.set(fe.LeftLowerLeg, y), this.boneLengthMap.set(fe.LeftFoot, S), this.boneLengthMap;
  }
  calculateBoneLengthNeck() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Neck), t = this.avatarEntity.findByName(W.Head);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthHipsToSpine() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Hips), t = e == null ? void 0 : e.findByName(W.Spine);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthSpine() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Spine), t = e == null ? void 0 : e.findByName(W.Chest);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthChest() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Chest), t = e == null ? void 0 : e.findByName(W.UpperChest);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthUpperChest() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.UpperChest), t = e == null ? void 0 : e.findByName(W.Neck);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightShoulder() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightShoulder), t = e == null ? void 0 : e.findByName(W.RightUpperArm);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightUpperArm() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightUpperArm), t = e == null ? void 0 : e.findByName(W.RightLowerArm);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightLowerArm() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightLowerArm), t = e == null ? void 0 : e.findByName(W.RightHand);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightHand() {
    var s;
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = (s = this.avatarEntity) == null ? void 0 : s.findByName(W.RightHand), t = e == null ? void 0 : e.findByName(W.RightMiddle1);
    if (e && t) {
      const i = e == null ? void 0 : e.getPosition(), n = t == null ? void 0 : t.getPosition();
      return i == null ? void 0 : i.distance(n);
    }
    return 0;
  }
  calculateBoneLengthLeftShoulder() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftShoulder), t = e == null ? void 0 : e.findByName(W.LeftUpperArm);
    if (e && t) {
      const s = e.getPosition(), i = t.getPosition();
      return s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftUpperArm() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftUpperArm), t = e == null ? void 0 : e.findByName(W.LeftLowerArm);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftLowerArm() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftLowerArm), t = e == null ? void 0 : e.findByName(W.LeftHand);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftHand() {
    var s;
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = (s = this.avatarEntity) == null ? void 0 : s.findByName(W.LeftHand), t = e == null ? void 0 : e.findByName(W.LeftMiddle1);
    if (e && t) {
      const i = e == null ? void 0 : e.getPosition(), n = t == null ? void 0 : t.getPosition();
      return i == null ? void 0 : i.distance(n);
    }
    return 0;
  }
  calculateBoneLengthRightHip() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Hips), t = e == null ? void 0 : e.findByName(W.RightUpperLeg);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightUpperLeg() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightUpperLeg), t = e == null ? void 0 : e.findByName(W.RightLowerLeg);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightLowerLeg() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightLowerLeg), t = e == null ? void 0 : e.findByName(W.RightFoot);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthRightFoot() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.RightFoot), t = e == null ? void 0 : e.findByName(W.RightToeBase);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftHip() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.Hips), t = e == null ? void 0 : e.findByName(W.LeftUpperLeg);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftUpperLeg() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftUpperLeg), t = e == null ? void 0 : e.findByName(W.LeftLowerLeg);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftLowerLeg() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftLowerLeg), t = e == null ? void 0 : e.findByName(W.LeftFoot);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  calculateBoneLengthLeftFoot() {
    if (!this.avatarEntity)
      throw new Error("avatar entity is undefined");
    const e = this.avatarEntity.findByName(W.LeftFoot), t = e == null ? void 0 : e.findByName(W.LeftToeBase);
    if (e && t) {
      const s = e == null ? void 0 : e.getPosition(), i = t == null ? void 0 : t.getPosition();
      return s == null ? void 0 : s.distance(i);
    }
    return 0;
  }
  addScaleAvatarWithHMDCallback(e) {
    this.scaleAvatarWithHDMCallback.push(e);
  }
  addFitXRCameraToAvatarHeadCallback(e) {
    this.fitXRCameraToAvatarHeadCallback.push(e);
  }
  scaleAvatarWithHMD() {
    if (ze.Instance.log("[AvatarRender] calculateAvatarScaleWithHMD()"), ze.Instance.log("[AvatarRender] this.xrCamera:", this.xrCamera), this.xrCamera) {
      const e = this.xrCamera.getLocalPosition();
      if (ze.Instance.log(
        "[AvatarRender] this.avatarEntity:",
        this.avatarEntity
      ), this.avatarEntity) {
        const t = this.avatarEntity.findByName(W.Head);
        if (ze.Instance.log("[AvatarRender] head:", t), t) {
          const s = t.getPosition();
          t.setLocalScale(0, 0, 0), ze.Instance.log(
            `[AvatarRender] xrCameraPos.y: ${e.y}, headPos.y: ${s.y}`
          ), this.scale = e.y / s.y, ze.Instance.log(`[AvatarRender]this.scale: ${this.scale}`), this.avatarEntity.setLocalScale(this.scale, this.scale, this.scale), this.calculateBoneLenth(), this.scaleAvatarWithHDMCallback.forEach((i) => {
            i.call(this, this.boneLengthMap);
          });
        }
      }
    }
  }
  fitXRCameraToAvatarHead() {
    var e, t, s, i, n, a;
    if (ze.Instance.log("[AvatarRender] fitXRCameraToAvatarHead()"), ze.Instance.log("[AvatarRender] this.xrCamera:", this.xrCamera), this.xrCamera) {
      const o = this.xrCamera.getLocalPosition();
      if (ze.Instance.log(
        "[AvatarRender] this.avatarEntity:",
        this.avatarEntity
      ), this.avatarEntity) {
        ze.Instance.log(
          "[AvatarRender] AvatarPartMap.Head:",
          W.Head
        );
        const h = this.avatarEntity.findByName(W.Head);
        if (ze.Instance.log("[AvatarRender] head:", h), h) {
          const l = h.getPosition();
          h.setLocalScale(0, 0, 0);
          const c = l.y - o.y;
          ze.Instance.log(
            `[AvatarRender] xrCameraPos.y: ${o.y}, headPos.y: ${l.y}, yOffset: ${c}`
          );
          const d = (e = this.xrCamera) == null ? void 0 : e.parent.getPosition(), u = (t = this.xrCamera) == null ? void 0 : t.parent.getLocalPosition();
          ze.Instance.log(
            "[AvatarRender] xrCameraParentPos:",
            d
          ), ze.Instance.log(
            "[AvatarRender] xrCameraParentLocalPos:",
            u
          ), ze.Instance.log(
            "[AvatarRender] this.xrCamera?.parent:",
            (s = this.xrCamera) == null ? void 0 : s.parent
          ), (i = this.xrCamera) != null && i.parent.parent && ze.Instance.log(
            "[AvatarRender] this.xrCamera?.parent.parent:",
            (n = this.xrCamera) == null ? void 0 : n.parent.parent
          ), (a = this.xrCamera) == null || a.parent.setLocalPosition(
            u.x,
            u.y + c,
            u.z
          ), this.calculateBoneLenth(), this.fitXRCameraToAvatarHeadCallback.forEach((f) => {
            f.call(this, this.boneLengthMap);
          });
        }
      }
    }
  }
  getAvatarEntityForward() {
    var e;
    return (e = this.avatarEntity) == null ? void 0 : e.forward;
  }
  getAvatarScale() {
    return this.scale;
  }
}
class af {
  static vec3LookRotation(e, t) {
    const s = new v(), i = new v(), n = new ee();
    e = e.normalize();
    var a = e.normalize(), o = s.copy(v.ZERO).cross(t, a).normalize(), h = i.copy(v.ZERO).cross(a, o), l = o.x, c = o.y, d = o.z, u = h.x, f = h.y, m = h.z, _ = a.x, p = a.y, g = a.z, b = l + f + g, x = n;
    if (b > 0) {
      var y = Math.sqrt(b + 1);
      return x.w = y * 0.5, y = 0.5 / y, x.x = (m - p) * y, x.y = (_ - d) * y, x.z = (c - u) * y, x;
    }
    if (l >= f && l >= g) {
      var S = Math.sqrt(1 + l - f - g), C = 0.5 / S;
      return x.x = 0.5 * S, x.y = (c + u) * C, x.z = (d + _) * C, x.w = (m - p) * C, x;
    }
    if (f > g) {
      var w = Math.sqrt(1 + f - l - g), M = 0.5 / w;
      return x.x = (u + c) * M, x.y = 0.5 * w, x.z = (p + m) * M, x.w = (_ - d) * M, x;
    }
    var T = Math.sqrt(1 + g - l - f), A = 0.5 / T;
    return x.x = (_ + d) * A, x.y = (p + m) * A, x.z = 0.5 * T, x.w = (c - u) * A, x;
  }
  //   mat3 rotateAlign( vec3 v1, vec3 v2)
  // {
  //     vec3 axis = cross( v1, v2 );
  //     const float cosA = dot( v1, v2 );
  //     const float k = 1.0f / (1.0f + cosA);
  //     mat3 result( (axis.x * axis.x * k) + cosA,
  //                  (axis.y * axis.x * k) - axis.z,
  //                  (axis.z * axis.x * k) + axis.y,
  //                  (axis.x * axis.y * k) + axis.z,
  //                  (axis.y * axis.y * k) + cosA,
  //                  (axis.z * axis.y * k) - axis.x,
  //                  (axis.x * axis.z * k) - axis.y,
  //                  (axis.y * axis.z * k) + axis.x,
  //                  (axis.z * axis.z * k) + cosA
  //                  );
  //     return result;
  // }
  static rotateAlign(e, t) {
    const s = new v().cross(e, t), i = e.dot(t), n = 1 / (1 + i), a = new is();
    return a.set([
      s.x * s.x * n + i,
      s.y * s.x * n - s.z,
      s.z * s.x * n + s.y,
      s.x * s.y * n + s.z,
      s.y * s.y * n + i,
      s.z * s.y * n - s.x,
      s.x * s.z * n - s.y,
      s.y * s.z * n + s.x,
      s.z * s.z * n + i
    ]), a;
  }
}
const dI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AvatarPart: fe,
  AvatarPartMap: W,
  AvatarRenderer: JP,
  Renderer: qy,
  Util: af
}, Symbol.toStringTag, { value: "Module" }));
class Qa {
  constructor(e) {
    if (this.ik = new Fy(), !e)
      throw new Error("Renderer is undefined");
    this.renderer = e, this.renderer.addUpdateCallback(this.update.bind(this)), this.renderer.init();
  }
  static pcV3ToFabrikV3(e) {
    return new R(e.x, e.y, e.z);
  }
  static fabrikV3ToPCV3(e) {
    return new v(e.x, e.y, e.z);
  }
  static equalV3BetweenPCV3(e, t) {
    return e.x == t.x && e.y == t.y && e.z == t.z;
  }
  static equalV3BetweenV3(e, t) {
    return e.x == t.x && e.y == t.y && e.z == t.z;
  }
  static equalBetweenQuat(e, t) {
    return e.x == t.x && e.y == t.y && e.z == t.z && e.w == t.w;
  }
  setIK(e) {
    this.ik = e, this.ik.setRenderer(this.renderer);
  }
  setDebug(e) {
    ze.Instance.setDebug(e);
  }
  run() {
    var e;
    (e = this.ik) == null || e.run();
  }
  update(e) {
    var t;
    (t = this.ik) == null || t.update(), this.updateTargetsByXRInputSources();
  }
  stop() {
    this.renderer.stop();
  }
  resume() {
    this.renderer.resume();
  }
  updateTargetsByXRInputSources() {
    var e, t, s;
    if (this.renderer && this.renderer.isLocalDemo) {
      (e = this.renderer.getXRInputSources()) == null || e.forEach((n) => {
        n && (n.handedness === Qu ? this.updateTargetByXRInputSource(Y.LeftArm, n) : n.handedness === GL && this.updateTargetByXRInputSource(
          Y.RightArm,
          n
        ));
      });
      const i = this.renderer.getXRCameraPos();
      if (i) {
        const n = this.ik.getTarget(Y.Head);
        n == null || n.setPosition(
          new R(i == null ? void 0 : i.x, i == null ? void 0 : i.y, i == null ? void 0 : i.z)
        ), (t = this.ik) == null || t.setNeedToSolve(!0), (s = this.ik) == null || s.update();
      }
    }
  }
  updateTargetByXRInputSource(e, t) {
    var i, n;
    const s = this.ik.getTarget(e);
    if (s && t) {
      const a = t.getPosition(), o = t.getRotation(), h = s.getPosition(), l = s.getRotation();
      if (this.renderer && this.renderer.isLocalDemo) {
        const c = s.getLocalPosition();
        switch (e) {
          case Y.LeftArm:
            this.renderer.setTextTargetLeftPos(
              `${c.x.toFixed(4)},${c.y.toFixed(
                4
              )},${c.z.toFixed(4)}`
            );
            break;
          case Y.RightArm:
            this.renderer.setTextTargetRightPos(
              `${c.x.toFixed(4)},${c.y.toFixed(
                4
              )},${c.z.toFixed(4)}`
            );
            break;
        }
      }
      (!Qa.equalV3BetweenPCV3(h, a) || !Qa.equalBetweenQuat(l, o)) && (s.setPosition(
        new R(a == null ? void 0 : a.x, a == null ? void 0 : a.y, a == null ? void 0 : a.z)
      ), s.setRotation(o), (i = this.ik) == null || i.setNeedToSolve(!0), (n = this.ik) == null || n.update());
    }
  }
  setAvatarPartMap(e, t) {
    W.set(e, t);
  }
}
class of {
  constructor(e, t) {
    this.printOnceFlag = !1, this.ik = e, this.renderer = t;
  }
  getSolver() {
    if (this.ikHumanoid)
      return this.ikHumanoid.getSolver();
  }
  solveForTargets(e) {
    this.ikHumanoid && this.ikHumanoid.solveForTargets(e);
  }
  run() {
    throw new Error("must implement");
  }
  update() {
    throw new Error("must implement");
  }
}
class hf {
  constructor() {
    this.solver = new St(), this.chains = /* @__PURE__ */ new Map(), this.boneScale = 0.1;
  }
  getSolver() {
    return this.solver;
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
}
var mt = /* @__PURE__ */ ((r) => (r[r.Min = 0.01] = "Min", r[r.Spine01 = 2] = "Spine01", r[r.Spine02 = 4] = "Spine02", r[r.Spine03 = 4] = "Spine03", r[r.Spine04 = 4] = "Spine04", r[r.Neck = 3] = "Neck", r[r.Shoulder = 6] = "Shoulder", r[r.UpperArm = 9] = "UpperArm", r[r.LowerArm = 8] = "LowerArm", r[r.Hand = 2] = "Hand", r[r.Hip = 3] = "Hip", r[r.UpperLeg = 22] = "UpperLeg", r[r.LowerLeg = 20] = "LowerLeg", r[r.Foot = 2] = "Foot", r))(mt || {});
class Xy extends hf {
  constructor() {
    super(), this.init();
  }
  init() {
    this.initSpine(), this.initHead(), this.initRightArm(), this.initLeftArm(), this.initRightLeg(), this.initLeftLeg();
  }
  initSpine() {
    const e = F.createRootBone(), t = new Le(Y.Spine);
    t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      re,
      mt.Spine01 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      mt.Spine02 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      mt.Spine03 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      mt.Spine04 * this.boneScale,
      30
    ), t.setColor(new Xe(0.2, 0.2, 0.2)), t.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      Ae,
      90,
      0,
      re
    ), this.chains.set(Y.Spine, t), this.solver.addChain(t);
  }
  initHead() {
    const e = F.createRootBone(), t = new Le(Y.Head), s = new Xe(1, 0, 1);
    t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(0, 1, -0.1),
      mt.Neck * this.boneScale,
      0.1,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(0, 0, 1),
      20
    ), this.chains.set(Y.Head, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initRightArm() {
    const e = F.createRootBone(), t = new Le(Y.RightArm), s = new Xe(1, 1, 0);
    e.setColor(s), t.setMinIterationChange(mt.Min * 0.1), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      Ae,
      mt.Shoulder * this.boneScale,
      10,
      s
    ), t.addConsecutiveHingedBone(
      Ae,
      mt.UpperArm * this.boneScale / 2,
      // HumanoidBoneLength.Min,
      Ce.LOCAL_HINGE,
      es,
      90,
      180,
      pn,
      s
    ), t.addConsecutiveHingedBone(
      Ae,
      mt.UpperArm * this.boneScale / 2,
      // HumanoidBoneLength.Min,
      Ce.LOCAL_HINGE,
      es,
      150,
      170,
      Ae,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      Ae,
      mt.UpperArm * this.boneScale,
      0,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(1, 0, 0),
      10
    ), this.chains.set(Y.RightArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initLeftArm() {
    const e = F.createRootBone(), t = new Le(Y.LeftArm), s = new Xe(0, 1, 1);
    e.setColor(s), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      mt.Shoulder * this.boneScale,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      mt.UpperArm * this.boneScale,
      60,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      mt.Spine02 * this.boneScale,
      30,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(1, 0, 0),
      2 * this.boneScale,
      60,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(-1, 0, 0),
      0
    ), this.chains.set(Y.LeftArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initRightLeg() {
    const e = F.createRootBone();
    e.setBallJointConstraintDegs(0);
    const t = new Le(Y.RightLeg), s = new Xe(1, 1, 0);
    e.setColor(s), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(1, -0.2, 0),
      2 * this.boneScale,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(0, -1, 0),
      22 * this.boneScale,
      90,
      s
    ), t.addConsecutiveHingedBone(
      new R(0, -1, 0),
      20 * this.boneScale,
      Ce.GLOBAL_HINGE,
      new R(-1, 0, 0),
      90,
      90,
      new R(0, 0, 1),
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(0, 0, -1),
      2 * this.boneScale,
      10,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(1, 0, 0),
      0
    ), this.chains.set(Y.RightLeg, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      0,
      _t.START
    );
  }
  initLeftLeg() {
    const e = F.createRootBone(), t = new Le(Y.LeftLeg), s = new Xe(0, 1, 1);
    e.setColor(s), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      2 * this.boneScale,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(0, -1, 0),
      22 * this.boneScale,
      90,
      s
    ), t.addConsecutiveHingedBone(
      new R(0, -1, 0),
      20 * this.boneScale,
      Ce.GLOBAL_HINGE,
      new R(-1, 0, 0),
      0,
      90,
      new R(0, 0, 1),
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(0, 0, -1),
      2 * this.boneScale,
      10,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(-1, 0, 0),
      0
    ), this.chains.set(Y.LeftLeg, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      0,
      _t.START
    );
  }
}
class QP extends of {
  constructor(e, t) {
    super(e, t), this.ik = e, this.ikHumanoid = new Xy();
  }
  update() {
    var t;
    this.renderer && this.renderer.update();
    const e = (t = this.renderer) == null ? void 0 : t.getAvatarEntity();
    e && this.applyIKToAvatar(e);
  }
  applyRotation(e, t, s) {
    const i = e.getRotation(), n = new ee().setFromEulerAngles(s.x, s.y, s.z);
    t.setRotation(i.mul(n));
  }
  applyRotationByJoints(e, t, s) {
    const i = new ee().setFromEulerAngles(s.x, s.y, s.z), n = e[0].getStartLocation(), a = e[e.length - 1].getEndLocation(), o = R.getDirectionUV(
      n,
      a
    ).normalised(), h = af.vec3LookRotation(
      new v(o.x, o.y, o.z),
      t.up
    );
    t.setRotation(h.mul(i));
  }
  applyIKToAvatarSpine(e) {
    var d, u, f;
    e.findByName(W.Head);
    const t = e.findByName(W.Chest), s = e.findByName(
      W.UpperChest
    ), i = (d = this.getSolver()) == null ? void 0 : d.getChainByName(
      W.Spine
    ), n = i == null ? void 0 : i.getName(), a = i == null ? void 0 : i.getBone(1), o = i == null ? void 0 : i.getBone(2), h = (u = this.ik) == null ? void 0 : u.getBoneFromCache(n, 1), l = (f = this.ik) == null ? void 0 : f.getBoneFromCache(n, 2), c = new R(-90, 0, 0);
    h && a && t && this.applyRotation(h, t, c), l && o && s && this.applyRotation(
      l,
      s,
      c
    );
  }
  applyIKToAvatarHead(e) {
    var h, l;
    const t = e.findByName(W.Neck), s = (h = this.getSolver()) == null ? void 0 : h.getChainByName(Y.Head), i = s == null ? void 0 : s.getName(), n = s == null ? void 0 : s.getBone(1), a = (l = this.ik) == null ? void 0 : l.getBoneFromCache(i, 1), o = new R(-90, 0, 0);
    a && n && t && this.applyRotation(a, t, o);
  }
  applyIKToAvatarRightArm(e) {
    var p, g, b, x, y, S, C, w, M;
    const t = e.findByName(
      W.RightUpperArm
    ), s = e.findByName(
      W.RightLowerArm
    ), i = e.findByName(
      W.RightHand
    ), n = (p = this.getSolver()) == null ? void 0 : p.getChainByName(Y.RightArm), a = n == null ? void 0 : n.getName();
    n == null || n.getBone(1);
    const o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3);
    n == null || n.getBone(4);
    const l = n == null ? void 0 : n.getBone(4);
    n == null || n.getBone(6), n == null || n.getBone(7);
    const c = n == null ? void 0 : n.getBone(8);
    (g = this.ik) == null || g.getBoneFromCache(a, 1);
    const d = (b = this.ik) == null ? void 0 : b.getBoneFromCache(a, 2), u = (x = this.ik) == null ? void 0 : x.getBoneFromCache(a, 3);
    (y = this.ik) == null || y.getBoneFromCache(a, 4);
    const f = (S = this.ik) == null ? void 0 : S.getBoneFromCache(a, 4);
    (C = this.ik) == null || C.getBoneFromCache(a, 6), (w = this.ik) == null || w.getBoneFromCache(a, 7);
    const m = (M = this.ik) == null ? void 0 : M.getBoneFromCache(a, 8), _ = new R(
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(-90),
      F.applyApproximatelyEqualsTolerance(0)
    );
    this.printOnceFlag || (this.printOnceFlag = !0, console.log("ikRightLowerArmBone01:", l), console.log("ikRightLowerArmBoneEntity01:", f)), t && o && h && // ikRightUpperArmBone03
    d && u && this.applyRotationByJoints(
      // [ikRightUpperArmBone01, ikRightUpperArmBone02, ikRightUpperArmBone03],
      [o, h],
      t,
      _
    ), s && l && f && this.applyRotation(
      f,
      s,
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(90),
        F.applyApproximatelyEqualsTolerance(0)
      )
    ), i && c && m && this.applyRotation(
      m,
      i,
      _
    );
  }
  applyIKToAvatarLeftArm(e) {
    var m, _, p, g, b;
    const t = e.findByName(
      W.LeftUpperArm
    ), s = e.findByName(
      W.LeftLowerArm
    ), i = e.findByName(
      W.LeftHand
    ), n = (m = this.getSolver()) == null ? void 0 : m.getChainByName(Y.LeftArm), a = n == null ? void 0 : n.getName();
    n == null || n.getBone(1);
    const o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3), l = n == null ? void 0 : n.getBone(4);
    (_ = this.ik) == null || _.getBoneFromCache(a, 1);
    const c = (p = this.ik) == null ? void 0 : p.getBoneFromCache(a, 2), d = (g = this.ik) == null ? void 0 : g.getBoneFromCache(a, 3), u = (b = this.ik) == null ? void 0 : b.getBoneFromCache(a, 4), f = new R(0, -90, 0);
    t && o && c && this.applyRotation(
      c,
      t,
      f
    ), s && h && d && this.applyRotation(
      d,
      s,
      f
    ), i && l && u && this.applyRotation(
      u,
      i,
      f
    );
  }
  applyIKToAvatarRightLeg(e) {
    var m, _, p, g;
    const t = e.findByName(
      W.RightUpperLeg
    ), s = e.findByName(
      W.RightLowerLeg
    ), i = e.findByName(
      W.RightFoot
    ), n = (m = this.getSolver()) == null ? void 0 : m.getChainByName(Y.RightLeg), a = n == null ? void 0 : n.getName(), o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3), l = n == null ? void 0 : n.getBone(4), c = (_ = this.ik) == null ? void 0 : _.getBoneFromCache(a, 2), d = (p = this.ik) == null ? void 0 : p.getBoneFromCache(a, 3), u = (g = this.ik) == null ? void 0 : g.getBoneFromCache(a, 4), f = new R(90, 0, 0);
    t && o && c && this.applyRotation(
      c,
      t,
      f
    ), s && h && d && this.applyRotation(
      d,
      s,
      f
    ), i && l && u && this.applyRotation(u, i, f);
  }
  applyIKToAvatarLeftLeg(e) {
    var m, _, p, g;
    const t = e.findByName(
      W.LeftUpperLeg
    ), s = e.findByName(
      W.LeftLowerLeg
    ), i = e.findByName(
      W.LeftFoot
    ), n = (m = this.getSolver()) == null ? void 0 : m.getChainByName(Y.LeftLeg), a = n == null ? void 0 : n.getName(), o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3), l = n == null ? void 0 : n.getBone(4), c = (_ = this.ik) == null ? void 0 : _.getBoneFromCache(a, 2), d = (p = this.ik) == null ? void 0 : p.getBoneFromCache(a, 3), u = (g = this.ik) == null ? void 0 : g.getBoneFromCache(a, 4), f = new R(90, 0, 0);
    t && o && c && this.applyRotation(
      c,
      t,
      f
    ), s && h && d && this.applyRotation(
      d,
      s,
      f
    ), i && l && u && this.applyRotation(u, i, f);
  }
  applyIKToAvatar(e) {
    this.applyIKToAvatarSpine(e), this.applyIKToAvatarHead(e), this.applyIKToAvatarRightArm(e), this.applyIKToAvatarLeftArm(e), this.applyIKToAvatarRightLeg(e), this.applyIKToAvatarLeftLeg(e);
  }
}
class fu extends hf {
  constructor(e, t) {
    super(), this.boneLengthMap = /* @__PURE__ */ new Map(), this.hipsPos = new R(), e && (this.hipsPos = e), t && (this.boneLengthMap = t), this.init();
  }
  init() {
    this.initSpine(), this.initHead(), this.initRightArm(), this.initLeftArm(), this.initRightLeg(), this.initLeftLeg();
  }
  initSpine() {
    var o, h, l, c;
    const e = F.createRootBone(new R(0, this.hipsPos.y, 0)), t = new Le(Y.Spine);
    t.addBone(e);
    const s = (o = this.boneLengthMap) == null ? void 0 : o.get(fe.Hips), i = (h = this.boneLengthMap) == null ? void 0 : h.get(fe.Spine), n = (l = this.boneLengthMap) == null ? void 0 : l.get(fe.Chest), a = (c = this.boneLengthMap) == null ? void 0 : c.get(fe.UpperChest);
    if (!s || !i || !n || !a)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(re, s, 10), t.addConsecutiveRotorConstrainedBone(re, i, 10), t.addConsecutiveRotorConstrainedBone(re, n, 10), t.addConsecutiveRotorConstrainedBone(
      re,
      a,
      30
    ), t.setColor(new Xe(0.2, 0.2, 0.2)), t.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      Ae,
      90,
      0,
      re
    ), this.chains.set(Y.Spine, t), this.solver.addChain(t);
  }
  initHead() {
    const e = F.createRootBone(), t = new Le(Y.Head), s = new Xe(1, 0, 1);
    t.addBone(e);
    const i = this.boneLengthMap.get(fe.Neck);
    if (!i)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(
      new R(0, 1, -0.1),
      i,
      0.1,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      es,
      20
    ), this.chains.set(Y.Head, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initRightArm() {
    const e = F.createRootBone(), t = new Le(Y.RightArm), s = new Xe(1, 1, 0);
    e.setColor(s), t.setMinIterationChange(mt.Min * 0.1), t.addBone(e);
    const i = this.boneLengthMap.get(
      fe.RightShoulder
    ), n = this.boneLengthMap.get(
      fe.RightUpperArm
    ), a = this.boneLengthMap.get(
      fe.RightLowerArm
    ), o = this.boneLengthMap.get(fe.RightHand);
    if (!i || !n || !a || !o)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(
      Ae,
      i,
      10,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      Ae,
      n,
      180,
      s
    ), t.addConsecutiveHingedBone(
      Ae,
      a,
      Ce.LOCAL_HINGE,
      re,
      0,
      160,
      es,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      Ae,
      o,
      45,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      Ae,
      10
    ), this.chains.set(Y.RightArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initLeftArm() {
    const e = F.createRootBone(), t = new Le(Y.LeftArm), s = new Xe(0, 1, 1);
    e.setColor(s), t.addBone(e);
    const i = this.boneLengthMap.get(
      fe.LeftShoulder
    ), n = this.boneLengthMap.get(
      fe.LeftUpperArm
    ), a = this.boneLengthMap.get(
      fe.LeftUpperArm
    ), o = this.boneLengthMap.get(fe.LeftHand);
    if (!i || !n || !a || !o)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(
      pn,
      i,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      pn,
      n,
      180,
      s
    ), t.addConsecutiveHingedBone(
      pn,
      a,
      Ce.LOCAL_HINGE,
      re,
      160,
      0,
      es,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      pn,
      o,
      45,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      pn,
      0
    ), this.chains.set(Y.LeftArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    );
  }
  initRightLeg() {
    const e = F.createRootBone(), t = new Le(Y.RightLeg), s = new Xe(1, 1, 0);
    e.setColor(s), t.addBone(e);
    const i = this.boneLengthMap.get(fe.RightHip), n = this.boneLengthMap.get(
      fe.RightUpperLeg
    ), a = this.boneLengthMap.get(
      fe.RightLowerLeg
    ), o = this.boneLengthMap.get(fe.RightFoot);
    if (!i || !n || !a || !o)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(
      new R(1, -0.2, 0),
      i,
      0.1,
      s
    ), t.addConsecutiveHingedBone(
      ri,
      n,
      Ce.GLOBAL_HINGE,
      Ae,
      90,
      170,
      ri,
      s
    ), t.addConsecutiveHingedBone(
      ri,
      a,
      Ce.LOCAL_HINGE,
      Ae,
      0,
      0,
      es,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      Ae,
      0
    ), this.chains.set(Y.RightLeg, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      0,
      _t.START
    );
  }
  initLeftLeg() {
    const e = F.createRootBone(), t = new Le(Y.LeftLeg), s = new Xe(0, 1, 1);
    e.setColor(s), t.addBone(e);
    const i = this.boneLengthMap.get(fe.LeftHip), n = this.boneLengthMap.get(
      fe.LeftUpperLeg
    ), a = this.boneLengthMap.get(
      fe.LeftLowerLeg
    ), o = this.boneLengthMap.get(fe.LeftFoot);
    if (!i || !n || !a || !o)
      throw new Error("bone length is undefined");
    t.addConsecutiveRotorConstrainedBone(
      new R(-1, -0.2, 0),
      i,
      0.1,
      s
    ), t.addConsecutiveHingedBone(
      ri,
      n,
      Ce.GLOBAL_HINGE,
      Ae,
      90,
      170,
      ri,
      s
    ), t.addConsecutiveHingedBone(
      ri,
      a,
      Ce.LOCAL_HINGE,
      Ae,
      0,
      0,
      es,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      pn,
      0
    ), this.chains.set(Y.LeftLeg, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      0,
      _t.START
    );
  }
}
class jy extends of {
  constructor(e, t) {
    super(e, t), this.renderer && (this.renderer.addScaleAvatarWithHMDCallback((s) => {
      var n;
      const i = (n = this.renderer) == null ? void 0 : n.getAvatarHipsPosition();
      if (i) {
        const a = Qa.pcV3ToFabrikV3(i);
        this.ikHumanoid = new fu(a, s);
      }
    }), this.renderer.addFitXRCameraToAvatarHeadCallback((s) => {
      var n;
      ze.Instance.log("FitXRCameraToAvatarHeadCallback:", s);
      const i = (n = this.renderer) == null ? void 0 : n.getAvatarHipsPosition();
      if (i) {
        const a = Qa.pcV3ToFabrikV3(i);
        this.ikHumanoid = new fu(a, s);
      }
    }));
  }
  run() {
  }
  update() {
    var t;
    const e = (t = this.renderer) == null ? void 0 : t.getAvatarEntity();
    e && this.applyIKToAvatar(e);
  }
  applyRotation(e, t, s) {
    var o, h;
    const i = e.getRotation(), n = new ee().setFromEulerAngles(s.x, s.y, s.z), a = (h = (o = this.renderer) == null ? void 0 : o.getAvatarEntity()) == null ? void 0 : h.getEulerAngles();
    if (a) {
      const l = new ee().setFromEulerAngles(0, a.y, 0);
      t.setRotation(l.mul(i).mul(n));
    } else
      t.setRotation(i.mul(n));
  }
  applyRotationByInputSource(e, t, s, i) {
    const n = e.getRotation(), a = new ee().setFromEulerAngles(s.x, s.y, s.z);
    t.setRotation(n.mul2(i, a));
  }
  applyRotationForceFront(e, t, s) {
    const i = e.getRotation(), n = new ee().setFromEulerAngles(s.x, s.y, s.z);
    let a = i.mul(n);
    t.setRotation(a), t.forward.z > 0.01 && t.rotateLocal(0, 180, 0);
  }
  applyRotationByJoints(e, t, s) {
    const i = new ee().setFromEulerAngles(s.x, s.y, s.z), n = e[0].getStartLocation(), a = e[e.length - 1].getEndLocation(), o = R.getDirectionUV(
      n,
      a
    ).normalised(), h = af.vec3LookRotation(
      new v(o.x, o.y, o.z),
      t.up
    );
    t.setRotation(h.mul(i));
  }
  applyIKToAvatarSpine(e) {
    var d, u, f;
    e.findByName(W.Head);
    const t = e.findByName(W.Chest), s = e.findByName(W.UpperChest), i = (d = this.getSolver()) == null ? void 0 : d.getChainByName(Y.Spine), n = i == null ? void 0 : i.getName(), a = i == null ? void 0 : i.getBone(1), o = i == null ? void 0 : i.getBone(2), h = (u = this.ik) == null ? void 0 : u.getBoneFromCache(n, 1), l = (f = this.ik) == null ? void 0 : f.getBoneFromCache(n, 2), c = new R(-90, 0, 0);
    h && a && t && this.applyRotation(h, t, c), l && o && s && this.applyRotation(
      l,
      s,
      c
    );
  }
  applyIKToAvatarHead(e) {
    var h, l;
    const t = e.findByName(W.Neck), s = (h = this.getSolver()) == null ? void 0 : h.getChainByName(Y.Head), i = s == null ? void 0 : s.getName(), n = s == null ? void 0 : s.getBone(1), a = (l = this.ik) == null ? void 0 : l.getBoneFromCache(i, 1), o = new R(-90, 0, 0);
    a && n && t && this.applyRotation(a, t, o);
  }
  applyIKToAvatarRightArm(e) {
    var m, _, p, g, b, x, y;
    const t = e.findByName(
      W.RightUpperArm
    ), s = e.findByName(
      W.RightLowerArm
    ), i = e.findByName(W.RightHand), n = (m = this.getSolver()) == null ? void 0 : m.getChainByName(Y.RightArm), a = n == null ? void 0 : n.getName();
    n == null || n.getBone(1);
    const o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3), l = n == null ? void 0 : n.getBone(4);
    (_ = this.ik) == null || _.getBoneFromCache(a, 1);
    const c = (p = this.ik) == null ? void 0 : p.getBoneFromCache(a, 2), d = (g = this.ik) == null ? void 0 : g.getBoneFromCache(a, 3), u = (b = this.ik) == null ? void 0 : b.getBoneFromCache(a, 4), f = new R(
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(90),
      F.applyApproximatelyEqualsTolerance(0)
    );
    if (this.printOnceFlag || (this.printOnceFlag = !0, ze.Instance.log(
      "[applyIKToAvatarRightArm] avatarEntity:",
      e
    ), ze.Instance.log(`[applyIKToAvatarRightArm] chain: ${n}`)), t && o && c && this.applyRotation(
      c,
      t,
      f
    ), s && h && d && this.applyRotation(
      d,
      s,
      f
    ), i && l && u) {
      const S = (x = this.ik) == null ? void 0 : x.getTarget(Y.RightArm);
      if (S) {
        const C = S == null ? void 0 : S.getRotation();
        (y = this.renderer) != null && y.isInXR() ? this.applyRotationByInputSource(
          u,
          i,
          f,
          C
        ) : this.applyRotation(
          u,
          i,
          f
        );
      }
    }
  }
  applyIKToAvatarLeftArm(e) {
    var m, _, p, g, b, x, y;
    const t = e.findByName(
      W.LeftUpperArm
    ), s = e.findByName(
      W.LeftLowerArm
    ), i = e.findByName(W.LeftHand), n = (m = this.getSolver()) == null ? void 0 : m.getChainByName(Y.LeftArm), a = n == null ? void 0 : n.getName();
    n == null || n.getBone(1);
    const o = n == null ? void 0 : n.getBone(2), h = n == null ? void 0 : n.getBone(3), l = n == null ? void 0 : n.getBone(4);
    (_ = this.ik) == null || _.getBoneFromCache(a, 1);
    const c = (p = this.ik) == null ? void 0 : p.getBoneFromCache(a, 2), d = (g = this.ik) == null ? void 0 : g.getBoneFromCache(a, 3), u = (b = this.ik) == null ? void 0 : b.getBoneFromCache(a, 4), f = new R(0, -90, 0);
    if (t && o && c && this.applyRotation(
      c,
      t,
      f
    ), s && h && d && this.applyRotation(
      d,
      s,
      f
    ), i && l && u) {
      const S = (x = this.ik) == null ? void 0 : x.getTarget(Y.LeftArm);
      if (S) {
        const C = S == null ? void 0 : S.getRotation();
        (y = this.renderer) != null && y.isInXR() ? this.applyRotationByInputSource(
          u,
          i,
          f,
          C
        ) : this.applyRotation(
          u,
          i,
          f
        );
      }
    }
  }
  applyIKToAvatarRightLeg(e) {
    var d, u, f, m;
    const t = e.findByName(
      W.RightUpperLeg
    ), s = e.findByName(
      W.RightLowerLeg
    );
    e.findByName(W.RightFoot);
    const i = (d = this.getSolver()) == null ? void 0 : d.getChainByName(Y.RightLeg), n = i == null ? void 0 : i.getName(), a = i == null ? void 0 : i.getBone(2), o = i == null ? void 0 : i.getBone(3);
    i == null || i.getBone(4);
    const h = (u = this.ik) == null ? void 0 : u.getBoneFromCache(n, 2), l = (f = this.ik) == null ? void 0 : f.getBoneFromCache(n, 3);
    (m = this.ik) == null || m.getBoneFromCache(n, 4);
    const c = new R(90, 0, 90);
    t && a && h && this.applyRotation(
      h,
      t,
      c
    ), s && o && l && this.applyRotation(
      l,
      s,
      c
    );
  }
  applyIKToAvatarLeftLeg(e) {
    var d, u, f, m;
    const t = e.findByName(
      W.LeftUpperLeg
    ), s = e.findByName(
      W.LeftLowerLeg
    );
    e.findByName(W.LeftFoot);
    const i = (d = this.getSolver()) == null ? void 0 : d.getChainByName(Y.LeftLeg), n = i == null ? void 0 : i.getName(), a = i == null ? void 0 : i.getBone(2), o = i == null ? void 0 : i.getBone(3);
    i == null || i.getBone(4);
    const h = (u = this.ik) == null ? void 0 : u.getBoneFromCache(n, 2), l = (f = this.ik) == null ? void 0 : f.getBoneFromCache(n, 3);
    (m = this.ik) == null || m.getBoneFromCache(n, 4);
    const c = new R(90, 0, 90);
    t && a && h && this.applyRotation(
      h,
      t,
      c
    ), s && o && l && this.applyRotation(
      l,
      s,
      c
    );
  }
  applyIKToAvatar(e) {
    this.getSolver() && (this.applyIKToAvatarHead(e), this.applyIKToAvatarRightArm(e), this.applyIKToAvatarLeftArm(e));
  }
}
const uI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AvatarRendererBase: of,
  AvatarRendererLocalHinge: QP,
  AvatarRendererNormal: jy,
  Base: js,
  HumanoidBase: hf,
  HumanoidBoneLength: mt,
  HumanoidLocalHinge: Xy,
  HumanoidNormal: fu,
  HumanoidPart: Y,
  Util: F
}, Symbol.toStringTag, { value: "Module" }));
class eI extends js {
  constructor() {
    super(), this.solver = new St();
  }
  getSolver() {
    return this.solver;
  }
  update() {
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St();
    const e = new Le("chain1"), t = F.createRootBone(
      new R(0, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.setColor(new Xe(1, 0, 0)), this.solver.addChain(e);
    const s = new Le("chain2"), i = F.createRootBone(
      new R(0, 0, 0),
      Ae,
      1
    );
    s.addBone(i), s.addConsecutiveRotorConstrainedBone(Ae, 0.5, 90), s.addConsecutiveRotorConstrainedBone(Ae, 0.5, 90), s.setColor(new Xe(0, 1, 0)), s.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      Ae,
      45
    ), this.solver.connectChain(s, 0, 1, _t.END), this.addTarget("chain1", new R(0.01, 3, -1)), this.addTarget("chain2", new R(0.01, 3, 1)), this.randomMoveTarget("chain1"), this.randomMoveTarget("chain2"), this.solveIK(), this.render();
  }
}
const nh = "chainHingeRotateY", rh = "chainHingeRotateX", ah = "chainHingeRotateZ";
class tI extends js {
  constructor() {
    super(), this.angle = 0, this.solver = new St(), mi(document, "click").subscribe(() => {
      this.angle = this.angle === 0 ? 90 : 0, this.updateChainsConstraint(this.angle), this.setNeedToSolve(!0), this.solveIK(), this.render(), this.printRotation();
    });
  }
  getSolver() {
    return this.solver;
  }
  update() {
    this.solveIK(), this.render();
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St(), this.addTarget(
      nh,
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), this.addTarget(
      rh,
      new R(
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), this.addTarget(
      ah,
      new R(
        F.applyApproximatelyEqualsTolerance(-1),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), this.addChains(), this.solveIK(), this.render(), this.printRotation();
  }
  addChains() {
    this.addChainHingeRotateY(), this.addChainHingeRotateX(), this.addChainHingeRotateZ();
  }
  addChainHingeRotateY() {
    const e = new Le(nh), t = F.createRootBone(
      new R(0, 0, 0),
      re,
      0.5
    );
    e.addBone(t), e.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      re,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), this.solver.addChain(e);
  }
  addChainHingeRotateX() {
    const e = new Le(rh), t = F.createRootBone(
      new R(1, 0, 0),
      re,
      0.5
    );
    e.addBone(t), e.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      Ae,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Th
    ), this.solver.addChain(e);
  }
  addChainHingeRotateZ() {
    const e = new Le(ah), t = F.createRootBone(
      new R(-1, 0, 0),
      re,
      0.5
    );
    e.addBone(t), e.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      es,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), this.solver.addChain(e);
  }
  printRotation() {
    const e = this.getBoneFromCache(nh, 0), t = this.getBoneFromCache(rh, 0), s = this.getBoneFromCache(ah, 0);
    console.log("boneHingeRotateY:", e == null ? void 0 : e.getEulerAngles()), console.log("boneHingeRotateX:", t == null ? void 0 : t.getEulerAngles()), console.log("boneHingeRotateZ:", s == null ? void 0 : s.getEulerAngles());
  }
  updateChainsConstraint(e) {
    const t = this.getSolver().getChainByName(
      nh
    ), s = this.getSolver().getChainByName(
      rh
    ), i = this.getSolver().getChainByName(
      ah
    );
    console.log(t), console.log(s), console.log(i), t == null || t.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      re,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(e),
      Ae
    ), s == null || s.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      Ae,
      F.applyApproximatelyEqualsTolerance(e),
      F.applyApproximatelyEqualsTolerance(0),
      Th
    ), i == null || i.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      es,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(e),
      Ae
    );
  }
}
const oh = "chainHingeRotateY", hh = "chainHingeRotateX", lh = "chainHingeRotateZ";
class sI extends js {
  constructor() {
    super(), this.angle = 0, this.solver = new St(), mi(document, "click").subscribe(() => {
      this.angle = this.angle === 0 ? 90 : 0, this.updateChainsConstraint(this.angle), this.setNeedToSolve(!0), this.solveIK(), this.render(), this.printRotation();
    });
  }
  getSolver() {
    return this.solver;
  }
  update() {
    this.solveIK(), this.render();
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St(), this.addTarget(
      oh,
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(-1)
      )
    ), this.addTarget(
      hh,
      new R(
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(-1)
      )
    ), this.addTarget(
      lh,
      new R(
        F.applyApproximatelyEqualsTolerance(-1),
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(-1)
      )
    ), console.log("======== all constraint angles zero ========"), this.addChains(), this.solveIK(), this.render(), this.printRotation(), console.log("======== update all constraint angles to 90 degree ========"), this.updateChainsConstraint(0), this.setNeedToSolve(!0), this.solveIK(), this.render(), this.printRotation();
  }
  addChains() {
    this.addChainHingeRotateY(), this.addChainHingeRotateX(), this.addChainHingeRotateZ();
  }
  addChainHingeRotateY() {
    const e = new Le(oh), t = F.createRootBone(
      new R(0, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.GLOBAL_HINGE,
      re,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(0)
    ), this.solver.addChain(e);
  }
  addChainHingeRotateX() {
    const e = new Le(hh), t = F.createRootBone(
      new R(1, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.GLOBAL_HINGE,
      Ae,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Th
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(0)
    ), this.solver.addChain(e);
  }
  addChainHingeRotateZ() {
    const e = new Le(lh), t = F.createRootBone(
      new R(-1, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.GLOBAL_HINGE,
      es,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(0)
    ), this.solver.addChain(e);
  }
  printRotation() {
    const e = this.getBoneFromCache(oh, 1), t = this.getBoneFromCache(hh, 1), s = this.getBoneFromCache(lh, 1);
    console.log("boneHingeRotateY:", e == null ? void 0 : e.getLocalEulerAngles()), console.log("boneHingeRotateX:", t == null ? void 0 : t.getLocalEulerAngles()), console.log("boneHingeRotateZ:", s == null ? void 0 : s.getLocalEulerAngles());
  }
  updateChainsConstraint(e) {
    const t = this.getSolver().getChainByName(
      oh
    ), s = this.getSolver().getChainByName(
      hh
    ), i = this.getSolver().getChainByName(
      lh
    ), n = t == null ? void 0 : t.getBone(1), a = s == null ? void 0 : s.getBone(1), o = i == null ? void 0 : i.getBone(1);
    console.log(n), console.log(a), console.log(o), n == null || n.setHingeJointClockwiseConstraintDegs(0), n == null || n.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(e)
    ), a == null || a.setHingeJointClockwiseConstraintDegs(e), a == null || a.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(0)
    ), o == null || o.setHingeJointClockwiseConstraintDegs(0), o == null || o.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(e)
    );
  }
}
class iI extends js {
  constructor() {
    super(), this.chains = /* @__PURE__ */ new Map(), this.boneScale = 0.05, this.solver = new St(), this.init();
  }
  getSolver() {
    return this.solver;
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  init() {
    this.initSpine(), this.initRightArm(), this.initLeftArm();
  }
  initSpine() {
    const e = F.createRootBone(), t = new Le(Y.Spine);
    console.log("rootbone:", e), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      re,
      3 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      3 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      3 * this.boneScale,
      10
    ), t.addConsecutiveRotorConstrainedBone(
      re,
      8 * this.boneScale,
      30
    ), t.setColor(new Xe(0.2, 0.2, 0.2)), t.setHingeBaseboneConstraint(
      pe.GLOBAL_HINGE,
      Ae,
      90,
      0,
      re
    ), this.chains.set(Y.Spine, t), this.solver.addChain(t), console.log(t);
  }
  initRightArm() {
    const e = F.createRootBone(), t = new Le(Y.RightArm), s = new Xe(1, 1, 0);
    e.setColor(s), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(1, 0, 0),
      5 * this.boneScale,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(1, 0, 0),
      8 * this.boneScale,
      90,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(1, 0, 0),
      7 * this.boneScale,
      90,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(1, 0, 0),
      0
    ), this.chains.set(Y.RightArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    ), console.log(t);
  }
  initLeftArm() {
    const e = F.createRootBone(), t = new Le(Y.LeftArm), s = new Xe(0, 1, 1);
    e.setColor(s), t.addBone(e), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      5 * this.boneScale,
      0.1,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      8 * this.boneScale,
      90,
      s
    ), t.addConsecutiveRotorConstrainedBone(
      new R(-1, 0, 0),
      7 * this.boneScale,
      90,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      new R(-1, 0, 0),
      0
    ), this.chains.set(Y.LeftArm, t), this.solver.connectChainByName(
      t,
      Y.Spine,
      4,
      _t.END
    ), console.log(t);
  }
  run() {
    this.addTarget(Y.Spine, new R(0.01, 1, -2)), this.addTarget(Y.RightArm, new R(1.5, 1, -0.5)), this.addTarget(Y.LeftArm, new R(-1.5, 1, -0.5)), this.randomMoveTarget(
      Y.Spine,
      new R(-0.5, -1.5, -1.5),
      new R(0.5, 3.5, 0.5)
    ), this.randomMoveTarget(
      Y.RightArm,
      new R(1.5, 2.5, 0.5),
      new R(0.5, -0.5, -1.5)
    ), this.randomMoveTarget(
      Y.LeftArm,
      new R(-1.5, 2.5, 0.5),
      new R(-0.5, -0.5, -1.5)
    ), this.solveIK(), this.render();
  }
  update() {
  }
}
class nI extends js {
  constructor() {
    super(), this.init();
  }
  getSolver() {
    if (!this.ikAvatarRenderer)
      throw new Error("ikAvatarRenderer is undefined");
    return this.ikAvatarRenderer.getSolver();
  }
  solveForTargets(e) {
    if (!this.ikAvatarRenderer)
      throw new Error("ikAvatarRenderer is undefined");
    this.ikAvatarRenderer.solveForTargets(e);
  }
  init() {
  }
  run() {
    this.renderer && (this.ikAvatarRenderer = new jy(
      this,
      this.renderer
    ));
    const e = 0;
    this.addTarget(
      Y.RightArm,
      new R(e + 1, 1, 0.5)
    ), this.addTarget(
      Y.LeftArm,
      new R(e - 1, 2, 0.5)
    ), this.ikAvatarRenderer && this.ikAvatarRenderer.run(), this.solveIK(), this.render();
  }
  update() {
    this.solveIK(), this.render(), this.ikAvatarRenderer && this.ikAvatarRenderer.update();
  }
}
class rI extends js {
  constructor() {
    super(), this.solver = new St();
  }
  getSolver() {
    return this.solver;
  }
  update() {
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St();
    const e = new Le("default"), t = F.createRootBone(
      new R(0, 0, 0),
      re,
      0.1
    );
    console.log(t), e.addBone(t), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.addConsecutiveRotorConstrainedBone(re, 0.5, 90), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      45
    ), this.solver.addChain(e);
    const s = "default";
    this.addTarget(s, new R(0.01, 3, 0)), this.randomMoveTarget(s), this.solveIK(), this.render();
  }
}
const e_ = "chainHingeRotateY", t_ = "chainHingeRotateX", s_ = "chainHingeRotateZ";
class aI extends js {
  constructor() {
    super(), this.angle = 0, this.solver = new St(), mi(document, "click").subscribe(() => {
      this.angle = this.angle === 0 ? 89 : 0, this.updateChainsConstraint(this.angle), this.setNeedToSolve(!0), this.solveIK(), this.render();
    });
  }
  getSolver() {
    return this.solver;
  }
  update() {
    this.solveIK(), this.render();
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St(), this.addTarget(
      "chainHingeRotateY",
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), this.addTarget(
      "chainHingeRotateX",
      new R(
        F.applyApproximatelyEqualsTolerance(1),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), this.addTarget(
      "chainHingeRotateZ",
      new R(
        F.applyApproximatelyEqualsTolerance(-1),
        F.applyApproximatelyEqualsTolerance(3),
        F.applyApproximatelyEqualsTolerance(-3)
      )
    ), console.log("======== all constraint angles zero ========"), this.addChains(), this.solveIK(), this.render(), this.printRotation(), console.log("======== update all constraint angles to 90 degree ========"), this.updateChainsConstraint(0), this.setNeedToSolve(!0), this.solveIK(), this.render(), this.printRotation();
  }
  addChains() {
    this.addChainHingeRotateY(), this.addChainHingeRotateX(), this.addChainHingeRotateZ();
  }
  addChainHingeRotateY() {
    const e = new Le("chainHingeRotateY"), t = F.createRootBone(
      new R(0, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.LOCAL_HINGE,
      re,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(1)
    ), this.solver.addChain(e);
  }
  addChainHingeRotateX() {
    const e = new Le("chainHingeRotateX"), t = F.createRootBone(
      new R(2, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.LOCAL_HINGE,
      Ae,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Th
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(1)
    ), this.solver.addChain(e);
  }
  addChainHingeRotateZ() {
    const e = new Le("chainHingeRotateZ"), t = F.createRootBone(
      new R(-2, 0, 0),
      re,
      1
    );
    e.addBone(t), e.addConsecutiveHingedBone(
      re,
      0.5,
      Ce.LOCAL_HINGE,
      es,
      F.applyApproximatelyEqualsTolerance(0),
      F.applyApproximatelyEqualsTolerance(0),
      Ae
    ), e.setRotorBaseboneConstraint(
      pe.GLOBAL_ROTOR,
      re,
      F.applyApproximatelyEqualsTolerance(1)
    ), this.solver.addChain(e);
  }
  printRotation() {
    const e = this.getBoneFromCache(e_, 1), t = this.getBoneFromCache(t_, 1), s = this.getBoneFromCache(s_, 1);
    console.log("boneHingeRotateY:", e == null ? void 0 : e.getLocalEulerAngles()), console.log("boneHingeRotateX:", t == null ? void 0 : t.getLocalEulerAngles()), console.log("boneHingeRotateZ:", s == null ? void 0 : s.getLocalEulerAngles());
  }
  updateChainsConstraint(e) {
    const t = this.getSolver().getChainByName(
      e_
    ), s = this.getSolver().getChainByName(
      t_
    ), i = this.getSolver().getChainByName(
      s_
    ), n = t == null ? void 0 : t.getBone(1), a = s == null ? void 0 : s.getBone(1), o = i == null ? void 0 : i.getBone(1);
    console.log(n), console.log(a), console.log(o), n == null || n.setHingeJointClockwiseConstraintDegs(0), n == null || n.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(e)
    ), a == null || a.setHingeJointClockwiseConstraintDegs(0), a == null || a.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(e)
    ), o == null || o.setHingeJointClockwiseConstraintDegs(0), o == null || o.setHingeJointAnticlockwiseConstraintDegs(
      F.applyApproximatelyEqualsTolerance(e)
    );
  }
}
const hs = 3;
class oI extends js {
  constructor() {
    super(), this.boneScale = 0.1, this.targetIndex = 0, this.targetPosList = [
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(hs)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(hs),
        F.applyApproximatelyEqualsTolerance(hs)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(hs),
        F.applyApproximatelyEqualsTolerance(0)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(hs),
        F.applyApproximatelyEqualsTolerance(-hs)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(-hs)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(-hs),
        F.applyApproximatelyEqualsTolerance(-hs)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(-hs),
        F.applyApproximatelyEqualsTolerance(0)
      ),
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(-hs),
        F.applyApproximatelyEqualsTolerance(hs)
      )
    ], this.solver = new St(), mi(document, "keyup").subscribe((e) => {
      const t = this.getTarget(Y.RightLeg);
      if (t) {
        t.getPosition(), this.targetIndex++;
        const s = this.targetPosList[this.targetIndex % this.targetPosList.length];
        t.setPosition(s), this.setNeedToSolve(!0);
      }
    });
  }
  getSolver() {
    return this.solver;
  }
  update() {
    this.solveIK(), this.render();
  }
  solveForTarget(e) {
    this.solver.solveForTarget(e);
  }
  solveForTargets(e) {
    this.solver.solveForTargets(e);
  }
  run() {
    this.solver = new St(), this.addTarget(
      Y.RightLeg,
      new R(
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(0),
        F.applyApproximatelyEqualsTolerance(0)
      )
    ), this.addChains(), this.solveIK(), this.render();
  }
  addChains() {
    this.initRobotLeg();
  }
  initRobotLeg() {
    const e = F.createRootBone(), t = new Le(Y.RightLeg), s = new Xe(1, 1, 0);
    e.setColor(s), t.addBone(e), t.addConsecutiveHingedBone(
      ri,
      mt.UpperLeg * this.boneScale,
      Ce.LOCAL_HINGE,
      es,
      135,
      135,
      ri,
      s
    ), t.addConsecutiveHingedBone(
      ri,
      mt.LowerLeg * this.boneScale,
      Ce.LOCAL_HINGE,
      Ae,
      0,
      90,
      es,
      s
    ), t.setRotorBaseboneConstraint(
      pe.LOCAL_ROTOR,
      Ae,
      0
    ), this.solver.addChain(t);
  }
}
const fI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ConnectedChain: eI,
  GlobalHinge01: tI,
  GlobalHinge02: sI,
  Humanoid01: iI,
  HumanoidVRM: nI,
  IM01: Fy,
  IM02: rI,
  LocalHinge: aI,
  RobotLeg: oI
}, Symbol.toStringTag, { value: "Module" }));
export {
  pe as BaseboneConstraintType3D,
  _t as BoneConnectionPoint,
  Xe as Color,
  Cr as FabrikBone3D,
  Le as FabrikChain3D,
  Zt as FabrikJoint3D,
  St as FabrikStructure3D,
  uI as IK,
  Qa as IKRenderer,
  fI as Implement,
  Ce as JointType,
  Ns as Mat3,
  i_ as Mat4,
  dI as Renderer,
  be as Utils,
  R as Vec3,
  Ae as X_AXE,
  pn as X_NEG,
  re as Y_AXE,
  ri as Y_NEG,
  hI as ZERO_ALL_AXE,
  es as Z_AXE,
  Th as Z_NEG
};
//# sourceMappingURL=index.mjs.map
